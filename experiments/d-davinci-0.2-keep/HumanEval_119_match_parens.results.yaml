name: HumanEval_119_match_parens
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6a5_shba.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp6a5_shba.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmp6a5_shba.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x8a350554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    else if(count1 > 0 && count2\
    \ > 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n    {\n\
    \        if(abs(count1) == abs(count2))\n            return \"Yes\";\n       \
    \ else\n            return \"No\";\n    }\n    else if(count1 < 0 && count2 >\
    \ 0)\n    {\n        if(abs(count1) == abs(count2))\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmperhd7s0e.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291ad]\\n??:? void tmperhd7s0e.__unittest_L61_C1()\
    \ [0x428246]\\n??:? void tmperhd7s0e.__modtest() [0x428414]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dafb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa38]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a935]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428edd]\\n??:? runModuleUnitTests [0x42d8d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429670]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295f7]\\n??:? _d_run_main [0x429562]\\n??:? main [0x428427]\\\
    n??:? __libc_start_main [0x3ca5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1kem_nkc.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp1kem_nkc.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmp1kem_nkc.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x8b767554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp67thbpol.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp67thbpol.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp67thbpol.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x6a767554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4tpftbga.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp4tpftbga.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp4tpftbga.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x47966554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpd2ppotcx.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpd2ppotcx.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpd2ppotcx.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xb26f3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpavddzt56.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpavddzt56.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpavddzt56.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x36f93554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpskz74ui_.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpskz74ui_.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpskz74ui_.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd41ba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1h_gmha1.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp1h_gmha1.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmp1h_gmha1.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x450cd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n        if(count < 0)\n            return \"No\";\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            count++;\n        else\n     \
    \       count--;\n        if(count < 0)\n            return \"No\";\n    }\n \
    \   if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkdgh9sdg.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429085]\\n??:? void tmpkdgh9sdg.__unittest_L46_C1()\
    \ [0x427e4a]\\n??:? void tmpkdgh9sdg.__modtest() [0x4282ec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a881]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428db5]\\n??:? runModuleUnitTests [0x42d7a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429548]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294cf]\\n??:? _d_run_main [0x42943a]\\n??:? main [0x4282ff]\\\
    n??:? __libc_start_main [0xda0f8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpifaxwlhg.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpifaxwlhg.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpifaxwlhg.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x70d49554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoai0g1u6.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpoai0g1u6.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpoai0g1u6.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x8dce4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyplwfi8o.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpyplwfi8o.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpyplwfi8o.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x77cea554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf2o4sfj_.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpf2o4sfj_.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpf2o4sfj_.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x1f1fc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfgbp5br8.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpfgbp5br8.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmpfgbp5br8.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x5cb5c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n\
    \    int n = n1 + n2;\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n    foreach\
    \ (i; 0 .. n)\n    {\n        if (i < n1 && s1[i] == '(')\n        {\n       \
    \     dp[i + 1] = dp[i] + 1;\n        }\n        else if (i < n1 && s1[i] == ')')\n\
    \        {\n            dp[i + 1] = dp[i] - 1;\n        }\n        else if (i\
    \ < n2 && s2[i - n1] == '(')\n        {\n            dp[i + 1] = dp[i] + 1;\n\
    \        }\n        else if (i < n2 && s2[i - n1] == ')')\n        {\n       \
    \     dp[i + 1] = dp[i] - 1;\n        }\n        if (dp[i + 1] < 0)\n        {\n\
    \            return \"No\";\n        }\n    }\n    return dp[n] == 0 ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvlb4dgeq.d(23): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvlb4dgeq.d(24): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvlb4dgeq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpye1qs3ff.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpye1qs3ff.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpye1qs3ff.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x90a48554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else\n    {\n        if(count1 % 2 == 0 &&\
    \ count2 % 2 == 0)\n            return \"Yes\";\n        else if(count1 % 2 !=\
    \ 0 && count2 % 2 != 0)\n            return \"Yes\";\n        else\n         \
    \   return \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfnkl6vp3.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290fd]\\n??:? void tmpfnkl6vp3.__unittest_L55_C1()\
    \ [0x427dc6]\\n??:? void tmpfnkl6vp3.__modtest() [0x428364]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da4b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8f9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a988]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a885]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e2d]\\n??:? runModuleUnitTests [0x42d821]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429547]\\n??:? _d_run_main [0x4294b2]\\n??:? main [0x428377]\\\
    n??:? __libc_start_main [0xebcdd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplc405_37.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmplc405_37.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmplc405_37.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x25c31554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto count = 0;\n\
    \    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n      \
    \  else\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpge798zu9.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429035]\\n??:? void tmpge798zu9.__unittest_L36_C1()\
    \ [0x427dfe]\\n??:? void tmpge798zu9.__modtest() [0x4282a0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d983]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d8e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a831]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d65]\\n??:? runModuleUnitTests [0x42d759]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42947f]\\n??:? _d_run_main [0x4293ea]\\n??:? main [0x4282b3]\\\
    n??:? __libc_start_main [0x506e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    if(open\
    \ == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl4z4cp2y.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpl4z4cp2y.__unittest_L37_C1()\
    \ [0x4280ae]\\n??:? void tmpl4z4cp2y.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0x971fb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuc9_w867.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpuc9_w867.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpuc9_w867.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xbf191554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else if(c == ')')\n            close++;\n\
    \    }\n    foreach(char c; lst[1])\n    {\n        if(c == '(')\n           \
    \ open++;\n        else if(c == ')')\n            close++;\n    }\n    return\
    \ (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdvliqd_b.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpdvliqd_b.__unittest_L39_C1()\
    \ [0x428102]\\n??:? void tmpdvliqd_b.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0xa44e3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n        \
    \    c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n\
    \        return \"Yes\";\n    else if(c1 == 0 && c2 != 0)\n        return \"No\"\
    ;\n    else if(c1 != 0 && c2 == 0)\n        return \"No\";\n    else if(c1 < 0\
    \ && c2 > 0)\n        return \"No\";\n    else if(c1 > 0 && c2 < 0)\n        return\
    \ \"No\";\n    else if(c1 > 0 && c2 > 0)\n    {\n        if(c1 == c2)\n      \
    \      return \"Yes\";\n        else\n            return \"No\";\n    }\n    else\
    \ if(c1 < 0 && c2 < 0)\n    {\n        if(c1 == c2)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3rm9305p.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmp3rm9305p.__unittest_L65_C1()\
    \ [0x427d78]\\n??:? void tmp3rm9305p.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a939]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d861]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429600]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429587]\\n??:? _d_run_main [0x4294f2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0xa85f9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int cnt = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            cnt++;\n        else if(c == ')')\n            cnt--;\n\
    \        if(cnt < 0)\n            return \"No\";\n    }\n    return cnt == 0 ?\
    \ \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpumgudj37.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpumgudj37.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpumgudj37.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x48f5f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   count++;\n        else\n            count--;\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx1i1t9mm.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpx1i1t9mm.__unittest_L42_C1()\
    \ [0x428102]\\n??:? void tmpx1i1t9mm.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0xb1c2d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyb8fv19n.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpyb8fv19n.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpyb8fv19n.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x5cb6b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_jcdda8m.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp_jcdda8m.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmp_jcdda8m.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x79942554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    return\
    \ open == close ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphwn3mihh.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmphwn3mihh.__unittest_L35_C1()\
    \ [0x4280aa]\\n??:? void tmphwn3mihh.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xeeb25554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb0u0_ysy.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpb0u0_ysy.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpb0u0_ysy.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xd9c99554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7ub7kamw.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp7ub7kamw.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp7ub7kamw.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xda38e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    if(open\
    \ == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8h5pg543.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp8h5pg543.__unittest_L37_C1()\
    \ [0x4280ae]\\n??:? void tmp8h5pg543.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0x32944554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(string str; lst)\n    {\n        s ~= str;\n    }\n   \
    \ int count = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n      \
    \  {\n            count++;\n        }\n        else\n        {\n            count--;\n\
    \        }\n        if(count < 0)\n        {\n            return \"No\";\n   \
    \     }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_oysjw10.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmp_oysjw10.__unittest_L48_C1()\
    \ [0x427e06]\\n??:? void tmp_oysjw10.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0xc1dc1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_5pfe5j2.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp_5pfe5j2.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp_5pfe5j2.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x5e7de554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int l1 =\
    \ lst[0].length;\n    int l2 = lst[1].length;\n    int c1 = 0;\n    int c2 = 0;\n\
    \    foreach(c; lst[0])\n    {\n        if(c == '(')\n            c1++;\n    \
    \    else\n            c1--;\n    }\n    foreach(c; lst[1])\n    {\n        if(c\
    \ == '(')\n            c2++;\n        else\n            c2--;\n    }\n    if(c1\
    \ == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1 == 0 && c2 != 0)\n    \
    \    return \"No\";\n    if(c1 != 0 && c2 == 0)\n        return \"No\";\n    if(c1\
    \ < 0 && c2 < 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 < 0 && c2 > 0)\n    {\n        if(abs(c1) > c2)\n       \
    \     return \"No\";\n        else\n            return \"Yes\";\n    }\n    if(c1\
    \ > 0 && c2 < 0)\n    {\n        if(c1 > abs(c2))\n            return \"No\";\n\
    \        else\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfh756x2w.d(21): Error: cannot implicitly convert expression `lst[0].length`\
    \ of type `ulong` to `int`\\n/tmp/tmpfh756x2w.d(22): Error: cannot implicitly\
    \ convert expression `lst[1].length` of type `ulong` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfh756x2w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbn7sh4qz.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpbn7sh4qz.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpbn7sh4qz.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xa0f74554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(e;\
    \ s)\n    {\n        if(e == '(')\n            count++;\n        else if(e ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8lnlo9rc.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmp8lnlo9rc.__unittest_L38_C1()\
    \ [0x427e0e]\\n??:? void tmp8lnlo9rc.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x13d9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3wtvl88i.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp3wtvl88i.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmp3wtvl88i.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x44a19554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8b3nqra7.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp8b3nqra7.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp8b3nqra7.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x946fa554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(string i; lst)\n    {\n        s ~= i;\n    }\n    int\
    \ count = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n        {\n\
    \            count++;\n        }\n        else\n        {\n            count--;\n\
    \        }\n        if(count < 0)\n        {\n            return \"No\";\n   \
    \     }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv18k8woh.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpv18k8woh.__unittest_L48_C1()\
    \ [0x427e06]\\n??:? void tmpv18k8woh.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0xf2c26554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n        \
    \    c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n\
    \        return \"Yes\";\n    else if(c1 == 0 && c2 < 0)\n        return \"Yes\"\
    ;\n    else if(c1 > 0 && c2 == 0)\n        return \"Yes\";\n    else if(c1 > 0\
    \ && c2 < 0)\n    {\n        if(c1 == abs(c2))\n            return \"Yes\";\n\
    \        else\n            return \"No\";\n    }\n    else\n        return \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqrqiq3sd.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429135]\\n??:? void tmpqrqiq3sd.__unittest_L55_C1()\
    \ [0x427ee6]\\n??:? void tmpqrqiq3sd.__modtest() [0x42839c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e8e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a931]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e65]\\n??:? runModuleUnitTests [0x42d859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42957f]\\n??:? _d_run_main [0x4294ea]\\n??:? main [0x4283af]\\\
    n??:? __libc_start_main [0xeeb73554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(count1 == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    else\n      \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp573lzg2j.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429135]\\n??:? void tmp573lzg2j.__unittest_L58_C1()\
    \ [0x4281ce]\\n??:? void tmp573lzg2j.__modtest() [0x42839c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da83]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e8e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a931]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8bd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e65]\\n??:? runModuleUnitTests [0x42d859]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42957f]\\n??:? _d_run_main [0x4294ea]\\n??:? main [0x4283af]\\\
    n??:? __libc_start_main [0xf238554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            left++;\n        else\n            right++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            left++;\n        else\n\
    \            right++;\n    }\n    if(left == right)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpihu9xp23.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpihu9xp23.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpihu9xp23.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd4952554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    int count = 0;\n\
    \    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n      \
    \  else\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp66dvyo_g.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmp66dvyo_g.__unittest_L38_C1()\
    \ [0x427e02]\\n??:? void tmp66dvyo_g.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d98b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a839]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42d761]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429500]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429487]\\n??:? _d_run_main [0x4293f2]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0xb4812554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto c = 0;\n \
    \   foreach(c; s)\n    {\n        if(c == '(')\n            c++;\n        else\
    \ if(c == ')')\n            c--;\n        if(c < 0)\n            return \"No\"\
    ;\n    }\n    return c == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk6x0821i.d(25): Error: variable `c` is shadowing variable `tmpk6x0821i.match_parens.c`\\\
    n/tmp/tmpk6x0821i.d(28): Error: cannot modify `immutable` expression `c`\\n/tmp/tmpk6x0821i.d(30):\
    \ Error: cannot modify `immutable` expression `c`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpk6x0821i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9mvq9m43.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp9mvq9m43.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp9mvq9m43.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xf4cce554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    // your\
    \ code here\n    string s1 = lst[0];\n    string s2 = lst[1];\n    int count =\
    \ 0;\n    foreach(c; s1)\n    {\n        if(c == '(')\n            count++;\n\
    \        else\n            count--;\n        if(count < 0)\n            return\
    \ \"No\";\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n          \
    \  count++;\n        else\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   else\n        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpodwzfdgr.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429085]\\n??:? void tmpodwzfdgr.__unittest_L48_C1()\
    \ [0x427e4a]\\n??:? void tmpodwzfdgr.__modtest() [0x4282ec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a881]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428db5]\\n??:? runModuleUnitTests [0x42d7a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429548]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294cf]\\n??:? _d_run_main [0x42943a]\\n??:? main [0x4282ff]\\\
    n??:? __libc_start_main [0xaad20554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiakdvypg.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpiakdvypg.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpiakdvypg.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x83210554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6izc33l7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp6izc33l7.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp6izc33l7.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x582e7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            left++;\n        else\n            right++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            left++;\n        else\n\
    \            right++;\n    }\n    if(left == right)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcezjz7_z.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpcezjz7_z.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpcezjz7_z.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x4b4a6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgmtjxsja.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpgmtjxsja.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpgmtjxsja.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x8e931554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    return\
    \ (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfby_qefa.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpfby_qefa.__unittest_L35_C1()\
    \ [0x4280aa]\\n??:? void tmpfby_qefa.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xe437c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"No\";\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open == close)\n        result = \"Yes\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpa8dnnak3.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpa8dnnak3.__unittest_L38_C1()\
    \ [0x4280be]\\n??:? void tmpa8dnnak3.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0x4c19a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            left++;\n        else\n            right++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            left++;\n        else\n\
    \            right++;\n    }\n    if(left == right)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0emlji2j.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp0emlji2j.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp0emlji2j.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x46c5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int c1 = 0;\n    int c2 = 0;\n    foreach(c;\
    \ s1)\n    {\n        if(c == '(')\n            c1++;\n        else\n        \
    \    c1--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   c2++;\n        else\n            c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n\
    \        return \"Yes\";\n    else if(c1 == 0 && c2 != 0)\n        return \"No\"\
    ;\n    else if(c1 != 0 && c2 == 0)\n        return \"No\";\n    else if(c1 > 0\
    \ && c2 < 0)\n        return \"No\";\n    else if(c1 < 0 && c2 > 0)\n        return\
    \ \"No\";\n    else if(c1 > 0 && c2 > 0)\n    {\n        if(c1 == c2)\n      \
    \      return \"Yes\";\n        else\n            return \"No\";\n    }\n    else\
    \ if(c1 < 0 && c2 < 0)\n    {\n        if(c1 == c2)\n            return \"Yes\"\
    ;\n        else\n            return \"No\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvsm5b1sy.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmpvsm5b1sy.__unittest_L65_C1()\
    \ [0x427d78]\\n??:? void tmpvsm5b1sy.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a939]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d861]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429600]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429587]\\n??:? _d_run_main [0x4294f2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0x8e2ef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaux7l9gv.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpaux7l9gv.__unittest_L34_C1()\
    \ [0x427dee]\\n??:? void tmpaux7l9gv.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x22113554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz3sb9wrp.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpz3sb9wrp.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpz3sb9wrp.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xc1b31554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(i; lst)\n        s ~= i;\n    int c = 0;\n    foreach(i;\
    \ s)\n    {\n        if(i == '(')\n            c++;\n        else\n          \
    \  c--;\n        if(c < 0)\n            return \"No\";\n    }\n    return c ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpedel9e7m.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpedel9e7m.__unittest_L36_C1()\
    \ [0x427e02]\\n??:? void tmpedel9e7m.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0xa83cf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            left++;\n        else\n            right++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            left++;\n        else\n  \
    \          right++;\n    }\n    if(left == right)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp935lvxi0.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp935lvxi0.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp935lvxi0.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x602ca554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptxp5s57f.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmptxp5s57f.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmptxp5s57f.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xec974554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            left++;\n        else\n            right++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            left++;\n        else\n  \
    \          right++;\n    }\n    if(left == right)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyj_k42ca.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpyj_k42ca.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpyj_k42ca.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x24c6e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5decus_9.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp5decus_9.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp5decus_9.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xbd42c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(var s; lst)\n    {\n        foreach(var\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppn0mzaow.d(23): Error: undefined identifier `var`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppn0mzaow.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int s1_len = s1.length;\n    int s2_len\
    \ = s2.length;\n    int s1_open = 0;\n    int s2_open = 0;\n    int s1_close =\
    \ 0;\n    int s2_close = 0;\n    int s1_diff = 0;\n    int s2_diff = 0;\n    int\
    \ s1_index = 0;\n    int s2_index = 0;\n    int s1_index_open = 0;\n    int s2_index_open\
    \ = 0;\n    int s1_index_close = 0;\n    int s2_index_close = 0;\n    int s1_index_diff\
    \ = 0;\n    int s2_index_diff = 0;\n    int s1_index_open_diff = 0;\n    int s2_index_open_diff\
    \ = 0;\n    int s1_index_close_diff = 0;\n    int s2_index_close_diff = 0;\n \
    \   int s1_index_diff_diff = 0;\n    int s2_index_diff_diff = 0;\n    int s1_index_open_diff_diff\
    \ = 0;\n    int s2_index_open_diff_diff = 0;\n    int s1_index_close_diff_diff\
    \ = 0;\n    int s2_index_close_diff_diff = 0;\n    int s1_index_diff_diff_diff\
    \ = 0;\n    int s2_index_diff_diff_diff = 0;\n    int s1_index_open_diff_diff_diff\
    \ = 0;\n    int s2_index_open_diff_diff_diff = 0;\n    int s1_index_close_diff_diff_diff\
    \ = 0;\n    int s2_index_close_diff_diff_diff = 0;\n    int s1_index_diff_diff_diff_diff\
    \ = 0;\n    int s2_index_diff_diff_diff_diff = 0;\n    int s1_index_open_diff_diff_diff_diff\
    \ = 0;\n   \nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkzo8ar0l.d(59): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkzo8ar0l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpixhbbn10.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpixhbbn10.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpixhbbn10.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x70324554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(char c; s1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(char c; s2)\n    {\n\
    \        if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_mbmqale.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmp_mbmqale.__unittest_L44_C1()\
    \ [0x427c94]\\n??:? void tmp_mbmqale.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x86393554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    int cnt = 0;\n\
    \    foreach(c; s)\n    {\n        if(c == '(')\n            cnt++;\n        else\
    \ if(c == ')')\n            cnt--;\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias\
    \ candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\"\
    );\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyedb1jnj.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpyedb1jnj.__unittest_L36_C1()\
    \ [0x427e06]\\n??:? void tmpyedb1jnj.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d98b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a839]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42d761]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429500]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429487]\\n??:? _d_run_main [0x4293f2]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0x34540554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2q1w3uoc.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp2q1w3uoc.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp2q1w3uoc.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x5b33f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    // Your\
    \ code here\n    int open = 0;\n    int close = 0;\n    foreach(i; lst[0])\n \
    \   {\n        if(i == '(')\n            open++;\n        else\n            close++;\n\
    \    }\n    foreach(i; lst[1])\n    {\n        if(i == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf9y10c8b.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpf9y10c8b.__unittest_L42_C1()\
    \ [0x4280fa]\\n??:? void tmpf9y10c8b.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xf88dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    auto count = 0;\n\
    \    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n      \
    \  else if(c == ')')\n            count--;\n        if(count < 0)\n          \
    \  return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkn9cmgle.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpkn9cmgle.__unittest_L36_C1()\
    \ [0x427e06]\\n??:? void tmpkn9cmgle.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d98b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a839]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42d761]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429500]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429487]\\n??:? _d_run_main [0x4293f2]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0x950a4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmppcoilkud.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmppcoilkud.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmppcoilkud.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x6de15554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzxgicvlk.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpzxgicvlk.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpzxgicvlk.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x72b2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s = s1 ~ s2;\n    int count = 0;\n\
    \    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n      \
    \  else if(c == ')')\n            count--;\n        if(count < 0)\n          \
    \  return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n    else\n\
    \        return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdoh0lgvk.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpdoh0lgvk.__unittest_L39_C1()\
    \ [0x427e0a]\\n??:? void tmpdoh0lgvk.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xe7d79554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto n1 = s1.length;\n    auto n2 = s2.length;\n\
    \    auto n = n1 + n2;\n    auto cnt = 0;\n    foreach(i; 0 .. n)\n    {\n   \
    \     if(i < n1)\n        {\n            if(s1[i] == '(')\n                cnt++;\n\
    \            else\n                cnt--;\n        }\n        else\n        {\n\
    \            if(s2[i - n1] == '(')\n                cnt++;\n            else\n\
    \                cnt--;\n        }\n        if(cnt < 0)\n            return \"\
    No\";\n    }\n    if(cnt == 0)\n        return \"Yes\";\n    else\n        return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_odjzkml.d(58): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmp_odjzkml.__unittest_L51_C1()\
    \ [0x427e5a]\\n??:? void tmp_odjzkml.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0x93ea8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else\n    {\n        int count = 0;\n        foreach(c; s1)\n        {\n\
    \            if(c == '(')\n                count++;\n            else\n      \
    \          count--;\n            if(count == 0)\n                return \"Yes\"\
    ;\n        }\n        return \"No\";\n    }\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8pbaofag.d(68): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429165]\\n??:? void tmp8pbaofag.__unittest_L64_C1()\
    \ [0x427da4]\\n??:? void tmp8pbaofag.__modtest() [0x4283d0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ebe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a961]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e95]\\n??:? runModuleUnitTests [0x42d889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429628]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295af]\\n??:? _d_run_main [0x42951a]\\n??:? main [0x4283e3]\\\
    n??:? __libc_start_main [0x405ec554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7u1jfnba.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp7u1jfnba.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp7u1jfnba.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xd8593554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqntszbhz.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpqntszbhz.__unittest_L43_C1()\
    \ [0x427c94]\\n??:? void tmpqntszbhz.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x69cd6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return abs(open -\
    \ close) % 2 == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_upybiac.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42906d]\\n??:? void tmp_upybiac.__unittest_L35_C1()\
    \ [0x427d22]\\n??:? void tmp_upybiac.__modtest() [0x4282d4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d947]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dc6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a7f5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a884]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a781]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d9d]\\n??:? runModuleUnitTests [0x42d71d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294bc]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429443]\\n??:? _d_run_main [0x4293ae]\\n??:? main [0x4282e7]\\\
    n??:? __libc_start_main [0xe1265554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6788p43t.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp6788p43t.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp6788p43t.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x7a84b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(i; lst)\n        s ~= i;\n    int c = 0;\n    foreach(i;\
    \ s)\n    {\n        if(i == '(')\n            c++;\n        else\n          \
    \  c--;\n        if(c < 0)\n            return \"No\";\n    }\n    return c ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmk7hbpoe.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpmk7hbpoe.__unittest_L36_C1()\
    \ [0x427e02]\\n??:? void tmpmk7hbpoe.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0x75131554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s3 = s1 ~ s2;\n    auto s4 = s2 ~\
    \ s1;\n    auto s5 = s3.filter!(a => a == '(' || a == ')');\n    auto s6 = s4.filter!(a\
    \ => a == '(' || a == ')');\n    auto s7 = s5.join;\n    auto s8 = s6.join;\n\
    \    auto s9 = s7.count('(');\n    auto s10 = s7.count(')');\n    auto s11 = s8.count('(');\n\
    \    auto s12 = s8.count(')');\n    if (s9 == s10 && s11 == s12)\n    {\n    \
    \    return \"Yes\";\n    }\n    else\n    {\n        return \"No\";\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1l4uj7dw.d(25): Error: no property `filter` for type `string`\\\
    n/tmp/tmp1l4uj7dw.d(26): Error: no property `filter` for type `string`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1l4uj7dw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx3pwi5f1.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpx3pwi5f1.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpx3pwi5f1.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xf1349554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n        }\n    }\n    return count == 0 ?\
    \ \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp21rscd38.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp21rscd38.__unittest_L34_C1()\
    \ [0x4280a6]\\n??:? void tmp21rscd38.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x5ec9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"Yes\";\n    int count = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                count++;\n     \
    \       else\n                count--;\n            if(count < 0)\n          \
    \  {\n                result = \"No\";\n                break;\n            }\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpb2ltn4d3.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpb2ltn4d3.__unittest_L40_C1()\
    \ [0x427dde]\\n??:? void tmpb2ltn4d3.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x16d03554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuxscib3w.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmpuxscib3w.__unittest_L65_C1()\
    \ [0x427d78]\\n??:? void tmpuxscib3w.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a939]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d861]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429600]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429587]\\n??:? _d_run_main [0x4294f2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0x12b22554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int a =\
    \ 0;\n    int b = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\n  \
    \          a++;\n        else\n            a--;\n    }\n    foreach(c; lst[1])\n\
    \    {\n        if(c == '(')\n            b++;\n        else\n            b--;\n\
    \    }\n    if(a == 0 && b == 0)\n        return \"Yes\";\n    if(a < 0 || b <\
    \ 0)\n        return \"No\";\n    if(a == b)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf4lh2koz.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429085]\\n??:? void tmpf4lh2koz.__unittest_L45_C1()\
    \ [0x427cc4]\\n??:? void tmpf4lh2koz.__modtest() [0x4282f0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a881]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428db5]\\n??:? runModuleUnitTests [0x42d7a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429548]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294cf]\\n??:? _d_run_main [0x42943a]\\n??:? main [0x428303]\\\
    n??:? __libc_start_main [0xeed62554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2fc9jxuy.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmp2fc9jxuy.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmp2fc9jxuy.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xe1f34554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvumloho2.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpvumloho2.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpvumloho2.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x1b968554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgztnthdn.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpgztnthdn.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpgztnthdn.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x15fe8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxlswt_k_.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpxlswt_k_.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpxlswt_k_.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x907f2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbqb096bd.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpbqb096bd.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpbqb096bd.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xdc8fb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx1y_wi9m.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpx1y_wi9m.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpx1y_wi9m.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x4bf00554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz6ranf1w.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpz6ranf1w.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpz6ranf1w.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xaf2f8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n        }\n    }\n    return count == 0 ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpy5i_sw8k.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpy5i_sw8k.__unittest_L34_C1()\
    \ [0x4280a2]\\n??:? void tmpy5i_sw8k.__modtest() [0x42825c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x42826f]\\\
    n??:? __libc_start_main [0x5e246554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplts9maq1.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmplts9maq1.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmplts9maq1.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xbec03554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string a\
    \ = lst[0];\n    string b = lst[1];\n    int a_count = 0;\n    int b_count = 0;\n\
    \    foreach(c; a)\n    {\n        if(c == '(')\n            a_count++;\n    \
    \    else\n            a_count--;\n    }\n    foreach(c; b)\n    {\n        if(c\
    \ == '(')\n            b_count++;\n        else\n            b_count--;\n    }\n\
    \    if(a_count == 0 && b_count == 0)\n        return \"Yes\";\n    else if(a_count\
    \ == 0 && b_count != 0)\n        return \"No\";\n    else if(a_count != 0 && b_count\
    \ == 0)\n        return \"No\";\n    else if(a_count > 0 && b_count < 0)\n   \
    \     return \"No\";\n    else if(a_count < 0 && b_count > 0)\n        return\
    \ \"No\";\n    else\n        return \"Yes\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx4kjrk4k.d(56): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290cd]\\n??:? void tmpx4kjrk4k.__unittest_L52_C1()\
    \ [0x427d0c]\\n??:? void tmpx4kjrk4k.__modtest() [0x428338]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8c9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a958]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a855]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dfd]\\n??:? runModuleUnitTests [0x42d7f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429590]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429517]\\n??:? _d_run_main [0x429482]\\n??:? main [0x42834b]\\\
    n??:? __libc_start_main [0x8fc6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(e;\
    \ s)\n    {\n        if(e == '(')\n            count++;\n        else if(e ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsalya9ni.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpsalya9ni.__unittest_L38_C1()\
    \ [0x427e0e]\\n??:? void tmpsalya9ni.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0xbfb29554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            left++;\n        else\n            right++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            left++;\n        else\n  \
    \          right++;\n    }\n    if(left == right)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7jo_sk1o.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp7jo_sk1o.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp7jo_sk1o.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xc4d76554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4k0ye_uq.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp4k0ye_uq.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp4k0ye_uq.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x69d7a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpigqo2rle.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpigqo2rle.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpigqo2rle.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x28636554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int cnt = 0;\n    foreach(e;\
    \ s)\n    {\n        if(e == '(')\n            cnt++;\n        else if(e == ')')\n\
    \            cnt--;\n        if(cnt < 0)\n            return \"No\";\n    }\n\
    \    return cnt == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbwo69lls.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpbwo69lls.__unittest_L36_C1()\
    \ [0x427e0a]\\n??:? void tmpbwo69lls.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xdac82554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0030lq80.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp0030lq80.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmp0030lq80.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x2eba1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(ch; s1)\n    {\n        if(ch == '(')\n            count1++;\n  \
    \      else\n            count1--;\n    }\n    foreach(ch; s2)\n    {\n      \
    \  if(ch == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1\
    \ > 0 && count2 < 0)\n        return \"Yes\";\n    if(count1 < 0 && count2 > 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp608eknsh.d(53): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmp608eknsh.__unittest_L47_C1()\
    \ [0x427ddc]\\n??:? void tmp608eknsh.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0x3d980554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4308m74t.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp4308m74t.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp4308m74t.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xac5e9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   count++;\n        else\n            count--;\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpldpb9_7w.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpldpb9_7w.__unittest_L42_C1()\
    \ [0x428102]\\n??:? void tmpldpb9_7w.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0x32bfb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(paren; lst[0])\n    {\n        if(paren\
    \ == '(')\n            open++;\n        else\n            close++;\n    }\n  \
    \  foreach(paren; lst[1])\n    {\n        if(paren == '(')\n            open++;\n\
    \        else\n            close++;\n    }\n    if(open == close)\n        return\
    \ \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp04bq6cgg.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp04bq6cgg.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp04bq6cgg.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x286dc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjf2dl7wt.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpjf2dl7wt.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmpjf2dl7wt.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x6bf9c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"Yes\";\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open != close)\n        result = \"No\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkc4y500v.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpkc4y500v.__unittest_L38_C1()\
    \ [0x4280be]\\n??:? void tmpkc4y500v.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0x19562554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string a\
    \ = lst[0];\n    string b = lst[1];\n    int a_open = 0;\n    int b_open = 0;\n\
    \    foreach(c; a)\n    {\n        if(c == '(')\n            a_open++;\n     \
    \   else\n            a_open--;\n        if(a_open < 0)\n            return \"\
    No\";\n    }\n    foreach(c; b)\n    {\n        if(c == '(')\n            b_open++;\n\
    \        else\n            b_open--;\n        if(b_open < 0)\n            return\
    \ \"No\";\n    }\n    if(a_open == b_open)\n        return \"Yes\";\n    return\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqw8o3fcs.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429085]\\n??:? void tmpqw8o3fcs.__unittest_L47_C1()\
    \ [0x427cc0]\\n??:? void tmpqw8o3fcs.__modtest() [0x4282ec]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9d3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dde]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a881]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a910]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a80d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428db5]\\n??:? runModuleUnitTests [0x42d7a9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429548]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294cf]\\n??:? _d_run_main [0x42943a]\\n??:? main [0x4282ff]\\\
    n??:? __libc_start_main [0xd36f9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8peegue0.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp8peegue0.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp8peegue0.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x2ca2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk76s0mbf.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpk76s0mbf.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmpk76s0mbf.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xdfb85554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n            count++;\n\
    \        else\n            count--;\n    }\n    foreach(i; lst[1])\n    {\n  \
    \      if(i == '(')\n            count++;\n        else\n            count--;\n\
    \    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkkx98emc.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpkkx98emc.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpkkx98emc.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x5aedb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    return\
    \ (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpczffxse0.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpczffxse0.__unittest_L35_C1()\
    \ [0x4280aa]\\n??:? void tmpczffxse0.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x8855e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnrg5z9xi.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpnrg5z9xi.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpnrg5z9xi.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xcfa7b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int[] count\
    \ = new int[2];\n    foreach(i, s; lst)\n    {\n        foreach(c; s)\n      \
    \  {\n            if(c == '(')\n                count[i]++;\n            else\n\
    \                count[i]--;\n            if(count[i] < 0)\n                return\
    \ \"No\";\n        }\n    }\n    return count[0] == count[1] ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp22gjz812.d(40): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42939d]\\n??:? void tmp22gjz812.__unittest_L36_C1()\
    \ [0x427fd8]\\n??:? void tmp22gjz812.__modtest() [0x428604]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42df2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x4290f6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42abf5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42ac84]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ab81]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x4290cd]\\n??:? runModuleUnitTests [0x42dd01]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429860]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4297e7]\\n??:? _d_run_main [0x429752]\\n??:? main [0x428617]\\\
    n??:? __libc_start_main [0x3cc98554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ < 0 && count2 < 0)\n        return \"No\";\n    else if(count1 > 0 && count2\
    \ > 0)\n        return \"No\";\n    else\n    {\n        if(count1 > 0)\n    \
    \    {\n            if(count1 == abs(count2))\n                return \"Yes\"\
    ;\n            else\n                return \"No\";\n        }\n        else\n\
    \        {\n            if(count2 == abs(count1))\n                return \"Yes\"\
    ;\n            else\n                return \"No\";\n        }\n    }\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmuup0iu6.d(76): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42914d]\\n??:? void tmpmuup0iu6.__unittest_L63_C1()\
    \ [0x4281e6]\\n??:? void tmpmuup0iu6.__modtest() [0x4283b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ea6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a949]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e7d]\\n??:? runModuleUnitTests [0x42d871]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429610]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429597]\\n??:? _d_run_main [0x429502]\\n??:? main [0x4283c7]\\\
    n??:? __libc_start_main [0x4ff14554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpiw0a5zdp.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpiw0a5zdp.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpiw0a5zdp.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xab643554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"Yes\";\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else if(c == ')')\n                close++;\n\
    \        }\n    }\n    if(open != close)\n        result = \"No\";\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbaa_z6eg.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpbaa_z6eg.__unittest_L38_C1()\
    \ [0x4280c2]\\n??:? void tmpbaa_z6eg.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xa33ab554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpm7p9bwqv.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpm7p9bwqv.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpm7p9bwqv.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x724bd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4d4hcpt7.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp4d4hcpt7.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp4d4hcpt7.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x7f432554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    if(open\
    \ == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpoxug9eyt.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpoxug9eyt.__unittest_L37_C1()\
    \ [0x4280ae]\\n??:? void tmpoxug9eyt.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0x8a8e9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcje7bkve.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpcje7bkve.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpcje7bkve.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xfce78554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return open == close\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqemlhmcm.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpqemlhmcm.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmpqemlhmcm.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x68946554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s =\
    \ lst[0] ~ lst[1];\n    auto c = 0;\n    foreach(i; s)\n    {\n        if(i ==\
    \ '(')\n            c++;\n        else if(i == ')')\n            c--;\n      \
    \  if(c < 0)\n            return \"No\";\n    }\n    return c == 0 ? \"Yes\" :\
    \ \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp54dia4vj.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmp54dia4vj.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmp54dia4vj.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x9b75d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    if(count1 ==\
    \ 0 && count2 != 0)\n        return \"No\";\n    if(count1 != 0 && count2 == 0)\n\
    \        return \"No\";\n    if(count1 > 0 && count2 > 0)\n        return \"No\"\
    ;\n    if(count1 < 0 && count2 < 0)\n        return \"No\";\n    if(count1 < 0\
    \ && count2 > 0)\n    {\n        if(abs(count1) == count2)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    if(count1 > 0\
    \ && count2 < 0)\n    {\n        if(abs(count2) == count1)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmperk7kjya.d(78): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291a5]\\n??:? void tmperk7kjya.__unittest_L65_C1()\
    \ [0x428242]\\n??:? void tmperk7kjya.__modtest() [0x428410]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42daf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428efe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9a1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a92d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ed5]\\n??:? runModuleUnitTests [0x42d8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429668]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295ef]\\n??:? _d_run_main [0x42955a]\\n??:? main [0x428423]\\\
    n??:? __libc_start_main [0x5d15f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int x =\
    \ 0;\n    int y = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n  \
    \          x++;\n        else\n            x--;\n    }\n    foreach(i; lst[1])\n\
    \    {\n        if(i == '(')\n            y++;\n        else\n            y--;\n\
    \    }\n    if(x == 0 && y == 0)\n        return \"Yes\";\n    else if(x == 0\
    \ && y != 0)\n        return \"No\";\n    else if(x != 0 && y == 0)\n        return\
    \ \"No\";\n    else if(x < 0 && y < 0)\n        return \"No\";\n    else if(x\
    \ > 0 && y > 0)\n        return \"No\";\n    else if(x < 0 && y > 0)\n    {\n\
    \        if(abs(x) == y)\n            return \"Yes\";\n        else\n        \
    \    return \"No\";\n    }\n    else if(x > 0 && y < 0)\n    {\n        if(abs(y)\
    \ == x)\n            return \"Yes\";\n        else\n            return \"No\"\
    ;\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpytd2n3jl.d(76): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291a5]\\n??:? void tmpytd2n3jl.__unittest_L63_C1()\
    \ [0x42823e]\\n??:? void tmpytd2n3jl.__modtest() [0x42840c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42daf3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428efe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9a1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa30]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a92d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ed5]\\n??:? runModuleUnitTests [0x42d8c9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429668]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295ef]\\n??:? _d_run_main [0x42955a]\\n??:? main [0x42841f]\\\
    n??:? __libc_start_main [0x1c240554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string str; lst)\n    {\n        foreach(char c; str)\n  \
    \      {\n            if(c == '(')\n                count++;\n            else\n\
    \                count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyfzco8wd.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpyfzco8wd.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpyfzco8wd.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x836be554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdpvce4fm.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpdpvce4fm.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmpdpvce4fm.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xc3d4d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpy2rhqlg_.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpy2rhqlg_.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpy2rhqlg_.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xa44eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int a =\
    \ 0;\n    int b = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\n  \
    \          a++;\n        else\n            a--;\n    }\n    foreach(c; lst[1])\n\
    \    {\n        if(c == '(')\n            b++;\n        else\n            b--;\n\
    \    }\n    if(a == 0 && b == 0)\n        return \"Yes\";\n    if(a > 0 && b <\
    \ 0)\n        return \"Yes\";\n    if(a < 0 && b > 0)\n        return \"Yes\"\
    ;\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmps502n3ug.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42908d]\\n??:? void tmps502n3ug.__unittest_L45_C1()\
    \ [0x427dd4]\\n??:? void tmps502n3ug.__modtest() [0x4282f4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9db]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428de6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a889]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a918]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a815]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dbd]\\n??:? runModuleUnitTests [0x42d7b1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429550]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294d7]\\n??:? _d_run_main [0x429442]\\n??:? main [0x428307]\\\
    n??:? __libc_start_main [0x8e116554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxqf0q1ff.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpxqf0q1ff.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpxqf0q1ff.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xc97a0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp70xtbdul.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp70xtbdul.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp70xtbdul.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x1020d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int count =\
    \ 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n \
    \       else if(c == ')')\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptj7apiiq.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmptj7apiiq.__unittest_L38_C1()\
    \ [0x427e0a]\\n??:? void tmptj7apiiq.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0xcb9f5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeeug0q0w.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpeeug0q0w.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpeeug0q0w.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x727bf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    int\
    \ open2 = 0;\n    int close2 = 0;\n    foreach(char c; lst[1])\n    {\n      \
    \  if(c == '(')\n            open2++;\n        else\n            close2++;\n \
    \   }\n    if(open2 == close && open == close2)\n        return \"Yes\";\n   \
    \ return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk56u0f96.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42905d]\\n??:? void tmpk56u0f96.__unittest_L43_C1()\
    \ [0x427c98]\\n??:? void tmpk56u0f96.__modtest() [0x4282c4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9ab]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428db6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a859]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7e5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d8d]\\n??:? runModuleUnitTests [0x42d781]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429520]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294a7]\\n??:? _d_run_main [0x429412]\\n??:? main [0x4282d7]\\\
    n??:? __libc_start_main [0xa8ad5554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1rgoqo_g.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp1rgoqo_g.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp1rgoqo_g.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x4691a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"No\";\n    string s1 = lst[0];\n    string s2 = lst[1];\n    string s =\
    \ s1 ~ s2;\n    int open = 0;\n    int close = 0;\n    foreach(c; s)\n    {\n\
    \        if(c == '(')\n            open++;\n        else\n            close++;\n\
    \        if(close > open)\n            break;\n    }\n    if(open == close)\n\
    \        result = \"Yes\";\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpz1so0uj1.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpz1so0uj1.__unittest_L40_C1()\
    \ [0x427e02]\\n??:? void tmpz1so0uj1.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d98b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a839]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42d761]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429500]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429487]\\n??:? _d_run_main [0x4293f2]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0x27e89554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"Yes\";\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open != close)\n        result = \"No\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxh0jm0qm.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpxh0jm0qm.__unittest_L38_C1()\
    \ [0x4280be]\\n??:? void tmpxh0jm0qm.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0xa65b2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int cnt1 = 0;\n    int cnt2 = 0;\n \
    \   foreach(c; s1)\n    {\n        if(c == '(')\n            cnt1++;\n       \
    \ else\n            cnt1--;\n    }\n    foreach(c; s2)\n    {\n        if(c ==\
    \ '(')\n            cnt2++;\n        else\n            cnt2--;\n    }\n    if(cnt1\
    \ == 0 && cnt2 == 0)\n        return \"Yes\";\n    else if(cnt1 > 0 && cnt2 <\
    \ 0)\n        return \"Yes\";\n    else if(cnt1 < 0 && cnt2 > 0)\n        return\
    \ \"Yes\";\n    else\n        return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpf3khpcq4.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429095]\\n??:? void tmpf3khpcq4.__unittest_L48_C1()\
    \ [0x427ddc]\\n??:? void tmpf3khpcq4.__modtest() [0x4282fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9e3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a891]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a920]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a81d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428dc5]\\n??:? runModuleUnitTests [0x42d7b9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429558]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294df]\\n??:? _d_run_main [0x42944a]\\n??:? main [0x42830f]\\\
    n??:? __libc_start_main [0x51ee2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkl1pfs44.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpkl1pfs44.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmpkl1pfs44.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x7d4e0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(c; lst[0])\n    {\n        if(c == '(')\
    \ left++;\n        else right++;\n    }\n    foreach(c; lst[1])\n    {\n     \
    \   if(c == '(') left++;\n        else right++;\n    }\n    if(left == right)\
    \ return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpljttb2l7.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpljttb2l7.__unittest_L36_C1()\
    \ [0x4280fa]\\n??:? void tmpljttb2l7.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xf9c00554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1ehm__2w.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp1ehm__2w.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp1ehm__2w.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0xfce96554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(abs(count2) == count1)\n            return\
    \ \"Yes\";\n    }\n    else if(count1 < 0 && count2 > 0)\n    {\n        if(abs(count1)\
    \ == count2)\n            return \"Yes\";\n    }\n    return \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgj7kpw8c.d(66): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42910d]\\n??:? void tmpgj7kpw8c.__unittest_L53_C1()\
    \ [0x4281aa]\\n??:? void tmpgj7kpw8c.__modtest() [0x428378]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da5b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a909]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a998]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a895]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e3d]\\n??:? runModuleUnitTests [0x42d831]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4295d0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429557]\\n??:? _d_run_main [0x4294c2]\\n??:? main [0x42838b]\\\
    n??:? __libc_start_main [0xe277f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    return\
    \ (open == close) ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkoa9wisp.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpkoa9wisp.__unittest_L35_C1()\
    \ [0x4280aa]\\n??:? void tmpkoa9wisp.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x9717d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpv2527hh5.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpv2527hh5.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmpv2527hh5.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0x69085554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(i; lst)\n        s ~= i;\n    return balance(s) ? \"Yes\"\
    \ : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplyqjcmp9.d(24): Error: undefined identifier `balance`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplyqjcmp9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeeg0ioyj.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpeeg0ioyj.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpeeg0ioyj.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0x6aeae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else if(c\
    \ == ')')\n                count--;\n            if(count < 0)\n             \
    \   return \"No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpybucj0ec.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpybucj0ec.__unittest_L36_C1()\
    \ [0x427dde]\\n??:? void tmpybucj0ec.__modtest() [0x428280]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x428293]\\\
    n??:? __libc_start_main [0xad32b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplbrgdvqb.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmplbrgdvqb.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmplbrgdvqb.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xf3784554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s) {\n        if (c ==\
    \ '(') {\n            count++;\n        } else {\n            count--;\n     \
    \   }\n        if (count < 0) {\n            return \"No\";\n        }\n    }\n\
    \    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzi37u0ln.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpzi37u0ln.__unittest_L35_C1()\
    \ [0x427dee]\\n??:? void tmpzi37u0ln.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x73bfc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvgvq5y77.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpvgvq5y77.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpvgvq5y77.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x79519554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n\
    \    int c1 = 0;\n    int c2 = 0;\n    foreach(c; s1)\n    {\n        if(c ==\
    \ '(')\n            c1++;\n        else\n            c1--;\n    }\n    foreach(c;\
    \ s2)\n    {\n        if(c == '(')\n            c2++;\n        else\n        \
    \    c2--;\n    }\n    if(c1 == 0 && c2 == 0)\n        return \"Yes\";\n    if(c1\
    \ < 0 && c2 < 0)\n        return \"No\";\n    if(c1 > 0 && c2 > 0)\n        return\
    \ \"No\";\n    if(c1 > 0)\n    {\n        if(c1 == c2)\n            return \"\
    Yes\";\n        else\n            return \"No\";\n    }\n    else\n    {\n   \
    \     if(c1 == c2)\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvncvm09j.d(23): Error: cannot implicitly convert expression `s1.length`\
    \ of type `ulong` to `int`\\n/tmp/tmpvncvm09j.d(24): Error: cannot implicitly\
    \ convert expression `s2.length` of type `ulong` to `int`\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvncvm09j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    string s = s1 ~ s2;\n    int count =\
    \ 0;\n    foreach(c; s)\n    {\n        if(c == '(')\n            count++;\n \
    \       else if(c == ')')\n            count--;\n        if(count < 0)\n     \
    \       return \"No\";\n    }\n    if(count == 0)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpg84oykw0.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpg84oykw0.__unittest_L38_C1()\
    \ [0x427e0a]\\n??:? void tmpg84oykw0.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x11c2f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk5jg6tis.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpk5jg6tis.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpk5jg6tis.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xd8eb4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpmsfbml62.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmpmsfbml62.__unittest_L65_C1()\
    \ [0x427d78]\\n??:? void tmpmsfbml62.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a939]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d861]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429600]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429587]\\n??:? _d_run_main [0x4294f2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0xc9327554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2igo_w21.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp2igo_w21.__unittest_L34_C1()\
    \ [0x427dee]\\n??:? void tmp2igo_w21.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x914b9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int n1 = s1.length;\n    int n2 = s2.length;\n\
    \    int n = n1 + n2;\n    int[] a = new int[n];\n    int[] b = new int[n];\n\
    \    int[] c = new int[n];\n    int[] d = new int[n];\n    int[] e = new int[n];\n\
    \    int[] f = new int[n];\n    int[] g = new int[n];\n    int[] h = new int[n];\n\
    \    int[] i = new int[n];\n    int[] j = new int[n];\n    int[] k = new int[n];\n\
    \    int[] l = new int[n];\n    int[] m = new int[n];\n    int[] o = new int[n];\n\
    \    int[] p = new int[n];\n    int[] q = new int[n];\n    int[] r = new int[n];\n\
    \    int[] t = new int[n];\n    int[] u = new int[n];\n    int[] v = new int[n];\n\
    \    int[] w = new int[n];\n    int[] x = new int[n];\n    int[] y = new int[n];\n\
    \    int[] z = new int[n];\n    int[] aa = new int[n];\n    int[] bb = new int[n];\n\
    \    int[] cc = new int[n];\n    int[] dd = new int[n];\n    int[] ee = new int[n];\n\
    \    int[] ff = new int[n];\n    int[] gg = new int[n];\n    int[] hh = new int[n];\n\
    \    int[] ii = new int[n];\n    int[] jj = new int[n];\n    int[] kk = new int[n];\n\
    \    int[] ll = new int[n];\n    int[] mm = new int[n];\n    int[] oo = new int[n];\n\
    \    int[] pp = new int[n];\n    int[] qq = new int[n];\n    int[] rr\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf0qrfugd.d(67): Error: semicolon expected, not `unittest`\\n/tmp/tmpf0qrfugd.d(67):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpf0qrfugd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    return open == close ? \"Yes\" : \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplfk78dxr.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmplfk78dxr.__unittest_L39_C1()\
    \ [0x4280f6]\\n??:? void tmplfk78dxr.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x547eb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    if(open\
    \ == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5nxidz2n.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp5nxidz2n.__unittest_L37_C1()\
    \ [0x4280ae]\\n??:? void tmp5nxidz2n.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0xb033b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7h8gt40i.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmp7h8gt40i.__unittest_L34_C1()\
    \ [0x427dee]\\n??:? void tmp7h8gt40i.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x3e449554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpuccvcm2a.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpuccvcm2a.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpuccvcm2a.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x263db554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptef1x4kc.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmptef1x4kc.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmptef1x4kc.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xeb2d2554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqe6axr3p.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpqe6axr3p.__unittest_L34_C1()\
    \ [0x427dee]\\n??:? void tmpqe6axr3p.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x9a37f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    auto s1\
    \ = lst[0];\n    auto s2 = lst[1];\n    auto s3 = s1 ~ s2;\n    auto s4 = s2 ~\
    \ s1;\n    auto s5 = s1 ~ s1;\n    auto s6 = s2 ~ s2;\n    auto s7 = s3 ~ s3;\n\
    \    auto s8 = s4 ~ s4;\n    auto s9 = s5 ~ s5;\n    auto s10 = s6 ~ s6;\n   \
    \ auto s11 = s7 ~ s7;\n    auto s12 = s8 ~ s8;\n    auto s13 = s9 ~ s9;\n    auto\
    \ s14 = s10 ~ s10;\n    auto s15 = s11 ~ s11;\n    auto s16 = s12 ~ s12;\n   \
    \ auto s17 = s13 ~ s13;\n    auto s18 = s14 ~ s14;\n    auto s19 = s15 ~ s15;\n\
    \    auto s20 = s16 ~ s16;\n    auto s21 = s17 ~ s17;\n    auto s22 = s18 ~ s18;\n\
    \    auto s23 = s19 ~ s19;\n    auto s24 = s20 ~ s20;\n    auto s25 = s21 ~ s21;\n\
    \    auto s26 = s22 ~ s22;\n    auto s27 = s23 ~ s23;\n    auto s28 = s24 ~ s24;\n\
    \    auto s29 = s25 ~ s25;\n    auto s30 = s26 ~ s26;\n    auto s31 = s27 ~ s27;\n\
    \    auto s32 = s28 ~ s28;\n    auto s33 = s29 ~ s29;\n    auto s34 = s30 ~ s30;\n\
    \    auto s35 = s31 ~ s31;\n    auto s36 = s32 ~ s32;\n    auto s37 = s33 ~ s33;\n\
    \    auto s38 = s34 ~ s34;\n    auto s39 = s35 ~ s35;\n    auto s40 = s36 ~ s36;\n\
    \    auto s41 = s37 ~ s37;\n    auto s42 = s38 ~ s38;\n    auto s43 = s39\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpva70d7kj.d(64): Error: semicolon expected following auto declaration,\
    \ not `unittest`\\n/tmp/tmpva70d7kj.d(64): Error: found `unittest` instead of\
    \ statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpva70d7kj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkup9t75j.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpkup9t75j.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpkup9t75j.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x1053554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return open == close\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1e8gasff.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp1e8gasff.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmp1e8gasff.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xc0fc9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(string str; lst)\n    {\n        s ~= str;\n    }\n   \
    \ int count = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n      \
    \  {\n            count++;\n        }\n        else\n        {\n            count--;\n\
    \        }\n        if(count < 0)\n        {\n            return \"No\";\n   \
    \     }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6rg5_xk8.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmp6rg5_xk8.__unittest_L48_C1()\
    \ [0x427e06]\\n??:? void tmp6rg5_xk8.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0x864dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpo1r17ce0.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpo1r17ce0.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpo1r17ce0.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x46865554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp639wn7tn.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmp639wn7tn.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmp639wn7tn.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x5e46d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ > 0 && count2 < 0)\n    {\n        if(abs(count2) % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    else if(count1\
    \ < 0 && count2 > 0)\n    {\n        if(abs(count1) % 2 == 0)\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n    else\n      \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdake8xpy.d(62): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429145]\\n??:? void tmpdake8xpy.__unittest_L58_C1()\
    \ [0x427d70]\\n??:? void tmpdake8xpy.__modtest() [0x4283b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a941]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e75]\\n??:? runModuleUnitTests [0x42d869]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429608]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42958f]\\n??:? _d_run_main [0x4294fa]\\n??:? main [0x4283c3]\\\
    n??:? __libc_start_main [0x5216f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqx_das1e.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpqx_das1e.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpqx_das1e.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xc9871554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else if(c == ')')\n                close++;\n        }\n    }\n    if(open\
    \ == close)\n        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n   \
    \ alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) ==\
    \ \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpldcdctb8.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmpldcdctb8.__unittest_L37_C1()\
    \ [0x4280ae]\\n??:? void tmpldcdctb8.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0x931bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp715s8y7h.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp715s8y7h.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp715s8y7h.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x33bba554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else\n    {\n        if(abs(count1) == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpeq5b_5g1.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429165]\\n??:? void tmpeq5b_5g1.__unittest_L57_C1()\
    \ [0x427d8c]\\n??:? void tmpeq5b_5g1.__modtest() [0x4283cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ebe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a961]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e95]\\n??:? runModuleUnitTests [0x42d889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429628]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295af]\\n??:? _d_run_main [0x42951a]\\n??:? main [0x4283df]\\\
    n??:? __libc_start_main [0x354fc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count = 0;\n    foreach(c; s1)\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    foreach(c; s2)\n    {\n        if(c == '(')\n         \
    \   count++;\n        else\n            count--;\n    }\n    if(count == 0)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplodf5qzk.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmplodf5qzk.__unittest_L42_C1()\
    \ [0x428102]\\n??:? void tmplodf5qzk.__modtest() [0x4282bc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282cf]\\\
    n??:? __libc_start_main [0xd25ec554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int c = 0;\n    foreach(e;\
    \ s)\n    {\n        if(e == '(')\n            c++;\n        else\n          \
    \  c--;\n        if(c < 0)\n            return \"No\";\n    }\n    return c ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp30xwvfen.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmp30xwvfen.__unittest_L36_C1()\
    \ [0x427e02]\\n??:? void tmp30xwvfen.__modtest() [0x4282a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282b7]\\\
    n??:? __libc_start_main [0x42fc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_q5eyjey.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp_q5eyjey.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp_q5eyjey.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x9bce8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else\n            count--;\n        if(count\
    \ < 0)\n            return \"No\";\n    }\n    return count == 0 ? \"Yes\" : \"\
    No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp78d4dkg.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429025]\\n??:? void tmpp78d4dkg.__unittest_L34_C1()\
    \ [0x427dee]\\n??:? void tmpp78d4dkg.__modtest() [0x428290]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d973]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d7e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a821]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7ad]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d55]\\n??:? runModuleUnitTests [0x42d749]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x4282a3]\\\
    n??:? __libc_start_main [0x89936554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            left++;\n        else\n            right++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            left++;\n        else\n\
    \            right++;\n    }\n    if(left == right)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbjx3q650.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpbjx3q650.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpbjx3q650.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x173cb554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3mthfy1l.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp3mthfy1l.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp3mthfy1l.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0x708f9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    return \"No\"\
    ;\n}\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnifhqt4x.d(47): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429055]\\n??:? void tmpnifhqt4x.__unittest_L43_C1()\
    \ [0x427c94]\\n??:? void tmpnifhqt4x.__modtest() [0x4282c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9a3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428dae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a851]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8e0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7dd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d85]\\n??:? runModuleUnitTests [0x42d779]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429518]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42949f]\\n??:? _d_run_main [0x42940a]\\n??:? main [0x4282d3]\\\
    n??:? __libc_start_main [0x14280554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(char c; lst[0])\n    {\n        if(c ==\
    \ '(')\n            open++;\n        else\n            close++;\n    }\n    foreach(char\
    \ c; lst[1])\n    {\n        if(c == '(')\n            open++;\n        else\n\
    \            close++;\n    }\n    if(open == close)\n        return \"Yes\";\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0gd5vhvs.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp0gd5vhvs.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp0gd5vhvs.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x35f11554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp5ygavxb7.d(57): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4290ad]\\n??:? void tmp5ygavxb7.__unittest_L53_C1()\
    \ [0x427ce8]\\n??:? void tmp5ygavxb7.__modtest() [0x428314]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d9fb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e06]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a8a9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a938]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a835]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428ddd]\\n??:? runModuleUnitTests [0x42d7d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429570]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4294f7]\\n??:? _d_run_main [0x429462]\\n??:? main [0x428327]\\\
    n??:? __libc_start_main [0x1394d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(e; lst)\n        s ~= e;\n    int count = 0;\n    foreach(e;\
    \ s)\n    {\n        if(e == '(')\n            count++;\n        else if(e ==\
    \ ')')\n            count--;\n        if(count < 0)\n            return \"No\"\
    ;\n    }\n    if(count == 0)\n        return \"Yes\";\n    return \"No\";\n}\n\
    unittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\"\
    , \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n   \
    \ assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxc7dnte8.d(45): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpxc7dnte8.__unittest_L38_C1()\
    \ [0x427e0e]\\n??:? void tmpxc7dnte8.__modtest() [0x4282b0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3bb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b269]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1f5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42e191]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429494]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42941b]\\n??:? _d_run_main [0x429386]\\n??:? main [0x4282c3]\\\
    n??:? __libc_start_main [0x8b975554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    if(open == close)\n\
    \        return \"Yes\";\n    return \"No\";\n}\nunittest\n{\n    alias candidate\
    \ = match_parens;\n\n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n   \
    \ assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\"\
    , \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"\
    Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"\
    ()\", \"())\"]) == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"\
    Yes\");\n    assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1hib9zfr.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ffd]\\n??:? void tmp1hib9zfr.__unittest_L37_C1()\
    \ [0x4280aa]\\n??:? void tmp1hib9zfr.__modtest() [0x428264]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8d7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a785]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a814]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a711]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d6ad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42944c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293d3]\\n??:? _d_run_main [0x42933e]\\n??:? main [0x428277]\\\
    n??:? __libc_start_main [0x29371554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprw0848o3.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmprw0848o3.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmprw0848o3.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xce520554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else if(count1 > 0 && count2 > 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    else if(count1 < 0 && count2 < 0)\n    {\n        if(count1 == count2)\n\
    \            return \"Yes\";\n        else\n            return \"No\";\n    }\n\
    \    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n \
    \   assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpx58inz39.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42913d]\\n??:? void tmpx58inz39.__unittest_L65_C1()\
    \ [0x427d78]\\n??:? void tmpx58inz39.__modtest() [0x4283a4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42da8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428e96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a939]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8c5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e6d]\\n??:? runModuleUnitTests [0x42d861]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429600]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429587]\\n??:? _d_run_main [0x4294f2]\\n??:? main [0x4283b7]\\\
    n??:? __libc_start_main [0x32b9d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string result\
    \ = \"Yes\";\n    int open = 0;\n    int close = 0;\n    foreach(string s; lst)\n\
    \    {\n        foreach(char c; s)\n        {\n            if(c == '(')\n    \
    \            open++;\n            else\n                close++;\n        }\n\
    \    }\n    if(open != close)\n        result = \"No\";\n    return result;\n\
    }\nunittest\n{\n    alias candidate = match_parens;\n\n    assert(candidate([\"\
    ()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n\
    \    assert(candidate([\"(()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\"\
    )())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"\
    ]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpe66xg2tr.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42900d]\\n??:? void tmpe66xg2tr.__unittest_L38_C1()\
    \ [0x4280be]\\n??:? void tmpe66xg2tr.__modtest() [0x428278]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8e7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d66]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a824]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d3d]\\n??:? runModuleUnitTests [0x42d6bd]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42945c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293e3]\\n??:? _d_run_main [0x42934e]\\n??:? main [0x42828b]\\\
    n??:? __libc_start_main [0x765c3554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpswm_kwcf.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmpswm_kwcf.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmpswm_kwcf.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0x7be51554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = lst[0] ~ lst[1];\n    int count = 0;\n    foreach(c; s)\n    {\n        if(c\
    \ == '(')\n            count++;\n        else if(c == ')')\n            count--;\n\
    \        if(count < 0)\n            return \"No\";\n    }\n    return count ==\
    \ 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt_mad59l.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42902d]\\n??:? void tmpt_mad59l.__unittest_L34_C1()\
    \ [0x427df6]\\n??:? void tmpt_mad59l.__modtest() [0x428298]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d97b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d86]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a829]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d5d]\\n??:? runModuleUnitTests [0x42d751]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294f0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429477]\\n??:? _d_run_main [0x4293e2]\\n??:? main [0x4282ab]\\\
    n??:? __libc_start_main [0xf2685554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string str1\
    \ = lst[0];\n    string str2 = lst[1];\n    int count1 = 0;\n    int count2 =\
    \ 0;\n    foreach(c; str1)\n    {\n        if(c == '(')\n            count1++;\n\
    \        else\n            count1--;\n    }\n    foreach(c; str2)\n    {\n   \
    \     if(c == '(')\n            count2++;\n        else\n            count2--;\n\
    \    }\n    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else\
    \ if(count1 == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 !=\
    \ 0 && count2 == 0)\n        return \"No\";\n    else if(count1 < 0 && count2\
    \ < 0)\n        return \"No\";\n    else if(count1 > 0 && count2 > 0)\n      \
    \  return \"No\";\n    else if(count1 > 0 && count2 < 0)\n    {\n        if(abs(count1)\
    \ == abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    else if(count1 < 0 && count2 > 0)\n    {\n        if(abs(count1)\
    \ == abs(count2))\n            return \"Yes\";\n        else\n            return\
    \ \"No\";\n    }\n    return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\
    \n    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp03u0acc9.d(78): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4291ed]\\n??:? void tmp03u0acc9.__unittest_L65_C1()\
    \ [0x428286]\\n??:? void tmp03u0acc9.__modtest() [0x428454]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db3b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428f46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a9e9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42aa78]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a975]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428f1d]\\n??:? runModuleUnitTests [0x42d911]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4296b0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429637]\\n??:? _d_run_main [0x4295a2]\\n??:? main [0x428467]\\\
    n??:? __libc_start_main [0xa7d4e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(string s; lst)\n    {\n        foreach(char\
    \ c; s)\n        {\n            if(c == '(')\n                open++;\n      \
    \      else\n                close++;\n        }\n    }\n    return (open == close)\
    \ ? \"Yes\" : \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n\
    \    assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"\
    No\");\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph6m3afwf.d(48): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ff5]\\n??:? void tmph6m3afwf.__unittest_L35_C1()\
    \ [0x4280a6]\\n??:? void tmph6m3afwf.__modtest() [0x428260]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8cf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a77d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a80c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a709]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d6a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429444]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293cb]\\n??:? _d_run_main [0x429336]\\n??:? main [0x428273]\\\
    n??:? __libc_start_main [0xa3795554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(char c; lst[0])\n    {\n        if(c == '(')\n           \
    \ count++;\n        else\n            count--;\n    }\n    foreach(char c; lst[1])\n\
    \    {\n        if(c == '(')\n            count++;\n        else\n           \
    \ count--;\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfhhk319i.d(51): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429045]\\n??:? void tmpfhhk319i.__unittest_L38_C1()\
    \ [0x4280f2]\\n??:? void tmpfhhk319i.__modtest() [0x4282ac]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d993]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a841]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7cd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d75]\\n??:? runModuleUnitTests [0x42d769]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429508]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42948f]\\n??:? _d_run_main [0x4293fa]\\n??:? main [0x4282bf]\\\
    n??:? __libc_start_main [0x770a1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkqixijx6.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmpkqixijx6.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmpkqixijx6.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xa918f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int count\
    \ = 0;\n    foreach(string s; lst)\n    {\n        foreach(char c; s)\n      \
    \  {\n            if(c == '(')\n                count++;\n            else\n \
    \               count--;\n            if(count < 0)\n                return \"\
    No\";\n        }\n    }\n    return count == 0 ? \"Yes\" : \"No\";\n}\nunittest\n\
    {\n    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"\
    ]) == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6z0xj9nn.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429015]\\n??:? void tmp6z0xj9nn.__unittest_L36_C1()\
    \ [0x427dda]\\n??:? void tmp6z0xj9nn.__modtest() [0x42827c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d8ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d6e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a79d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a82c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a729]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d45]\\n??:? runModuleUnitTests [0x42d6c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429464]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4293eb]\\n??:? _d_run_main [0x429356]\\n??:? main [0x42828f]\\\
    n??:? __libc_start_main [0xebfe9554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            left++;\n        else\n            right++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            left++;\n        else\n  \
    \          right++;\n    }\n    if(left == right)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp9v0b3vbv.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmp9v0b3vbv.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmp9v0b3vbv.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x2123c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int open\
    \ = 0;\n    int close = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            open++;\n        else\n            close++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            open++;\n        else\n  \
    \          close++;\n    }\n    if(open == close)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprz2tft0n.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmprz2tft0n.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmprz2tft0n.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0x3f8bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s1\
    \ = lst[0];\n    string s2 = lst[1];\n    int count1 = 0;\n    int count2 = 0;\n\
    \    foreach(c; s1)\n    {\n        if(c == '(')\n            count1++;\n    \
    \    else\n            count1--;\n    }\n    foreach(c; s2)\n    {\n        if(c\
    \ == '(')\n            count2++;\n        else\n            count2--;\n    }\n\
    \    if(count1 == 0 && count2 == 0)\n        return \"Yes\";\n    else if(count1\
    \ == 0 && count2 != 0)\n        return \"No\";\n    else if(count1 != 0 && count2\
    \ == 0)\n        return \"No\";\n    else if(count1 > 0 && count2 < 0)\n     \
    \   return \"No\";\n    else if(count1 < 0 && count2 > 0)\n        return \"No\"\
    ;\n    else\n    {\n        if(abs(count1) == abs(count2))\n            return\
    \ \"Yes\";\n        else\n            return \"No\";\n    }\n}\nunittest\n{\n\
    \    alias candidate = match_parens;\n\n    assert(candidate([\"()(\", \")\"])\
    \ == \"Yes\");\n    assert(candidate([\")\", \")\"]) == \"No\");\n    assert(candidate([\"\
    (()(())\", \"())())\"]) == \"No\");\n    assert(candidate([\")())\", \"(()()(\"\
    ]) == \"Yes\");\n    assert(candidate([\"(())))\", \"(()())((\"]) == \"Yes\");\n\
    \    assert(candidate([\"()\", \"())\"]) == \"No\");\n    assert(candidate([\"\
    (()(\", \"()))()\"]) == \"Yes\");\n    assert(candidate([\"((((\", \"((())\"])\
    \ == \"No\");\n    assert(candidate([\")(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\"\
    )(\", \")(\"]) == \"No\");\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n\
    \    assert(candidate([\")\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwe6z1s66.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429165]\\n??:? void tmpwe6z1s66.__unittest_L57_C1()\
    \ [0x427d8c]\\n??:? void tmpwe6z1s66.__modtest() [0x4283cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42dab3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428ebe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a961]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a9f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a8ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428e95]\\n??:? runModuleUnitTests [0x42d889]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429628]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4295af]\\n??:? _d_run_main [0x42951a]\\n??:? main [0x4283df]\\\
    n??:? __libc_start_main [0x71c44554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    int left\
    \ = 0;\n    int right = 0;\n    foreach(i; lst[0])\n    {\n        if(i == '(')\n\
    \            left++;\n        else\n            right++;\n    }\n    foreach(i;\
    \ lst[1])\n    {\n        if(i == '(')\n            left++;\n        else\n  \
    \          right++;\n    }\n    if(left == right)\n        return \"Yes\";\n \
    \   return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n  \
    \  assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcuvmygie.d(54): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42904d]\\n??:? void tmpcuvmygie.__unittest_L41_C1()\
    \ [0x4280fa]\\n??:? void tmpcuvmygie.__modtest() [0x4282b4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d99b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428da6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a849]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d7d]\\n??:? runModuleUnitTests [0x42d771]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429510]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429497]\\n??:? _d_run_main [0x429402]\\n??:? main [0x4282c7]\\\
    n??:? __libc_start_main [0xf3981554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    You are given a list\
    \ of two strings, both strings consist of open\n    parentheses '(' or close parentheses\
    \ ')' only.\n    Your job is to check if it is possible to concatenate the two\
    \ strings in\n    some order, that the resulting string will be good.\n    A string\
    \ S is considered to be good if and only if all parentheses in S\n    are balanced.\
    \ For example: the string '(())()' is good, while the string\n    '())' is not.\n\
    \    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')',\
    \ ')']) == 'No'\n    \n*/\nstring match_parens(string[] lst) \n{\n    string s\
    \ = \"\";\n    foreach(string i; lst)\n    {\n        s ~= i;\n    }\n    int\
    \ count = 0;\n    foreach(char c; s)\n    {\n        if(c == '(')\n        {\n\
    \            count++;\n        }\n        else\n        {\n            count--;\n\
    \        }\n        if(count < 0)\n        {\n            return \"No\";\n   \
    \     }\n    }\n    if(count == 0)\n    {\n        return \"Yes\";\n    }\n  \
    \  return \"No\";\n}\nunittest\n{\n    alias candidate = match_parens;\n\n   \
    \ assert(candidate([\"()(\", \")\"]) == \"Yes\");\n    assert(candidate([\")\"\
    , \")\"]) == \"No\");\n    assert(candidate([\"(()(())\", \"())())\"]) == \"No\"\
    );\n    assert(candidate([\")())\", \"(()()(\"]) == \"Yes\");\n    assert(candidate([\"\
    (())))\", \"(()())((\"]) == \"Yes\");\n    assert(candidate([\"()\", \"())\"])\
    \ == \"No\");\n    assert(candidate([\"(()(\", \"()))()\"]) == \"Yes\");\n   \
    \ assert(candidate([\"((((\", \"((())\"]) == \"No\");\n    assert(candidate([\"\
    )(()\", \"(()(\"]) == \"No\");\n    assert(candidate([\")(\", \")(\"]) == \"No\"\
    );\n    assert(candidate([\"(\", \")\"]) == \"Yes\");\n    assert(candidate([\"\
    )\", \"(\"]) == \"Yes\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpbm3c42g1.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42903d]\\n??:? void tmpbm3c42g1.__unittest_L48_C1()\
    \ [0x427e06]\\n??:? void tmpbm3c42g1.__modtest() [0x4282a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e3b3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d96]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b261]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b2f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b1ed]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d6d]\\n??:? runModuleUnitTests [0x42e189]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42948c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429413]\\n??:? _d_run_main [0x42937e]\\n??:? main [0x4282bb]\\\
    n??:? __libc_start_main [0x25d2c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
