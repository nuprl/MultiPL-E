name: HumanEval_6_parse_nested_parens
language: humaneval_to_dlang.py
prompt: "import std.typecons;\nimport std.math;\n/*\n Input to this function is a\
  \ string represented multiple groups for nested parentheses separated by spaces.\n\
  \    For each of the group, output the deepest level of nesting of parentheses.\n\
  \    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n \
  \   >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n \
  \   \n*/\nlong[] parse_nested_parens(string paren_string) \n"
tests: "unittest\n{\n    alias candidate = parse_nested_parens;\n\n    assert(candidate(\"\
  (()()) ((())) () ((())()())\") == [2L, 3L, 1L, 3L]);\n    assert(candidate(\"()\
  \ (()) ((())) (((())))\") == [1L, 2L, 3L, 4L]);\n    assert(candidate(\"(()(())((())))\"\
  ) == [4L]);\n}\nvoid main(){}"
completions: ["{\n    long[] result = new long[];\n    long[] stack = new long[];\n\
    \    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n           \
    \ depth += 1;\n            max_depth = max(max_depth, depth);\n        }\n   \
    \     else if(c == ')')\n        {\n            stack ~= -1;\n            depth\
    \ -= 1;\n        }\n        else if(c == ' ')\n        {\n            result ~=\
    \ max_depth;\n            max_depth = 0;\n            depth = 0;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n  \
    \  long[] max_stack;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            depth += 1;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n \
    \           depth -= 1;\n        }\n        else if(c == ' ')\n        {\n   \
    \         max_stack ~= max_depth;\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    max_stack ~= max_depth;\n    return max_stack;\n\
    }", "{\n    long[] result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    long max_depth = 0;\n\
    \    long depth = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(')\
    \ \n        {\n            stack ~= depth;\n            depth++;\n           \
    \ max_depth = max(max_depth, depth);\n        }\n        else if (c == ')') \n\
    \        {\n            depth = stack.pop;\n        }\n        else if (c == '\
    \ ') \n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    long[] stack = new long[];\n    long max_depth = 0;\n    long depth = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      stack ~= depth;\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if(c == ')')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                throw new Exception(\"Invalid input string\"\
    );\n            }\n            else\n            {\n                depth = stack[$-1];\n\
    \                stack = stack[0..$-1];\n            }\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n        else\n        {\n         \
    \   throw new Exception(\"Invalid input string\");\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long current_depth;\n    foreach (paren_group; paren_string.split) \n   \
    \ {\n        max_depth = 0;\n        current_depth = 0;\n        stack = [];\n\
    \        foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack ~= paren;\n                current_depth++;\n\
    \                max_depth = max(max_depth, current_depth);\n            } \n\
    \            else if (paren == ')') \n            {\n                stack.pop;\n\
    \                current_depth--;\n            }\n        }\n        result ~=\
    \ max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n    int max_nesting\
    \ = 0;\n    int current_nesting = 0;\n    foreach(c; paren_string) \n    {\n \
    \       if(c == '(') \n        {\n            current_nesting++;\n           \
    \ max_nesting = max(max_nesting, current_nesting);\n        }\n        else if(c\
    \ == ')') \n        {\n            current_nesting--;\n        }\n        else\
    \ if(c == ' ') \n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            current_nesting = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long max_depth = 0;\n    long current_depth =\
    \ 0;\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n        {\n\
    \            current_depth++;\n            max_depth = max(max_depth, current_depth);\n\
    \        } \n        else if(c == ')') \n        {\n            current_depth--;\n\
    \        } \n        else if(c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    foreach(paren_group; paren_string.split)\
    \ \n    {\n        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             depth++;\n                max_depth = max(max_depth, depth);\n \
    \           }\n            else if(paren == ')') \n            {\n           \
    \     depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    int[] stack\
    \ = new int[];\n    int max_depth = 0;\n    int depth = 0;\n    for (int i = 0;\
    \ i < paren_string.length; i++) \n    {\n        if (paren_string[i] == '(') \n\
    \        {\n            stack.push(paren_string[i]);\n            depth++;\n \
    \           max_depth = max(max_depth, depth);\n        } \n        else if (paren_string[i]\
    \ == ')') \n        {\n            stack.pop();\n            depth--;\n      \
    \  } \n        else if (paren_string[i] == ' ') \n        {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long[] max_stack;\n\
    \    long max_stack_size;\n    long stack_size;\n    long max_depth;\n    long\
    \ depth;\n    long i;\n    long j;\n    long k;\n    long l;\n    long m;\n  \
    \  long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long s;\n\
    \    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long y;\n\
    \    long z;\n    long aa;\n    long ab;\n    long ac;\n    long ad;\n    long\
    \ ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n    long aj;\n\
    \    long ak;\n    long al;\n    long am;\n    long an;\n    long ao;\n    long\
    \ ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n    long au;\n\
    \    long av;\n    long aw;\n    long ax;\n    long ay;\n    long az;\n    long\
    \ ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n    long bf;\n\
    \    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long bk;\n    long\
    \ bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n    long bq;\n\
    \    long br;\n    long bs;\n    long bt;\n    long bu;\n    long bv;\n    long\
    \ bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n    long cb;\n\
    \    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long cg;\n    long\
    \ ch;\n    long ci;\n    long cj;\n    long ck;\n    long cl;\n    long cm;\n\
    \    long cn;\n    long co;\n    long cp;\n    long", "{\n    long[] result;\n\
    \    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            current_depth += 1;\n   \
    \         max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth -= 1;\n        }\n      \
    \  else if(c == ' ')\n        {\n            result ~= max_depth;\n          \
    \  max_depth = 0;\n            current_depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    int max_level = 0;\n \
    \   int level = 0;\n    foreach(char c; paren_string) \n    {\n        if (c ==\
    \ '(') \n        {\n            level++;\n            max_level = max(max_level,\
    \ level);\n        } \n        else if (c == ')') \n        {\n            level--;\n\
    \        } \n        else if (c == ' ') \n        {\n            result ~= max_level;\n\
    \            max_level = 0;\n            level = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long max_nesting = 0;\n    long nesting\
    \ = 0;\n    foreach(ch; paren_string)\n    {\n        if(ch == '(')\n        {\n\
    \            nesting++;\n            max_nesting = max(max_nesting, nesting);\n\
    \        }\n        else if(ch == ')')\n        {\n            nesting--;\n  \
    \      }\n        else if(ch == ' ')\n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result = new long[];\n    long[] stack =\
    \ new long[];\n    foreach(paren; paren_string.split(\" \"))\n    {\n        foreach(c;\
    \ paren)\n        {\n            if(c == '(')\n            {\n               \
    \ stack ~= 1;\n            }\n            else if(c == ')')\n            {\n \
    \               stack ~= -1;\n            }\n        }\n        result ~= max(stack);\n\
    \        stack = new long[];\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] stack;\n    long max_level = 0;\n    long level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            level += 1;\n            max_level = max(max_level, level);\n\
    \        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n \
    \           level -= 1;\n        }\n        else\n        {\n            if(stack.length\
    \ > 0)\n            {\n                result ~= max_level;\n                max_level\
    \ = 0;\n                level = 0;\n                stack = [];\n            }\n\
    \        }\n    }\n    if(stack.length > 0)\n    {\n        result ~= max_level;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    long[]\
    \ stack = new long[];\n    foreach(char c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            stack ~= 1;\n        }\n        else if(c ==\
    \ ')')\n        {\n            if(stack.length == 0)\n            {\n        \
    \        throw new Exception(\"Invalid input\");\n            }\n            else\n\
    \            {\n                result ~= stack.length;\n                stack.length\
    \ = stack.length - 1;\n            }\n        }\n        else if(c == ' ')\n \
    \       {\n            if(stack.length != 0)\n            {\n                throw\
    \ new Exception(\"Invalid input\");\n            }\n        }\n        else\n\
    \        {\n            throw new Exception(\"Invalid input\");\n        }\n \
    \   }\n    if(stack.length != 0)\n    {\n        throw new Exception(\"Invalid\
    \ input\");\n    }\n    return result;\n}", "{\n    long[] result;\n    int max_depth\
    \ = 0;\n    int current_depth = 0;\n    foreach(c; paren_string) \n    {\n   \
    \     if(c == '(') \n        {\n            current_depth++;\n            max_depth\
    \ = max(max_depth, current_depth);\n        }\n        else if(c == ')') \n  \
    \      {\n            current_depth--;\n        }\n        else if(c == ' ') \n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \         current_depth = 0;\n        }\n    }\n    return result;\n}", "{\n \
    \   long[] result;\n    long max_nesting = 0;\n    long nesting = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if (c == '(') \n        {\n            ++nesting;\n\
    \            max_nesting = max(max_nesting, nesting);\n        } \n        else\
    \ if (c == ')') \n        {\n            --nesting;\n        } \n        else\
    \ if (c == ' ') \n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    int depth = 0;\n    int max_depth = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      depth++;\n            max_depth = max(max_depth, depth);\n        }\n \
    \       else if(c == ')')\n        {\n            depth--;\n        }\n      \
    \  else if(c == ' ')\n        {\n            result ~= max_depth;\n          \
    \  max_depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] paren_count;\n    long max_count;\n    long i;\n    long j;\n    long\
    \ k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long p;\n    long\
    \ q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long v;\n    long\
    \ w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long ab;\n    long\
    \ ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n\
    \    long ai;\n    long aj;\n    long ak;\n    long al;\n    long am;\n    long\
    \ an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n\
    \    long at;\n    long au;\n    long av;\n    long aw;\n    long ax;\n    long\
    \ ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n\
    \    long be;\n    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long\
    \ bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n\
    \    long bp;\n    long bq;\n    long br;\n    long bs;\n    long bt;\n    long\
    \ bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n\
    \    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long\
    \ cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck;\n\
    \    long cl;\n    long cm;\n    long cn;\n    long co;\n    long cp;\n    long\
    \ cq;\n    long cr;\n    long cs;\n    long ct;\n    long cu;\n   ", "{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    int max_nesting = 0;\n    int nesting = 0;\n \
    \   foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n       \
    \     nesting++;\n            max_nesting = max(max_nesting, nesting);\n     \
    \   }\n        else if(c == ')')\n        {\n            nesting--;\n        }\n\
    \        else if(c == ' ')\n        {\n            result ~= max_nesting;\n  \
    \          max_nesting = 0;\n            nesting = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    int i = 0;\n    int j\
    \ = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int\
    \ o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n   \
    \ int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n\
    \    int y = 0;\n    int z = 0;\n    int aa = 0;\n    int ab = 0;\n    int ac\
    \ = 0;\n    int ad = 0;\n    int ae = 0;\n    int af = 0;\n    int ag = 0;\n \
    \   int ah = 0;\n    int ai = 0;\n    int aj = 0;\n    int ak = 0;\n    int al\
    \ = 0;\n    int am = 0;\n    int an = 0;\n    int ao = 0;\n    int ap = 0;\n \
    \   int aq = 0;\n    int ar = 0;\n    int as = 0;\n    int at = 0;\n    int au\
    \ = 0;\n    int av = 0;\n    int aw = 0;\n    int ax = 0;\n    int ay = 0;\n \
    \   int az = 0;\n    int ba = 0;\n    int bb = 0;\n    int bc = 0;\n    int bd\
    \ = 0;\n    int be = 0;\n    int bf = 0;\n    int bg = 0;\n    int bh = 0;\n \
    \   int bi = 0;\n    int bj = 0;\n    int bk = 0;\n    int bl = 0;\n    int bm\
    \ = 0;\n    int bn = 0;\n    int bo = 0;\n    int bp = 0;\n    int bq = 0;\n \
    \   int br = 0;\n    int bs = 0;\n    int bt = 0;\n    int bu = 0;\n    int bv\
    \ = 0;\n    int bw = 0;\n    int bx = 0;\n   ", "{\n    long[] result;\n    int\
    \ i;\n    int j;\n    int max_level;\n    int level;\n    int len;\n    char c;\n\
    \    int start;\n    int end;\n    int[] paren_count;\n    int[] paren_count_max;\n\
    \    int[] paren_count_min;\n    int[] paren_count_max_index;\n    int[] paren_count_min_index;\n\
    \    int[] paren_count_max_index_start;\n    int[] paren_count_max_index_end;\n\
    \    int[] paren_count_min_index_start;\n    int[] paren_count_min_index_end;\n\
    \    int[] paren_count_max_index_start_end;\n    int[] paren_count_min_index_start_end;\n\
    \    int[] paren_count_max_index_start_end_start;\n    int[] paren_count_min_index_start_end_start;\n\
    \    int[] paren_count_max_index_start_end_end;\n    int[] paren_count_min_index_start_end_end;\n\
    \    int[] paren_count_max_index_start_end_start_end;\n    int[] paren_count_min_index_start_end_start_end;\n\
    \    int[] paren_count_max_index_start_end_start_end_start;\n    int[] paren_count_min_index_start_end_start_end_start;\n\
    \    int[] paren_count_max_index_start_end_start_end_end;\n    int[] paren_count_min_index_start_end_start_end_end;\n\
    \    int[] paren_count_max_index_start_end_start_end_start_end;\n    int[] paren_count_min_index_start_end_start_end_start_end;\n\
    \    int[] paren_count_max_index_start_end_start_end_start_end_start;\n    int[]\
    \ paren_count_min_index_start_end_start_end_start_end", "{\n    long[] result\
    \ = new long[];\n    long[] stack = new long[];\n    long max_depth = 0;\n   \
    \ foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n    \
    \        stack ~= 1;\n            max_depth = max(max_depth, stack.length);\n\
    \        }\n        else if(c == ')')\n        {\n            stack.pop;\n   \
    \     }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n        }\n    }\n    return result;\n}", "{\n  \
    \  long[] result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        } \n        else\
    \ if(c == ')') \n        {\n            current_depth--;\n        } \n       \
    \ else if(c == ' ') \n        {\n            if(current_depth != 0) \n       \
    \     {\n                result ~= max_depth;\n                max_depth = 0;\n\
    \                current_depth = 0;\n            }\n        }\n    }\n    if(current_depth\
    \ != 0) \n    {\n        result ~= max_depth;\n    }\n    return result;\n}",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group;\
    \ paren_string.split) \n    {\n        stack = [];\n        max_depth = 0;\n \
    \       foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack ~= 1;\n                max_depth = max(max_depth,\
    \ stack.length);\n            } \n            else if (paren == ')') \n      \
    \      {\n                stack.pop;\n            }\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n    int\
    \ i = 0;\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n       \
    \ int max_depth = 0;\n        int depth = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n                depth++;\n         \
    \   else if(paren == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    int\
    \ max_depth = 0;\n    int depth = 0;\n    foreach (paren; paren_string) \n   \
    \ {\n        if (paren == '(') \n        {\n            stack ~= 1;\n        \
    \    depth++;\n            max_depth = max(max_depth, depth);\n        } \n  \
    \      else if (paren == ')') \n        {\n            stack.pop;\n          \
    \  depth--;\n        } \n        else if (paren == ' ') \n        {\n        \
    \    result ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    long max_depth\
    \ = 0;\n    long depth = 0;\n    foreach(c; paren_string) \n    {\n        if\
    \ (c == '(') \n        {\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if (c == ')') \n        {\n            depth--;\n\
    \        }\n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long len;\n    long len2;\n  \
    \  long len3;\n    char c;\n    char c2;\n    char c3;\n    string paren_string2;\n\
    \    string paren_string3;\n    string paren_string4;\n    string paren_string5;\n\
    \    string paren_string6;\n    string paren_string7;\n    string paren_string8;\n\
    \    string paren_string9;\n    string paren_string10;\n    string paren_string11;\n\
    \    string paren_string12;\n    string paren_string13;\n    string paren_string14;\n\
    \    string paren_string15;\n    string paren_string16;\n    string paren_string17;\n\
    \    string paren_string18;\n    string paren_string19;\n    string paren_string20;\n\
    \    string paren_string21;\n    string paren_string22;\n    string paren_string23;\n\
    \    string paren_string24;\n    string paren_string25;\n    string paren_string26;\n\
    \    string paren_string27;\n    string paren_string28;\n    string paren_string29;\n\
    \    string paren_string30;\n    string paren_string31;\n    string paren_string32;\n\
    \    string paren_string33;\n    string paren_string34;\n    string paren_string35;\n\
    \    string paren_string36;\n    string paren_string37;\n    string paren_string38;\n\
    \    string paren_string39;\n    string paren_string40;\n    string paren_string41;\n\
    \    string paren_string42;\n    string paren_string43;\n    string paren_string44;\n\
    \    string paren_string45;\n    string paren_string46;\n    string paren_string47;\n\
    \    string paren_string48;\n    string paren_string49;\n    string paren_string50;\n",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    long i;\n    long j;\n    long len;\n    long len2;\n    char c;\n    stack\
    \ = [];\n    result = [];\n    max_depth = 0;\n    depth = 0;\n    len = paren_string.length;\n\
    \    for (i = 0; i < len; i++) \n    {\n        c = paren_string[i];\n       \
    \ if (c == '(') \n        {\n            stack.push(i);\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if (c\
    \ == ')') \n        {\n            stack.pop();\n            depth--;\n      \
    \  }\n        else if (c == ' ') \n        {\n            if (stack.length ==\
    \ 0) \n            {\n                result.push(max_depth);\n              \
    \  max_depth = 0;\n                depth = 0;\n            }\n        }\n    }\n\
    \    if (stack.length == 0) \n    {\n        result.push(max_depth);\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long len;\n    long paren_count;\n    long\
    \ paren_start;\n    long paren_end;\n    string paren_group;\n    string[] paren_groups;\n\
    \    paren_groups = paren_string.split(\" \");\n    foreach(paren_group; paren_groups)\n\
    \    {\n        stack = [];\n        max_depth = 0;\n        depth = 0;\n    \
    \    paren_count = 0;\n        paren_start = 0;\n        paren_end = 0;\n    \
    \    len = paren_group.length;\n        for(i = 0; i < len; i++)\n        {\n\
    \            if(paren_group[i] == '(')\n            {\n                stack ~=\
    \ 1;\n                depth += 1;\n                paren_count += 1;\n       \
    \         if(paren_count == 1)\n                {\n                    paren_start\
    \ = i;\n                }\n            }\n            else if(paren_group[i] ==\
    \ ')')\n            {\n                stack.pop();\n                depth -=\
    \ 1;\n                paren_count -= 1;\n                if(paren_count == 0)\n\
    \                {\n                    paren_end = i;\n                    max_depth\
    \ = max(max_depth, paren_end - paren_start + 1);\n                }\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    foreach (paren_group; paren_string.split)\n    {\n        max_depth = 0;\n\
    \        depth = 0;\n        stack = [];\n        foreach (paren; paren_group)\n\
    \        {\n            if (paren == '(')\n            {\n                stack\
    \ ~= paren;\n                depth += 1;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if (paren == ')')\n            {\n\
    \                stack.pop;\n                depth -= 1;\n            }\n    \
    \    }\n        assert(stack.empty);\n        result ~= max_depth;\n    }\n  \
    \  return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n    long\
    \ current_depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            current_depth++;\n            max_depth = max(max_depth,\
    \ current_depth);\n        }\n        else if(c == ')')\n        {\n         \
    \   current_depth--;\n        }\n        else if(c == ' ')\n        {\n      \
    \      result ~= max_depth;\n            max_depth = 0;\n            current_depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string) \n  \
    \  {\n        if (c == '(') \n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        } \n        else if (c == ')') \n        {\n\
    \            depth--;\n        } \n        else if (c == ' ') \n        {\n  \
    \          result ~= max_depth;\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ foreach(paren_group; paren_string.split(\" \")) \n    {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        foreach(paren; paren_group) \n      \
    \  {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}",
  "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    int max_depth\
    \ = 0;\n    int depth = 0;\n    int i = 0;\n    while (i < paren_string.length)\
    \ \n    {\n        if (paren_string[i] == '(') \n        {\n            stack.push(i);\n\
    \            depth++;\n            if (depth > max_depth) \n            {\n  \
    \              max_depth = depth;\n            }\n        } \n        else if\
    \ (paren_string[i] == ')') \n        {\n            if (stack.length == 0) \n\
    \            {\n                throw new Exception(\"Invalid string\");\n   \
    \         }\n            stack.pop();\n            depth--;\n        } \n    \
    \    else if (paren_string[i] == ' ') \n        {\n            if (stack.length\
    \ == 0) \n            {\n                result.push(max_depth);\n           \
    \     max_depth = 0;\n            }\n        } \n        else \n        {\n  \
    \          throw new Exception(\"Invalid string\");\n        }\n        i++;\n\
    \    }\n    if (stack.length != 0) \n    {\n        throw new Exception(\"Invalid\
    \ string\");\n    }\n    result.push(max_depth);\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    long current_level = 0;\n    long max_level\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if(c == ')')\n        {\n            current_level--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_level;\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    long[] stack\
    \ = new long[];\n    long[] max_stack = new long[];\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n           \
    \ if(max_stack.length == 0)\n            {\n                max_stack ~= 1;\n\
    \            }\n            else\n            {\n                max_stack[$-1]\
    \ += 1;\n            }\n        }\n        else if(c == ')')\n        {\n    \
    \        if(stack.length == 0)\n            {\n                throw new Exception(\"\
    Invalid string\");\n            }\n            else\n            {\n         \
    \       stack[$-1] -= 1;\n                if(stack[$-1] == 0)\n              \
    \  {\n                    stack.length -= 1;\n                    result ~= max_stack[$-1];\n\
    \                    max_stack.length -= 1;\n                }\n            }\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ != 0)\n            {\n                throw new Exception(\"Invalid string\"\
    );\n            }\n        }\n        else\n        {\n            throw new Exception(\"\
    Invalid string\");\n        }\n    }\n    if(stack.length != 0)\n    {\n     \
    \   throw new Exception(\"Invalid string\");\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    int[] stack = new int[];\n    int max_depth\
    \ = 0;\n    int depth = 0;\n    foreach (c; paren_string) \n    {\n        if\
    \ (c == '(') \n        {\n            stack ~= 1;\n            depth++;\n    \
    \        max_depth = max(max_depth, depth);\n        } \n        else if (c ==\
    \ ')') \n        {\n            stack ~= -1;\n            depth--;\n        }\
    \ \n        else if (c == ' ') \n        {\n            if (stack.length > 0)\
    \ \n            {\n                result ~= max_depth;\n                max_depth\
    \ = 0;\n                depth = 0;\n                stack = new int[];\n     \
    \       }\n        }\n    }\n    if (stack.length > 0) \n    {\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    int max_depth = 0;\n    int current_depth = 0;\n    foreach(char c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            current_depth++;\n      \
    \      max_depth = max(max_depth, current_depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            current_depth--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    foreach (paren_group; paren_string.split) \n    {\n        stack = [];\n\
    \        max_depth = 0;\n        depth = 0;\n        foreach (paren; paren_group)\
    \ \n        {\n            if (paren == '(') \n            {\n               \
    \ stack ~= depth;\n                depth += 1;\n                max_depth = max(max_depth,\
    \ depth);\n            } \n            else if (paren == ')') \n            {\n\
    \                depth = stack.pop;\n            }\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    string[] groups = paren_string.split(\" \");\n    foreach(string group; groups)\n\
    \    {\n        long max_level = 0;\n        long level = 0;\n        foreach(char\
    \ c; group)\n        {\n            if(c == '(')\n            {\n            \
    \    level++;\n                max_level = max(max_level, level);\n          \
    \  }\n            else if(c == ')')\n            {\n                level--;\n\
    \            }\n        }\n        result ~= max_level;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    int\
    \ max_depth = 0;\n    int depth = 0;\n    int i = 0;\n    while (i < paren_string.length)\
    \ \n    {\n        if (paren_string[i] == '(') \n        {\n            stack.push(i);\n\
    \            depth++;\n            max_depth = max(max_depth, depth);\n      \
    \  } \n        else if (paren_string[i] == ')') \n        {\n            stack.pop();\n\
    \            depth--;\n        } \n        else if (paren_string[i] == ' ') \n\
    \        {\n            result.push(max_depth);\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n        i++;\n    }\n    result.push(max_depth);\n\
    \    return result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long n;\n    long m;\n    long\
    \ len;\n    long len_paren_string;\n    long[] paren_string_split;\n    string\
    \ paren_string_split_i;\n    len_paren_string = paren_string.length;\n    paren_string_split\
    \ = paren_string.split(' ');\n    n = paren_string_split.length;\n    result =\
    \ new long[];\n    for (i = 0; i < n; i++) {\n        paren_string_split_i = paren_string_split[i];\n\
    \        len = paren_string_split_i.length;\n        stack = new long[];\n   \
    \     max_depth = 0;\n        depth = 0;\n        for (j = 0; j < len; j++) {\n\
    \            if (paren_string_split_i[j] == '(') {\n                stack ~= 1;\n\
    \                depth++;\n                max_depth = max(max_depth, depth);\n\
    \            } else if (paren_string_split_i[j] == ')') {\n                stack\
    \ ~= -1;\n                depth--;\n            }\n        }\n        m = stack.length;\n\
    \        if (m == 0) {\n            result ~= max_depth;\n        } else {\n \
    \           result ~= -1;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    int count = 0;\n    int max_count = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            count++;\n            max_count\
    \ = max(max_count, count);\n        }\n        else if(c == ')')\n        {\n\
    \            count--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_count;\n            max_count = 0;\n            count =\
    \ 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    long[] stack = new long[];\n    long max_depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n           \
    \ max_depth = max(max_depth, stack.length);\n        }\n        else if(c == ')')\n\
    \        {\n            stack.pop;\n        }\n        else if(c == ' ')\n   \
    \     {\n            result ~= max_depth;\n            max_depth = 0;\n      \
    \  }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n   \
    \ int max_nesting = 0;\n    int current_nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            current_nesting++;\n    \
    \        max_nesting = max(max_nesting, current_nesting);\n        }\n       \
    \ else if(c == ')')\n        {\n            current_nesting--;\n        }\n  \
    \      else if(c == ' ')\n        {\n            result ~= max_nesting;\n    \
    \        max_nesting = 0;\n            current_nesting = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long depth = 0;\n    long\
    \ max_depth = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(')\
    \ \n        {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if (c == ')') \n        {\n            depth--;\n   \
    \     }\n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n        }\n    }\n    return result;\n}", "{\n  \
    \  long[] result;\n    long[] stack;\n    long max_level;\n    foreach(paren_group;\
    \ paren_string.split)\n    {\n        stack = [];\n        max_level = 0;\n  \
    \      foreach(paren; paren_group)\n        {\n            if(paren == '(')\n\
    \            {\n                stack ~= 1;\n                max_level = max(max_level,\
    \ stack.length);\n            }\n            else if(paren == ')')\n         \
    \   {\n                stack.pop;\n            }\n        }\n        result ~=\
    \ max_level;\n    }\n    return result;\n}", "{\n    long[] result;\n    long\
    \ max_nesting = 0;\n    long cur_nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            cur_nesting++;\n        \
    \    max_nesting = max(max_nesting, cur_nesting);\n        }\n        else if(c\
    \ == ')')\n        {\n            cur_nesting--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            cur_nesting = 0;\n        }\n    }\n    return result;\n}",
  "{\n    auto paren_groups = paren_string.split;\n    long[] max_nesting_levels;\n\
    \    foreach(paren_group; paren_groups) \n    {\n        long max_nesting_level\
    \ = 0;\n        long current_nesting_level = 0;\n        foreach(paren; paren_group)\
    \ \n        {\n            if(paren == '(') \n            {\n                current_nesting_level++;\n\
    \                max_nesting_level = max(max_nesting_level, current_nesting_level);\n\
    \            }\n            else if(paren == ')') \n            {\n          \
    \      current_nesting_level--;\n            }\n        }\n        max_nesting_levels\
    \ ~= max_nesting_level;\n    }\n    return max_nesting_levels;\n}", "{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split(\" \")) \n    {\n        max_depth = 0;\n \
    \       depth = 0;\n        stack = [];\n        foreach (paren; paren_group)\
    \ \n        {\n            if (paren == '(') \n            {\n               \
    \ depth++;\n                stack ~= depth;\n            }\n            else if\
    \ (paren == ')') \n            {\n                stack.pop();\n             \
    \   depth = stack.length ? stack[$-1] : 0;\n            }\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}", "{\n    long[] result;\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int max_depth = 0;\n    int depth = 0;\n    int len = paren_string.length;\n\
    \    while (i < len)\n    {\n        if (paren_string[i] == '(')\n        {\n\
    \            depth++;\n            if (depth > max_depth)\n            {\n   \
    \             max_depth = depth;\n            }\n        }\n        else if (paren_string[i]\
    \ == ')')\n        {\n            depth--;\n        }\n        else if (paren_string[i]\
    \ == ' ')\n        {\n            result[j] = max_depth;\n            j++;\n \
    \           max_depth = 0;\n            depth = 0;\n        }\n        i++;\n\
    \    }\n    result[j] = max_depth;\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] paren_stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n\
    \    long p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n\
    \    long v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n\
    \    long ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long\
    \ ag;\n    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n\
    \    long am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long\
    \ ar;\n    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n\
    \    long ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long\
    \ bc;\n    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n\
    \    long bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long\
    \ bn;\n    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n\
    \    long bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long\
    \ by;\n    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n\
    \    long ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long\
    \ cj;\n    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n\
    \    long cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n   ", "{\n\
    \    long[] result;\n    long[] stack;\n    long max_depth = 0;\n    long depth\
    \ = 0;\n    foreach (c; paren_string) \n    {\n        if (c == '(') \n      \
    \  {\n            depth++;\n            max_depth = max(max_depth, depth);\n \
    \       } \n        else if (c == ')') \n        {\n            depth--;\n   \
    \     } \n        else if (c == ' ') \n        {\n            if (depth != 0)\
    \ \n            {\n                throw new Exception(\"Invalid input\");\n \
    \           }\n            result ~= max_depth;\n            max_depth = 0;\n\
    \        } \n        else \n        {\n            throw new Exception(\"Invalid\
    \ input\");\n        }\n    }\n    if (depth != 0) \n    {\n        throw new\
    \ Exception(\"Invalid input\");\n    }\n    result ~= max_depth;\n    return result;\n\
    }", "{\n    long[] result;\n    int max_nesting = 0;\n    int current_nesting\
    \ = 0;\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n        {\n\
    \            current_nesting++;\n            max_nesting = max(max_nesting, current_nesting);\n\
    \        }\n        else if(c == ')') \n        {\n            current_nesting--;\n\
    \        }\n        else if(c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n    return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n\
    \    long depth = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(')\
    \ \n        {\n            depth += 1;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if (c == ')') \n        {\n            depth\
    \ -= 1;\n        }\n        else if (c == ' ') \n        {\n            result\
    \ ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    int count = 0;\n \
    \   int max = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            count++;\n            if(count > max)\n            {\n\
    \                max = count;\n            }\n        }\n        else if(c ==\
    \ ')')\n        {\n            count--;\n        }\n        else if(c == ' ')\n\
    \        {\n            result ~= max;\n            max = 0;\n            count\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[];\n    long[] stack = new long[];\n    long max_depth = 0;\n    long depth\
    \ = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(') \n       \
    \ {\n            depth++;\n            max_depth = max(max_depth, depth);\n  \
    \      } \n        else if (c == ')') \n        {\n            depth--;\n    \
    \    } \n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    foreach (paren_group; paren_string.split(\" \")) \n    {\n\
    \        stack = [];\n        max_depth = 0;\n        depth = 0;\n        foreach\
    \ (paren; paren_group) \n        {\n            if (paren == '(') \n         \
    \   {\n                stack ~= paren;\n                depth += 1;\n        \
    \        max_depth = max(max_depth, depth);\n            }\n            else if\
    \ (paren == ')') \n            {\n                stack.pop();\n             \
    \   depth -= 1;\n            }\n        }\n        result ~= max_depth;\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n   \
    \ long current_depth = 0;\n    foreach(c; paren_string) \n    {\n        if(c\
    \ == '(') \n        {\n            current_depth++;\n            max_depth = max(max_depth,\
    \ current_depth);\n        }\n        else if(c == ')') \n        {\n        \
    \    current_depth--;\n        }\n        else if(c == ' ') \n        {\n    \
    \        result ~= max_depth;\n            max_depth = 0;\n            current_depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new\
    \ long[];\n    foreach(paren_group; paren_string.split(\" \"))\n    {\n      \
    \  long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n            {\n     \
    \           current_depth += 1;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')')\n            {\n           \
    \     current_depth -= 1;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n  \
    \  long max_depth;\n    long depth;\n    long i;\n    long j;\n    long len;\n\
    \    long len2;\n    char c;\n    foreach(paren_string; paren_string.split(\"\
    \ \"))\n    {\n        stack = [];\n        max_depth = 0;\n        depth = 0;\n\
    \        i = 0;\n        len = paren_string.length;\n        while(i < len)\n\
    \        {\n            c = paren_string[i];\n            if(c == '(')\n     \
    \       {\n                stack.push(i);\n                depth++;\n        \
    \        if(depth > max_depth)\n                {\n                    max_depth\
    \ = depth;\n                }\n            }\n            else if(c == ')')\n\
    \            {\n                if(stack.length == 0)\n                {\n   \
    \                 throw new Exception(\"Invalid input\");\n                }\n\
    \                stack.pop();\n                depth--;\n            }\n     \
    \       i++;\n        }\n        if(stack.length != 0)\n        {\n          \
    \  throw new Exception(\"Invalid input\");\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    foreach(paren;\
    \ paren_string.split(\" \"))\n    {\n        long max_depth = 0;\n        long\
    \ depth = 0;\n        foreach(c; paren)\n        {\n            if(c == '(')\n\
    \            {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(c == ')')\n            {\n     \
    \           depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n  \
    \  long max_depth;\n    long depth;\n    foreach (paren_group; paren_string.split)\
    \ \n    {\n        stack = [];\n        max_depth = 0;\n        depth = 0;\n \
    \       foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack ~= 1;\n                depth += 1;\n\
    \                max_depth = max(max_depth, depth);\n            } \n        \
    \    else if (paren == ')') \n            {\n                stack ~= -1;\n  \
    \              depth -= 1;\n            }\n        }\n        if (stack.sum !=\
    \ 0) \n        {\n            throw new Exception(\"Invalid paren string\");\n\
    \        }\n        result ~= max_depth;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int start = 0;\n    int end = 0;\n    int max_depth\
    \ = 0;\n    int depth = 0;\n    while (end < paren_string.length) \n    {\n  \
    \      if (paren_string[end] == '(') \n        {\n            depth++;\n     \
    \       max_depth = max(max_depth, depth);\n        }\n        else if (paren_string[end]\
    \ == ')') \n        {\n            depth--;\n        }\n        else if (paren_string[end]\
    \ == ' ') \n        {\n            if (depth == 0) \n            {\n         \
    \       result ~= max_depth;\n                max_depth = 0;\n               \
    \ start = end + 1;\n            }\n        }\n        end++;\n    }\n    if (depth\
    \ == 0) \n    {\n        result ~= max_depth;\n    }\n    return result;\n}",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    long i;\n    long j;\n    long len;\n    long len2;\n    char c;\n    foreach(paren_group;\
    \ paren_string.split(\" \"))\n    {\n        stack = new long[];\n        max_depth\
    \ = 0;\n        depth = 0;\n        len = paren_group.length;\n        for(i =\
    \ 0; i < len; i++)\n        {\n            c = paren_group[i];\n            if(c\
    \ == '(')\n            {\n                stack ~= 1;\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(c == ')')\n            {\n                stack ~= -1;\n         \
    \       depth--;\n            }\n        }\n        len2 = stack.length;\n   \
    \     for(j = 0; j < len2; j++)\n        {\n            if(stack[j] == -1)\n \
    \           {\n                stack[j] = 1;\n            }\n            else\n\
    \            {\n                stack[j] = 0;\n            }\n        }\n    \
    \    result ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(paren_group; paren_string.split(\" \")) \n    {\n        long max_depth\
    \ = 0;\n        long current_depth = 0;\n        foreach(paren; paren_group) \n\
    \        {\n            if(paren == '(') \n            {\n                current_depth++;\n\
    \                max_depth = max(max_depth, current_depth);\n            } \n\
    \            else if(paren == ')') \n            {\n                current_depth--;\n\
    \            }\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] stack;\n    long current_level;\n    long\
    \ max_level;\n    foreach (paren_group; paren_string.split)\n    {\n        stack\
    \ = [];\n        current_level = 0;\n        max_level = 0;\n        foreach (paren;\
    \ paren_group)\n        {\n            if (paren == '(')\n            {\n    \
    \            stack ~= current_level;\n                current_level++;\n     \
    \           max_level = max(max_level, current_level);\n            }\n      \
    \      else if (paren == ')')\n            {\n                if (stack.length\
    \ == 0)\n                {\n                    throw new Exception(\"Invalid\
    \ paren string\");\n                }\n                current_level = stack.pop;\n\
    \            }\n        }\n        if (stack.length != 0)\n        {\n       \
    \     throw new Exception(\"Invalid paren string\");\n        }\n        result\
    \ ~= max_level;\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    int start = 0;\n    int end = 0;\n    int max_depth = 0;\n    int depth =\
    \ 0;\n    while (end < paren_string.length) \n    {\n        if (paren_string[end]\
    \ == '(') \n        {\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        } \n        else if (paren_string[end] == ')') \n        {\n\
    \            depth--;\n        } \n        else if (paren_string[end] == ' ')\
    \ \n        {\n            if (depth == 0) \n            {\n                result\
    \ ~= max_depth;\n                max_depth = 0;\n                start = end +\
    \ 1;\n            }\n        }\n        end++;\n    }\n    if (depth == 0) \n\
    \    {\n        result ~= max_depth;\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long max_nesting = 0;\n    long nesting = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            nesting++;\n       \
    \     max_nesting = max(max_nesting, nesting);\n        }\n        else if (c\
    \ == ')') \n        {\n            nesting--;\n        }\n        else if (c ==\
    \ ' ') \n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    long i;\n    long paren_count;\n    long group_count;\n    long group_start;\n\
    \    long group_end;\n    long group_length;\n    long group_index;\n    long\
    \ group_depth;\n    long group_depth_index;\n    long group_depth_count;\n   \
    \ long group_depth_start;\n    long group_depth_end;\n    long group_depth_length;\n\
    \    long group_depth_index;\n    long group_depth_depth;\n    long group_depth_depth_index;\n\
    \    long group_depth_depth_count;\n    long group_depth_depth_start;\n    long\
    \ group_depth_depth_end;\n    long group_depth_depth_length;\n    long group_depth_depth_index;\n\
    \    long group_depth_depth_depth;\n    long group_depth_depth_depth_index;\n\
    \    long group_depth_depth_depth_count;\n    long group_depth_depth_depth_start;\n\
    \    long group_depth_depth_depth_end;\n    long group_depth_depth_depth_length;\n\
    \    long group_depth_depth_depth_index;\n    long group_depth_depth_depth_depth;\n\
    \    long group_depth_depth_depth_depth_index;\n    long group_depth_depth_depth_depth_count;\n\
    \    long group_depth_depth_depth_depth_start;\n    long group_depth_depth_depth_depth_end;\n\
    \    long group_depth_depth_depth_depth_length;\n    long group_depth_depth_depth_depth_index;\n\
    \    long group_depth_depth_depth_depth_depth;\n    long group_depth_depth_depth_depth_depth_index;\n\
    \    long group_depth_depth_depth_depth_depth_count;\n    long group_depth_depth_depth_depth_depth_start;\n\
    \    long group_depth_depth_depth_depth_depth_end;\n    long group_depth_depth_depth_depth_depth_length;\n\
    \    long group_depth_depth_depth", "{\n    long[] result = new long[];\n    long[]\
    \ stack = new long[];\n    long max_depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n           \
    \ max_depth = max(max_depth, stack.length);\n        }\n        else if(c == ')')\n\
    \        {\n            stack.popBack();\n        }\n        else if(c == ' ')\n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \     }\n    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n\
    \    long max_depth = 0;\n    long depth = 0;\n    long i = 0;\n    foreach (c;\
    \ paren_string)\n    {\n        if (c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if (c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if (c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int max_level = 0;\n    int level = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            level++;\n\
    \            max_level = max(max_level, level);\n        }\n        else if(c\
    \ == ')')\n        {\n            level--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_level;\n            max_level = 0;\n\
    \            level = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long max_level = 0;\n    long level = 0;\n   \
    \ foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n         \
    \   level++;\n            max_level = max(max_level, level);\n        }\n    \
    \    else if(c == ')')\n        {\n            level--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            level = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long max_nesting = 0;\n    long current_nesting = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      current_nesting++;\n            max_nesting = max(max_nesting, current_nesting);\n\
    \        }\n        else if(c == ')')\n        {\n            current_nesting--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \   }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n   \
    \ foreach(paren_group; paren_string.split(\" \")) \n    {\n        stack = [];\n\
    \        foreach(paren; paren_group) \n        {\n            if(paren == '(')\
    \ \n            {\n                stack ~= 1;\n            } \n            else\
    \ \n            {\n                stack[$-1] += 1;\n            }\n        }\n\
    \        result ~= max(stack);\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] paren_count;\n    long[] paren_depth;\n    long[] paren_max;\n\
    \    long[] paren_min;\n    long[] paren_max_depth;\n    long[] paren_min_depth;\n\
    \    long[] paren_max_depth_count;\n    long[] paren_min_depth_count;\n    long[]\
    \ paren_max_depth_count_max;\n    long[] paren_min_depth_count_max;\n    long[]\
    \ paren_max_depth_count_min;\n    long[] paren_min_depth_count_min;\n    long[]\
    \ paren_max_depth_count_max_max;\n    long[] paren_min_depth_count_max_max;\n\
    \    long[] paren_max_depth_count_min_min;\n    long[] paren_min_depth_count_min_min;\n\
    \    long[] paren_max_depth_count_max_max_max;\n    long[] paren_min_depth_count_max_max_max;\n\
    \    long[] paren_max_depth_count_min_min_min;\n    long[] paren_min_depth_count_min_min_min;\n\
    \    long[] paren_max_depth_count_max_max_max_max;\n    long[] paren_min_depth_count_max_max_max_max;\n\
    \    long[] paren_max_depth_count_min_min_min_min;\n    long[] paren_min_depth_count_min_min_min_min;\n\
    \    long[] paren_max_depth_count_max_max_max_max_max;\n    long[] paren_min_depth_count_max_max_max_max_max;\n\
    \    long[] paren_max_depth_count_min_min_min_min_min;\n    long[] paren_min_depth_count_min_min_min_min_min;\n\
    \    long[] paren_max_depth_count_max_max_max_max_max_max;\n    long[] paren_min_depth_count_max_",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth = 0;\n    long depth\
    \ = 0;\n    foreach (c; paren_string) \n    {\n        if (c == '(') \n      \
    \  {\n            stack ~= 1;\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if (c == ')') \n        {\n            stack.popBack();\n\
    \            depth--;\n        }\n        else if (c == ' ') \n        {\n   \
    \         result ~= max_depth;\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ int[] paren_stack;\n    int paren_count;\n    int max_paren_count;\n    foreach(paren_group;\
    \ paren_string.split(\" \")) \n    {\n        paren_stack = [];\n        paren_count\
    \ = 0;\n        max_paren_count = 0;\n        foreach(paren; paren_group) \n \
    \       {\n            if(paren == '(') \n            {\n                paren_stack\
    \ ~= paren_count;\n                paren_count++;\n                max_paren_count\
    \ = max(max_paren_count, paren_count);\n            }\n            else \n   \
    \         {\n                paren_count = paren_stack.pop;\n            }\n \
    \       }\n        result ~= max_paren_count;\n    }\n    return result;\n}",
  "{\n    long[] result;\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    foreach(paren_group; paren_string.split(\" \")) \n    {\n     \
    \   long max_depth = 0;\n        long current_depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             current_depth++;\n                max_depth = max(max_depth, current_depth);\n\
    \            }\n            else if(paren == ')') \n            {\n          \
    \      current_depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    int[]\
    \ stack = new int[];\n    int max_depth = 0;\n    int cur_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            cur_depth++;\n            max_depth = max(max_depth, cur_depth);\n\
    \        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n \
    \           cur_depth--;\n        }\n        else if(c == ' ')\n        {\n  \
    \          if(stack.length > 0)\n            {\n                if(stack.sum ==\
    \ 0)\n                {\n                    result ~= max_depth;\n          \
    \          max_depth = 0;\n                    cur_depth = 0;\n              \
    \      stack = new int[];\n                }\n            }\n        }\n    }\n\
    \    if(stack.length > 0)\n    {\n        if(stack.sum == 0)\n        {\n    \
    \        result ~= max_depth;\n            max_depth = 0;\n            cur_depth\
    \ = 0;\n            stack = new int[];\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    int\
    \ max_depth = 0;\n    int depth = 0;\n    foreach (c; paren_string)\n    {\n \
    \       if (c == '(')\n        {\n            stack ~= 1;\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if (c\
    \ == ')')\n        {\n            stack ~= -1;\n            depth--;\n       \
    \ }\n        else if (c == ' ')\n        {\n            if (stack.length > 0)\n\
    \            {\n                result ~= max_depth;\n                max_depth\
    \ = 0;\n                depth = 0;\n                stack = new int[];\n     \
    \       }\n        }\n    }\n    if (stack.length > 0)\n    {\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    long[] stack = new long[];\n    long max_depth = 0;\n    long depth = 0;\n\
    \    foreach(c; paren_string) \n    {\n        if (c == '(') \n        {\n   \
    \         stack ~= 1;\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if (c == ')') \n        {\n            stack\
    \ ~= -1;\n            depth--;\n        }\n        else if (c == ' ') \n     \
    \   {\n            result ~= max_depth;\n            max_depth = 0;\n        \
    \    depth = 0;\n        }\n    }\n    result ~= max_depth;\n    return result;\n\
    }", "{\n    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n   \
    \ foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n         \
    \   depth++;\n            max_depth = max(max_depth, depth);\n        }\n    \
    \    else if(c == ')')\n        {\n            depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long[] stack;\n    long i;\n    long j;\n    long n;\n\
    \    long max_nesting;\n    long[] paren_groups;\n    long[] paren_group;\n  \
    \  long[] paren_group_nesting;\n    long[] paren_group_nesting_stack;\n    long[]\
    \ paren_group_nesting_stack_top;\n    long[] paren_group_nesting_stack_top_max;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting;\n    long[] paren_group_nesting_stack_top_max_nesting_max;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting;\n    long[]\
    \ paren_group_nesting_stack_top_max_nesting_max_nesting_max;\n    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max_nesting;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max_nesting_max;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max_nesting_max_nesting;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max_nesting_max_nesting_max;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_max_nesting_max_nesting_max_nesting;\n\
    \    long[] paren_group_nesting_stack_top_max_nesting_max_nesting_max_nesting_",
  "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n    long depth;\n\
    \    long i;\n    long j;\n    long len;\n    long len2;\n    long[] paren_string_split;\n\
    \    long[] paren_string_split_i;\n    long[] paren_string_split_i_j;\n    paren_string_split\
    \ = paren_string.split(' ');\n    len = paren_string_split.length;\n    result\
    \ = new long[len];\n    for (i = 0; i < len; i++) \n    {\n        stack = new\
    \ long[paren_string_split[i].length];\n        max_depth = 0;\n        depth =\
    \ 0;\n        paren_string_split_i = paren_string_split[i];\n        len2 = paren_string_split_i.length;\n\
    \        for (j = 0; j < len2; j++) \n        {\n            paren_string_split_i_j\
    \ = paren_string_split_i[j];\n            if (paren_string_split_i_j == '(') \n\
    \            {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if (paren_string_split_i_j == ')')\
    \ \n            {\n                depth--;\n            }\n        }\n      \
    \  result[i] = max_depth;\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[];\n    int[] stack = new int[];\n    int max_depth = 0;\n    int\
    \ depth = 0;\n    foreach (c; paren_string)\n    {\n        if (c == '(')\n  \
    \      {\n            stack ~= 1;\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if (c == ')')\n        {\n\
    \            stack ~= -1;\n            depth--;\n        }\n        else if (c\
    \ == ' ')\n        {\n            if (stack.length > 0)\n            {\n     \
    \           result ~= max_depth;\n                max_depth = 0;\n           \
    \     depth = 0;\n                stack = new int[];\n            }\n        }\n\
    \    }\n    if (stack.length > 0)\n    {\n        result ~= max_depth;\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    int current_level\
    \ = 0;\n    int max_level = 0;\n    foreach(char c; paren_string)\n    {\n   \
    \     if(c == '(')\n        {\n            current_level++;\n            max_level\
    \ = max(max_level, current_level);\n        }\n        else if(c == ')')\n   \
    \     {\n            current_level--;\n        }\n        else if(c == ' ')\n\
    \        {\n            result ~= max_level;\n            max_level = 0;\n   \
    \         current_level = 0;\n        }\n    }\n    return result;\n}", "{\n \
    \   long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    long i;\n\
    \    long len;\n    long paren_count;\n    long paren_start;\n    long paren_end;\n\
    \    long paren_len;\n    string paren_group;\n    string[] paren_groups;\n  \
    \  paren_groups = paren_string.split(\" \");\n    len = paren_groups.length;\n\
    \    result = new long[len];\n    for (i = 0; i < len; i++) {\n        paren_group\
    \ = paren_groups[i];\n        paren_count = paren_group.count('(');\n        paren_start\
    \ = paren_group.find('(');\n        paren_end = paren_group.rfind(')');\n    \
    \    paren_len = paren_end - paren_start + 1;\n        if (paren_count == 0 ||\
    \ paren_len != paren_count * 2) {\n            result[i] = 0;\n            continue;\n\
    \        }\n        stack = new long[paren_count];\n        max_depth = 0;\n \
    \       depth = 0;\n        for (j = 0; j < paren_len; j++) {\n            if\
    \ (paren_group[j] == '(') {\n                depth++;\n                max_depth\
    \ = max(max_depth, depth);\n                stack[depth - 1] = j;\n          \
    \  } else {\n                depth--;\n            }\n        }\n        result[i]\
    \ = max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ paren_count;\n    long max_paren_count;\n    long paren_count_len;\n    long\
    \ i;\n    long j;\n    long k;\n    long paren_count_index;\n    long paren_count_index_max;\n\
    \    long paren_count_index_max_old;\n    long paren_count_index_max_old_old;\n\
    \    long paren_count_index_max_old_old_old;\n    long paren_count_index_max_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old;\n    long paren_count_index_max_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old;\n    long paren_count_index_max_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old_old_old;\n    long\
    \ paren_count_index_max_old_old_old_old_old_old_old_old_old_old;\n    long paren_count_index_max_old_old_old_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old_old_old_old_old_old_old_old_old_old_old_old;\n\
    \    long paren_count_index_max_old_old_old_old", "{\n    long[] result;\n   \
    \ long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string) \n  \
    \  {\n        if (c == '(') \n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if (c == ')') \n        {\n\
    \            depth--;\n        }\n        else if (c == ' ') \n        {\n   \
    \         result ~= max_depth;\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n   \
    \ {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    int i = 0;\n    int j = 0;\n    int max_nesting = 0;\n    int current_nesting\
    \ = 0;\n    while (i < paren_string.length) \n    {\n        if (paren_string[i]\
    \ == '(') \n        {\n            current_nesting++;\n            max_nesting\
    \ = max(max_nesting, current_nesting);\n        }\n        else if (paren_string[i]\
    \ == ')') \n        {\n            current_nesting--;\n        }\n        else\
    \ if (paren_string[i] == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            current_nesting = 0;\n        }\n \
    \       i++;\n    }\n    result ~= max_nesting;\n    return result;\n}", "{\n\
    \    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int paren_count = 0;\n    int max_paren_count = 0;\n\
    \    foreach(char c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           paren_count++;\n            max_paren_count = max(max_paren_count,\
    \ paren_count);\n        }\n        else if(c == ')')\n        {\n           \
    \ paren_count--;\n        }\n        else if(c == ' ')\n        {\n          \
    \  result ~= max_paren_count;\n            max_paren_count = 0;\n            paren_count\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n   \
    \ {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ stack;\n    long max_depth;\n    long depth;\n    long i;\n    long j;\n   \
    \ long n;\n    long paren_count;\n    long[] paren_counts;\n    long[] paren_counts_temp;\n\
    \    long[] paren_counts_temp2;\n    string[] paren_strings;\n    string[] paren_strings_temp;\n\
    \    string[] paren_strings_temp2;\n    string[] paren_strings_temp3;\n    string[]\
    \ paren_strings_temp4;\n    string[] paren_strings_temp5;\n    string[] paren_strings_temp6;\n\
    \    string[] paren_strings_temp7;\n    string[] paren_strings_temp8;\n    string[]\
    \ paren_strings_temp9;\n    string[] paren_strings_temp10;\n    string[] paren_strings_temp11;\n\
    \    string[] paren_strings_temp12;\n    string[] paren_strings_temp13;\n    string[]\
    \ paren_strings_temp14;\n    string[] paren_strings_temp15;\n    string[] paren_strings_temp16;\n\
    \    string[] paren_strings_temp17;\n    string[] paren_strings_temp18;\n    string[]\
    \ paren_strings_temp19;\n    string[] paren_strings_temp20;\n    string[] paren_strings_temp21;\n\
    \    string[] paren_strings_temp22;\n    string[] paren_strings_temp23;\n    string[]\
    \ paren_strings_temp24;\n    string[] paren_strings_temp25;\n    string[] paren_strings_temp26;\n\
    \    string[] paren_strings_temp27;\n    string[] paren_strings_temp28;\n    string[]\
    \ paren_strings_temp29;\n    string[] paren_strings_temp30;\n    string[] paren_strings_temp31;\n\
    \    string[] paren_strings_temp32;\n    string[] paren_strings_temp33;\n    string[]\
    \ paren_strings_temp34;\n    string[] paren_strings_temp35;", "{\n    long[] result;\n\
    \    int max_nesting = 0;\n    int current_nesting = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            current_nesting++;\n    \
    \        max_nesting = max(max_nesting, current_nesting);\n        }\n       \
    \ else if(c == ')')\n        {\n            current_nesting--;\n        }\n  \
    \      else if(c == ' ')\n        {\n            result ~= max_nesting;\n    \
    \        max_nesting = 0;\n            current_nesting = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result = new long[];\n    int[] stack\
    \ = new int[];\n    int max_depth = 0;\n    int depth = 0;\n    foreach (c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            stack ~= 1;\n      \
    \      depth++;\n            max_depth = max(max_depth, depth);\n        } \n\
    \        else if (c == ')') \n        {\n            stack ~= -1;\n          \
    \  depth--;\n        } \n        else if (c == ' ') \n        {\n            result\
    \ ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    long[]\
    \ stack = new long[];\n    long max_depth = 0;\n    long depth = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            stack\
    \ ~= 1;\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if(c == ')')\n        {\n            stack ~= -1;\n \
    \           depth--;\n        }\n        else if(c == ' ')\n        {\n      \
    \      if(stack.length == 0)\n            {\n                continue;\n     \
    \       }\n            if(stack.back == -1)\n            {\n                stack.popBack();\n\
    \                result ~= max_depth;\n                max_depth = 0;\n      \
    \          depth = 0;\n            }\n        }\n    }\n    return result;\n}",
  "{\n    long[] result;\n    foreach(paren_group; paren_string.split)\n    {\n  \
    \      long max_depth = 0;\n        long depth = 0;\n        foreach(c; paren_group)\n\
    \        {\n            if(c == '(')\n                depth++;\n            else\
    \ if(c == ')')\n                depth--;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        result ~= max_depth;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long max_depth = 0;\n    long current_depth =\
    \ 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n \
    \           current_depth++;\n            max_depth = max(max_depth, current_depth);\n\
    \        }\n        else if(c == ')')\n        {\n            current_depth--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n   \
    \ long depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if(c == ')')\n        {\n            depth--;\n     \
    \   }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    int[] paren_count;\n    int max_count;\n\
    \    int i;\n    int j;\n    int k;\n    int l;\n    int m;\n    int n;\n    int\
    \ o;\n    int p;\n    int q;\n    int r;\n    int s;\n    int t;\n    int u;\n\
    \    int v;\n    int w;\n    int x;\n    int y;\n    int z;\n    int aa;\n   \
    \ int bb;\n    int cc;\n    int dd;\n    int ee;\n    int ff;\n    int gg;\n \
    \   int hh;\n    int ii;\n    int jj;\n    int kk;\n    int ll;\n    int mm;\n\
    \    int nn;\n    int oo;\n    int pp;\n    int qq;\n    int rr;\n    int ss;\n\
    \    int tt;\n    int uu;\n    int vv;\n    int ww;\n    int xx;\n    int yy;\n\
    \    int zz;\n    int aaa;\n    int bbb;\n    int ccc;\n    int ddd;\n    int\
    \ eee;\n    int fff;\n    int ggg;\n    int hhh;\n    int iii;\n    int jjj;\n\
    \    int kkk;\n    int lll;\n    int mmm;\n    int nnn;\n    int ooo;\n    int\
    \ ppp;\n    int qqq;\n    int rrr;\n    int sss;\n    int ttt;\n    int uuu;\n\
    \    int vvv;\n    int www;\n    int xxx;\n    int yyy;\n    int zzz;\n    int\
    \ aaaa;\n    int bbbb;\n    int cccc;\n    int dddd;\n    int eeee;\n    int ffff;\n\
    \    int gggg;\n    int hhhh;\n    int iiii;\n    int jjjj;\n    int kkkk;\n \
    \   int llll;\n    int mmmm;\n    int nnnn;\n    int oooo", "{\n    long[] result;\n\
    \    long[] stack;\n    long[] temp;\n    long[] temp2;\n    long[] temp3;\n \
    \   long[] temp4;\n    long[] temp5;\n    long[] temp6;\n    long[] temp7;\n \
    \   long[] temp8;\n    long[] temp9;\n    long[] temp10;\n    long[] temp11;\n\
    \    long[] temp12;\n    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n\
    \    long[] temp16;\n    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n\
    \    long[] temp20;\n    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n\
    \    long[] temp24;\n    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n\
    \    long[] temp28;\n    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n\
    \    long[] temp32;\n    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n\
    \    long[] temp36;\n    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n\
    \    long[] temp40;\n    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n\
    \    long[] temp44;\n    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n\
    \    long[] temp48;\n    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n\
    \    long[] temp52;\n    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n\
    \    long[] temp56;\n    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n\
    \    long[] temp60;\n    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n\
    \    long[] temp64;\n    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n\
    \    long[] temp68;\n    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n\
    \   ", "{\n    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n\
    \    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n      \
    \      depth++;\n            max_depth = max(max_depth, depth);\n        }\n \
    \       else if(c == ')')\n        {\n            depth--;\n        }\n      \
    \  else if(c == ' ')\n        {\n            result ~= max_depth;\n          \
    \  max_depth = 0;\n            depth = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(paren_group; paren_string.split)\n   \
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group)\n        {\n            if(paren == '(')\n                depth++;\n\
    \            else if(paren == ')')\n                depth--;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        result ~= max_depth;\n    }\n \
    \   return result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long len;\n    long len_paren_string;\n\
    \    char c;\n    len_paren_string = paren_string.length;\n    result = new long[];\n\
    \    stack = new long[];\n    max_depth = 0;\n    depth = 0;\n    i = 0;\n   \
    \ while (i < len_paren_string) \n    {\n        c = paren_string[i];\n       \
    \ if (c == '(') \n        {\n            stack.push(1);\n            depth +=\
    \ 1;\n            max_depth = max(max_depth, depth);\n        }\n        else\
    \ if (c == ')') \n        {\n            stack.pop();\n            depth -= 1;\n\
    \        }\n        else if (c == ' ') \n        {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n        i += 1;\n\
    \    }\n    result.push(max_depth);\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] paren_count;\n    long[] paren_depth;\n    long max_depth;\n    long\
    \ i;\n    long j;\n    long k;\n    long m;\n    long n;\n    long o;\n    long\
    \ p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long\
    \ v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long\
    \ ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n\
    \    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long\
    \ am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n\
    \    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long\
    \ ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n\
    \    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long\
    \ bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n\
    \    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long\
    \ bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n\
    \    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long\
    \ ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n\
    \    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long\
    \ cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long", "{\n\
    \    long[] result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int max_level\
    \ = 0;\n    int level = 0;\n    int len = paren_string.length;\n    while (i <\
    \ len)\n    {\n        if (paren_string[i] == '(')\n        {\n            level++;\n\
    \            if (level > max_level)\n            {\n                max_level\
    \ = level;\n            }\n        }\n        else if (paren_string[i] == ')')\n\
    \        {\n            level--;\n        }\n        else if (paren_string[i]\
    \ == ' ')\n        {\n            result ~= max_level;\n            max_level\
    \ = 0;\n            level = 0;\n        }\n        i++;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    long[] stack = new long[];\n    long\
    \ max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n    {\n \
    \       if(c == '(')\n        {\n            depth++;\n            max_depth =\
    \ max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n  \
    \          depth--;\n        }\n        else if(c == ' ')\n        {\n       \
    \     result ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ stack;\n    long max_depth;\n    long current_depth;\n    long i;\n    long\
    \ j;\n    long k;\n    long l;\n    long m;\n    long n;\n    long o;\n    long\
    \ p;\n    long q;\n    long r;\n    long s;\n    long t;\n    long u;\n    long\
    \ v;\n    long w;\n    long x;\n    long y;\n    long z;\n    long aa;\n    long\
    \ ab;\n    long ac;\n    long ad;\n    long ae;\n    long af;\n    long ag;\n\
    \    long ah;\n    long ai;\n    long aj;\n    long ak;\n    long al;\n    long\
    \ am;\n    long an;\n    long ao;\n    long ap;\n    long aq;\n    long ar;\n\
    \    long as;\n    long at;\n    long au;\n    long av;\n    long aw;\n    long\
    \ ax;\n    long ay;\n    long az;\n    long ba;\n    long bb;\n    long bc;\n\
    \    long bd;\n    long be;\n    long bf;\n    long bg;\n    long bh;\n    long\
    \ bi;\n    long bj;\n    long bk;\n    long bl;\n    long bm;\n    long bn;\n\
    \    long bo;\n    long bp;\n    long bq;\n    long br;\n    long bs;\n    long\
    \ bt;\n    long bu;\n    long bv;\n    long bw;\n    long bx;\n    long by;\n\
    \    long bz;\n    long ca;\n    long cb;\n    long cc;\n    long cd;\n    long\
    \ ce;\n    long cf;\n    long cg;\n    long ch;\n    long ci;\n    long cj;\n\
    \    long ck;\n    long cl;\n    long cm;\n    long cn;\n    long co;\n    long\
    \ cp;\n    long cq;\n    long cr;\n    long cs;\n    long ct;\n    long", "{\n\
    \    long[] result = new long[];\n    int i = 0;\n    int max = 0;\n    int count\
    \ = 0;\n    while (i < paren_string.length)\n    {\n        if (paren_string[i]\
    \ == '(')\n        {\n            count++;\n            if (count > max)\n   \
    \         {\n                max = count;\n            }\n        }\n        else\
    \ if (paren_string[i] == ')')\n        {\n            count--;\n        }\n  \
    \      else if (paren_string[i] == ' ')\n        {\n            result ~= max;\n\
    \            max = 0;\n            count = 0;\n        }\n        i++;\n    }\n\
    \    result ~= max;\n    return result;\n}", "{\n    long[] result;\n    int max_depth\
    \ = 0;\n    int depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            depth++;\n            max_depth = max(max_depth,\
    \ depth);\n        }\n        else if(c == ')')\n        {\n            depth--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long current_max;\n\
    \    long current_index;\n    long current_paren;\n    long current_char;\n  \
    \  long current_paren_count;\n    long current_paren_index;\n    long current_paren_max;\n\
    \    long current_paren_max_index;\n    long current_paren_max_count;\n    long\
    \ current_paren_max_char;\n    long current_paren_max_char_index;\n    long current_paren_max_char_count;\n\
    \    long current_paren_max_char_max;\n    long current_paren_max_char_max_index;\n\
    \    long current_paren_max_char_max_count;\n    long current_paren_max_char_max_char;\n\
    \    long current_paren_max_char_max_char_index;\n    long current_paren_max_char_max_char_count;\n\
    \    long current_paren_max_char_max_char_max;\n    long current_paren_max_char_max_char_max_index;\n\
    \    long current_paren_max_char_max_char_max_count;\n    long current_paren_max_char_max_char_max_char;\n\
    \    long current_paren_max_char_max_char_max_char_index;\n    long current_paren_max_char_max_char_max_char_count;\n\
    \    long current_paren_max_char_max_char_max_char_max;\n    long current_paren_max_char_max_char_max_char_max_index;\n\
    \    long current_paren_max_char_max_char_max_char_max_count;\n    long current_paren_max_char_max_char_max_char_max_char;\n\
    \    long current_paren_max_char_max_char_max_char_max_char_index;\n    long current_paren_max_char_max_char_max_char_max_char_count;\n\
    \    long current_paren_max_char_max_char_max_char_max_char_max;\n    long current_paren_max_char_",
  "{\n    long[] result;\n    long max_nesting = 0;\n    long nesting = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            nesting++;\n\
    \            max_nesting = max(max_nesting, nesting);\n        }\n        else\
    \ if(c == ')')\n        {\n            nesting--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    long[] stack = new long[];\n    long max_depth\
    \ = 0;\n    long cur_depth = 0;\n    foreach(c; paren_string)\n    {\n       \
    \ if(c == '(')\n        {\n            stack ~= 1;\n            cur_depth += 1;\n\
    \            max_depth = max(max_depth, cur_depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            stack ~= -1;\n            cur_depth -= 1;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ > 0)\n            {\n                result ~= max_depth;\n                max_depth\
    \ = 0;\n                cur_depth = 0;\n                stack = new long[];\n\
    \            }\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[];\n    int i = 0;\n    while (i < paren_string.length) \n    {\n\
    \        int j = i;\n        int level = 0;\n        while (j < paren_string.length\
    \ && paren_string[j] != ' ') \n        {\n            if (paren_string[j] == '(')\
    \ \n            {\n                level++;\n            } \n            else\
    \ if (paren_string[j] == ')') \n            {\n                level--;\n    \
    \        }\n            j++;\n        }\n        result ~= level;\n        i =\
    \ j + 1;\n    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n\
    \    long max_depth;\n    long depth;\n    long i;\n    long j;\n    long len;\n\
    \    long len2;\n    long[] temp;\n    char c;\n    bool is_open;\n    bool is_close;\n\
    \    bool is_space;\n    bool is_paren;\n    bool is_empty;\n    bool is_not_empty;\n\
    \    bool is_not_space;\n    bool is_not_paren;\n    bool is_not_open;\n    bool\
    \ is_not_close;\n    bool is_not_empty_or_space;\n    bool is_not_empty_or_paren;\n\
    \    bool is_not_empty_or_open;\n    bool is_not_empty_or_close;\n    bool is_not_space_or_paren;\n\
    \    bool is_not_space_or_open;\n    bool is_not_space_or_close;\n    bool is_not_paren_or_open;\n\
    \    bool is_not_paren_or_close;\n    bool is_not_open_or_close;\n    bool is_not_empty_or_space_or_paren;\n\
    \    bool is_not_empty_or_space_or_open;\n    bool is_not_empty_or_space_or_close;\n\
    \    bool is_not_empty_or_paren_or_open;\n    bool is_not_empty_or_paren_or_close;\n\
    \    bool is_not_empty_or_open_or_close;\n    bool is_not_space_or_paren_or_open;\n\
    \    bool is_not_space_or_paren_or_close;\n    bool is_not_space_or_open_or_close;\n\
    \    bool is_not_paren_or_open_or_close;\n    bool is_not_empty_or_space_or_paren_or_open;\n\
    \    bool is_not_empty_or_space_or_paren_or_close;\n    bool is_not_empty_or_space_or_open_or_close;\n\
    \    bool is_not_empty_or_", "{\n    long[] result = new long[];\n    int[] stack\
    \ = new int[];\n    int max_level = 0;\n    int level = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            stack ~= 1;\n           \
    \ level++;\n            max_level = max(max_level, level);\n        }\n      \
    \  else if(c == ')')\n        {\n            stack ~= -1;\n            level--;\n\
    \        }\n        else if(c == ' ')\n        {\n            if(stack.length\
    \ == 0)\n            {\n                result ~= 0;\n            }\n        \
    \    else\n            {\n                result ~= max_level;\n             \
    \   max_level = 0;\n                level = 0;\n                stack = new int[];\n\
    \            }\n        }\n    }\n    if(stack.length != 0)\n    {\n        result\
    \ ~= max_level;\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ stack;\n    long[] max_stack;\n    long max_stack_size;\n    long max_stack_size_prev;\n\
    \    long max_stack_size_curr;\n    long stack_size;\n    long stack_size_prev;\n\
    \    long stack_size_curr;\n    long i;\n    long j;\n    long k;\n    long l;\n\
    \    long m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n\
    \    long s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n\
    \    long y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n    long\
    \ ad;\n    long ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n\
    \    long aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n    long\
    \ ao;\n    long ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n\
    \    long au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n    long\
    \ az;\n    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n\
    \    long bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long\
    \ bk;\n    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n\
    \    long bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n    long\
    \ bv;\n    long bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n\
    \    long cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long\
    \ cg;\n    long ch;\n    long ci;\n    long cj;\n    long ck", "{\n    long[]\
    \ result = new long[];\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    long max_depth = 0;\n\
    \    long depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            stack ~= 1;\n            depth += 1;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            stack ~= -1;\n            depth -= 1;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            depth = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            depth++;\n         \
    \   max_depth = max(max_depth, depth);\n        } \n        else if (c == ')')\
    \ \n        {\n            depth--;\n        } \n        else if (c == ' ') \n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split(\" \"))\n    {\n        stack = [];\n     \
    \   max_depth = 0;\n        depth = 0;\n        foreach (paren; paren_group)\n\
    \        {\n            if (paren == '(')\n            {\n                stack\
    \ ~= 1;\n                depth += 1;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if (paren == ')')\n            {\n\
    \                stack.pop();\n                depth -= 1;\n            }\n  \
    \      }\n        result ~= max_depth;\n    }\n    return result;\n}", "{\n  \
    \  long[] result;\n    long[] stack;\n    long max_depth;\n    foreach (paren_group;\
    \ paren_string.split)\n    {\n        max_depth = 0;\n        stack = [];\n  \
    \      foreach (paren; paren_group)\n        {\n            if (paren == '(')\n\
    \            {\n                stack ~= 1;\n                max_depth = max(max_depth,\
    \ stack.length);\n            }\n            else if (paren == ')')\n        \
    \    {\n                stack.pop;\n            }\n        }\n        result ~=\
    \ max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ paren_stack;\n    long paren_count;\n    long max_depth;\n    long depth;\n\
    \    long i;\n    long j;\n    long n;\n    long m;\n    long k;\n    long l;\n\
    \    long len;\n    long len2;\n    long len3;\n    long len4;\n    long len5;\n\
    \    long len6;\n    long len7;\n    long len8;\n    long len9;\n    long len10;\n\
    \    long len11;\n    long len12;\n    long len13;\n    long len14;\n    long\
    \ len15;\n    long len16;\n    long len17;\n    long len18;\n    long len19;\n\
    \    long len20;\n    long len21;\n    long len22;\n    long len23;\n    long\
    \ len24;\n    long len25;\n    long len26;\n    long len27;\n    long len28;\n\
    \    long len29;\n    long len30;\n    long len31;\n    long len32;\n    long\
    \ len33;\n    long len34;\n    long len35;\n    long len36;\n    long len37;\n\
    \    long len38;\n    long len39;\n    long len40;\n    long len41;\n    long\
    \ len42;\n    long len43;\n    long len44;\n    long len45;\n    long len46;\n\
    \    long len47;\n    long len48;\n    long len49;\n    long len50;\n    long\
    \ len51;\n    long len52;\n    long len53;\n    long len54;\n    long len55;\n\
    \    long len56;\n    long len57;\n    long len58;\n    long len59;\n    long\
    \ len60;\n    long len61;\n    long len62;\n    long len63;\n    long len64;\n\
    \    long len65;\n    long len66;\n    long len67;\n    long len68;\n    long\
    \ len69;\n    long len70;\n    long len71;\n    long len72;\n    long len73;\n\
    \    long len74;\n   ", "{\n    long[] result;\n    long[] stack;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long len;\n    long len_paren_string;\n\
    \    char c;\n    len_paren_string = paren_string.length;\n    result = new long[];\n\
    \    stack = new long[];\n    max_depth = 0;\n    depth = 0;\n    i = 0;\n   \
    \ j = 0;\n    while (i < len_paren_string) \n    {\n        c = paren_string[i];\n\
    \        if (c == '(') \n        {\n            stack.push(depth);\n         \
    \   depth++;\n            max_depth = max(max_depth, depth);\n        }\n    \
    \    else if (c == ')') \n        {\n            depth = stack.pop();\n      \
    \  }\n        else if (c == ' ') \n        {\n            result.push(max_depth);\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n        i++;\n\
    \    }\n    result.push(max_depth);\n    return result;\n}", "{\n    long[] result;\n\
    \    foreach(paren_group; paren_string.split) \n    {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        foreach(paren; paren_group) \n      \
    \  {\n            if(paren == '(') \n            {\n                depth++;\n\
    \                max_depth = max(max_depth, depth);\n            }\n         \
    \   else if(paren == ')') \n            {\n                depth--;\n        \
    \    }\n        }\n        result ~= max_depth;\n    }\n    return result;\n}",
  "{\n    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(char\
    \ c; paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int i = 0;\n    while (i < paren_string.length)\n\
    \    {\n        int start = i;\n        int end = i;\n        int count = 0;\n\
    \        while (end < paren_string.length && paren_string[end] != ' ')\n     \
    \   {\n            if (paren_string[end] == '(')\n                count++;\n \
    \           else if (paren_string[end] == ')')\n                count--;\n   \
    \         end++;\n        }\n        if (count == 0)\n            result ~= max(0,\
    \ count);\n        i = end + 1;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int max_depth = 0;\n    int depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth = 0;\n    long depth = 0;\n \
    \   foreach (paren; paren_string) \n    {\n        if (paren == '(') \n      \
    \  {\n            depth++;\n            max_depth = max(max_depth, depth);\n \
    \       }\n        else if (paren == ')') \n        {\n            depth--;\n\
    \        }\n        else if (paren == ' ') \n        {\n            result ~=\
    \ max_depth;\n            max_depth = 0;\n            depth = 0;\n        }\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long max_nesting =\
    \ 0;\n    long nesting = 0;\n    foreach(c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            nesting++;\n            max_nesting = max(max_nesting,\
    \ nesting);\n        }\n        else if(c == ')')\n        {\n            nesting--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n    long\
    \ depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n    \
    \    {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if(c == ')')\n        {\n            depth--;\n     \
    \   }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long[] stack;\n    long max_level;\n\
    \    long level;\n    foreach (paren; paren_string.split(' ')) \n    {\n     \
    \   stack = [];\n        max_level = 0;\n        level = 0;\n        foreach (c;\
    \ paren) \n        {\n            if (c == '(') \n            {\n            \
    \    stack ~= level;\n                level++;\n                max_level = max(max_level,\
    \ level);\n            } \n            else if (c == ')') \n            {\n  \
    \              if (stack.length == 0) \n                {\n                  \
    \  throw new Exception(\"Unbalanced parentheses\");\n                }\n     \
    \           stack.length--;\n                level = stack[$-1];\n           \
    \ }\n        }\n        if (stack.length != 0) \n        {\n            throw\
    \ new Exception(\"Unbalanced parentheses\");\n        }\n        result ~= max_level;\n\
    \    }\n    return result;\n}", "{\n    long[] result = new long[];\n    long\
    \ max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string) \n    {\n\
    \        if(c == '(') \n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        } \n        else if(c == ')') \n        {\n\
    \            depth--;\n        } \n        else if(c == ' ') \n        {\n   \
    \         result ~= max_depth;\n            max_depth = 0;\n            depth\
    \ = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n   \
    \ foreach(paren_group; paren_string.split)\n    {\n        long max_level = 0;\n\
    \        long level = 0;\n        foreach(paren; paren_group)\n        {\n   \
    \         if(paren == '(')\n                level++;\n            else\n     \
    \           level--;\n            max_level = max(max_level, level);\n       \
    \ }\n        result ~= max_level;\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    long[] stack = new long[];\n    long current_max =\
    \ 0;\n    long current_depth = 0;\n    foreach(c; paren_string)\n    {\n     \
    \   if(c == '(')\n        {\n            stack ~= 1;\n            current_depth\
    \ += 1;\n            current_max = max(current_max, current_depth);\n        }\n\
    \        else if(c == ')')\n        {\n            if(stack.length == 0)\n   \
    \         {\n                throw new Exception(\"Invalid input\");\n       \
    \     }\n            stack.popBack();\n            current_depth -= 1;\n     \
    \   }\n        else if(c == ' ')\n        {\n            if(stack.length != 0)\n\
    \            {\n                throw new Exception(\"Invalid input\");\n    \
    \        }\n            result ~= current_max;\n            current_max = 0;\n\
    \            current_depth = 0;\n        }\n        else\n        {\n        \
    \    throw new Exception(\"Invalid input\");\n        }\n    }\n    if(stack.length\
    \ != 0)\n    {\n        throw new Exception(\"Invalid input\");\n    }\n    result\
    \ ~= current_max;\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ paren_count;\n    long max_paren_count;\n    long i;\n    long j;\n    long\
    \ k;\n    long n;\n    long m;\n    long len;\n    long paren_count_len;\n   \
    \ long result_len;\n    long max_paren_count_len;\n    long paren_count_i;\n \
    \   long paren_count_j;\n    long paren_count_k;\n    long paren_count_n;\n  \
    \  long paren_count_m;\n    long paren_count_len;\n    long result_len;\n    long\
    \ max_paren_count_len;\n    long paren_count_i;\n    long paren_count_j;\n   \
    \ long paren_count_k;\n    long paren_count_n;\n    long paren_count_m;\n    long\
    \ paren_count_len;\n    long result_len;\n    long max_paren_count_len;\n    long\
    \ paren_count_i;\n    long paren_count_j;\n    long paren_count_k;\n    long paren_count_n;\n\
    \    long paren_count_m;\n    long paren_count_len;\n    long result_len;\n  \
    \  long max_paren_count_len;\n    long paren_count_i;\n    long paren_count_j;\n\
    \    long paren_count_k;\n    long paren_count_n;\n    long paren_count_m;\n \
    \   long paren_count_len;\n    long result_len;\n    long max_paren_count_len;\n\
    \    long paren_count_i;\n    long paren_count_j;\n    long paren_count_k;\n \
    \   long paren_count_n;\n    long paren_count_m;\n    long paren_count_len;\n\
    \    long result_len;\n    long max_paren_count_len;\n    long paren_count_i;\n\
    \    long paren_count_j;\n    long paren_count_k;\n    long paren_count_", "{\n\
    \    long[] result;\n    long[] stack;\n    long i;\n    long j;\n    long max;\n\
    \    long len;\n    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[]\
    \ temp4;\n    long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[]\
    \ temp8;\n    long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[]\
    \ temp12;\n    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[]\
    \ temp16;\n    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[]\
    \ temp20;\n    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[]\
    \ temp24;\n    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[]\
    \ temp28;\n    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[]\
    \ temp32;\n    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[]\
    \ temp36;\n    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[]\
    \ temp40;\n    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[]\
    \ temp44;\n    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[]\
    \ temp48;\n    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[]\
    \ temp52;\n    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[]\
    \ temp56;\n    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[]\
    \ temp60;\n    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[]\
    \ temp64;\n    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[]\
    \ temp68;\n    long", "{\n    long[] result;\n    long max_depth = 0;\n    long\
    \ depth = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(') \n \
    \       {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        } \n        else if (c == ')') \n        {\n            depth--;\n  \
    \      } \n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    long[] stack = new long[];\n\
    \    long level = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            level++;\n            stack ~= level;\n        }\n   \
    \     else if(c == ')')\n        {\n            result ~= stack.back;\n      \
    \      stack.popBack;\n            level--;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] paren_count;\n    long[] paren_max;\n \
    \   long[] paren_min;\n    long[] paren_level;\n    long[] paren_level_max;\n\
    \    long[] paren_level_min;\n    long[] paren_level_count;\n    long[] paren_level_max_count;\n\
    \    long[] paren_level_min_count;\n    long[] paren_level_max_index;\n    long[]\
    \ paren_level_min_index;\n    long[] paren_level_max_index_count;\n    long[]\
    \ paren_level_min_index_count;\n    long[] paren_level_max_index_count_max;\n\
    \    long[] paren_level_min_index_count_max;\n    long[] paren_level_max_index_count_min;\n\
    \    long[] paren_level_min_index_count_min;\n    long[] paren_level_max_index_count_max_index;\n\
    \    long[] paren_level_min_index_count_max_index;\n    long[] paren_level_max_index_count_min_index;\n\
    \    long[] paren_level_min_index_count_min_index;\n    long[] paren_level_max_index_count_max_index_count;\n\
    \    long[] paren_level_min_index_count_max_index_count;\n    long[] paren_level_max_index_count_min_index_count;\n\
    \    long[] paren_level_min_index_count_min_index_count;\n    long[] paren_level_max_index_count_max_index_count_max;\n\
    \    long[] paren_level_min_index_count_max_index_count_max;\n    long[] paren_level_max_index_count_min_index_count_max;\n\
    \    long[] paren_level_min_index_count_min_index_count_max;\n    long[] paren_level_max_index_count_max_index_count_min;\n\
    \    long[] paren_level_min", "{\n    long[] result = new long[];\n    long[]\
    \ stack = new long[];\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            stack ~=\
    \ 1;\n            depth++;\n            max_depth = max(max_depth, depth);\n \
    \       }\n        else if(c == ')')\n        {\n            stack ~= -1;\n  \
    \          depth--;\n        }\n        else if(c == ' ')\n        {\n       \
    \     result ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n\
    \            stack = new long[];\n        }\n    }\n    result ~= max_depth;\n\
    \    return result;\n}", "{\n    long[] result;\n    long max_nesting = 0;\n \
    \   long nesting = 0;\n    foreach(c; paren_string) \n    {\n        if (c ==\
    \ '(') \n        {\n            nesting++;\n            max_nesting = max(max_nesting,\
    \ nesting);\n        } \n        else if (c == ')') \n        {\n            nesting--;\n\
    \        } \n        else if (c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result = new long[];\n    int[] stack =\
    \ new int[];\n    int max_depth = 0;\n    int depth = 0;\n    foreach (ch; paren_string)\n\
    \    {\n        if (ch == '(')\n        {\n            stack ~= 1;\n         \
    \   depth += 1;\n            max_depth = max(max_depth, depth);\n        }\n \
    \       else if (ch == ')')\n        {\n            stack ~= -1;\n           \
    \ depth -= 1;\n        }\n        else if (ch == ' ')\n        {\n           \
    \ result ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n \
    \           stack = new int[];\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result = new long[];\n    string[] groups = paren_string.split(\"\
    \ \");\n    foreach(string group; groups)\n    {\n        long max_depth = 0;\n\
    \        long depth = 0;\n        foreach(char c; group)\n        {\n        \
    \    if(c == '(')\n            {\n                depth++;\n                max_depth\
    \ = max(max_depth, depth);\n            }\n            else if(c == ')')\n   \
    \         {\n                depth--;\n            }\n        }\n        result\
    \ ~= max_depth;\n    }\n    return result;\n}", "{\n    long[] result;\n    long\
    \ max_nesting = 0;\n    long nesting = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    int i;\n    int max_depth;\n    int depth;\n    int len;\n    int start;\n\
    \    int end;\n    int[] paren_count;\n    int[] paren_depth;\n    int[] paren_start;\n\
    \    int[] paren_end;\n    int[] paren_max_depth;\n    int[] paren_max_depth_start;\n\
    \    int[] paren_max_depth_end;\n    int[] paren_max_depth_count;\n    int[] paren_max_depth_depth;\n\
    \    int[] paren_max_depth_start_index;\n    int[] paren_max_depth_end_index;\n\
    \    int[] paren_max_depth_count_index;\n    int[] paren_max_depth_depth_index;\n\
    \    int[] paren_max_depth_start_index_index;\n    int[] paren_max_depth_end_index_index;\n\
    \    int[] paren_max_depth_count_index_index;\n    int[] paren_max_depth_depth_index_index;\n\
    \    int[] paren_max_depth_start_index_index_index;\n    int[] paren_max_depth_end_index_index_index;\n\
    \    int[] paren_max_depth_count_index_index_index;\n    int[] paren_max_depth_depth_index_index_index;\n\
    \    int[] paren_max_depth_start_index_index_index_index;\n    int[] paren_max_depth_end_index_index_index_index;\n\
    \    int[] paren_max_depth_count_index_index_index_index;\n    int[] paren_max_depth_depth_index_index_index_index;\n\
    \    int[] paren_max_depth_start_index_index_index_index_index;\n    int[] paren_max_depth_end_index_index_index_index_index;\n\
    \    int[] paren_max_depth_count_index_index_index_index_index;\n    int[] paren_max_depth_depth_index_index",
  "{\n    long[] result = new long[];\n    string[] paren_groups = paren_string.split(\"\
    \ \");\n    foreach(string paren_group; paren_groups)\n    {\n        long max_nesting\
    \ = 0;\n        long current_nesting = 0;\n        foreach(char c; paren_group)\n\
    \        {\n            if(c == '(')\n            {\n                current_nesting++;\n\
    \                max_nesting = max(max_nesting, current_nesting);\n          \
    \  }\n            else if(c == ')')\n            {\n                current_nesting--;\n\
    \            }\n        }\n        result ~= max_nesting;\n    }\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    int\
    \ i = 0;\n    int j = 0;\n    int max = 0;\n    while (i < paren_string.length)\n\
    \    {\n        if (paren_string[i] == '(')\n        {\n            stack ~= 1;\n\
    \            j++;\n        }\n        else if (paren_string[i] == ')')\n     \
    \   {\n            stack ~= -1;\n            j++;\n        }\n        else if\
    \ (paren_string[i] == ' ')\n        {\n            result ~= j;\n            j\
    \ = 0;\n        }\n        i++;\n    }\n    result ~= j;\n    return result;\n\
    }", "{\n    long[] result = new long[];\n    int[] stack = new int[];\n    foreach(paren;\
    \ paren_string.split(\" \"))\n    {\n        foreach(c; paren)\n        {\n  \
    \          if(c == '(')\n            {\n                stack ~= 1;\n        \
    \    }\n            else if(c == ')')\n            {\n                stack ~=\
    \ -1;\n            }\n        }\n        result ~= stack.length;\n        stack\
    \ = new int[];\n    }\n    return result;\n}", "{\n    long[] result;\n    long\
    \ max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n    {\n \
    \       if(c == '(')\n        {\n            depth++;\n            max_depth =\
    \ max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n  \
    \          depth--;\n        }\n        else if(c == ' ')\n        {\n       \
    \     result ~= max_depth;\n            max_depth = 0;\n            depth = 0;\n\
    \        }\n    }\n    return result;\n}", "{\n    long[] result = new long[];\n\
    \    foreach(paren_group; paren_string.split(\" \"))\n    {\n        long max_nesting\
    \ = 0;\n        long current_nesting = 0;\n        foreach(paren; paren_group)\n\
    \        {\n            if(paren == '(')\n            {\n                current_nesting++;\n\
    \                max_nesting = max(max_nesting, current_nesting);\n          \
    \  }\n            else if(paren == ')')\n            {\n                current_nesting--;\n\
    \            }\n        }\n        result ~= max_nesting;\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    long[] stack;\n    long[] temp;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long k;\n    long l;\n    long\
    \ m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long\
    \ s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long\
    \ y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n    long ad;\n  \
    \  long ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n    long\
    \ aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n    long ao;\n\
    \    long ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n    long\
    \ au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n    long az;\n\
    \    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n    long\
    \ bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long bk;\n\
    \    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n    long\
    \ bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n    long bv;\n\
    \    long bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n    long\
    \ cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long cg;\n\
    \    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long cl;\n    long\
    \ cm;\n    long cn;\n    long co;\n    long cp;\n    long cq;\n    long cr;\n\
    \    long cs;\n    long ct", "{\n    long[] result;\n    long max_depth = 0;\n\
    \    long depth = 0;\n    foreach(c; paren_string) \n    {\n        if (c == '(')\
    \ \n        {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        } \n        else if (c == ')') \n        {\n            depth--;\n  \
    \      } \n        else if (c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] result = new long[];\n    int i = 0;\n    while\
    \ (i < paren_string.length) \n    {\n        int start = i;\n        while (paren_string[i]\
    \ != ' ') \n        {\n            i++;\n        }\n        string paren_group\
    \ = paren_string[start..i];\n        result ~= get_max_nesting(paren_group);\n\
    \        i++;\n    }\n    return result;\n}", "{\n    long[] result;\n    long\
    \ max_nesting = 0;\n    long nesting = 0;\n    foreach(c; paren_string)\n    {\n\
    \        if(c == '(')\n        {\n            nesting++;\n            max_nesting\
    \ = max(max_nesting, nesting);\n        }\n        else if(c == ')')\n       \
    \ {\n            nesting--;\n        }\n        else if(c == ' ')\n        {\n\
    \            result ~= max_nesting;\n            max_nesting = 0;\n          \
    \  nesting = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n\
    \    long[] stack;\n    long max_depth;\n    long depth;\n    foreach (paren_group;\
    \ paren_string.split) \n    {\n        stack = [];\n        max_depth = 0;\n \
    \       depth = 0;\n        foreach (paren; paren_group) \n        {\n       \
    \     if (paren == '(') \n            {\n                stack ~= depth;\n   \
    \             depth += 1;\n                max_depth = max(max_depth, depth);\n\
    \            }\n            else if (paren == ')') \n            {\n         \
    \       depth = stack.pop;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n  \
    \  long max_level;\n    long level;\n    foreach (paren_group; paren_string.split(\"\
    \ \")) \n    {\n        stack = [];\n        max_level = 0;\n        level = 0;\n\
    \        foreach (paren; paren_group) \n        {\n            if (paren == '(')\
    \ \n            {\n                stack ~= level;\n                level += 1;\n\
    \                max_level = max(max_level, level);\n            }\n         \
    \   else \n            {\n                level = stack.back;\n              \
    \  stack.popBack;\n            }\n        }\n        result ~= max_level;\n  \
    \  }\n    return result;\n}", "{\n    long[] result;\n    long[] stack;\n    long[]\
    \ max_stack;\n    long max_stack_size;\n    long stack_size;\n    long max_depth;\n\
    \    long depth;\n    long i;\n    long j;\n    long k;\n    long l;\n    long\
    \ m;\n    long n;\n    long o;\n    long p;\n    long q;\n    long r;\n    long\
    \ s;\n    long t;\n    long u;\n    long v;\n    long w;\n    long x;\n    long\
    \ y;\n    long z;\n    long aa;\n    long ab;\n    long ac;\n    long ad;\n  \
    \  long ae;\n    long af;\n    long ag;\n    long ah;\n    long ai;\n    long\
    \ aj;\n    long ak;\n    long al;\n    long am;\n    long an;\n    long ao;\n\
    \    long ap;\n    long aq;\n    long ar;\n    long as;\n    long at;\n    long\
    \ au;\n    long av;\n    long aw;\n    long ax;\n    long ay;\n    long az;\n\
    \    long ba;\n    long bb;\n    long bc;\n    long bd;\n    long be;\n    long\
    \ bf;\n    long bg;\n    long bh;\n    long bi;\n    long bj;\n    long bk;\n\
    \    long bl;\n    long bm;\n    long bn;\n    long bo;\n    long bp;\n    long\
    \ bq;\n    long br;\n    long bs;\n    long bt;\n    long bu;\n    long bv;\n\
    \    long bw;\n    long bx;\n    long by;\n    long bz;\n    long ca;\n    long\
    \ cb;\n    long cc;\n    long cd;\n    long ce;\n    long cf;\n    long cg;\n\
    \    long ch;\n    long ci;\n    long cj;\n    long ck;\n    long cl;\n    long\
    \ cm;\n    long cn;\n    long co;\n    long cp;\n    long", "{\n    long[] result\
    \ = new long[];\n    int max_nesting = 0;\n    int nesting = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            nesting++;\n\
    \            max_nesting = max(max_nesting, nesting);\n        }\n        else\
    \ if(c == ')')\n        {\n            nesting--;\n        }\n        else if(c\
    \ == ' ')\n        {\n            result ~= max_nesting;\n            max_nesting\
    \ = 0;\n            nesting = 0;\n        }\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            max_depth = max(max_depth, depth);\n        }\n        else if(c\
    \ == ')')\n        {\n            depth--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_depth;\n            max_depth = 0;\n\
    \            depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[]\
    \ result = new long[];\n    int current_level = 0;\n    int max_level = 0;\n \
    \   foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n       \
    \     current_level++;\n            max_level = max(max_level, current_level);\n\
    \        }\n        else if(c == ')')\n        {\n            current_level--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_level;\n\
    \            max_level = 0;\n            current_level = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long[] stack;\n    int i;\n\
    \    int j;\n    int k;\n    int n;\n    int m;\n    int len;\n    int max;\n\
    \    int temp;\n    int count;\n    int[] temp_arr;\n    int[] temp_arr2;\n  \
    \  int[] temp_arr3;\n    int[] temp_arr4;\n    int[] temp_arr5;\n    int[] temp_arr6;\n\
    \    int[] temp_arr7;\n    int[] temp_arr8;\n    int[] temp_arr9;\n    int[] temp_arr10;\n\
    \    int[] temp_arr11;\n    int[] temp_arr12;\n    int[] temp_arr13;\n    int[]\
    \ temp_arr14;\n    int[] temp_arr15;\n    int[] temp_arr16;\n    int[] temp_arr17;\n\
    \    int[] temp_arr18;\n    int[] temp_arr19;\n    int[] temp_arr20;\n    int[]\
    \ temp_arr21;\n    int[] temp_arr22;\n    int[] temp_arr23;\n    int[] temp_arr24;\n\
    \    int[] temp_arr25;\n    int[] temp_arr26;\n    int[] temp_arr27;\n    int[]\
    \ temp_arr28;\n    int[] temp_arr29;\n    int[] temp_arr30;\n    int[] temp_arr31;\n\
    \    int[] temp_arr32;\n    int[] temp_arr33;\n    int[] temp_arr34;\n    int[]\
    \ temp_arr35;\n    int[] temp_arr36;\n    int[] temp_arr37;\n    int[] temp_arr38;\n\
    \    int[] temp_arr39;\n    int[] temp_arr40;\n    int[] temp_arr41;\n    int[]\
    \ temp_arr42;\n    int[] temp_arr43;\n    int[] temp_arr44;\n    int[] temp_arr45;\n\
    \    int[] temp_arr46;\n    int[] temp_arr47;\n    int[] temp_arr48;\n    int[]\
    \ temp_arr49;\n    int[] temp_arr50;\n    int[]", "{\n    long[] result = new\
    \ long[];\n    long[] stack = new long[];\n    long max_nesting = 0;\n    long\
    \ nesting = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n  \
    \      {\n            nesting++;\n            max_nesting = max(max_nesting, nesting);\n\
    \        }\n        else if(c == ')')\n        {\n            nesting--;\n   \
    \     }\n        else if(c == ' ')\n        {\n            stack ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  stack ~= max_nesting;\n    return stack;\n}", "{\n    long[] result;\n    long[]\
    \ paren_stack;\n    long[] paren_count;\n    long[] paren_max;\n    long[] paren_max_index;\n\
    \    long[] paren_max_count;\n    long[] paren_max_count_index;\n    long[] paren_max_count_index_index;\n\
    \    long[] paren_max_count_index_index_index;\n    long[] paren_max_count_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index;\n    long[] paren_max_count_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index;\n    long[]\
    \ paren_max_count_index_index_index_index_index_index_index_index;\n    long[]\
    \ paren_max_count_index_index_index_index_index_index_index_index_index;\n   \
    \ long[] paren_max_count_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_max_count_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index_index;\n\
    \    long[] paren_", "{\n    long[] result;\n    long max_depth = 0;\n    long\
    \ cur_depth = 0;\n    foreach(c; paren_string) \n    {\n        if(c == '(') \n\
    \        {\n            cur_depth++;\n            max_depth = max(max_depth, cur_depth);\n\
    \        }\n        else if(c == ')') \n        {\n            cur_depth--;\n\
    \        }\n        else if(c == ' ') \n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            cur_depth = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result;\n    long max_nesting = 0;\n   \
    \ long current_nesting = 0;\n    foreach(c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            current_nesting++;\n            max_nesting\
    \ = max(max_nesting, current_nesting);\n        }\n        else if(c == ')')\n\
    \        {\n            current_nesting--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_nesting;\n            max_nesting =\
    \ 0;\n            current_nesting = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    int i = 0;\n    foreach(paren_group; paren_string.split(\"\
    \ \"))\n    {\n        int max_depth = 0;\n        int current_depth = 0;\n  \
    \      foreach(paren; paren_group)\n        {\n            if(paren == '(')\n\
    \            {\n                current_depth++;\n                max_depth =\
    \ max(max_depth, current_depth);\n            }\n            else if(paren ==\
    \ ')')\n            {\n                current_depth--;\n            }\n     \
    \   }\n        result ~= max_depth;\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long max_depth = 0;\n    long current_depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            current_depth++;\n\
    \            max_depth = max(max_depth, current_depth);\n        }\n        else\
    \ if(c == ')')\n        {\n            current_depth--;\n        }\n        else\
    \ if(c == ' ')\n        {\n            result ~= max_depth;\n            max_depth\
    \ = 0;\n            current_depth = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(paren_group; paren_string.split) \n  \
    \  {\n        long max_depth = 0;\n        long depth = 0;\n        foreach(paren;\
    \ paren_group) \n        {\n            if(paren == '(') \n            {\n   \
    \             depth++;\n                max_depth = max(max_depth, depth);\n \
    \           } \n            else if(paren == ')') \n            {\n          \
    \      depth--;\n            }\n        }\n        result ~= max_depth;\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    long max_depth = 0;\n   \
    \ long depth = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n\
    \        {\n            depth++;\n            max_depth = max(max_depth, depth);\n\
    \        }\n        else if(c == ')')\n        {\n            depth--;\n     \
    \   }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            depth = 0;\n        }\n    }\n    return\
    \ result;\n}", "{\n    long[] paren_counts;\n    long paren_count = 0;\n    foreach(c;\
    \ paren_string) \n    {\n        if(c == '(') \n        {\n            paren_count++;\n\
    \        }\n        else if(c == ')') \n        {\n            paren_counts ~=\
    \ paren_count;\n            paren_count = 0;\n        }\n    }\n    return paren_counts;\n\
    }", "{\n    long[] result;\n    long max_nesting = 0;\n    long nesting = 0;\n\
    \    foreach(c; paren_string) \n    {\n        if (c == '(') \n        {\n   \
    \         nesting++;\n            max_nesting = max(max_nesting, nesting);\n \
    \       } \n        else if (c == ')') \n        {\n            nesting--;\n \
    \       } \n        else if (c == ' ') \n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result;\n    long[] paren_count;\n    long[]\
    \ max_paren_count;\n    long[] max_paren_count_index;\n    long[] paren_count_index;\n\
    \    long[] paren_count_index_temp;\n    long[] paren_count_index_temp2;\n   \
    \ long[] paren_count_index_temp3;\n    long[] paren_count_index_temp4;\n    long[]\
    \ paren_count_index_temp5;\n    long[] paren_count_index_temp6;\n    long[] paren_count_index_temp7;\n\
    \    long[] paren_count_index_temp8;\n    long[] paren_count_index_temp9;\n  \
    \  long[] paren_count_index_temp10;\n    long[] paren_count_index_temp11;\n  \
    \  long[] paren_count_index_temp12;\n    long[] paren_count_index_temp13;\n  \
    \  long[] paren_count_index_temp14;\n    long[] paren_count_index_temp15;\n  \
    \  long[] paren_count_index_temp16;\n    long[] paren_count_index_temp17;\n  \
    \  long[] paren_count_index_temp18;\n    long[] paren_count_index_temp19;\n  \
    \  long[] paren_count_index_temp20;\n    long[] paren_count_index_temp21;\n  \
    \  long[] paren_count_index_temp22;\n    long[] paren_count_index_temp23;\n  \
    \  long[] paren_count_index_temp24;\n    long[] paren_count_index_temp25;\n  \
    \  long[] paren_count_index_temp26;\n    long[] paren_count_index_temp27;\n  \
    \  long[] paren_count_index_temp28;\n    long[] paren_count_index_temp29;\n  \
    \  long[] paren_count_index_temp30;\n    long[] paren_count_index_temp31;\n  \
    \  long[] paren_count_index_temp32;\n    long[] paren_count_index_temp33;\n",
  "{\n    long[] result;\n    long max_depth = 0;\n    long current_depth = 0;\n \
    \   foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n       \
    \     current_depth++;\n            max_depth = max(max_depth, current_depth);\n\
    \        }\n        else if(c == ')')\n        {\n            current_depth--;\n\
    \        }\n        else if(c == ' ')\n        {\n            result ~= max_depth;\n\
    \            max_depth = 0;\n            current_depth = 0;\n        }\n    }\n\
    \    return result;\n}", "{\n    long[] result;\n    foreach(paren_group; paren_string.split)\n\
    \    {\n        long max_nesting = 0;\n        long current_nesting = 0;\n   \
    \     foreach(paren; paren_group)\n        {\n            if(paren == '(')\n \
    \           {\n                current_nesting++;\n                max_nesting\
    \ = max(max_nesting, current_nesting);\n            }\n            else if(paren\
    \ == ')')\n            {\n                current_nesting--;\n            }\n\
    \        }\n        result ~= max_nesting;\n    }\n    return result;\n}", "{\n\
    \    long[] result;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l\
    \ = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int\
    \ q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n   \
    \ int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int aa = 0;\n    int ab = 0;\n    int ac = 0;\n    int ad = 0;\n    int ae\
    \ = 0;\n    int af = 0;\n    int ag = 0;\n    int ah = 0;\n    int ai = 0;\n \
    \   int aj = 0;\n    int ak = 0;\n    int al = 0;\n    int am = 0;\n    int an\
    \ = 0;\n    int ao = 0;\n    int ap = 0;\n    int aq = 0;\n    int ar = 0;\n \
    \   int as = 0;\n    int at = 0;\n    int au = 0;\n    int av = 0;\n    int aw\
    \ = 0;\n    int ax = 0;\n    int ay = 0;\n    int az = 0;\n    int ba = 0;\n \
    \   int bb = 0;\n    int bc = 0;\n    int bd = 0;\n    int be = 0;\n    int bf\
    \ = 0;\n    int bg = 0;\n    int bh = 0;\n    int bi = 0;\n    int bj = 0;\n \
    \   int bk = 0;\n    int bl = 0;\n    int bm = 0;\n    int bn = 0;\n    int bo\
    \ = 0;\n    int bp = 0;\n    int bq = 0;\n    int br = 0;\n    int bs = 0;\n \
    \   int bt = 0;\n    int bu = 0;\n    int bv = 0;\n    int bw = 0;\n    int bx\
    \ = 0;\n    int by = 0", "{\n    long[] result = new long[];\n    long[] stack\
    \ = new long[];\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c;\
    \ paren_string)\n    {\n        if(c == '(')\n        {\n            depth++;\n\
    \            stack ~= depth;\n        }\n        else if(c == ')')\n        {\n\
    \            if(depth > max_depth)\n                max_depth = depth;\n     \
    \       stack.popBack();\n            depth = stack.back;\n        }\n       \
    \ else if(c == ' ')\n        {\n            result ~= max_depth;\n           \
    \ max_depth = 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result\
    \ = new long[];\n    int[] stack = new int[];\n    int max_depth = 0;\n    int\
    \ depth = 0;\n    int i = 0;\n    while (i < paren_string.length) \n    {\n  \
    \      if (paren_string[i] == '(') \n        {\n            stack.push(i);\n \
    \           depth++;\n            max_depth = max(max_depth, depth);\n       \
    \ } \n        else if (paren_string[i] == ')') \n        {\n            stack.pop();\n\
    \            depth--;\n        } \n        else if (paren_string[i] == ' ') \n\
    \        {\n            result ~= max_depth;\n            max_depth = 0;\n   \
    \         depth = 0;\n        }\n        i++;\n    }\n    result ~= max_depth;\n\
    \    return result;\n}", "{\n    long[] result;\n    int max_nesting = 0;\n  \
    \  int current_nesting = 0;\n    foreach(c; paren_string)\n    {\n        if(c\
    \ == '(')\n        {\n            current_nesting++;\n            max_nesting\
    \ = max(max_nesting, current_nesting);\n        }\n        else if(c == ')')\n\
    \        {\n            current_nesting--;\n        }\n        else if(c == '\
    \ ')\n        {\n            result ~= max_nesting;\n            max_nesting =\
    \ 0;\n            current_nesting = 0;\n        }\n    }\n    return result;\n\
    }", "{\n    long[] result;\n    foreach(paren_group; paren_string.split(' '))\
    \ \n    {\n        long max_level = 0;\n        long current_level = 0;\n    \
    \    foreach(paren; paren_group) \n        {\n            if(paren == '(') \n\
    \            {\n                current_level++;\n                max_level =\
    \ max(max_level, current_level);\n            }\n            else if(paren ==\
    \ ')') \n            {\n                current_level--;\n            }\n    \
    \    }\n        result ~= max_level;\n    }\n    return result;\n}", "{\n    long[]\
    \ result;\n    long[] stack;\n    long max_depth;\n    long depth;\n    foreach\
    \ (paren_group; paren_string.split) \n    {\n        stack = [];\n        max_depth\
    \ = 0;\n        depth = 0;\n        foreach (paren; paren_group) \n        {\n\
    \            if (paren == '(') \n            {\n                stack ~= 1;\n\
    \                depth += 1;\n                max_depth = max(max_depth, depth);\n\
    \            } \n            else if (paren == ')') \n            {\n        \
    \        stack.pop;\n                depth -= 1;\n            }\n        }\n \
    \       assert(stack.empty);\n        result ~= max_depth;\n    }\n    return\
    \ result;\n}", "{\n    long[] result;\n    long max_nesting = 0;\n    long nesting\
    \ = 0;\n    foreach(c; paren_string)\n    {\n        if(c == '(')\n        {\n\
    \            nesting++;\n            max_nesting = max(max_nesting, nesting);\n\
    \        }\n        else if(c == ')')\n        {\n            nesting--;\n   \
    \     }\n        else if(c == ' ')\n        {\n            result ~= max_nesting;\n\
    \            max_nesting = 0;\n            nesting = 0;\n        }\n    }\n  \
    \  return result;\n}", "{\n    long[] result = new long[];\n    long[] stack =\
    \ new long[];\n    long max_depth = 0;\n    long depth = 0;\n    foreach(c; paren_string)\n\
    \    {\n        if(c == '(')\n        {\n            depth++;\n            max_depth\
    \ = max(max_depth, depth);\n        }\n        else if(c == ')')\n        {\n\
    \            depth--;\n        }\n        else if(c == ' ')\n        {\n     \
    \       result ~= max_depth;\n            max_depth = 0;\n            depth =\
    \ 0;\n        }\n    }\n    return result;\n}", "{\n    long[] result;\n    long[]\
    \ stack;\n    long max_level = 0;\n    long level = 0;\n    foreach(c; paren_string)\
    \ \n    {\n        if (c == '(') \n        {\n            level++;\n         \
    \   max_level = max(max_level, level);\n        } \n        else if (c == ')')\
    \ \n        {\n            level--;\n        } \n        else if (c == ' ') \n\
    \        {\n            if (level != 0) \n            {\n                stack\
    \ ~= max_level;\n                max_level = 0;\n            }\n        }\n  \
    \  }\n    if (level != 0) \n    {\n        stack ~= max_level;\n    }\n    return\
    \ stack;\n}", "{\n    long[] result;\n    foreach(paren_group; paren_string.split(\"\
    \ \")) \n    {\n        long max_depth = 0;\n        long depth = 0;\n       \
    \ foreach(paren; paren_group) \n        {\n            if(paren == '(') \n   \
    \         {\n                depth++;\n                max_depth = max(max_depth,\
    \ depth);\n            }\n            else if(paren == ')') \n            {\n\
    \                depth--;\n            }\n        }\n        result ~= max_depth;\n\
    \    }\n    return result;\n}"]
stop_tokens:
- "\n\n"
- "\nvoid"
- "\nbool"
- "\nint"
