name: HumanEval_156_int_to_mini_roman
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto digits = to!string(number);\n    auto len = digits.length;\n\
    \    auto roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    auto roman_tens = [\n       \
    \ \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\
    \n    ];\n    auto roman_hundreds = [\n        \"\", \"c\", \"cc\", \"ccc\", \"\
    cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    auto roman_thousands\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    switch (len) {\n    \
    \    case 1:\n            result = roman_digits[to!int(digits[0..1])];\n     \
    \       break;\n        case 2:\n            result = roman_tens[to!int(digits[0..1])]\
    \ ~ roman_digits[to!int(digits[1..2])];\n            break;\n        case 3:\n\
    \            result = roman_hundreds[to!int(digits[0..1])] ~ roman_tens[to!int(digits[1..2])]\
    \ ~ roman_digits[to!int(digits[2..3])];\n            break;\n        case 4:\n\
    \            result = roman_thousands[to!int(digits[0..1])] ~ roman_hundreds[to!int(digits[1..2])]\
    \ ~ roman_tens[to!int(digits[2..3])] ~ roman_digits[to!int(digits[3..4])];\n \
    \           break;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsm0r05es.d(18): Error: template instance `to!string` template\
    \ `to` is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(34): Error: template\
    \ instance `to!int` template `to` is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(37):\
    \ Error: template instance `to!int` template `to` is not defined, did you mean\
    \ No?\\n/tmp/tmpsm0r05es.d(37): Error: template instance `to!int` template `to`\
    \ is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(40): Error: template instance\
    \ `to!int` template `to` is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(40):\
    \ Error: template instance `to!int` template `to` is not defined, did you mean\
    \ No?\\n/tmp/tmpsm0r05es.d(40): Error: template instance `to!int` template `to`\
    \ is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(43): Error: template instance\
    \ `to!int` template `to` is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(43):\
    \ Error: template instance `to!int` template `to` is not defined, did you mean\
    \ No?\\n/tmp/tmpsm0r05es.d(43): Error: template instance `to!int` template `to`\
    \ is not defined, did you mean No?\\n/tmp/tmpsm0r05es.d(43): Error: template instance\
    \ `to!int` template `to` is not defined, did you mean No?\\nFailed: [\"dmd\",\
    \ \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsm0r05es.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numbers = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\",\
    \ \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    return roman_thousands[number / 1000] ~\n           roman_hundreds[(number\
    \ / 100) % 10] ~\n           roman_tens[(number / 10) % 10] ~\n           roman_numbers[number\
    \ % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] hundreds = [\n        \"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[4] thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return\
    \ thousands[number / 1000] ~\n           hundreds[(number / 100) % 10] ~\n   \
    \        tens[(number / 10) % 10] ~\n           digits[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number > 0)\n    {\n   \
    \     result ~= roman_thousands[number / 1000];\n        number %= 1000;\n   \
    \     result ~= roman_hundreds[number / 100];\n        number %= 100;\n      \
    \  result ~= roman_tens[number / 10];\n        number %= 10;\n        result ~=\
    \ roman_numerals[number];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ Implement me!\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcj_531d6.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmpcj_531d6.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmpcj_531d6.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x1ccc0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] decimal_values = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    static const string[] roman_values = [\"i\"\
    , \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"];\n\
    \    static const int[] decimal_values_2 = [10, 20, 30, 40, 50, 60, 70, 80, 90,\
    \ 100];\n    static const string[] roman_values_2 = [\"x\", \"xx\", \"xxx\", \"\
    xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static const int[]\
    \ decimal_values_3 = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000];\n  \
    \  static const string[] roman_values_3 = [\"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static const int[] decimal_values_4\
    \ = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000];\n    static\
    \ const string[] roman_values_4 = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\"\
    , \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static const int[] decimal_values_5\
    \ = [10000, 20000, 30000, 40000, 50000, 60000, 70000, 80000, 90000, 100000];\n\
    \    static const string[] roman_values_5 = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static const int[] decimal_values_6\
    \ = [100000, 200000, 300000, 400000, 500000, 600000, 700000, 800000, 900000, 1000000];\n\
    \    static const string[] roman_values_6 = [\"c\", \"cc\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkw9gu5ou.d(30): Error: unterminated string constant starting\
    \ at /tmp/tmpkw9gu5ou.d(48)\\n/tmp/tmpkw9gu5ou.d(35): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpkw9gu5ou.d(35): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpkw9gu5ou.d(36):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(37):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(38):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(39):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpkw9gu5ou.d(40):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(41):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(42):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(43):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(44):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(45):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(46):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(47):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(48):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(50):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpkw9gu5ou.d(50):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkw9gu5ou.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    static string[4] roman_tens_of_thousands = [\n       \
    \ \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4]\
    \ roman_tens_of_millions = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n\
    \    static string[4] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\"\n    ];\n    static string[4] roman_billions = [\n        \"m\"\
    , \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_tens_of_billions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\n    ];\n    static string[4] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp04hzlqqe.d(57): Error: found `unittest` when expecting `]`\\\
    n/tmp/tmp04hzlqqe.d(58): Error: no identifier for declarator `string[4]`\\n/tmp/tmp04hzlqqe.d(76):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp04hzlqqe.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"\
    v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xmm\", \"xmmm\", \"xmmmm\"\n    ];\n    static string[4]\
    \ roman_hundred_millions = [\n        \"\", \"cmm\", \"cmmm\", \"cmmmm\"\n   \
    \ ];\n    static string[4] roman_billions = [\n        \"\", \"mmm\", \"mmmm\"\
    , \"mmmmm\"\n    ];\n    static string[4] roman_ten_billions = [\n        \"\"\
    , \"xmmm\", \"xmmmm\", \"xmmmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cmmm\", \"cmmmm\", \"cmmmmm\"\n    ];\n    static string[4]\
    \ roman_trillions = [\n        \"\", \"mmmm\", \"mmmmm\", \"mmmmmm\"\n    ];\n\
    \    static string[4] roman_ten_trillions = [\n        \"\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppx772bwb.d(56): Error: unterminated string constant starting\
    \ at /tmp/tmppx772bwb.d(75)\\n/tmp/tmppx772bwb.d(62): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmppx772bwb.d(62): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmppx772bwb.d(63):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(64):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(65):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(66):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmppx772bwb.d(67):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(68):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(69):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(70):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(71):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(72):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(73):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(74):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(75):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(77):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmppx772bwb.d(77):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppx772bwb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[4] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\
    , \"mmmm\"\n    ];\n    string result = \"\";\n    if (number > 1000)\n      \
    \  return \"\";\n    if (number >= 1000)\n        result ~= roman_thousands[number\
    \ / 1000];\n    if (number >= 100)\n        result ~= roman_hundreds[(number %\
    \ 1000) / 100];\n    if (number >= 10)\n        result ~= roman_tens[(number %\
    \ 100) / 10];\n    if (number >= 1)\n        result ~= roman_numerals[number %\
    \ 10];\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpgwx84h3v.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4284d5]\\n??:? void tmpgwx84h3v.__unittest_L42_C1()\
    \ [0x427e5c]\\n??:? void tmpgwx84h3v.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cc8f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bb9e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4304c5]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430974]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430451]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb75]\\n??:? runModuleUnitTests [0x42ca65]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428998]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42891f]\\n??:? _d_run_main [0x42888a]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0x67bb4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    int i = 0;\n    while (number > 0) {\n\
    \        int times = number / values[i];\n        number -= values[i] * times;\n\
    \        while (times-- > 0) {\n            result ~= roman_numerals[i];\n   \
    \     }\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpayhw7ti_.d(26): Error: cannot implicitly convert expression `number\
    \ / cast(long)values[cast(ulong)i]` of type `long` to `int`\\nFailed: [\"dmd\"\
    , \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpayhw7ti_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpht4hb6be.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmpht4hb6be.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmpht4hb6be.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x1c336554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    foreach(i; reverse(iota(values.length)))\n    {\n        while(number\
    \ >= values[i])\n        {\n            result ~= numerals[i];\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpet0suwkv.d(20): Error: undefined identifier `iota`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpet0suwkv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ digits[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xmm\", \"xmmm\", \"xmmmm\"\n    ];\n    static string[4]\
    \ roman_hundred_millions = [\n        \"\", \"cmm\", \"cmmm\", \"cmmmm\"\n   \
    \ ];\n    static string[4] roman_billions = [\n        \"\", \"mmm\", \"mmmm\"\
    , \"mmmmm\"\n    ];\n    static string[4] roman_ten_billions = [\n        \"\"\
    , \"xmmm\", \"xmmmm\", \"xmmmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cmmm\", \"cmmmm\", \"cmmmmm\"\n    ];\n    static string[4]\
    \ roman_trillions = [\n        \"\", \"mmmm\", \"mmmmm\", \"mmmmmm\"\n    ];\n\
    \    static string[4] roman_ten_trillions = [\n       \nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcz57552v.d(58): Error: expression expected, not `unittest`\\\
    n/tmp/tmpcz57552v.d(59): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpcz57552v.d(77): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpcz57552v.d(77): Error: semicolon expected, not `main`\\\
    n/tmp/tmpcz57552v.d(77): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcz57552v.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static\
    \ string[10] roman_ten_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\",\
    \ \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10]\
    \ roman_hundred_thousands = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\",\
    \ \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static string[10] roman_millions\
    \ = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\", \"x\"\n    ];\n    static string[10] roman_ten_millions = [\n      \
    \  \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"\
    c\"\n    ];\n    static string[10] roman_hundred_millions = [\n        \"c\",\
    \ \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n \
    \   ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\", \"mmm\"\
    , \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4_nkygq3.d(44): Error: unterminated string constant starting\
    \ at /tmp/tmp4_nkygq3.d(63)\\n/tmp/tmp4_nkygq3.d(50): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp4_nkygq3.d(50): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp4_nkygq3.d(51):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(52):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(53):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(54):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp4_nkygq3.d(55):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(56):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(57):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(58):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(59):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(60):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(61):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(62):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(63):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(65):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp4_nkygq3.d(65):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4_nkygq3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] decimal_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(index, numeral; roman_numerals)\n    {\n        while(number\
    \ >= decimal_numerals[index])\n        {\n            result ~= numeral;\n   \
    \         number -= decimal_numerals[index];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple('i', 'v', 'x'),\n \
    \       tuple('x', 'l', 'c'),\n        tuple('c', 'd', 'm'),\n        tuple('m',\
    \ 'v', 'x')\n    );\n    foreach(i, roman_numerals)\n    {\n        auto numeral\
    \ = roman_numerals[i];\n        auto digit = number % 10;\n        if (digit ==\
    \ 0)\n        {\n            number /= 10;\n            continue;\n        }\n\
    \        if (digit <= 3)\n        {\n            result = repeat(numeral[0], digit)\
    \ ~ result;\n        }\n        else if (digit == 4)\n        {\n            result\
    \ = numeral[0] ~ numeral[1] ~ result;\n        }\n        else if (digit <= 8)\n\
    \        {\n            result = numeral[1] ~ repeat(numeral[0], digit - 5) ~\
    \ result;\n        }\n        else if (digit == 9)\n        {\n            result\
    \ = numeral[0] ~ numeral[2] ~ result;\n        }\n        number /= 10;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqu0aa1x6.d(24): Error: no identifier for declarator `roman_numerals`\\\
    n/tmp/tmpqu0aa1x6.d(24): Error: found `)` when expecting `;`\\n/tmp/tmpqu0aa1x6.d(51):\
    \ Error: found `return` when expecting `)`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpqu0aa1x6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_numerals_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_numerals_values_sorted\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_numerals_values_sorted_reversed\
    \ = [1000, 500, 100, 50, 10, 5, 1];\n    static const string[] roman_numerals_sorted\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_numerals_sorted_reversed = [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\",\
    \ \"i\"];\n    static const int[] roman_numerals_values_sorted_reversed_index\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_numerals_values_sorted_index\
    \ = [0, 1, 2, 3, 4, 5, 6];\n    static const string[] roman_numerals_sorted_index\
    \ = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static const string[]\
    \ roman_numerals_sorted_reversed_index = [\"m\", \"d\", \"c\", \"l\", \"x\", \"\
    v\", \"i\"];\n    static const string[] roman_numerals_sorted_index_reversed =\
    \ [\"m\", \"d\", \"c\", \"l\", \"x\", \"v\", \"i\"];\n    static const string[]\
    \ roman_numerals_sorted_reversed_index_reversed = [\"i\", \"v\", \"x\", \"l\"\
    , \"c\", \"d\", \"m\"];\n    static const int[] roman_numerals_values_sorted_index_reversed\
    \ = [6, 5, 4, 3, 2, 1, 0];\n    static const int[] roman_numerals_values_sorted_reversed_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpod9k86c2.d(31): Error: semicolon expected, not `unittest`\\n/tmp/tmpod9k86c2.d(31):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpod9k86c2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"\",\
    \ \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenmillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredmillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredbillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tentrillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_h\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1g5cq9f1.d(60): Error: semicolon expected, not `unittest`\\n/tmp/tmp1g5cq9f1.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp1g5cq9f1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.algorithm;\n    import std.array;\n    import std.range;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.stdio;\n    import std.traits;\n    import std.typecons;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.math;\n    import std.range;\n    import std.stdio;\n    import std.string;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.conv;\n    import std.range;\n\
    \    import std.stdio;\n    import std.string;\n    import std.traits;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.conv;\n    import std.range;\n    import std.stdio;\n    import\
    \ std.string;\n    import std.traits;\n    import std.typecons;\n    import std.math;\n\
    \    import std.algorithm;\n    import std.array;\n    import std.conv;\n    import\
    \ std.range;\n    import std.stdio;\n    import std.string;\n    import std.traits;\n\
    \    import std.typecons;\n    import std.math;\n    import std.algorithm;\n \
    \   import std.array;\n    import std.conv;\n    import std.range;\n    import\
    \ std.stdio;\n    import std.string;\n    import std.traits;\n    import std.typecons;\n\
    \    import std.math;\n    import std.algorithm;\n    import std.array;\n    import\
    \ std.conv;\n    import std.range;\n    import std.stdio;\n    import std.string;\n\
    \    import std.traits;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphtlvj54j.d(86): Error: `;` expected\\n/tmp/tmphtlvj54j.d(105):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphtlvj54j.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    string result\
    \ = \"\";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n\
    \    result ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~=\
    \ roman_tens[number / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    // TODO\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdw06e_yd.d(25): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42812d]\\n??:? void tmpdw06e_yd.__unittest_L21_C1()\
    \ [0x427ab4]\\n??:? void tmpdw06e_yd.__modtest() [0x427eb0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bdd7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ace6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fdfd]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302ac]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd89]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acbd]\\n??:? runModuleUnitTests [0x42bbad]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x42857c]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428503]\\n??:? _d_run_main [0x42846e]\\n??:? main [0x427ec3]\\\
    n??:? __libc_start_main [0xd8ad0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, roman_num; zip(roman, arabic))\n    {\n        while(number >= roman_num[1])\n\
    \        {\n            result ~= roman_num[0];\n            number -= roman_num[1];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgrqcq4mw.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgrqcq4mw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n   \
    \ static string[] numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    string result = \"\";\n\
    \    foreach(i, v; values)\n    {\n        while(number >= v)\n        {\n   \
    \         result ~= numerals[i];\n            number -= v;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement this function\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpj87rzlgp.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmpj87rzlgp.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmpj87rzlgp.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x8388c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"i\", \"ii\", \"\
    iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\", \"m\"\n    ];\n    static string[10] roman_thousands = [\n        \"\
    m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n\
    \    ];\n    static string[10] roman_tenthousands = [\n        \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"\n    ];\n \
    \   static string[10] roman_hundredthousands = [\n        \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n    ];\n    static\
    \ string[10] roman_millions = [\n        \"m\", \"mm\", \"mmm\", \"mv\", \"v\"\
    , \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    static string[10] roman_tenmillions\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundredmillions = [\n   \
    \     \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"\n    ];\n    static string[10] roman_billions = [\n        \"m\", \"mm\"\
    , \"mmm\",\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl8zfzdf6.d(47): Error: expression expected, not `unittest`\\\
    n/tmp/tmpl8zfzdf6.d(48): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpl8zfzdf6.d(66): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpl8zfzdf6.d(66): Error: semicolon expected, not `main`\\\
    n/tmp/tmpl8zfzdf6.d(66): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl8zfzdf6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral; zip(decimal_numerals,\
    \ roman_numerals)) {\n        while(number >= numeral[0]) {\n            result\
    \ ~= numeral[1];\n            number -= numeral[0];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8gtvxgav.d(24): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gtvxgav.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= values[i])\n        {\n\
    \            number -= values[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    auto thousands\
    \ = number / 1000;\n    auto hundreds = (number % 1000) / 100;\n    auto tens\
    \ = (number % 100) / 10;\n    auto ones = number % 10;\n    return roman_thousands[thousands]\
    \ ~ roman_hundreds[hundreds] ~ roman_tens[tens] ~ roman_numerals[ones];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman = [](long number, string one, string five, string ten)\
    \ {\n        if (number == 0) return \"\";\n        if (number == 1) return one;\n\
    \        if (number == 2) return one ~ one;\n        if (number == 3) return one\
    \ ~ one ~ one;\n        if (number == 4) return one ~ five;\n        if (number\
    \ == 5) return five;\n        if (number == 6) return five ~ one;\n        if\
    \ (number == 7) return five ~ one ~ one;\n        if (number == 8) return five\
    \ ~ one ~ one ~ one;\n        if (number == 9) return one ~ ten;\n    };\n   \
    \ result ~= roman(number / 100, \"c\", \"d\", \"m\");\n    number %= 100;\n  \
    \  result ~= roman(number / 10, \"x\", \"l\", \"c\");\n    number %= 10;\n   \
    \ result ~= roman(number, \"i\", \"v\", \"x\");\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw0fx678_.d(18): Error: found `number` when expecting `.` following\
    \ long\\n/tmp/tmpw0fx678_.d(18): Error: found `,` when expecting identifier following\
    \ `long`.\\n/tmp/tmpw0fx678_.d(18): Error: found `string` when expecting `,`\\\
    n/tmp/tmpw0fx678_.d(18): Error: found `five` when expecting `,`\\n/tmp/tmpw0fx678_.d(18):\
    \ Error: expression expected, not `,`\\n/tmp/tmpw0fx678_.d(18): Error: found `string`\
    \ when expecting `,`\\n/tmp/tmpw0fx678_.d(18): Error: semicolon expected following\
    \ auto declaration, not `{`\\n/tmp/tmpw0fx678_.d(29): Deprecation: use `{ }` for\
    \ an empty statement, not `;`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpw0fx678_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple('i', 'v', 'x'),\n \
    \       tuple('x', 'l', 'c'),\n        tuple('c', 'd', 'm'),\n        tuple('m',\
    \ 'v', 'x')\n    );\n    foreach (i, roman_tuple; roman_numerals)\n    {\n   \
    \     auto ones = number % 10;\n        number /= 10;\n        auto ones_roman\
    \ = \"\";\n        if (ones == 9)\n            ones_roman = roman_tuple[0] ~ roman_tuple[2];\n\
    \        else if (ones == 4)\n            ones_roman = roman_tuple[0] ~ roman_tuple[1];\n\
    \        else\n        {\n            if (ones >= 5)\n                ones_roman\
    \ ~= roman_tuple[1];\n            ones_roman ~= roman_tuple[0] * (ones % 5);\n\
    \        }\n        result = ones_roman ~ result;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp62r5d6ff.d(30): Error: incompatible types for `(cast(int)roman_tuple.__expand_field_0)\
    \ ~ (cast(int)roman_tuple.__expand_field_2)`: both operands are of type `int`\\\
    n/tmp/tmp62r5d6ff.d(32): Error: incompatible types for `(cast(int)roman_tuple.__expand_field_0)\
    \ ~ (cast(int)roman_tuple.__expand_field_1)`: both operands are of type `int`\\\
    n/tmp/tmp62r5d6ff.d(37): Error: cannot append type `long` to type `string`\\n/tmp/tmp62r5d6ff.d(30):\
    \ Error: incompatible types for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_2)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(32): Error: incompatible\
    \ types for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(37): Error: cannot append\
    \ type `long` to type `string`\\n/tmp/tmp62r5d6ff.d(30): Error: incompatible types\
    \ for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_2)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(32): Error: incompatible\
    \ types for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(37): Error: cannot append\
    \ type `long` to type `string`\\n/tmp/tmp62r5d6ff.d(30): Error: incompatible types\
    \ for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_2)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(32): Error: incompatible\
    \ types for `(cast(int)roman_tuple.__expand_field_0) ~ (cast(int)roman_tuple.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmp62r5d6ff.d(37): Error: cannot append\
    \ type `long` to type `string`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp62r5d6ff.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 3,\
    \ 2, 1, 2, 3, 4, 2];\n    static const int[] subtracts = [0, 0, 0, 0, 1, 0, 1,\
    \ 0, 0, 0];\n    static const int[] subtracts_value = [0, 0, 0, 0, 4, 0, 9, 0,\
    \ 0, 0];\n    static const int[] subtracts_index = [0, 0, 0, 0, 1, 0, 2, 0, 0,\
    \ 0];\n    static const int[] adds = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n    static\
    \ const int[] adds_value = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n    static const int[]\
    \ adds_index = [0, 0, 0, 0, 0, 0, 0, 0, 0, 2];\n    static const int[] repeats\
    \ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    static const int[] repeats_value = [0,\
    \ 0, 0, 0, 0, 0, 0, 0, 0, 0];\n    static const int[] repeats_index = [0, 0, 0,\
    \ 0, 0, 0, 0, 0, 0, 0];\n    static const int[] repeats_count = [0, 0, 0, 0, 0,\
    \ 0, 0, 0, 0, 0];\n    static const int[] repeats_max = [0, 0, 0, 0, 0, 0, 0,\
    \ 0, 0, 0];\n    static const int[] repeats_min = [0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    static const int[] repeats_min_count = [0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    static const int[] repeats_max_count = [0, 0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0];\n    static const\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpar7k66c_.d(35): Error: basic type expected, not `unittest`\\\
    n/tmp/tmpar7k66c_.d(35): Error: no identifier for declarator `_error_`\\n/tmp/tmpar7k66c_.d(35):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpar7k66c_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\n \
    \   {\n        while(number >= values[i])\n        {\n            result ~= numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.algorithm : map;\n    import std.range : iota;\n    import std.conv : to;\n\
    \    import std.array : array;\n    import std.string : join;\n    import std.typecons\
    \ : tuple;\n    import std.math : div;\n    import std.typecons : tuple;\n   \
    \ import std.range : iota;\n    import std.algorithm : map;\n    import std.conv\
    \ : to;\n    import std.array : array;\n    import std.string : join;\n    import\
    \ std.typecons : tuple;\n    import std.math : div;\n    import std.typecons :\
    \ tuple;\n    import std.range : iota;\n    import std.algorithm : map;\n    import\
    \ std.conv : to;\n    import std.array : array;\n    import std.string : join;\n\
    \    import std.typecons : tuple;\n    import std.math : div;\n    import std.typecons\
    \ : tuple;\n    import std.range : iota;\n    import std.algorithm : map;\n  \
    \  import std.conv : to;\n    import std.array : array;\n    import std.string\
    \ : join;\n    import std.typecons : tuple;\n    import std.math : div;\n    import\
    \ std.typecons : tuple;\n    import std.range : iota;\n    import std.algorithm\
    \ : map;\n    import std.conv : to;\n    import std.array : array;\n    import\
    \ std.string : join;\n    import std.typecons : tuple;\n    import std.math :\
    \ div;\n    import std.typecons : tuple;\n    import std.range : iota;\n    import\
    \ std.algorithm : map;\n    import std.conv : to;\n    import std.array : array;\n\
    \    import std.string : join;\n    import std.typecons : tuple;\n    import std.math\
    \ : div;\n    import std.typecons : tuple;\n    import std.range : iota;\n   \
    \ import std.algorithm : map;\n    import std.conv : to;\n    import std.array\
    \ : array;\n    import std.string : join;\n    import std.typecons\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3sqyet74.d(71): Error: `;` expected\\n/tmp/tmp3sqyet74.d(90):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3sqyet74.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long remainder = number;\n    while (remainder > 0) {\n       \
    \ if (remainder >= 1000) {\n            result ~= 'm';\n            remainder\
    \ -= 1000;\n        } else if (remainder >= 900) {\n            result ~= \"cm\"\
    ;\n            remainder -= 900;\n        } else if (remainder >= 500) {\n   \
    \         result ~= 'd';\n            remainder -= 500;\n        } else if (remainder\
    \ >= 400) {\n            result ~= \"cd\";\n            remainder -= 400;\n  \
    \      } else if (remainder >= 100) {\n            result ~= 'c';\n          \
    \  remainder -= 100;\n        } else if (remainder >= 90) {\n            result\
    \ ~= \"xc\";\n            remainder -= 90;\n        } else if (remainder >= 50)\
    \ {\n            result ~= 'l';\n            remainder -= 50;\n        } else\
    \ if (remainder >= 40) {\n            result ~= \"xl\";\n            remainder\
    \ -= 40;\n        } else if (remainder >= 10) {\n            result ~= 'x';\n\
    \            remainder -= 10;\n        } else if (remainder >= 9) {\n        \
    \    result ~= \"ix\";\n            remainder -= 9;\n        } else if (remainder\
    \ >= 5) {\n            result ~= 'v';\n            remainder -= 5;\n        }\
    \ else if (remainder >= 4) {\n            result ~= \"iv\";\n            remainder\
    \ -= 4;\n        } else if (remainder >= 1) {\n            result ~= 'i';\n  \
    \          remainder -= 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement me\n    return \"\";\n}\n/*\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6jdnwdgz.d(20): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6jdnwdgz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, roman_numeral; roman)\n    {\n        while(number >= values[i])\n\
    \        {\n            result ~= roman_numeral;\n            number -= values[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.algorithm : map;\n    import std.array : array;\n    import std.conv : to;\n\
    \    import std.range : iota;\n    import std.typecons : tuple;\n    import std.math\
    \ : ceil;\n    import std.string : toLower;\n    import std.typecons : tuple;\n\
    \    import std.algorithm : map;\n    import std.array : array;\n    import std.conv\
    \ : to;\n    import std.range : iota;\n    import std.typecons : tuple;\n    import\
    \ std.math : ceil;\n    import std.string : toLower;\n    import std.typecons\
    \ : tuple;\n    import std.algorithm : map;\n    import std.array : array;\n \
    \   import std.conv : to;\n    import std.range : iota;\n    import std.typecons\
    \ : tuple;\n    import std.math : ceil;\n    import std.string : toLower;\n  \
    \  import std.typecons : tuple;\n    import std.algorithm : map;\n    import std.array\
    \ : array;\n    import std.conv : to;\n    import std.range : iota;\n    import\
    \ std.typecons : tuple;\n    import std.math : ceil;\n    import std.string :\
    \ toLower;\n    import std.typecons : tuple;\n    import std.algorithm : map;\n\
    \    import std.array : array;\n    import std.conv : to;\n    import std.range\
    \ : iota;\n    import std.typecons : tuple;\n    import std.math : ceil;\n   \
    \ import std.string : toLower;\n    import std.typecons : tuple;\n    import std.algorithm\
    \ : map;\n    import std.array : array;\n    import std.conv : to;\n    import\
    \ std.range : iota;\n    import std.typecons : tuple;\n    import std.math : ceil;\n\
    \    import std.string : toLower;\n    import std.typecons : tuple;\n    import\
    \ std.algorithm : map;\n    import std.array : array;\n    import std.conv : to;\n\
    \    import std.range : iota;\n    import std\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphqr5k4mr.d(70): Error: `;` expected\\n/tmp/tmphqr5k4mr.d(89):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphqr5k4mr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman = [ \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\" ];\n    static string[10] roman10 = [ \"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\" ];\n    static\
    \ string[10] roman100 = [ \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\"\
    , \"dcc\", \"dccc\", \"cm\" ];\n    static string[4] roman1000 = [ \"\", \"m\"\
    , \"mm\", \"mmm\" ];\n    string result = \"\";\n    int i = 0;\n    while (number\
    \ > 0)\n    {\n        if (i == 0)\n            result = roman[number % 10] ~\
    \ result;\n        else if (i == 1)\n            result = roman10[number % 10]\
    \ ~ result;\n        else if (i == 2)\n            result = roman100[number %\
    \ 10] ~ result;\n        else if (i == 3)\n            result = roman1000[number\
    \ % 10] ~ result;\n        number /= 10;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement me!\n    return \"\";\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqh7aj8uw.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmpqh7aj8uw.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmpqh7aj8uw.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x86ed6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ assert(1 <= number && number <= 1000);\n    return thousands[number / 1000]\
    \ ~ hundreds[(number / 100) % 10] ~ tens[(number / 10) % 10] ~ ones[number % 10];\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long remainder = number;\n    while (remainder > 0) {\n       \
    \ if (remainder >= 1000) {\n            result ~= 'm';\n            remainder\
    \ -= 1000;\n        } else if (remainder >= 900) {\n            result ~= \"cm\"\
    ;\n            remainder -= 900;\n        } else if (remainder >= 500) {\n   \
    \         result ~= 'd';\n            remainder -= 500;\n        } else if (remainder\
    \ >= 400) {\n            result ~= \"cd\";\n            remainder -= 400;\n  \
    \      } else if (remainder >= 100) {\n            result ~= 'c';\n          \
    \  remainder -= 100;\n        } else if (remainder >= 90) {\n            result\
    \ ~= \"xc\";\n            remainder -= 90;\n        } else if (remainder >= 50)\
    \ {\n            result ~= 'l';\n            remainder -= 50;\n        } else\
    \ if (remainder >= 40) {\n            result ~= \"xl\";\n            remainder\
    \ -= 40;\n        } else if (remainder >= 10) {\n            result ~= 'x';\n\
    \            remainder -= 10;\n        } else if (remainder >= 9) {\n        \
    \    result ~= \"ix\";\n            remainder -= 9;\n        } else if (remainder\
    \ >= 5) {\n            result ~= 'v';\n            remainder -= 5;\n        }\
    \ else if (remainder >= 4) {\n            result ~= \"iv\";\n            remainder\
    \ -= 4;\n        } else if (remainder >= 1) {\n            result ~= 'i';\n  \
    \          remainder -= 1;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto digits = to!string(number);\n    auto len = digits.length;\n\
    \    for (int i = 0; i < len; i++)\n    {\n        auto digit = digits[i];\n \
    \       if (digit == '0')\n            continue;\n        auto power = len - i\
    \ - 1;\n        auto base = pow(10, power);\n        auto num = to!long(digit)\
    \ * base;\n        result ~= int_to_mini_roman_helper(num);\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvb4poy83.d(18): Error: template instance `to!string` template\
    \ `to` is not defined, did you mean No?\\n/tmp/tmpvb4poy83.d(27): Error: template\
    \ instance `to!long` template `to` is not defined, did you mean No?\\n/tmp/tmpvb4poy83.d(28):\
    \ Error: undefined identifier `int_to_mini_roman_helper`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpvb4poy83.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    enum roman_numeral_t {\n        I = 1,\n        V = 5,\n      \
    \  X = 10,\n        L = 50,\n        C = 100,\n        D = 500,\n        M = 1000\n\
    \    }\n    static immutable roman_numeral_t[] roman_numerals = [\n        I,\
    \ V, X, L, C, D, M\n    ];\n    static immutable string[] roman_numeral_strings\
    \ = [\n        \"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"\n    ];\n    static\
    \ immutable int[] roman_numeral_values = [\n        1, 5, 10, 50, 100, 500, 1000\n\
    \    ];\n    static immutable int[] roman_numeral_subtractors = [\n        0,\
    \ 0, 1, 10, 100, 500, 1000\n    ];\n    static immutable int[] roman_numeral_multipliers\
    \ = [\n        1, 1, 10, 100, 1000, 10000, 100000\n    ];\n    static immutable\
    \ int[] roman_numeral_divisors = [\n        1, 1, 5, 10, 50, 100, 500\n    ];\n\
    \    static immutable int[] roman_numeral_addends = [\n        0, 0, 1, 10, 100,\
    \ 500, 1000\n    ];\n    static immutable int[] roman_numeral_maxima = [\n   \
    \     3, 1, 3, 1, 3, 1, 3\n    ];\n    static immutable int[] roman_numeral_minima\
    \ = [\n        0, 0, 0, 0, 0, 0, 0\n    ];\n    static immutable int[] roman_numeral_maxima_subtractors\
    \ = [\n        0, 0, 1, 10, 100, 500, 1000\n    ];\n    static immutable int[]\
    \ roman_numeral_minima_addends = [\n        0, 0, 1, 10, 100, 500, 1000\n    ];\n\
    \    static immutable int[] roman_numeral_maxima_addends = [\n        0, 0, 1,\
    \ 10, 100, 500, 1000\n    ];\n    static immutable int[] roman_numeral_minima_subt\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8aoea7n9.d(64): Error: semicolon expected, not `unittest`\\n/tmp/tmp8aoea7n9.d(64):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp8aoea7n9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ivxlcdm\";\n    static int[] values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static int[] divisors = [1, 10, 100,\
    \ 1000];\n    static int[] multipliers = [1, 10, 100, 1000];\n    static int[]\
    \ roman_multipliers = [1, 2, 3, 4, 5, 6, 7];\n    static int[] roman_divisors\
    \ = [1, 2, 3, 4, 5, 6, 7];\n    static int[] roman_values = [1, 5, 10, 50, 100,\
    \ 500, 1000];\n    static int[] roman_numerals_length = [1, 1, 1, 1, 1, 1, 1];\n\
    \    static int[] roman_numerals_length_multipliers = [1, 2, 3, 4, 5, 6, 7];\n\
    \    static int[] roman_numerals_length_divisors = [1, 2, 3, 4, 5, 6, 7];\n  \
    \  static int[] roman_numerals_length_values = [1, 5, 10, 50, 100, 500, 1000];\n\
    \    static int[] roman_numerals_length_values_multipliers = [1, 2, 3, 4, 5, 6,\
    \ 7];\n    static int[] roman_numerals_length_values_divisors = [1, 2, 3, 4, 5,\
    \ 6, 7];\n    static int[] roman_numerals_length_values_numerals = [1, 1, 1, 1,\
    \ 1, 1, 1];\n    static int[] roman_numerals_length_values_numerals_multipliers\
    \ = [1, 2, 3, 4, 5, 6, 7];\n    static int[] roman_numerals_length_values_numerals_divisors\
    \ = [1, 2, 3, 4, 5, 6, 7];\n    static int[] roman_numerals_length_values_numerals_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static int[] roman_n\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvpjw0kq3.d(36): Error: semicolon expected, not `unittest`\\n/tmp/tmpvpjw0kq3.d(36):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpvpjw0kq3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 0, 1, 2,\
    \ 2, 2, 3, 3, 3, 4];\n    static const int[] subtractors = [0, 0, 0, 0, 1, 2,\
    \ 2, 2, 3, 4];\n    static const int[] multipliers = [0, 0, 0, 0, 0, 0, 0, 0,\
    \ 0, 1];\n    static const int[] divisors = [0, 0, 0, 0, 0, 0, 0, 0, 0, 10];\n\
    \    static const int[] subtractor_values = [0, 0, 0, 0, 1, 10, 10, 10, 100, 1000];\n\
    \    static const int[] multiplier_values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 10];\n\
    \    static const int[] divisor_values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 10];\n  \
    \  static const int[] subtractor_indexes = [0, 0, 0, 0, 1, 2, 2, 2, 3, 4];\n \
    \   static const int[] multiplier_indexes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\
    \    static const int[] divisor_indexes = [0, 0, 0, 0, 0, 0, 0, 0, 0, 2];\n  \
    \  static const int[] subtractor_multipliers = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1];\n\
    \    static const int[] multiplier_multipliers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\
    \    static const int[] divisor_multipliers = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1];\n\
    \    static const int[] subtractor_divisors = [0, 0, 0, 0, 1, 1, 1, 1, 1, 1];\n\
    \    static const int[] multiplier_divisors = [0, 0, 0, 0\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp32codvpj.d(34): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmp32codvpj.d(35): Error: semicolon expected, not `{`\\\
    n/tmp/tmp32codvpj.d(53): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp32codvpj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ struct RomanNumeral \n    {\n        int value;\n        string numeral;\n \
    \   }\n    romanNumerals[] = \n    [\n        RomanNumeral(1000, \"m\"),\n   \
    \     RomanNumeral(900, \"cm\"),\n        RomanNumeral(500, \"d\"),\n        RomanNumeral(400,\
    \ \"cd\"),\n        RomanNumeral(100, \"c\"),\n        RomanNumeral(90, \"xc\"\
    ),\n        RomanNumeral(50, \"l\"),\n        RomanNumeral(40, \"xl\"),\n    \
    \    RomanNumeral(10, \"x\"),\n        RomanNumeral(9, \"ix\"),\n        RomanNumeral(5,\
    \ \"v\"),\n        RomanNumeral(4, \"iv\"),\n        RomanNumeral(1, \"i\")\n\
    \    ];\n    string result;\n    foreach(RomanNumeral romanNumeral; romanNumerals)\
    \ \n    {\n        while(number >= romanNumeral.value) \n        {\n         \
    \   result ~= romanNumeral.numeral;\n            number -= romanNumeral.value;\n\
    \        }\n    }\n    return result;\n}\n/*\n    Given a positive integer, obtain\
    \ its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 3999\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2gpfb_4.d(49): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps2gpfb_4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman = [\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman10 =\
    \ [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman100 = [\"\", \"c\", \"cc\", \"ccc\", \"cd\"\
    , \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman1000 =\
    \ [\"\", \"m\", \"mm\", \"mmm\"];\n    if (number < 1 || number > 1000)\n    \
    \    return \"\";\n    if (number >= 1000)\n    {\n        result ~= roman1000[number\
    \ / 1000];\n        number %= 1000;\n    }\n    if (number >= 100)\n    {\n  \
    \      result ~= roman100[number / 100];\n        number %= 100;\n    }\n    if\
    \ (number >= 10)\n    {\n        result ~= roman10[number / 10];\n        number\
    \ %= 10;\n    }\n    result ~= roman[number];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_digits = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] arabic_digits\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, roman_digit; roman_digits)\n    {\n        while(number\
    \ >= arabic_digits[i])\n        {\n            result ~= roman_digit;\n      \
    \      number -= arabic_digits[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    if (number < 1 || number > 1000)\n        return result;\n    //\n\
    \    //  Roman Numerals\n    //  I = 1, V = 5, X = 10, L = 50, C = 100, D = 500,\
    \ M = 1000\n    //\n    //  Roman Numeral Rules\n    //  1. If a symbol appears\
    \ after a larger (or equal) symbol it is added\n    //  2. If a symbol appears\
    \ before a larger symbol it is subtracted\n    //  3. Only one smaller symbol\
    \ may be subtracted from any larger symbol\n    //  4. The symbols \"I\", \"X\"\
    , and \"C\" are used to make 4 and 9\n    //  5. The symbols \"X\", \"L\", and\
    \ \"C\" are used to make 40 and 90\n    //  6. The symbols \"C\", \"D\", and \"\
    M\" are used to make 400 and 900\n    //\n    //  Roman Numeral Symbols\n    //\
    \  1 = I, 2 = II, 3 = III, 4 = IV, 5 = V, 6 = VI, 7 = VII, 8 = VIII, 9 = IX\n\
    \    //  10 = X, 20 = XX, 30 = XXX, 40 = XL, 50 = L, 60 = LX, 70 = LXX, 80 = LXXX,\
    \ 90 = XC\n    //  100 = C, 200 = CC, 300 = CCC, 400 = CD, 500 = D, 600 = DC,\
    \ 700 = DCC, 800 = DCCC, 900 = CM\n    //  1000 = M, 2000 = MM, 3000 = MMM\n \
    \   //\n    //  Roman Numeral Symbols (in order of precedence)\n    //  M = 1000,\
    \ CM = 900, D = 500, CD = 400, C = 100, XC = 90, L = 50, XL = 40, X = 10, IX =\
    \ 9, V = 5, IV = 4, I = 1\n    //\n    //  Roman Numeral Symbols (in order of\
    \ precedence)\n    //  M = 1000, D = 500, C = 100, L = 50, X = 10, V = 5, I =\
    \ 1\n    //\n    //  Roman Numeral Symbols (in order of precedence)\n    //  M\
    \ = 1000, CM = 900\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps3tjzn86.d(46): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps3tjzn86.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman; roman_numerals)\n    {\n        while(number >= values[i])\n\
    \        {\n            result ~= roman;\n            number -= values[i];\n \
    \       }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ numbers = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n\
    \    ];\n    string result = \"\";\n    foreach(i, num; numbers)\n    {\n    \
    \    while(number >= num)\n        {\n            result ~= roman_numerals[i];\n\
    \            number -= num;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_tenthousands =\
    \ [\"\", \"xm\", \"xmm\", \"xmmm\"];\n    static string[4] roman_hundredthousands\
    \ = [\"\", \"cm\", \"cmm\", \"cmmm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tenmillions =\
    \ [\"\", \"xmm\", \"xmmm\", \"xmmmm\"];\n    static string[4] roman_hundredmillions\
    \ = [\"\", \"cmm\", \"cmmm\", \"cmmmm\"];\n    static string[4] roman_billions\
    \ = [\"\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tenbillions\
    \ = [\"\", \"xmm\", \"xmmm\", \"xmmmm\"];\n    static string[4] roman_hundredbillions\
    \ = [\"\", \"cmm\", \"cmmm\", \"cmmmm\"];\n    static string[4] roman_trillions\
    \ = [\"\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_tentrillions\
    \ = [\"\", \"xmm\", \"xmmm\", \"xmmmm\"];\n    static string[4] roman_hundredtrillions\
    \ = [\"\", \"cmm\", \"cmmm\", \"cmmmm\"];\n    static string[4] roman_quadrillions\
    \ = [\"\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] r\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cd_al2q.d(34): Error: semicolon expected, not `unittest`\\n/tmp/tmp5cd_al2q.d(34):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5cd_al2q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 3,\
    \ 2, 1, 2, 3, 4, 2];\n    static const int[] subtractors = [0, 2, 2, 2, 1, 2,\
    \ 2, 2, 1, 2];\n    static const int[] subtractor_values = [0, 1, 10, 100, 1000];\n\
    \    static const string[] roman_digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static const string[] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static const string[] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\"\
    , \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static const string[]\
    \ roman_thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n    static const string[]\
    \ roman_tenthousands = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static const string[]\
    \ roman_hundredthousands = [\"\", \"cm\", \"ccm\", \"cccm\"];\n    static const\
    \ string[] roman_millions = [\"\", \"m\", \"mm\", \"mmm\"];\n    static const\
    \ string[] roman_tenmillions = [\"\", \"xm\", \"xxm\", \"xxxm\"];\n    static\
    \ const string[] roman_hundredmillions = [\"\", \"cm\", \"ccm\", \"cccm\"];\n\
    \    static const string[] roman_billions = [\"\", \"m\", \"mm\", \"mmm\"];\n\
    \    static const string[] roman_tenbillions = [\"\", \"xm\", \"xxm\", \"xxxm\"\
    ];\n    static const string[] roman_hundredbillions = [\"\", \"cm\", \"ccm\",\
    \ \"cccm\"];\n    static const string[] roman_trillions\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxawud0ja.d(35): Error: semicolon expected, not `unittest`\\n/tmp/tmpxawud0ja.d(35):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxawud0ja.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500,\
    \ 900, 1000];\n    static string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"\
    x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    int i =\
    \ values.length - 1;\n    while (number > 0) {\n        if (number >= values[i])\
    \ {\n            result ~= numerals[i];\n            number -= values[i];\n  \
    \      } else {\n            i--;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcvgywij2.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcvgywij2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] roman10 = [\"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ roman100 = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] roman1000 = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    if (number >= 1000)\n    {\n        result\
    \ ~= roman1000[number / 1000];\n        number %= 1000;\n    }\n    if (number\
    \ >= 100)\n    {\n        result ~= roman100[number / 100];\n        number %=\
    \ 100;\n    }\n    if (number >= 10)\n    {\n        result ~= roman10[number\
    \ / 10];\n        number %= 10;\n    }\n    if (number >= 1)\n    {\n        result\
    \ ~= roman[number];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"\",\
    \ \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenmillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredmillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredbillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tentrillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_h\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt4243az2.d(60): Error: semicolon expected, not `unittest`\\n/tmp/tmpt4243az2.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpt4243az2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, romanNumeral; arabic)\n    {\n        while(number >= romanNumeral)\n\
    \        {\n            result ~= roman[i];\n            number -= romanNumeral;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    for (int i = 0; i\
    \ < values.length; i++) \n    {\n        while (number >= values[i]) \n      \
    \  {\n            result ~= numerals[i];\n            number -= values[i];\n \
    \       }\n    }\n    return result;\n}\n/*\n    Given a string, return a new\
    \ string with the reversed order of characters.\n    Restrictions: 1 <= str.length\
    \ <= 1000\n    \n    Examples:\n    >>> reverse_string(\"Hello World!\") == \"\
    !dlroW olleH\"\n    >>> reverse_string(\"\") == \"\"\n    >>> reverse_string(\"\
    a\") == \"a\"\n    >>> reverse_string(\"ab\") == \"ba\"\n    >>> reverse_string(\"\
    abc\") == \"cba\"\n*/\nstring reverse_string(string str) \n{\n    string result;\n\
    \    for (int i = str.length - 1; i >= 0; i--) \n    {\n        result ~= str[i];\n\
    \    }\n    return result;\n}\n/*\n    Given an array of integers, return a new\
    \ array such that each element at index i of the new array\n    is the product\
    \ of all the numbers in the original array except the one at i.\n    Restrictions:\
    \ 1 <= nums.length <= 1000\n    \n    Examples:\n    >>> product_of_others([1,\
    \ 2, 3, 4, 5]) == [120, 60, 40, 30, 24]\n    >>> product_of_others([3, 2, 1])\
    \ == [2, 3, 6]\n*/\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgncb1bqd.d(44): Error: cannot implicitly convert expression `str.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpgncb1bqd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) \n    {\n  \
    \      int div = number / values[i];\n        number %= values[i];\n        while\
    \ (div-- > 0)\n            result ~= numerals[i];\n        --i;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd5ed55m0.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpd5ed55m0.d(23): Error: cannot implicitly\
    \ convert expression `number / cast(long)values[cast(ulong)i]` of type `long`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd5ed55m0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, romanDigit; roman) \n    {\n        while(number >= arabic[i]) \n\
    \        {\n            number -= arabic[i];\n            result ~= romanDigit;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ roman;\n    static int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10,\
    \ 9, 5, 4, 1];\n    static string[] numerals = [\"m\", \"cm\", \"d\", \"cd\",\
    \ \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    foreach(i,\
    \ numeral; zip(values, numerals))\n    {\n        while(number >= i[0])\n    \
    \    {\n            roman ~= i[1];\n            number -= i[0];\n        }\n \
    \   }\n    return roman;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpndx1yv7r.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpndx1yv7r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"xm\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf3pl__u6.d(56): Error: unterminated string constant starting\
    \ at /tmp/tmpf3pl__u6.d(75)\\n/tmp/tmpf3pl__u6.d(62): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpf3pl__u6.d(62): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpf3pl__u6.d(63):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(64):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(65):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(66):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpf3pl__u6.d(67):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(68):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(69):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(70):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(71):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(72):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(73):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(74):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(75):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(77):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpf3pl__u6.d(77):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf3pl__u6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_values = [1, 10, 100];\n\
    \    static const int[] roman_subtractor_indices = [0, 2, 4];\n    static const\
    \ int[] roman_subtractor_multipliers = [1, 1, 10];\n    static const int[] roman_subtractor_multiplier_indices\
    \ = [0, 2, 4];\n    static const int[] roman_subtractor_multiplier_values = [1,\
    \ 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractors =\
    \ [1, 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractor_indices\
    \ = [0, 2, 4];\n    static const int[] roman_subtractor_multiplier_subtractor_values\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractor_multipliers\
    \ = [1, 1, 10];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_indices\
    \ = [0, 2, 4];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_values\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_subtractors\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_subtractor_indices\
    \ = [0, 2, 4];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_subtractor_values\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_multiplier_subtractor_multiplier_subtractor_multipliers\
    \ = [1, 1,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9xwkabke.d(35): Error: expression expected, not `unittest`\\\
    n/tmp/tmp9xwkabke.d(36): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmp9xwkabke.d(54): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmp9xwkabke.d(54): Error: semicolon expected, not `main`\\\
    n/tmp/tmp9xwkabke.d(54): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9xwkabke.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_tenthousands = [\n        \"\",\
    \ \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredthousands\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenmillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredmillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tenbillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_hundredbillions\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_tentrillions\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\"\n    ];\n    static string[4] roman_h\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnrfr_k1s.d(60): Error: semicolon expected, not `unittest`\\n/tmp/tmpnrfr_k1s.d(60):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnrfr_k1s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    assert(number > 0 && number <= 1000);\n\
    \    return roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10]\
    \ ~ roman_tens[(number / 10) % 10] ~ roman_numerals[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    string result\
    \ = \"\";\n    result ~= roman_thousands[number / 1000];\n    number %= 1000;\n\
    \    result ~= roman_hundreds[number / 100];\n    number %= 100;\n    result ~=\
    \ roman_tens[number / 10];\n    number %= 10;\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.algorithm;\n    import std.range;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.string;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.string;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.string;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.string;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.string;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.array;\n    import std.typecons;\n    import std.math;\n    import\
    \ std.string;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.array;\n    import std.typecons;\n\
    \    import std.math;\n    import std.string;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.array;\n    import std.typecons;\n    import\
    \ std.math;\n    import std.string;\n    import std.range;\n    import std.algorithm;\n\
    \    import std\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n   \
    \ assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\");\n\
    \    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\"\
    );\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) == \"i\");\n\
    \    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) == \"xliii\"\
    );\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L) == \"xciv\"\
    );\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L) ==\
    \ \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqt6zem2k.d(87): Error: `;` expected\\n/tmp/tmpqt6zem2k.d(106):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqt6zem2k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    foreach(i; reverse(iota(values.length)))\n    {\n        while(number\
    \ >= values[i])\n        {\n            result ~= numerals[i];\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptacps1tr.d(20): Error: undefined identifier `iota`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptacps1tr.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        int\
    \ v = values[i];\n        if (number >= v) {\n            result ~= numerals[i];\n\
    \            number -= v;\n        } else {\n            --i;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp38c7n4p9.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp38c7n4p9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ivxlcdm\";\n    static int[] values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    int index = roman_numerals.length - 1;\n\
    \    while (number > 0) \n    {\n        int value = values[index];\n        int\
    \ count = number / value;\n        number %= value;\n        if (count < 4) \n\
    \        {\n            result ~= roman_numerals[index].repeat(count);\n     \
    \   } \n        else if (count == 4) \n        {\n            result ~= roman_numerals[index]\
    \ ~ roman_numerals[index + 1];\n        } \n        else if (count == 5) \n  \
    \      {\n            result ~= roman_numerals[index + 1];\n        } \n     \
    \   else if (count < 9) \n        {\n            result ~= roman_numerals[index\
    \ + 1] ~ roman_numerals[index].repeat(count - 5);\n        } \n        else if\
    \ (count == 9) \n        {\n            result ~= roman_numerals[index] ~ roman_numerals[index\
    \ + 2];\n        }\n        index -= 2;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv7sjwnbq.d(20): Error: cannot implicitly convert expression `roman_numerals.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpv7sjwnbq.d(24): Error: cannot implicitly\
    \ convert expression `number / cast(long)value` of type `long` to `int`\\n/tmp/tmpv7sjwnbq.d(28):\
    \ Error: no property `repeat` for type `immutable(char)`\\n/tmp/tmpv7sjwnbq.d(32):\
    \ Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)index]) ~\
    \ (cast(int)roman_numerals[cast(ulong)(index + 1)])`: both operands are of type\
    \ `int`\\n/tmp/tmpv7sjwnbq.d(40): Error: no property `repeat` for type `immutable(char)`\\\
    n/tmp/tmpv7sjwnbq.d(44): Error: incompatible types for `(cast(int)roman_numerals[cast(ulong)index])\
    \ ~ (cast(int)roman_numerals[cast(ulong)(index + 2)])`: both operands are of type\
    \ `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv7sjwnbq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    int thousands = cast(int)(number / 1000);\n\
    \    int hundreds = cast(int)((number % 1000) / 100);\n    int tens = cast(int)((number\
    \ % 100) / 10);\n    int ones = cast(int)(number % 10);\n    result ~= roman_thousands[thousands];\n\
    \    result ~= roman_hundreds[hundreds];\n    result ~= roman_tens[tens];\n  \
    \  result ~= roman_numerals[ones];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    static string[4] roman_ten_thousands\
    \ = [\"\", \"xm\", \"xmm\", \"xmmm\"];\n    static string[4] roman_hundred_thousands\
    \ = [\"\", \"cm\", \"cmm\", \"cmmm\"];\n    static string[4] roman_millions =\
    \ [\"\", \"mm\", \"mmm\", \"mmmm\"];\n    static string[4] roman_ten_millions\
    \ = [\"\", \"xmm\", \"xmmm\", \"xmmmm\"];\n    static string[4] roman_hundred_millions\
    \ = [\"\", \"cmm\", \"cmmm\", \"cmmmm\"];\n    static string[4] roman_billions\
    \ = [\"\", \"mmm\", \"mmmm\", \"mmmmm\"];\n    static string[4] roman_ten_billions\
    \ = [\"\", \"xmmm\", \"xmmmm\", \"xmmmmm\"];\n    static string[4] roman_hundred_billions\
    \ = [\"\", \"cmmm\", \"cmmmm\", \"cmmmmm\"];\n    static string[4] roman_trillions\
    \ = [\"\", \"mmmm\", \"mmmmm\", \"mmmmmm\"];\n    static string[4] roman_ten_trillions\
    \ = [\"\", \"xmmmm\", \"xmmmmm\", \"xmmmmmm\"];\n    static string[4] roman_hundred_trillions\
    \ = [\"\", \"cmmmm\", \"cmmmmm\", \"cmmmmmm\"];\n    static string[4] roman_quadrillion\
    \ = [\"\", \"mm\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n   \
    \ assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\");\n\
    \    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\"\
    );\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) == \"i\");\n\
    \    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) == \"xliii\"\
    );\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L) == \"xciv\"\
    );\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L) ==\
    \ \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptlta9u5m.d(32): Error: unterminated string constant starting\
    \ at /tmp/tmptlta9u5m.d(50)\\n/tmp/tmptlta9u5m.d(37): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmptlta9u5m.d(37): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmptlta9u5m.d(38):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(39):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(40):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(41):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmptlta9u5m.d(42):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(43):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(44):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(45):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(46):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(47):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(48):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(49):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(50):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(52):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmptlta9u5m.d(52):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptlta9u5m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"\n    ];\n    static int[]\
    \ values = [\n        1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000\n \
    \   ];\n    string result = \"\";\n    while (number > 0) {\n        int index\
    \ = lower_bound(values, number);\n        result ~= roman_numerals[index];\n \
    \       number -= values[index];\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1i_79vp8.d(25): Error: undefined identifier `lower_bound`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1i_79vp8.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[] roman_tens =\
    \ [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[] roman_hundreds = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    string\
    \ result = \"\";\n    if (number >= 1000) {\n        result ~= roman_thousands[number\
    \ / 1000 - 1];\n        number %= 1000;\n    }\n    if (number >= 100) {\n   \
    \     result ~= roman_hundreds[number / 100 - 1];\n        number %= 100;\n  \
    \  }\n    if (number >= 10) {\n        result ~= roman_tens[number / 10 - 1];\n\
    \        number %= 10;\n    }\n    if (number > 0) {\n        result ~= roman_numerals[number\
    \ - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, numeral; arabic_numerals) \n    {\n        while(number\
    \ >= numeral) \n        {\n            result ~= roman_numerals[i];\n        \
    \    number -= numeral;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400,\
    \ 500, 900, 1000];\n    static const string[] numerals = [\"i\", \"iv\", \"v\"\
    , \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n\
    \    int i = values.length - 1;\n    while (number > 0) \n    {\n        int div\
    \ = number / values[i];\n        number %= values[i];\n        while (div-- >\
    \ 0) \n        {\n            result ~= numerals[i];\n        }\n        --i;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvqvutn9b.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpvqvutn9b.d(23): Error: cannot implicitly\
    \ convert expression `number / cast(long)values[cast(ulong)i]` of type `long`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvqvutn9b.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\n   \
    \ {\n        while(number >= values[i])\n        {\n            result ~= roman;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_digits = \"ivxlcdm\";\n    static const int[] values = [1,\
    \ 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 2, 2,\
    \ 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9];\n    static\
    \ const int[] offsets = [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5,\
    \ 6, 6, 6, 7, 7, 7, 8, 8, 8];\n    static const int[] multipliers = [1, 10, 100,\
    \ 1000];\n    static const int[] divisors = [1, 2, 2, 5, 5];\n    static const\
    \ int[] powers = [1, 10, 100, 1000];\n    static const int[] powers_of_ten = [1,\
    \ 10, 100, 1000];\n    static const int[] powers_of_five = [1, 5, 25, 125, 625];\n\
    \    static const int[] powers_of_two = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512,\
    \ 1024];\n    static const int[] powers_of_two_minus_one = [1, 3, 7, 15, 31, 63,\
    \ 127, 255, 511, 1023];\n    static const int[] powers_of_two_plus_one = [3, 5,\
    \ 9, 17, 33, 65, 129, 257, 513, 1025];\n    static const int[] powers_of_two_times_three\
    \ = [3, 6, 12, 24, 48, 96, 192, 384, 768, 1536];\n    static const int[] powers_of_two_times_five\
    \ = [5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560];\n    static const int[] powers_of_two_times_seven\
    \ = [7, 14, 28, 56, 112, 224, 448, 896, 1792, 3584];\n    static const int[] powers_of_two_times_nine\
    \ =\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1h295m4n.d(33): Error: expression expected, not `unittest`\\\
    n/tmp/tmp1h295m4n.d(34): Error: semicolon expected, not `{`\\n/tmp/tmp1h295m4n.d(52):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1h295m4n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv : to;\n    import std.algorithm : map;\n    import std.range : iota;\n\
    \    import std.array : array;\n    import std.range : retro;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tupleOf;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tupleOf;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tupleOf;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tupleOf;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tupleOf;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tupleOf;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tupleOf;\n    import std.typecons\
    \ : tuple;\n    import std.typecons : Tuple;\n    import std.typecons : tupleOf;\n\
    \    import std.typecons : tuple;\n    import std.typecons : Tuple;\n    import\
    \ std.typecons : tupleOf;\n    import std.typecons : tuple;\n    import std.typecons\
    \ : Tuple;\n    import std.typecons : tupleOf;\n    import std.typecons : tuple;\n\
    \    import std.typecons : Tuple;\n    import std.typecons : tupleOf;\n    import\
    \ std.typecons : tuple;\n    import std.typecons : Tuple;\n    import std.typecons\
    \ : tupleOf;\n    import std.typecons : tuple;\n    import std.typecons : Tuple;\n\
    \    import std.typecons : tupleOf;\n    import std.typecons : tuple;\n    import\
    \ std.typecons : Tuple;\n    import std.typecons : tupleOf;\n    import std.typecons\
    \ : tuple;\n    import std.\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmy2trt1k.d(66): Error: identifier expected following `package`\\\
    n/tmp/tmpmy2trt1k.d(66): Error: `;` expected\\n/tmp/tmpmy2trt1k.d(85): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmy2trt1k.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] bases = [1, 10, 100,\
    \ 1000];\n    string result;\n    foreach (base; bases) \n    {\n        int digit\
    \ = (number / base) % 10;\n        if (digit == 0) continue;\n        int index\
    \ = 2 * (digit - 1);\n        if (digit == 4 || digit == 9) index++;\n       \
    \ result ~= roman_numerals[index .. index + 1];\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmptcyv7z0l.d(27): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x4283c6]\\n??:? immutable(char)[] tmptcyv7z0l.int_to_mini_roman(long)\
    \ [0x427c0d]\\n??:? void tmptcyv7z0l.__unittest_L31_C1() [0x427c65]\\n??:? void\
    \ tmptcyv7z0l.__modtest() [0x428098]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cacf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b9de]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430305]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4307b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430291]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b9b5]\\n??:? runModuleUnitTests [0x42c8a5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287d8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42875f]\\n??:? _d_run_main [0x4286ca]\\n??:? main [0x4280ab]\\\
    n??:? __libc_start_main [0x64e2e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[] roman_numerals = [\n        \"m\", \"cm\", \"d\"\
    , \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n\
    \    ];\n    static int[] values = [\n        1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1\n    ];\n    foreach(index, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[index])\n        {\n            result\
    \ ~= roman_numeral;\n            number -= values[index];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, romanDigit; roman)\n    {\n        while(number >= values[i])\n \
    \       {\n            number -= values[i];\n            result ~= romanDigit;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) \n    {\n  \
    \      while (number < values[i]) \n        {\n            i--;\n        }\n \
    \       number -= values[i];\n        result ~= numerals[i];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbapummo5.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpbapummo5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\n/*\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpylsvr0mp.d(35): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpylsvr0mp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\"\
    , \"vi\", \"vii\", \"viii\", \"ix\", \"x\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\", \"c\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\
    c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"\n\
    \    ];\n    static string[10] roman_thousands = [\n        \"m\", \"mm\", \"\
    mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"\n    ];\n    assert(number\
    \ > 0 && number <= 1000);\n    string result = \"\";\n    if (number >= 1000)\
    \ {\n        result ~= roman_thousands[number / 1000];\n        number %= 1000;\n\
    \    }\n    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n\
    \        number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    if (number > 0) {\n        result\
    \ ~= roman_numerals[number];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpirlwmdfp.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4285e9]\\n??:? void tmpirlwmdfp.__unittest_L48_C1()\
    \ [0x427ebc]\\n??:? void tmpirlwmdfp.__modtest() [0x4282b8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cda3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bcb2]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x4305d9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430a88]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430565]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bc89]\\n??:? runModuleUnitTests [0x42cb79]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428aac]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428a33]\\n??:? _d_run_main [0x42899e]\\n??:? main [0x4282cb]\\\
    n??:? __libc_start_main [0x96c56554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, romanNumeral; roman)\n    {\n        while(number >= values[i])\n\
    \        {\n            number -= values[i];\n            result ~= romanNumeral;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_digits = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_digits\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, roman_digit; roman_digits)\n    {\n        while(number\
    \ >= arabic_digits[i])\n        {\n            result ~= roman_digit;\n      \
    \      number -= arabic_digits[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[] numbers\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number\
    \ >= numbers[i])\n        {\n            result ~= roman_numeral;\n          \
    \  number -= numbers[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string roman_numerals = \"ivxlcdm\";\n    static int[] values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    int[] digits = to!(int[])(number.digits);\n\
    \    int place = digits.length - 1;\n    foreach(digit; digits)\n    {\n     \
    \   int value = digit * values[place];\n        if(value == 0)\n        {\n  \
    \          place--;\n            continue;\n        }\n        int index = value.indexOf(values);\n\
    \        if(index == -1)\n        {\n            int closest = value.closest(values);\n\
    \            int diff = value - closest;\n            result ~= roman_numerals[diff.indexOf(values)];\n\
    \            result ~= roman_numerals[closest.indexOf(values)];\n        }\n \
    \       else\n        {\n            if(value == 4 || value == 9)\n          \
    \  {\n                result ~= roman_numerals[index];\n                result\
    \ ~= roman_numerals[index + 1];\n            }\n            else\n           \
    \ {\n                result ~= roman_numerals[index];\n                if(value\
    \ > 5)\n                {\n                    result ~= roman_numerals[index];\n\
    \                }\n            }\n        }\n        place--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt2gl3836.d(20): Error: template instance `to!(int[])` template\
    \ `to` is not defined, did you mean No?\\n/tmp/tmpt2gl3836.d(21): Error: cannot\
    \ implicitly convert expression `digits.length - 1LU` of type `ulong` to `int`\\\
    n/tmp/tmpt2gl3836.d(30): Error: no property `indexOf` for type `int`\\n/tmp/tmpt2gl3836.d(33):\
    \ Error: no property `closest` for type `int`\\n/tmp/tmpt2gl3836.d(35): Error:\
    \ no property `indexOf` for type `int`\\n/tmp/tmpt2gl3836.d(36): Error: no property\
    \ `indexOf` for type `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpt2gl3836.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\"\
    , \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    assert(1 <= number && number <= 1000);\n    return\
    \ roman_thousands[number / 1000] ~ roman_hundreds[(number / 100) % 10] ~ roman_tens[(number\
    \ / 10) % 10] ~ roman_digits[number % 10];\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    int digit;\n    int i = 0;\n    while (number > 0)\n    {\n   \
    \     digit = number % 10;\n        number /= 10;\n        switch (i)\n      \
    \  {\n            case 0:\n                result = repeat(digit, 'i');\n    \
    \            break;\n            case 1:\n                result = repeat(digit,\
    \ 'x') ~ result;\n                break;\n            case 2:\n              \
    \  result = repeat(digit, 'c') ~ result;\n                break;\n           \
    \ case 3:\n                result = repeat(digit, 'm') ~ result;\n           \
    \     break;\n        }\n        i++;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph4gyhez7.d(27): Error: undefined identifier `repeat`\\n/tmp/tmph4gyhez7.d(30):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmph4gyhez7.d(33): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmph4gyhez7.d(36): Error: undefined identifier `repeat`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmph4gyhez7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach (i, v; values) {\n        while (number >= v) {\n            result\
    \ ~= roman[i];\n            number -= v;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    int[] nums = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    string[] romans = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"\
    xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    int index = nums.length - 1;\n\
    \    while (number > 0) \n    {\n        int times = number / nums[index];\n \
    \       number %= nums[index];\n        while (times-- > 0) \n        {\n    \
    \        result ~= romans[index];\n        }\n        index--;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6g3n4a3q.d(20): Error: cannot implicitly convert expression `nums.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp6g3n4a3q.d(23): Error: cannot implicitly\
    \ convert expression `number / cast(long)nums[cast(ulong)index]` of type `long`\
    \ to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6g3n4a3q.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[] decimal = [ 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n  \
    \  foreach(i, r; roman)\n    {\n        while(number >= decimal[i])\n        {\n\
    \            number -= decimal[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number >= 1000) {\n    \
    \    result ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n\
    \    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n \
    \       number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\",\
    \ \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[]\
    \ values = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    foreach(i,\
    \ r; roman)\n    {\n        while(number >= values[i])\n        {\n          \
    \  result ~= r;\n            number -= values[i];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\",\
    \ \"vii\", \"viii\", \"ix\", \"x\"];\n    static string[10] roman_tens = [\"x\"\
    , \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n\
    \    static string[10] roman_hundreds = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_thousands\
    \ = [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\"\
    , \"x\"];\n    static string[10] roman_ten_thousands = [\"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10]\
    \ roman_hundred_thousands = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"\
    dcc\", \"dccc\", \"cm\", \"m\"];\n    static string[10] roman_millions = [\"m\"\
    , \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n\
    \    static string[10] roman_ten_millions = [\"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\", \"c\"];\n    static string[10] roman_hundred_millions\
    \ = [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\
    , \"m\"];\n    static string[10] roman_billions = [\"m\", \"mm\", \"mmm\", \"\
    mv\", \"v\", \"vm\", \"vmm\", \"vmmm\", \"mx\", \"x\"];\n    static string[10]\
    \ roman_ten_billions = [\"x\", \"xx\", \"xxx\",\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr9mtgqz3.d(28): Error: expression expected, not `unittest`\\\
    n/tmp/tmpr9mtgqz3.d(29): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpr9mtgqz3.d(47): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpr9mtgqz3.d(47): Error: semicolon expected, not `main`\\\
    n/tmp/tmpr9mtgqz3.d(47): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr9mtgqz3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    int[] values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1];\n    string[] numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\"\
    , \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    foreach(i, v; values)\n\
    \    {\n        while(number >= v)\n        {\n            result ~= numerals[i];\n\
    \            number -= v;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] arabic_numerals = [1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9];\n    static const string[] roman_numerals_for_arabic_numerals\
    \ = \n        [\"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\"\
    , \"ix\"];\n    static const string[] roman_numerals_for_arabic_numerals_10 =\
    \ \n        [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"];\n    static const string[] roman_numerals_for_arabic_numerals_100 =\
    \ \n        [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\"];\n    static const string[] roman_numerals_for_arabic_numerals_1000\
    \ = \n        [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\"];\n    static const string[] roman_numerals_for_arabic_numerals_10000\
    \ = \n        [\"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"];\n    static const string[] roman_numerals_for_arabic_numerals_100000\
    \ = \n        [\"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\"];\n    static const string[] roman_numerals_for_arabic_numerals_1000000\
    \ = \n        [\"m\", \"mm\", \"mmm\", \"mv\", \"v\", \"vm\", \"vmm\", \"vmmm\"\
    , \"mx\"];\n    static const string[] roman_numerals_for_arabic_\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwohqekgv.d(35): Error: semicolon expected, not `unittest`\\n/tmp/tmpwohqekgv.d(35):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpwohqekgv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numbers = [\"\", \"i\", \"ii\", \"iii\"\
    , \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens\
    \ = [\"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"\
    xc\"];\n    static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\",\
    \ \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    result ~= roman_thousands[number / 1000];\n\
    \    number %= 1000;\n    result ~= roman_hundreds[number / 100];\n    number\
    \ %= 100;\n    result ~= roman_tens[number / 10];\n    number %= 10;\n    result\
    \ ~= roman_numbers[number];\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, numeral; arabic_numerals)\n    {\n        while(number\
    \ >= numeral)\n        {\n            result ~= roman_numerals[i];\n         \
    \   number -= numeral;\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500,\
    \ 900, 1000];\n    static string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"\
    x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    foreach(i;\
    \ 0 .. values.length)\n    {\n        while(number >= values[i])\n        {\n\
    \            result ~= numerals[i];\n            number -= values[i];\n      \
    \  }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1hl09ar0.d(34): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428335]\\n??:? void tmp1hl09ar0.__unittest_L30_C1()\
    \ [0x427cbc]\\n??:? void tmp1hl09ar0.__modtest() [0x4280b8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42caef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b9fe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430325]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4307d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x4302b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b9d5]\\n??:? runModuleUnitTests [0x42c8c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4287f8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42877f]\\n??:? _d_run_main [0x4286ea]\\n??:? main [0x4280cb]\\\
    n??:? __libc_start_main [0x6234a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static immutable int[] values = [1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1];\n    static immutable string[] numerals = [\"m\", \"\
    cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\"\
    , \"i\"];\n    foreach(i, v; values)\n    {\n        while(number >= v)\n    \
    \    {\n            result ~= numerals[i];\n            number -= v;\n       \
    \ }\n    }\n    return result;\n}\n/*\n    Given a positive integer, return the\
    \ number of trailing zeros in its factorial.\n    Restrictions: 1 <= num <= 1000\n\
    \    Examples:\n    >>> trailing_zeros(5) == 1\n    >>> trailing_zeros(10) ==\
    \ 2\n    >>> trailing_zeros(15) == 3\n*/\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static\
    \ long[] values = [1, 5, 10, 50, 100, 500, 1000];\n    static long[] divisors\
    \ = [1, 10, 100, 1000];\n    static long[] divisors_len = [1, 2, 3, 4];\n    static\
    \ long[] divisors_len_sum = [1, 3, 6, 10];\n    static long[] divisors_len_sum_rev\
    \ = [10, 6, 3, 1];\n    static long[] divisors_len_sum_rev_minus_one = [9, 5,\
    \ 2, 0];\n    static long[] divisors_len_sum_rev_minus_two = [8, 4, 1, 0];\n \
    \   static long[] divisors_len_sum_rev_minus_three = [7, 3, 0, 0];\n    static\
    \ long[] divisors_len_sum_rev_minus_four = [6, 2, 0, 0];\n    static long[] divisors_len_sum_rev_minus_five\
    \ = [5, 1, 0, 0];\n    static long[] divisors_len_sum_rev_minus_six = [4, 0, 0,\
    \ 0];\n    static long[] divisors_len_sum_rev_minus_seven = [3, 0, 0, 0];\n  \
    \  static long[] divisors_len_sum_rev_minus_eight = [2, 0, 0, 0];\n    static\
    \ long[] divisors_len_sum_rev_minus_nine = [1, 0, 0, 0];\n    static long[] divisors_len_sum_rev_minus_ten\
    \ = [0, 0, 0, 0];\n    static long[] divisors_len_sum_rev_minus_eleven = [0, 0,\
    \ 0, 0];\n    static long[] divisors_len_sum_rev_minus_twelve = [0, 0, 0, 0];\n\
    \    static long[] divisors_len_sum_rev_minus_thirteen = [0, 0, 0, 0];\n    static\
    \ long[] divis\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgbd6j5eq.d(37): Error: semicolon expected, not `unittest`\\n/tmp/tmpgbd6j5eq.d(37):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpgbd6j5eq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"\
    c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static\
    \ const long[] arabic_numerals = [\n        1000, 900, 500, 400, 100, 90, 50,\
    \ 40, 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ arabic_numerals)\n    {\n        while(number >= numeral)\n        {\n     \
    \       result ~= roman_numerals[i];\n            number -= numeral;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, romanNum; arabic)\n    {\n        while(number >= i)\n        {\n\
    \            result ~= romanNum;\n            number -= i;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc3rnxoqm.d(24): Error: cannot append type `long` to type `string`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc3rnxoqm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    int i = values.length - 1;\n    while (number > 0) {\n        int\
    \ val = values[i];\n        if (number >= val) {\n            result ~= numerals[i];\n\
    \            number -= val;\n        } else {\n            i--;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc2yfa334.d(20): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc2yfa334.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement this function\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmporu2r2ky.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmporu2r2ky.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmporu2r2ky.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x3f662554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    if (number < 1 || number > 1000)\n        return result;\n    auto\
    \ roman_numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\"\
    , \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    auto decimal_numbers = [1, 4, 5,\
    \ 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n    auto i = roman_numerals.length;\n\
    \    while (number > 0)\n    {\n        if (number >= decimal_numbers[i - 1])\n\
    \        {\n            result ~= roman_numerals[i - 1];\n            number -=\
    \ decimal_numbers[i - 1];\n        }\n        else\n            i--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals) {\n\
    \        while(number >= values[i]) {\n            result ~= numeral;\n      \
    \      number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n   \
    \ Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    \    and return it in uppercase.\n    Restrictions: 1 <= num <= 3999\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmparalavng.d(32): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmparalavng.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long remainder = number;\n    while (remainder > 0)\n    {\n  \
    \      if (remainder >= 1000)\n        {\n            result ~= \"m\";\n     \
    \       remainder -= 1000;\n        }\n        else if (remainder >= 900)\n  \
    \      {\n            result ~= \"cm\";\n            remainder -= 900;\n     \
    \   }\n        else if (remainder >= 500)\n        {\n            result ~= \"\
    d\";\n            remainder -= 500;\n        }\n        else if (remainder >=\
    \ 400)\n        {\n            result ~= \"cd\";\n            remainder -= 400;\n\
    \        }\n        else if (remainder >= 100)\n        {\n            result\
    \ ~= \"c\";\n            remainder -= 100;\n        }\n        else if (remainder\
    \ >= 90)\n        {\n            result ~= \"xc\";\n            remainder -= 90;\n\
    \        }\n        else if (remainder >= 50)\n        {\n            result ~=\
    \ \"l\";\n            remainder -= 50;\n        }\n        else if (remainder\
    \ >= 40)\n        {\n            result ~= \"xl\";\n            remainder -= 40;\n\
    \        }\n        else if (remainder >= 10)\n        {\n            result ~=\
    \ \"x\";\n            remainder -= 10;\n        }\n        else if (remainder\
    \ >= 9)\n        {\n            result ~= \"ix\";\n            remainder -= 9;\n\
    \        }\n        else if (remainder >= 5)\n        {\n            result ~=\
    \ \"v\";\n            remainder -= 5;\n        }\n        else if (remainder >=\
    \ 4)\n        {\n            result ~= \"iv\";\n            remainder -= 4;\n\
    \        }\n        else if (remainder >= 1)\n        {\n            result ~=\
    \ \"i\";\n            remainder -= 1;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\",\
    \ \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10]\
    \ hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"\
    ];\n    string result = \"\";\n    result ~= thousands[number / 1000];\n    result\
    \ ~= hundreds[(number % 1000) / 100];\n    result ~= tens[(number % 100) / 10];\n\
    \    result ~= digits[number % 10];\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n        roman_hundreds[(number / 100) % 10] ~\n        roman_tens[(number\
    \ / 10) % 10] ~\n        roman_numerals[number % 10];\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number > 0 && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\
    \ {\n        while(number >= values[i]) {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.math;\n    import std.typecons;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.range;\n\
    \    import std.conv;\n    import std.array;\n    import std.string;\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp99pzu8x3.d(87): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp99pzu8x3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ immutable string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\"\
    , \"c\", \"xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n\
    \    static immutable int[] values = [\n        1000, 900, 500, 400, 100, 90,\
    \ 50, 40, 10, 9, 5, 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral;\
    \ roman_numerals) {\n        while(number >= values[i]) {\n            result\
    \ ~= numeral;\n            number -= values[i];\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    foreach(i; 0 .. 4)\n    {\n        auto digit = number % 10;\n\
    \        number /= 10;\n        if(digit == 0)\n            continue;\n      \
    \  if(i == 0)\n        {\n            result ~= repeat(\"i\", digit);\n      \
    \  }\n        else if(i == 1)\n        {\n            if(digit <= 3)\n       \
    \         result ~= repeat(\"x\", digit);\n            else if(digit == 4)\n \
    \               result ~= \"xl\";\n            else if(digit == 5)\n         \
    \       result ~= \"l\";\n            else if(digit <= 8)\n                result\
    \ ~= \"l\" ~ repeat(\"x\", digit - 5);\n            else\n                result\
    \ ~= \"xc\";\n        }\n        else if(i == 2)\n        {\n            if(digit\
    \ <= 3)\n                result ~= repeat(\"c\", digit);\n            else if(digit\
    \ == 4)\n                result ~= \"cd\";\n            else if(digit == 5)\n\
    \                result ~= \"d\";\n            else if(digit <= 8)\n         \
    \       result ~= \"d\" ~ repeat(\"c\", digit - 5);\n            else\n      \
    \          result ~= \"cm\";\n        }\n        else if(i == 3)\n        {\n\
    \            result ~= repeat(\"m\", digit);\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1st0sz8j.d(26): Error: undefined identifier `repeat`\\n/tmp/tmp1st0sz8j.d(31):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmp1st0sz8j.d(37): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmp1st0sz8j.d(44): Error: undefined identifier `repeat`\\\
    n/tmp/tmp1st0sz8j.d(50): Error: undefined identifier `repeat`\\n/tmp/tmp1st0sz8j.d(56):\
    \ Error: undefined identifier `repeat`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp1st0sz8j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(1 <= number && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] roman_numerals = [\n        \"\", \"i\", \"ii\"\
    , \"iii\", \"iv\", \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static\
    \ string[10] roman_tens = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"\
    l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds\
    \ = [\n        \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\"\n    ];\n    static string[4] roman_thousands = [\n        \"\"\
    , \"m\", \"mm\", \"mmm\"\n    ];\n    if (number > 1000)\n        return \"\"\
    ;\n    if (number > 0)\n        result ~= roman_thousands[number / 1000];\n  \
    \  if (number > 0)\n        result ~= roman_hundreds[(number % 1000) / 100];\n\
    \    if (number > 0)\n        result ~= roman_tens[(number % 100) / 10];\n   \
    \ if (number > 0)\n        result ~= roman_numerals[number % 10];\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ implement this function\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp81em1sqp.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmp81em1sqp.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmp81em1sqp.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x6616e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ decimal_numerals = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5,\
    \ 4, 1\n    ];\n    string result = \"\";\n    foreach(i, numeral; roman_numerals)\
    \ {\n        while(number >= decimal_numerals[i]) {\n            result ~= numeral;\n\
    \            number -= decimal_numerals[i];\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\n/*\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjkhgvj0x.d(34): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjkhgvj0x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[] roman_tens =\
    \ [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[] roman_hundreds = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    string\
    \ result = \"\";\n    if (number >= 1000) {\n        result ~= roman_thousands[number\
    \ / 1000 - 1];\n        number %= 1000;\n    }\n    if (number >= 100) {\n   \
    \     result ~= roman_hundreds[number / 100 - 1];\n        number %= 100;\n  \
    \  }\n    if (number >= 10) {\n        result ~= roman_tens[number / 10 - 1];\n\
    \        number %= 10;\n    }\n    if (number > 0) {\n        result ~= roman_numerals[number\
    \ - 1];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000];\n\
    \    static const string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"\
    xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    string result\
    \ = \"\";\n    foreach(i; reverse(iota(values.length)))\n    {\n        while(number\
    \ >= values[i])\n        {\n            result ~= numerals[i];\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyb9qnrkb.d(20): Error: undefined identifier `iota`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyb9qnrkb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, roman_num; zip(roman, values))\n    {\n        while(number >= roman_num[1])\n\
    \        {\n            result ~= roman_num[0];\n            number -= roman_num[1];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk7jlv4tr.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7jlv4tr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_digits = [](long number, long digit) {\n        long\
    \ n = number / digit;\n        string result;\n        if (n == 4) {\n       \
    \     result ~= \"iv\";\n        } else if (n == 9) {\n            result ~= \"\
    ix\";\n        } else {\n            if (n >= 5) {\n                result ~=\
    \ \"v\";\n                n -= 5;\n            }\n            result ~= \"i\"\
    \ * n;\n        }\n        return result;\n    };\n    result ~= roman_digits(number,\
    \ 1000);\n    number %= 1000;\n    result ~= roman_digits(number, 100);\n    number\
    \ %= 100;\n    result ~= roman_digits(number, 10);\n    number %= 10;\n    result\
    \ ~= roman_digits(number, 1);\n    return result;\n}\n/*\n    Given a positive\
    \ integer, obtain its roman numeral equivalent as a string,\n    and return it\
    \ in lowercase.\n    Restrictions: 1 <= num <= 3999\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6kj4fg2j.d(18): Error: found `number` when expecting `.` following\
    \ long\\n/tmp/tmp6kj4fg2j.d(18): Error: found `,` when expecting identifier following\
    \ `long`.\\n/tmp/tmp6kj4fg2j.d(18): Error: found `long` when expecting `,`\\n/tmp/tmp6kj4fg2j.d(18):\
    \ Error: semicolon expected following auto declaration, not `{`\\n/tmp/tmp6kj4fg2j.d(33):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\n/tmp/tmp6kj4fg2j.d(43):\
    \ Error: unterminated /* */ comment\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp6kj4fg2j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number > 0 && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    foreach(i; [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4,\
    \ 1])\n    {\n        while(number >= i)\n        {\n            result ~= roman_symbols[i];\n\
    \            number -= i;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwoe0phq7.d(22): Error: undefined identifier `roman_symbols`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwoe0phq7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.range;\n    import std.algorithm;\n    import std.conv;\n    import std.array;\n\
    \    import std.math;\n    import std.typecons;\n    import std.string;\n    import\
    \ std.traits;\n    import std.range;\n    import std.algorithm;\n    import std.conv;\n\
    \    import std.array;\n    import std.math;\n    import std.typecons;\n    import\
    \ std.string;\n    import std.traits;\n    import std.range;\n    import std.algorithm;\n\
    \    import std.conv;\n    import std.array;\n    import std.math;\n    import\
    \ std.typecons;\n    import std.string;\n    import std.traits;\n    import std.range;\n\
    \    import std.algorithm;\n    import std.conv;\n    import std.array;\n    import\
    \ std.math;\n    import std.typecons;\n    import std.string;\n    import std.traits;\n\
    \    import std.range;\n    import std.algorithm;\n    import std.conv;\n    import\
    \ std.array;\n    import std.math;\n    import std.typecons;\n    import std.string;\n\
    \    import std.traits;\n    import std.range;\n    import std.algorithm;\n  \
    \  import std.conv;\n    import std.array;\n    import std.math;\n    import std.typecons;\n\
    \    import std.string;\n    import std.traits;\n    import std.range;\n    import\
    \ std.algorithm;\n    import std.conv;\n    import std.array;\n    import std.math;\n\
    \    import std.typecons;\n    import std.string;\n    import std.traits;\n  \
    \  import std.range;\n    import std.algorithm;\n    import std.conv;\n    import\
    \ std.array;\n    import std.math;\n    import std.typecons;\n    import std.string;\n\
    \    import std.traits;\n    import std.range;\n    import std.algorithm;\n  \
    \  import std.conv;\n    import std.array;\n    import std.math;\n   \nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc3v308lp.d(87): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc3v308lp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 3,\
    \ 2, 1, 2, 3, 4, 2];\n    static const int[] subtractors = [0, 0, 0, 0, 1, 2,\
    \ 2, 2, 2, 1];\n    static const int[] divisors = [0, 0, 0, 0, 1, 10, 100, 1000];\n\
    \    static const int[] multipliers = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static\
    \ const int[] powers = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[]\
    \ powers_of_ten = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_squared\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_cubed\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_fourth\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_fifth\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_sixth\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_seventh\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_eighth\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_ninth\
    \ = [0, 0, 0, 0, 1, 10, 100, 1000];\n    static const int[] powers_of_ten_to_the_tenth\
    \ = [0, 0\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx7iz_a6f.d(34): Error: comma expected separating array initializers,\
    \ not `unittest`\\n/tmp/tmpx7iz_a6f.d(35): Error: semicolon expected, not `{`\\\
    n/tmp/tmpx7iz_a6f.d(53): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7iz_a6f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[] arabic = [ 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n  \
    \  foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\n/*\n    Given a positive integer, obtain its roman numeral\
    \ equivalent as a string,\n    and return it in uppercase.\n    Restrictions:\
    \ 1 <= num <= 1000\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1h8qmmwt.d(30): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1h8qmmwt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[] roman_tens =\
    \ [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[] roman_hundreds = [\n        \"c\", \"cc\"\
    , \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[] roman_thousands = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static\
    \ string[] roman_tens_of_thousands = [\n        \"x\", \"xx\", \"xxx\", \"xl\"\
    , \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[] roman_hundreds_of_thousands\
    \ = [\n        \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\"\
    , \"cm\"\n    ];\n    static string[] roman_millions = [\n        \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[] roman_tens_of_millions = [\n        \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n\
    \    static string[] roman_hundreds_of_millions = [\n        \"c\", \"cc\", \"\
    ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static string[]\
    \ roman_billions = [\n        \"m\", \"mm\", \"mmm\"\n    ];\n    static string[]\
    \ roman_tens_of_billions = [\n        \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"\
    lx\", \"lxx\", \"lxxx\", \"xc\"\n    ];\n    static string[] roman_hundreds_of_billions\
    \ = [\n        \"c\", \"cc\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp33jrt62g.d(50): Error: unterminated string constant starting\
    \ at /tmp/tmp33jrt62g.d(69)\\n/tmp/tmp33jrt62g.d(56): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmp33jrt62g.d(56): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmp33jrt62g.d(57):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(58):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(59):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(60):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmp33jrt62g.d(61):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(62):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(63):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(64):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(65):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(66):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(67):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(68):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(69):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(71):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp33jrt62g.d(71):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp33jrt62g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    foreach(i; 0 .. 4)\n    {\n        int digit = number % 10;\n \
    \       number /= 10;\n        switch(i)\n        {\n            case 0:\n   \
    \             result = repeat(digit, \"i\");\n                break;\n       \
    \     case 1:\n                result = repeat(digit, \"x\") ~ result;\n     \
    \           break;\n            case 2:\n                result = repeat(digit,\
    \ \"c\") ~ result;\n                break;\n            case 3:\n            \
    \    result = repeat(digit, \"m\") ~ result;\n                break;\n       \
    \ }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp06u3mbjg.d(25): Error: undefined identifier `repeat`\\n/tmp/tmp06u3mbjg.d(28):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmp06u3mbjg.d(31): Error: undefined\
    \ identifier `repeat`\\n/tmp/tmp06u3mbjg.d(34): Error: undefined identifier `repeat`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp06u3mbjg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string roman_numerals = \"ivxlcdm\";\n    static int[] roman_values = [1, 5,\
    \ 10, 50, 100, 500, 1000];\n    static string[] roman_strings = [\"i\", \"v\"\
    , \"x\", \"l\", \"c\", \"d\", \"m\"];\n    static int[] roman_subtractors = [1,\
    \ 10, 100];\n    static string[] roman_subtractor_strings = [\"i\", \"x\", \"\
    c\"];\n    static int[] roman_subtractor_values = [1, 10, 100];\n    static string[]\
    \ roman_subtractor_strings_2 = [\"iv\", \"ix\", \"xc\", \"xl\", \"cd\", \"cm\"\
    ];\n    static int[] roman_subtractor_values_2 = [4, 9, 90, 40, 400, 900];\n \
    \   string result = \"\";\n    foreach(i; 0 .. roman_values.length)\n    {\n \
    \       if(number >= roman_values[i])\n        {\n            result ~= roman_strings[i];\n\
    \            number -= roman_values[i];\n        }\n        else if(number >=\
    \ roman_values[i] - roman_subtractors[i])\n        {\n            result ~= roman_subtractor_strings[i]\
    \ ~ roman_strings[i];\n            number -= roman_values[i] - roman_subtractors[i];\n\
    \        }\n        else if(number >= roman_values[i] - roman_subtractors[i] *\
    \ 2)\n        {\n            result ~= roman_subtractor_strings[i] ~ roman_subtractor_strings[i]\
    \ ~ roman_strings[i];\n            number -= roman_values[i] - roman_subtractors[i]\
    \ * 2;\n        }\n        else if(number >= roman_values[i] - roman_subtractors[i]\
    \ * 3)\n        {\n            result ~= roman_subtractor_strings[i] ~ roman_subtractor_strings[i]\
    \ ~ roman_subt\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9ucg95ps.d(46): Error: found `unittest` when expecting `;` following\
    \ statement\\n/tmp/tmp9ucg95ps.d(65): Error: found `End of File` when expecting\
    \ `}` following compound statement\\n/tmp/tmp9ucg95ps.d(65): Error: found `End\
    \ of File` when expecting `}` following compound statement\\n/tmp/tmp9ucg95ps.d(65):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp9ucg95ps.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] decimal_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, numeral; roman_numerals)\n    {\n        while(number\
    \ >= decimal_numerals[i])\n        {\n            result ~= numeral;\n       \
    \     number -= decimal_numerals[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    if (number >= 1000) {\n    \
    \    result ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n\
    \    if (number >= 100) {\n        result ~= roman_hundreds[number / 100];\n \
    \       number %= 100;\n    }\n    if (number >= 10) {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    string result = \"\";\n    result ~= roman_thousands[number\
    \ / 1000];\n    number %= 1000;\n    result ~= roman_hundreds[number / 100];\n\
    \    number %= 100;\n    result ~= roman_tens[number / 10];\n    number %= 10;\n\
    \    result ~= roman_numerals[number];\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const long[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const long[] subtract_values = [1,\
    \ 10, 100];\n    static const long[] subtract_values_index = [0, 2, 4];\n    static\
    \ const long[] subtract_values_index_2 = [1, 2, 4];\n    static const long[] subtract_values_index_3\
    \ = [2, 4, 6];\n    static const long[] subtract_values_index_4 = [0, 2, 4, 6];\n\
    \    static const long[] subtract_values_index_5 = [1, 2, 4, 6];\n    static const\
    \ long[] subtract_values_index_6 = [2, 4, 6];\n    static const long[] subtract_values_index_7\
    \ = [0, 2, 4, 6];\n    static const long[] subtract_values_index_8 = [1, 2, 4,\
    \ 6];\n    static const long[] subtract_values_index_9 = [0, 2, 4];\n    static\
    \ const long[] subtract_values_index_10 = [2, 4, 6];\n    static const long[]\
    \ subtract_values_index_11 = [0, 2, 4, 6];\n    static const long[] subtract_values_index_12\
    \ = [1, 2, 4, 6];\n    static const long[] subtract_values_index_13 = [0, 2, 4];\n\
    \    static const long[] subtract_values_index_14 = [2, 4, 6];\n    static const\
    \ long[] subtract_values_index_15 = [0, 2, 4, 6];\n    static const long[] subtract_values_index_16\
    \ = [1, 2, 4, 6];\n    static const long[] subtract_values_index_17 = [0, 2, 4];\n\
    \    static const long[] subtract_values_index_18 = [2, 4, 6];\n    static const\
    \ long[] subtract_values_index_19 = [0, 2, 4];\n    static const long[] subtract_values_index_20\
    \ = [2, 4, 6];\n    static const long[] subtract_values_index_30 = [0,\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpddifip8l.d(41): Error: expression expected, not `unittest`\\\
    n/tmp/tmpddifip8l.d(42): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpddifip8l.d(60): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpddifip8l.d(60): Error: semicolon expected, not `main`\\\
    n/tmp/tmpddifip8l.d(60): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpddifip8l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] arabic = [ 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n  \
    \  foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"xm\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpepx4abjh.d(56): Error: unterminated string constant starting\
    \ at /tmp/tmpepx4abjh.d(75)\\n/tmp/tmpepx4abjh.d(62): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpepx4abjh.d(62): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpepx4abjh.d(63):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(64):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(65):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(66):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpepx4abjh.d(67):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(68):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(69):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(70):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(71):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(72):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(73):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(74):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(75):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(77):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpepx4abjh.d(77):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepx4abjh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    int[] values = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900,\
    \ 1000];\n    string[] numerals = [\"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\"\
    , \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\"];\n    while (number > 0)\
    \ \n    {\n        int i = values.length - 1;\n        while (values[i] > number)\
    \ \n        {\n            i--;\n        }\n        result ~= numerals[i];\n \
    \       number -= values[i];\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa6b7403y.d(22): Error: cannot implicitly convert expression `values.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpa6b7403y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] roman_values\
    \ = [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] roman_subtractors\
    \ = [1, 10, 100];\n    static const int[] roman_subtractor_values = [1, 10, 100];\n\
    \    static const int[] roman_subtractor_indices = [0, 2, 4];\n    static const\
    \ int[] roman_subtractor_multipliers = [4, 4, 4];\n    static const int[] roman_subtractor_addends\
    \ = [1, 1, 1];\n    static const int[] roman_subtractor_addend_indices = [1, 1,\
    \ 1];\n    static const int[] roman_subtractor_addend_multipliers = [1, 1, 1];\n\
    \    static const int[] roman_subtractor_addend_addends = [1, 1, 1];\n    static\
    \ const int[] roman_subtractor_addend_addend_indices = [0, 0, 0];\n    static\
    \ const int[] roman_subtractor_addend_addend_multipliers = [1, 1, 1];\n    static\
    \ const int[] roman_subtractor_addend_addend_addends = [1, 1, 1];\n    static\
    \ const int[] roman_subtractor_addend_addend_addend_indices = [0, 0, 0];\n   \
    \ static const int[] roman_subtractor_addend_addend_addend_multipliers = [1, 1,\
    \ 1];\n    static const int[] roman_subtractor_addend_addend_addend_addends =\
    \ [1, 1, 1];\n    static const int[] roman_subtractor_addend_addend_addend_addend_indices\
    \ = [0, 0, 0];\n    static const int[] roman_subtractor_addend_addend_addend_addend_multipliers\
    \ = [1, 1, 1];\n    static const int[] roman_subtractor_addend_addend_addend_\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzya26eoh.d(36): Error: semicolon expected, not `unittest`\\n/tmp/tmpzya26eoh.d(36):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpzya26eoh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [ \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\" ];\n    static string[10] tens = [ \"\", \"x\", \"xx\"\
    , \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\" ];\n    static string[10]\
    \ hundreds = [ \"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"\
    dccc\", \"cm\" ];\n    static string[4] thousands = [ \"\", \"m\", \"mm\", \"\
    mmm\" ];\n    string result = \"\";\n    result ~= thousands[number / 1000];\n\
    \    result ~= hundreds[(number % 1000) / 100];\n    result ~= tens[(number %\
    \ 100) / 10];\n    result ~= digits[number % 10];\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\n   \
    \ {\n        while(number >= values[i])\n        {\n            result ~= roman;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ numbers = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n\
    \    ];\n    string result = \"\";\n    foreach(i, num; numbers)\n    {\n    \
    \    while(number >= num)\n        {\n            result ~= roman_numerals[i];\n\
    \            number -= num;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"\
    xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach (i, numeral; numerals) {\n        while (number >= values[i]) {\n\
    \            result ~= numeral;\n            number -= values[i];\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals)\n   \
    \ {\n        while(number >= values[i])\n        {\n            result ~= roman;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] digits = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\",\
    \ \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] tens = [\n\
    \        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\"\
    , \"xc\"\n    ];\n    static string[10] hundreds = [\n        \"\", \"c\", \"\
    cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n    ];\n    static\
    \ string[4] thousands = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    return\
    \ thousands[number / 1000] ~\n           hundreds[(number / 100) % 10] ~\n   \
    \        tens[(number / 10) % 10] ~\n           digits[number % 10];\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= decimal[i])\n        {\n\
    \            number -= decimal[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"i\", \"v\", \"x\", \"l\", \"c\", \"d\", \"m\"];\n    string\
    \ result = \"\";\n    int i = 0;\n    while (number > 0)\n    {\n        int digit\
    \ = number % 10;\n        if (digit == 9)\n        {\n            result = roman[i]\
    \ ~ roman[i + 2] ~ result;\n        }\n        else if (digit == 4)\n        {\n\
    \            result = roman[i] ~ roman[i + 1] ~ result;\n        }\n        else\n\
    \        {\n            if (digit >= 5)\n            {\n                result\
    \ = roman[i + 1] ~ result;\n                digit -= 5;\n            }\n     \
    \       result = repeat(roman[i], digit) ~ result;\n        }\n        number\
    \ /= 10;\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3m47oni.d(38): Error: undefined identifier `repeat`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu3m47oni.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = [](long number)\n    {\n        return tuple(\n\
    \            tuple('i', 'v', 'x'),\n            tuple('x', 'l', 'c'),\n      \
    \      tuple('c', 'd', 'm'),\n            tuple('m', 'v', 'x')\n        );\n \
    \   };\n    auto to_roman = [](long number, char one, char five, char ten)\n \
    \   {\n        string result;\n        if (number == 0)\n            return result;\n\
    \        if (number < 4)\n            result ~= repeat(one, number);\n       \
    \ else if (number == 4)\n            result ~= one ~ five;\n        else if (number\
    \ < 9)\n            result ~= five ~ repeat(one, number - 5);\n        else\n\
    \            result ~= one ~ ten;\n        return result;\n    };\n    auto digits\
    \ = to!(int[])(number.to!string);\n    foreach (i, digit; digits)\n    {\n   \
    \     result ~= to_roman(digit, roman_numerals[i][0], roman_numerals[i][1], roman_numerals[i][2]);\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpol_z2r6w.d(18): Error: found `number` when expecting `.` following\
    \ long\\n/tmp/tmpol_z2r6w.d(18): Error: found `)` when expecting identifier following\
    \ `long`.\\n/tmp/tmpol_z2r6w.d(19): Error: found `{` when expecting `,`\\n/tmp/tmpol_z2r6w.d(20):\
    \ Error: expression expected, not `return`\\n/tmp/tmpol_z2r6w.d(20): Error: found\
    \ `tuple` when expecting `,`\\n/tmp/tmpol_z2r6w.d(25): Error: found `;` when expecting\
    \ `,`\\n/tmp/tmpol_z2r6w.d(26): Error: expression expected, not `}`\\n/tmp/tmpol_z2r6w.d(26):\
    \ Error: found `;` when expecting `,`\\n/tmp/tmpol_z2r6w.d(27): Error: expression\
    \ expected, not `auto`\\n/tmp/tmpol_z2r6w.d(27): Error: found `to_roman` when\
    \ expecting `,`\\n/tmp/tmpol_z2r6w.d(27): Error: expression expected, not `=`\\\
    n/tmp/tmpol_z2r6w.d(27): Error: found `number` when expecting `.` following long\\\
    n/tmp/tmpol_z2r6w.d(27): Error: found `,` when expecting identifier following\
    \ `long`.\\n/tmp/tmpol_z2r6w.d(27): Error: found `char` when expecting `,`\\n/tmp/tmpol_z2r6w.d(27):\
    \ Error: found `five` when expecting `.` following char\\n/tmp/tmpol_z2r6w.d(27):\
    \ Error: found `,` when expecting identifier following `char`.\\n/tmp/tmpol_z2r6w.d(27):\
    \ Error: found `char` when expecting `,`\\n/tmp/tmpol_z2r6w.d(28): Error: found\
    \ `{` when expecting `,`\\n/tmp/tmpol_z2r6w.d(29): Error: found `result` when\
    \ expecting `,`\\n/tmp/tmpol_z2r6w.d(29): Error: expression expected, not `;`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpol_z2r6w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    foreach(i; 0 .. 4)\n    {\n        auto digit = number % 10;\n\
    \        number /= 10;\n        switch(i)\n        {\n            case 0:\n  \
    \              switch(digit)\n                {\n                    case 1:\n\
    \                        result ~= \"i\";\n                        break;\n  \
    \                  case 2:\n                        result ~= \"ii\";\n      \
    \                  break;\n                    case 3:\n                     \
    \   result ~= \"iii\";\n                        break;\n                    case\
    \ 4:\n                        result ~= \"iv\";\n                        break;\n\
    \                    case 5:\n                        result ~= \"v\";\n     \
    \                   break;\n                    case 6:\n                    \
    \    result ~= \"vi\";\n                        break;\n                    case\
    \ 7:\n                        result ~= \"vii\";\n                        break;\n\
    \                    case 8:\n                        result ~= \"viii\";\n  \
    \                      break;\n                    case 9:\n                 \
    \       result ~= \"ix\";\n                        break;\n                }\n\
    \                break;\n            case 1:\n                switch(digit)\n\
    \                {\n                    case 1:\n                        result\
    \ ~= \"x\";\n                        break;\n                    case 2:\n   \
    \                     result ~= \"xx\";\n                        break;\n    \
    \                case 3:\n                        result ~= \"xxx\";\n       \
    \                 break;\n                    case 4:\n                      \
    \  result ~= \"xl\";\n                        break;\n                    case\
    \ 5:\n                        result ~= \"l\";\n                        break;\n\
    \                    case 6:\n                        result ~= \"lx\";\n    \
    \                    break;\n                    case 7:\n                   \
    \     result ~= \"lxx\";\n                        break;\n                   \
    \ case 8:\n                        result ~= \"lxxx\";\n                     \
    \   break;\n                    case 9:\n                        result ~= \"\
    xc\";\n                        break;\n                }\n                break;\n\
    \            case 2:\n                switch(digit)\n                {\n     \
    \               case 1:\n                        result ~= \"c\";\n          \
    \              break;\n                    case 2:\n                        result\
    \ ~= \"cc\";\n                        break;\n                    case 3:\n  \
    \                      result ~= \"ccc\";\n                        break;\n  \
    \                  case 4:\n                        result ~= \"cd\";\n      \
    \                  break;\n                    case 5:\n                     \
    \   result ~= \"d\";\n                        break;\n                    case\
    \ 6:\n                        result ~= \"dc\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6rkaynj1.d(112): Error: found `xix` when expecting `;` following\
    \ statement\\n/tmp/tmp6rkaynj1.d(113): Error: found `lii` when expecting `;` following\
    \ statement\\n/tmp/tmp6rkaynj1.d(114): Error: found `cli` when expecting `;` following\
    \ statement\\n/tmp/tmp6rkaynj1.d(115): Error: found `dxxvi` when expecting `;`\
    \ following statement\\n/tmp/tmp6rkaynj1.d(116): Error: Implicit string concatenation\
    \ is deprecated, use \");\\\\x0a    assert(candidate(500L) == \"d ~ \");\\\\x0a\
    \    assert(candidate(1L) == \" instead\\n/tmp/tmp6rkaynj1.d(117): Error: found\
    \ `i` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(118): Error:\
    \ found `iv` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(119):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(120):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(121):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(122):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(123):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(124):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(125):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(125):\
    \ Error: unterminated string constant starting at /tmp/tmp6rkaynj1.d(125)\\n/tmp/tmp6rkaynj1.d(127):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmp6rkaynj1.d(127):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    n/tmp/tmp6rkaynj1.d(127): Error: found `End of File` when expecting `}` following\
    \ compound statement\\n/tmp/tmp6rkaynj1.d(127): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmp6rkaynj1.d(127): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6rkaynj1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman; roman_numerals) {\n \
    \       while(number >= values[i]) {\n            result ~= roman;\n         \
    \   number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] arabic_numerals\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result\
    \ = \"\";\n    foreach(i, arabic; arabic_numerals)\n    {\n        while(number\
    \ >= arabic)\n        {\n            result ~= roman_numerals[i];\n          \
    \  number -= arabic;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] arabic\
    \ = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    foreach(i, r;\
    \ arabic)\n    {\n        while(number >= i)\n        {\n            result ~=\
    \ r;\n            number -= i;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: None
  stderr: None
  exit_code: -1
  status: Timeout
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    for (int i = 0; i < values.length; i++)\n    {\n        while (number >=\
    \ values[i])\n        {\n            number -= values[i];\n            result\
    \ ~= roman_numerals[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(\n        tuple('i', 'v', 'x'),\n \
    \       tuple('x', 'l', 'c'),\n        tuple('c', 'd', 'm'),\n        tuple('m',\
    \ 'v', 'x')\n    );\n    foreach(i, numeral; roman_numerals) {\n        auto digit\
    \ = number % 10;\n        if (digit == 0) {\n            number /= 10;\n     \
    \       continue;\n        }\n        if (digit <= 3) {\n            result ~=\
    \ repeat(numeral[0], digit);\n        } else if (digit == 4) {\n            result\
    \ ~= numeral[0] ~ numeral[1];\n        } else if (digit <= 8) {\n            result\
    \ ~= numeral[1] ~ repeat(numeral[0], digit - 5);\n        } else {\n         \
    \   result ~= numeral[0] ~ numeral[2];\n        }\n        number /= 10;\n   \
    \ }\n    return result.reverse;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpelbnfw56.d(31): Error: undefined identifier `repeat`\\n/tmp/tmpelbnfw56.d(33):\
    \ Error: incompatible types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmpelbnfw56.d(35): Error: undefined identifier\
    \ `repeat`\\n/tmp/tmpelbnfw56.d(37): Error: incompatible types for `(cast(int)numeral.__expand_field_0)\
    \ ~ (cast(int)numeral.__expand_field_2)`: both operands are of type `int`\\n/tmp/tmpelbnfw56.d(31):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpelbnfw56.d(33): Error: incompatible\
    \ types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmpelbnfw56.d(35): Error: undefined identifier\
    \ `repeat`\\n/tmp/tmpelbnfw56.d(37): Error: incompatible types for `(cast(int)numeral.__expand_field_0)\
    \ ~ (cast(int)numeral.__expand_field_2)`: both operands are of type `int`\\n/tmp/tmpelbnfw56.d(31):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpelbnfw56.d(33): Error: incompatible\
    \ types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmpelbnfw56.d(35): Error: undefined identifier\
    \ `repeat`\\n/tmp/tmpelbnfw56.d(37): Error: incompatible types for `(cast(int)numeral.__expand_field_0)\
    \ ~ (cast(int)numeral.__expand_field_2)`: both operands are of type `int`\\n/tmp/tmpelbnfw56.d(31):\
    \ Error: undefined identifier `repeat`\\n/tmp/tmpelbnfw56.d(33): Error: incompatible\
    \ types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmpelbnfw56.d(35): Error: undefined identifier\
    \ `repeat`\\n/tmp/tmpelbnfw56.d(37): Error: incompatible types for `(cast(int)numeral.__expand_field_0)\
    \ ~ (cast(int)numeral.__expand_field_2)`: both operands are of type `int`\\n/tmp/tmpelbnfw56.d(41):\
    \ Error: template `std.typecons.reverse` cannot deduce function from argument\
    \ types `!()(string)`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnff"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"\
    vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"x\", \"\
    xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static\
    \ string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"\
    dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    return roman_thousands[number / 1000] ~ roman_hundreds[(number\
    \ % 1000) / 100] ~ roman_tens[(number % 100) / 10] ~ roman[number % 10];\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    static string[10] digits = [\"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] tens = [\"\
    \", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n\
    \    static string[10] hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\"\
    , \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] thousands = [\"\"\
    , \"m\", \"mm\", \"mmm\"];\n    result ~= thousands[number / 1000];\n    number\
    \ %= 1000;\n    result ~= hundreds[number / 100];\n    number %= 100;\n    result\
    \ ~= tens[number / 10];\n    number %= 10;\n    result ~= digits[number];\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n\
    \    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[] arabic = [ 1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result = \"\";\n  \
    \  foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] decimal = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ for (size_t i = 0; i < roman.length; i++)\n    {\n        while (number >= decimal[i])\n\
    \        {\n            number -= decimal[i];\n            result += roman[i];\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbn_pptnt.d(25): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbn_pptnt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    // TODO:\
    \ write your code here\n    return \"\";\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyj15yyd1.d(24): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428135]\\n??:? void tmpyj15yyd1.__unittest_L20_C1()\
    \ [0x427ab8]\\n??:? void tmpyj15yyd1.__modtest() [0x427eb4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42bddf]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42acee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42fe05]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4302b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42fd91]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42acc5]\\n??:? runModuleUnitTests [0x42bbb5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428584]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42850b]\\n??:? _d_run_main [0x428476]\\n??:? main [0x427ec7]\\\
    n??:? __libc_start_main [0x887fc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    foreach(i; 0 .. 4)\n    {\n        auto digit = number % 10;\n\
    \        auto romanDigit = to!string(repeat(\"i\", digit));\n        if (i ==\
    \ 0)\n        {\n            if (digit == 4)\n                romanDigit = \"\
    iv\";\n            else if (digit == 9)\n                romanDigit = \"ix\";\n\
    \        }\n        else if (i == 1)\n        {\n            if (digit == 4)\n\
    \                romanDigit = \"xl\";\n            else if (digit == 9)\n    \
    \            romanDigit = \"xc\";\n        }\n        else if (i == 2)\n     \
    \   {\n            if (digit == 4)\n                romanDigit = \"cd\";\n   \
    \         else if (digit == 9)\n                romanDigit = \"cm\";\n       \
    \ }\n        else if (i == 3)\n        {\n            if (digit == 4)\n      \
    \          romanDigit = \"mv\";\n            else if (digit == 9)\n          \
    \      romanDigit = \"mx\";\n        }\n        result = romanDigit ~ result;\n\
    \        number /= 10;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6b128w3v.d(21): Error: template instance `to!string` template\
    \ `to` is not defined, did you mean No?\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp6b128w3v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    auto roman_numerals = tuple(tuple('i', 'v', 'x'), tuple('x', 'l',\
    \ 'c'), tuple('c', 'd', 'm'));\n    foreach(i, numeral; roman_numerals)\n    {\n\
    \        auto digit = number % 10;\n        number /= 10;\n        if (digit ==\
    \ 9)\n            result ~= numeral[0] ~ numeral[2];\n        else if (digit ==\
    \ 4)\n            result ~= numeral[0] ~ numeral[1];\n        else\n        {\n\
    \            if (digit >= 5)\n            {\n                result ~= numeral[1];\n\
    \                digit -= 5;\n            }\n            result ~= numeral[0].repeat(digit);\n\
    \        }\n    }\n    return result.dup.reverse;\n}\nunittest\n{\n    alias candidate\
    \ = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L)\
    \ == \"clii\");\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L)\
    \ == \"cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L)\
    \ == \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L)\
    \ == \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplpiz4l4_.d(24): Error: incompatible types for `(cast(int)numeral.__expand_field_0)\
    \ ~ (cast(int)numeral.__expand_field_2)`: both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(26):\
    \ Error: incompatible types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(34): Error: no property\
    \ `repeat` for type `char`\\n/tmp/tmplpiz4l4_.d(24): Error: incompatible types\
    \ for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_2)`:\
    \ both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(26): Error: incompatible\
    \ types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(34): Error: no property\
    \ `repeat` for type `char`\\n/tmp/tmplpiz4l4_.d(24): Error: incompatible types\
    \ for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_2)`:\
    \ both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(26): Error: incompatible\
    \ types for `(cast(int)numeral.__expand_field_0) ~ (cast(int)numeral.__expand_field_1)`:\
    \ both operands are of type `int`\\n/tmp/tmplpiz4l4_.d(34): Error: no property\
    \ `repeat` for type `char`\\n/tmp/tmplpiz4l4_.d(37): Error: template `std.typecons.reverse`\
    \ cannot deduce function from argument types `!()(char[])`, candidates are:\\\
    n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmplpiz4l4_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static int[] arabic_numerals\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, numeral; zip(arabic_numerals, roman_numerals))\n   \
    \ {\n        while(number >= numeral[0])\n        {\n            result ~= numeral[1];\n\
    \            number -= numeral[0];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpburlro3o.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpburlro3o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static long[] values = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, v; zip(roman, values))\n    {\n        while(number >= v)\n     \
    \   {\n            result ~= i.front;\n            number -= v;\n        }\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp57l0h0eb.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp57l0h0eb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\"\
    , \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] values = [1000,\
    \ 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n\
    \    foreach(i, roman_numeral; roman_numerals)\n    {\n        while(number >=\
    \ values[i])\n        {\n            result ~= roman_numeral;\n            number\
    \ -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    string\
    \ result;\n    long remainder;\n    auto roman_digits = [](long number, long divisor,\
    \ string one, string five, string ten) {\n        long digit = number / divisor;\n\
    \        if (digit == 0) return \"\";\n        if (digit <= 3) return one.repeat(digit);\n\
    \        if (digit == 4) return one ~ five;\n        if (digit <= 8) return five\
    \ ~ one.repeat(digit - 5);\n        return one ~ ten;\n    };\n    result ~= roman_digits(number,\
    \ 1000, \"m\", \"\", \"\");\n    remainder = number % 1000;\n    result ~= roman_digits(remainder,\
    \ 100, \"c\", \"d\", \"m\");\n    remainder = remainder % 100;\n    result ~=\
    \ roman_digits(remainder, 10, \"x\", \"l\", \"c\");\n    remainder = remainder\
    \ % 10;\n    result ~= roman_digits(remainder, 1, \"i\", \"v\", \"x\");\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk5_m2ws_.d(19): Error: found `number` when expecting `.` following\
    \ long\\n/tmp/tmpk5_m2ws_.d(19): Error: found `,` when expecting identifier following\
    \ `long`.\\n/tmp/tmpk5_m2ws_.d(19): Error: found `long` when expecting `,`\\n/tmp/tmpk5_m2ws_.d(19):\
    \ Error: found `one` when expecting `,`\\n/tmp/tmpk5_m2ws_.d(19): Error: expression\
    \ expected, not `,`\\n/tmp/tmpk5_m2ws_.d(19): Error: found `string` when expecting\
    \ `,`\\n/tmp/tmpk5_m2ws_.d(19): Error: found `ten` when expecting `,`\\n/tmp/tmpk5_m2ws_.d(19):\
    \ Error: semicolon expected following auto declaration, not `{`\\n/tmp/tmpk5_m2ws_.d(26):\
    \ Deprecation: use `{ }` for an empty statement, not `;`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpk5_m2ws_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_millions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_billions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_billions\
    \ = [\n        \"\", \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_trillions\
    \ = [\n        \"\", \"m\", \"mm\", \"mmm\"\n    ];\n    static string[4] roman_ten_trillions\
    \ = [\n        \"\", \"xm\", \"\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpttle6ygl.d(56): Error: unterminated string constant starting\
    \ at /tmp/tmpttle6ygl.d(75)\\n/tmp/tmpttle6ygl.d(62): Error: comma expected separating\
    \ array initializers, not `xix`\\n/tmp/tmpttle6ygl.d(62): Error: semicolon expected,\
    \ not `\");\\\\x0a    assert(candidate(152L) == \"c`\\n/tmp/tmpttle6ygl.d(63):\
    \ Error: found `lii` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(64):\
    \ Error: found `cli` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(65):\
    \ Error: found `dxxvi` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(66):\
    \ Error: Implicit string concatenation is deprecated, use \");\\\\x0a    assert(candidate(500L)\
    \ == \"d ~ \");\\\\x0a    assert(candidate(1L) == \" instead\\n/tmp/tmpttle6ygl.d(67):\
    \ Error: found `i` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(68):\
    \ Error: found `iv` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(69):\
    \ Error: found `xliii` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(70):\
    \ Error: found `xc` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(71):\
    \ Error: found `xciv` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(72):\
    \ Error: found `xxxii` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(73):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(74):\
    \ Error: found `mxciv` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(75):\
    \ Error: found `m` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(77):\
    \ Error: found `End of File` when expecting `;` following statement\\n/tmp/tmpttle6ygl.d(77):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpttle6ygl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static int[]\
    \ roman_values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4,\
    \ 1\n    ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= roman_values[i])\n        {\n            result\
    \ ~= roman_numeral;\n            number -= roman_values[i];\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] ones = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"vi\", \"vii\"\
    , \"viii\", \"ix\"];\n    static string[10] tens = [\"\", \"x\", \"xx\", \"xxx\"\
    , \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n    static string[10] hundreds\
    \ = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"\
    cm\"];\n    static string[4] thousands = [\"\", \"m\", \"mm\", \"mmm\"];\n   \
    \ return thousands[number / 1000] ~ hundreds[(number / 100) % 10] ~ tens[(number\
    \ / 10) % 10] ~ ones[number % 10];\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ const string roman_numerals = \"ivxlcdm\";\n    static const int[] values =\
    \ [1, 5, 10, 50, 100, 500, 1000];\n    static const int[] digits = [0, 1, 2, 3,\
    \ 2, 1, 2, 3, 4, 2];\n    static const int[] subtractors = [0, 1, 2, 2, 1, 2,\
    \ 2, 3, 4, 2];\n    static const int[] subtractor_values = [0, 1, 2, 4, 5, 10,\
    \ 20, 40, 50, 100];\n    static const int[] subtractor_digits = [0, 1, 2, 2, 1,\
    \ 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractors = [0, 1, 2, 2,\
    \ 1, 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractor_values = [0,\
    \ 1, 2, 4, 5, 10, 20, 40, 50, 100];\n    static const int[] subtractor_subtractor_digits\
    \ = [0, 1, 2, 2, 1, 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractor_subtractors\
    \ = [0, 1, 2, 2, 1, 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractor_subtractor_values\
    \ = [0, 1, 2, 4, 5, 10, 20, 40, 50, 100];\n    static const int[] subtractor_subtractor_subtractor_digits\
    \ = [0, 1, 2, 2, 1, 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractor_subtractor_subtractors\
    \ = [0, 1, 2, 2, 1, 2, 2, 3, 4, 2];\n    static const int[] subtractor_subtractor_subtractor_subtractor_values\
    \ = [0, 1, 2, 4, 5, 10, 20, 40, 50, 100];\n    static const int[] subtractor_subtractor_subtractor_subtractor_digits\
    \ = [0, 1,\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiu4rnaxv.d(32): Error: expression expected, not `unittest`\\\
    n/tmp/tmpiu4rnaxv.d(33): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmpiu4rnaxv.d(51): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmpiu4rnaxv.d(51): Error: semicolon expected, not `main`\\\
    n/tmp/tmpiu4rnaxv.d(51): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu4rnaxv.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [\n        \"m\", \"cm\", \"d\", \"cd\", \"c\", \"\
    xc\", \"l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\"\n    ];\n    static long[]\
    \ values = [\n        1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n \
    \   ];\n    string result = \"\";\n    foreach(i, roman_numeral; roman_numerals)\n\
    \    {\n        while(number >= values[i])\n        {\n            result ~= roman_numeral;\n\
    \            number -= values[i];\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    assert(number >= 1 && number <= 1000);\n    return roman_thousands[number\
    \ / 1000] ~\n           roman_hundreds[(number / 100) % 10] ~\n           roman_tens[(number\
    \ / 10) % 10] ~\n           roman_numerals[number % 10];\n}\nunittest\n{\n   \
    \ alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\"\
    );\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"\
    ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman = [\"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"l\", \"xl\"\
    , \"x\", \"ix\", \"v\", \"iv\", \"i\"];\n    static int[] arabic = [1000, 900,\
    \ 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];\n    string result = \"\";\n   \
    \ foreach(i, r; roman)\n    {\n        while(number >= arabic[i])\n        {\n\
    \            number -= arabic[i];\n            result ~= r;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[] roman_numerals = [ \"m\", \"cm\", \"d\", \"cd\", \"c\", \"xc\", \"\
    l\", \"xl\", \"x\", \"ix\", \"v\", \"iv\", \"i\" ];\n    static long[] arabic_numerals\
    \ = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ];\n    string result\
    \ = \"\";\n    foreach(i, numeral; zip(arabic_numerals, roman_numerals))\n   \
    \ {\n        while(number >= numeral[0])\n        {\n            result ~= numeral[1];\n\
    \            number -= numeral[0];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L)\
    \ == \"xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmfluj1ly.d(20): Error: undefined identifier `zip`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmfluj1ly.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\n        \"\", \"i\", \"ii\", \"iii\", \"iv\"\
    , \"v\", \"vi\", \"vii\", \"viii\", \"ix\"\n    ];\n    static string[10] roman_tens\
    \ = [\n        \"\", \"x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"\
    lxxx\", \"xc\"\n    ];\n    static string[10] roman_hundreds = [\n        \"\"\
    , \"c\", \"cc\", \"ccc\", \"cd\", \"d\", \"dc\", \"dcc\", \"dccc\", \"cm\"\n \
    \   ];\n    static string[4] roman_thousands = [\n        \"\", \"m\", \"mm\"\
    , \"mmm\"\n    ];\n    static string[4] roman_ten_thousands = [\n        \"\"\
    , \"xm\", \"xmm\", \"xmmm\"\n    ];\n    static string[4] roman_hundred_thousands\
    \ = [\n        \"\", \"cm\", \"cmm\", \"cmmm\"\n    ];\n    static string[4] roman_millions\
    \ = [\n        \"\", \"mm\", \"mmm\", \"mmmm\"\n    ];\n    static string[4] roman_ten_millions\
    \ = [\n        \"\", \"xmm\", \"xmmm\", \"xmmmm\"\n    ];\n    static string[4]\
    \ roman_hundred_millions = [\n        \"\", \"cmm\", \"cmmm\", \"cmmmm\"\n   \
    \ ];\n    static string[4] roman_billions = [\n        \"\", \"mmm\", \"mmmm\"\
    , \"mmmmm\"\n    ];\n    static string[4] roman_ten_billions = [\n        \"\"\
    , \"xmmm\", \"xmmmm\", \"xmmmmm\"\n    ];\n    static string[4] roman_hundred_billions\
    \ = [\n        \"\", \"cmmm\", \"cmmmm\", \"cmmmmm\"\n    ];\n    static string[4]\
    \ roman_trillions = [\n        \"\", \"mmmm\", \"mmmmm\", \"mmmmmm\"\n    ];\n\
    \    static string[4] roman_ten_trillions = [\n       \nunittest\n{\n    alias\
    \ candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"xix\");\n \
    \   assert(candidate(152L) == \"clii\");\n    assert(candidate(251L) == \"ccli\"\
    );\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L) ==\
    \ \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) == \"\
    iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L) ==\
    \ \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphwmf19qr.d(58): Error: expression expected, not `unittest`\\\
    n/tmp/tmphwmf19qr.d(59): Error: comma expected separating array initializers,\
    \ not `{`\\n/tmp/tmphwmf19qr.d(77): Error: comma expected separating array initializers,\
    \ not `void`\\n/tmp/tmphwmf19qr.d(77): Error: semicolon expected, not `main`\\\
    n/tmp/tmphwmf19qr.d(77): Error: found `{` when expecting `;` following statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphwmf19qr.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    import\
    \ std.conv;\n    import std.range;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.typecons;\n    import std.math;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\n    import\
    \ std.typecons;\n    import std.math;\n    import std.algorithm;\n    import std.array;\n\
    \    import std.range;\n    import std.conv;\n    import std.string;\nunittest\n\
    {\n    alias candidate = int_to_mini_roman;\n\n    assert(candidate(19L) == \"\
    xix\");\n    assert(candidate(152L) == \"clii\");\n    assert(candidate(251L)\
    \ == \"ccli\");\n    assert(candidate(426L) == \"cdxxvi\");\n    assert(candidate(500L)\
    \ == \"d\");\n    assert(candidate(1L) == \"i\");\n    assert(candidate(4L) ==\
    \ \"iv\");\n    assert(candidate(43L) == \"xliii\");\n    assert(candidate(90L)\
    \ == \"xc\");\n    assert(candidate(94L) == \"xciv\");\n    assert(candidate(532L)\
    \ == \"dxxxii\");\n    assert(candidate(900L) == \"cm\");\n    assert(candidate(994L)\
    \ == \"cmxciv\");\n    assert(candidate(1000L) == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpom6wfx5y.d(87): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpom6wfx5y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given a positive integer,\
    \ obtain its roman numeral equivalent as a string,\n    and return it in lowercase.\n\
    \    Restrictions: 1 <= num <= 1000\n\n    Examples:\n    >>> int_to_mini_roman(19)\
    \ == 'xix'\n    >>> int_to_mini_roman(152) == 'clii'\n    >>> int_to_mini_roman(426)\
    \ == 'cdxxvi'\n    \n*/\nstring int_to_mini_roman(long number) \n{\n    static\
    \ string[10] roman_numerals = [\"\", \"i\", \"ii\", \"iii\", \"iv\", \"v\", \"\
    vi\", \"vii\", \"viii\", \"ix\"];\n    static string[10] roman_tens = [\"\", \"\
    x\", \"xx\", \"xxx\", \"xl\", \"l\", \"lx\", \"lxx\", \"lxxx\", \"xc\"];\n   \
    \ static string[10] roman_hundreds = [\"\", \"c\", \"cc\", \"ccc\", \"cd\", \"\
    d\", \"dc\", \"dcc\", \"dccc\", \"cm\"];\n    static string[4] roman_thousands\
    \ = [\"\", \"m\", \"mm\", \"mmm\"];\n    string result = \"\";\n    if (number\
    \ > 1000)\n        return \"\";\n    if (number >= 1000)\n    {\n        result\
    \ ~= roman_thousands[number / 1000];\n        number %= 1000;\n    }\n    if (number\
    \ >= 100)\n    {\n        result ~= roman_hundreds[number / 100];\n        number\
    \ %= 100;\n    }\n    if (number >= 10)\n    {\n        result ~= roman_tens[number\
    \ / 10];\n        number %= 10;\n    }\n    result ~= roman_numerals[number];\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = int_to_mini_roman;\n\
    \n    assert(candidate(19L) == \"xix\");\n    assert(candidate(152L) == \"clii\"\
    );\n    assert(candidate(251L) == \"ccli\");\n    assert(candidate(426L) == \"\
    cdxxvi\");\n    assert(candidate(500L) == \"d\");\n    assert(candidate(1L) ==\
    \ \"i\");\n    assert(candidate(4L) == \"iv\");\n    assert(candidate(43L) ==\
    \ \"xliii\");\n    assert(candidate(90L) == \"xc\");\n    assert(candidate(94L)\
    \ == \"xciv\");\n    assert(candidate(532L) == \"dxxxii\");\n    assert(candidate(900L)\
    \ == \"cm\");\n    assert(candidate(994L) == \"cmxciv\");\n    assert(candidate(1000L)\
    \ == \"m\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
