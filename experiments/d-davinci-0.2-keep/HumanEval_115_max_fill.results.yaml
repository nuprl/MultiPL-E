name: HumanEval_115_max_fill
language: humaneval_to_dlang.py
results:
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(fill / capacity);\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if(fill > 0)\n        {\n     \
    \       max_fill += ceil(fill / capacity);\n        }\n    }\n    return max_fill;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjhw0se97.d(53): Error: `std.math.ceil` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\n/tmp/tmpjhw0se97.d(60): Error: `std.math.ceil`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpjhw0se97.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n            else\n\
    \            {\n                if(fill > 0)\n                {\n            \
    \        max_fill += fill;\n                    fill = 0;\n                }\n\
    \            }\n        }\n        if(fill > 0)\n        {\n            max_fill\
    \ += fill;\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpcydguk3r.d(70): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429079]\\n??:? void tmpcydguk3r.__unittest_L65_C1()\
    \ [0x428051]\\n??:? void tmpcydguk3r.__modtest() [0x428268]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db7f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d56]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a825]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8b4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d2d]\\n??:? runModuleUnitTests [0x42d955]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294c8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42944f]\\n??:? _d_run_main [0x4293ba]\\n??:? main [0x42827b]\\\
    n??:? __libc_start_main [0xf8b38554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl6qlnv1l.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl6qlnv1l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvz4o1svd.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvz4o1svd.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(cast(double)fill / capacity);\n                    fill =\
    \ 0;\n                }\n            }\n        }\n        if(fill > 0)\n    \
    \    {\n            max_fill += ceil(cast(double)fill / capacity);\n        }\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp21daloe1.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp21daloe1.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp21daloe1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            fill += grid[i][j];\n        }\n        max_fill =\
    \ max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk7qi39xc.d(47): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk7qi39xc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyyi5bfz1.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpyyi5bfz1.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyyi5bfz1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long current_fill = 0;\n        for (long j = 0; j < grid[i].length;\
    \ j++) \n        {\n            current_fill += grid[i][j];\n            if (current_fill\
    \ > capacity) \n            {\n                max_fill += current_fill - capacity;\n\
    \                current_fill = capacity;\n            }\n        }\n    }\n \
    \   return max_fill;\n}\nlong min_fill(long[][] grid, long capacity) \n{\n   \
    \ long min_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n    {\n   \
    \     long current_fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            current_fill += grid[i][j];\n            if (current_fill\
    \ > capacity) \n            {\n                min_fill += current_fill - capacity;\n\
    \                current_fill = capacity;\n            }\n        }\n    }\n \
    \   return min_fill;\n}\nlong binary_search(long[][] grid, long capacity) \n{\n\
    \    long low = min_fill(grid, capacity);\n    long high = max_fill(grid, capacity);\n\
    \    while (low < high) \n    {\n        long mid = (low + high) / 2;\n      \
    \  if (mid == low) \n        {\n            break;\n        }\n        if (min_fill(grid,\
    \ mid) > mid) \n        {\n            low = mid;\n        } \n        else \n\
    \        {\n            high = mid;\n        }\n    }\n    return low;\n}\nlong\
    \ solve(long[][] grid, long capacity) \n{\n    return binary_search(grid, capacity);\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxdju98wx.d(103): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429311]\\n??:? void tmpxdju98wx.__unittest_L99_C1()\
    \ [0x4281b0]\\n??:? void tmpxdju98wx.__modtest() [0x4284fc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42de8b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428fee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ab31]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42abc0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42aabd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428fc5]\\n??:? runModuleUnitTests [0x42dc61]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4297d4]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42975b]\\n??:? _d_run_main [0x4296c6]\\n??:? main [0x42850f]\\\
    n??:? __libc_start_main [0x50a02554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            if (grid[i][j] == 1) \n            {\n            \
    \    fill += 1;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp93eaz2xa.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp93eaz2xa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                row_fill = 0;\n            }\n            max_fill\
    \ = max(max_fill, row_fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp018whn5f.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp018whn5f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprq7jhxmh.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmprq7jhxmh.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprq7jhxmh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity > 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity > 0)\n         \
    \   {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2kypmdxi.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp2kypmdxi.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp2kypmdxi.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfekekdht.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpfekekdht.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfekekdht.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                fill = 0;\n            }\n        }\n        max_fill\
    \ = max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_n5nclgj.d(54): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_n5nclgj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr04laiyv.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr04laiyv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp4dvtlj3x.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmp4dvtlj3x.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmp4dvtlj3x.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0xfcfe0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid) \n    {\n        long fill\
    \ = 0;\n        foreach(cell; row) \n        {\n            if(cell == 1) \n \
    \           {\n                fill++;\n            }\n            else \n   \
    \         {\n                max_fill = max(max_fill, fill);\n               \
    \ fill = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt7otqxvo.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpt7otqxvo.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpt7otqxvo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpflnhls6v.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpflnhls6v.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += min(row_fill, capacity);\n                    row_fill\
    \ = 0;\n                }\n            }\n        }\n        max_fill += min(row_fill,\
    \ capacity);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl6pwgz48.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpl6pwgz48.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpl6pwgz48.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzq9dxptq.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzq9dxptq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ total = 0;\n    long max_fill = 0;\n    for (long i = 0; i < rows; i++)\n  \
    \  {\n        for (long j = 0; j < cols; j++)\n        {\n            if (grid[i][j]\
    \ == 1)\n            {\n                total++;\n                max_fill = max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return min(total, max_fill + capacity);\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl_cslagl.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpl_cslagl.d(54): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpl_cslagl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        for (int j = 0; j < grid[i].length; j++)\n        {\n           \
    \ if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ j + 1);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz2k_mp_3.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz2k_mp_3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc9nwnu9h.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc9nwnu9h.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp274w_9l1.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp274w_9l1.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp274w_9l1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzw4jvaoq.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpzw4jvaoq.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpzw4jvaoq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9o7pk7q3.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp9o7pk7q3.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9o7pk7q3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        for (long j = 0; j < grid[i].length; j++)\n        {\n         \
    \   if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n\
    \    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy89mcy39.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy89mcy39.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long result = 0;\n    foreach(row; grid)\n    {\n        long row_max\
    \ = max(row);\n        if(row_max > 0)\n        {\n            result += row_max\
    \ / capacity;\n            if(row_max % capacity != 0)\n            {\n      \
    \          result++;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz8az105j.d(42): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz8az105j.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity > 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity > 0)\n         \
    \   {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsp_q5vus.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsp_q5vus.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoli8w845.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpoli8w845.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpoli8w845.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += min(fill, capacity);\n                    fill = 0;\n         \
    \       }\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfza07kip.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpfza07kip.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfza07kip.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long count\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                count++;\n            }\n        }\n        max_fill\
    \ += count / capacity;\n        if(count % capacity != 0)\n        {\n       \
    \     max_fill++;\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n  \
    \  alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfzwhi6ox.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpfzwhi6ox.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfzwhi6ox.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += (fill / capacity) + (fill % capacity > 0 ? 1 : 0);\n          \
    \          fill = 0;\n                }\n            }\n        }\n        if(fill\
    \ > 0)\n        {\n            max_fill += (fill / capacity) + (fill % capacity\
    \ > 0 ? 1 : 0);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(fill / capacity);\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if(fill > 0)\n        {\n     \
    \       max_fill += ceil(fill / capacity);\n        }\n    }\n    return max_fill;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsjl5dbiu.d(53): Error: `std.math.ceil` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\n/tmp/tmpsjl5dbiu.d(60): Error: `std.math.ceil`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpsjl5dbiu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppxn8tp21.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmppxn8tp21.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppxn8tp21.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity > 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity > 0)\n         \
    \   {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        long row_fill\
    \ = 0;\n        for (long j = 0; j < cols; j++)\n        {\n            if (grid[i][j]\
    \ == 1)\n            {\n                row_fill++;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill * capacity;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbsddj0kl.d(52): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbsddj0kl.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx4wvmgur.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx4wvmgur.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                max_fill += min(fill, capacity);\n              \
    \  fill = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwfrw8hbu.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpwfrw8hbu.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpwfrw8hbu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvmi9dkbn.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpvmi9dkbn.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpvmi9dkbn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc_hb2upr.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpc_hb2upr.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc_hb2upr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++) \n  \
    \  {\n        for (int j = 0; j < grid[i].length; j++) \n        {\n         \
    \   if (grid[i][j] == 1) \n            {\n                max_fill = max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n\
    \    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnv_87tz1.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnv_87tz1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                row_fill = 0;\n            }\n            max_fill\
    \ = max(max_fill, row_fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpedy16rwq.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpedy16rwq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(cast(double)fill / capacity);\n                    fill =\
    \ 0;\n                }\n            }\n        }\n        if(fill > 0)\n    \
    \    {\n            max_fill += ceil(cast(double)fill / capacity);\n        }\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5fo64y1f.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5fo64y1f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfplq3v2x.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpfplq3v2x.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpfplq3v2x.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xfc2e4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        long row_fill = 0;\n        for (int j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                row_fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, row_fill);\n    }\n\
    \    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n   \
    \ assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L)\
    \ == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L,\
    \ 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L, 0L],\
    \ [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L, 1L,\
    \ 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiqunklei.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiqunklei.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        long sum\
    \ = 0;\n        for (long j = 0; j < cols; j++)\n        {\n            sum +=\
    \ grid[i][j];\n        }\n        max_fill = max(max_fill, sum);\n    }\n    return\
    \ max_fill * capacity;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n  \
    \  assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L)\
    \ == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L,\
    \ 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L, 0L],\
    \ [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L, 1L,\
    \ 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe0s77snw.d(49): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe0s77snw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm41vonxx.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm41vonxx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            if (grid[i][j] == 1) \n            {\n            \
    \    fill++;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfu3y55eg.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfu3y55eg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_qqe_xuc.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_qqe_xuc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        for (long\
    \ j = 0; j < cols; j++)\n        {\n            if (grid[i][j] == 1)\n       \
    \     {\n                max_fill = max(max_fill, j);\n            }\n       \
    \ }\n    }\n    return max_fill * capacity;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp572ku0no.d(48): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp572ku0no.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyqc0_pbu.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpyqc0_pbu.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpyqc0_pbu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long n = grid.length;\n    long m = grid[0].length;\n    long max_fill\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        long fill = 0;\n   \
    \     for (long j = 0; j < m; j++) \n        {\n            if (grid[i][j] ==\
    \ 1) \n            {\n                fill++;\n            }\n        }\n    \
    \    max_fill = max(max_fill, fill);\n    }\n    return max_fill * capacity;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd9ioheg9.d(52): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd9ioheg9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjygu4_o2.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpjygu4_o2.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjygu4_o2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(cast(double)fill / capacity);\n                    fill =\
    \ 0;\n                }\n            }\n        }\n        if(fill > 0)\n    \
    \    {\n            max_fill += ceil(cast(double)fill / capacity);\n        }\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplbp29xtw.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplbp29xtw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity > 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity > 0)\n         \
    \   {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3j913xnj.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp3j913xnj.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3j913xnj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4cilxo3g.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp4cilxo3g.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4cilxo3g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpw6_aegjh.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpw6_aegjh.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpw6_aegjh.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xc6b7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_5me1a9k.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp_5me1a9k.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_5me1a9k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4h9z7j8k.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp4h9z7j8k.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4h9z7j8k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9no8a6h6.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp9no8a6h6.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9no8a6h6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += min(fill, capacity);\n                    fill = 0;\n         \
    \       }\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4_lqg5uy.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp4_lqg5uy.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp4_lqg5uy.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7xfxp458.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7xfxp458.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1r71xt9i.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1r71xt9i.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        long sum = 0;\n        for (long j = 0; j < grid[i].length; j++)\n\
    \        {\n            sum += grid[i][j];\n        }\n        max_fill = max(max_fill,\
    \ sum);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnf373n0n.d(47): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnf373n0n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb81yxo3m.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb81yxo3m.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyr94jiqr.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpyr94jiqr.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpyr94jiqr.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0x67596554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvkz7lbye.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpvkz7lbye.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpvkz7lbye.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcntqozf8.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpcntqozf8.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcntqozf8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_e92ja8.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp5_e92ja8.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5_e92ja8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkve6ldxj.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmpkve6ldxj.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmpkve6ldxj.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0x8abf0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(fill / capacity);\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if(fill > 0)\n        {\n     \
    \       max_fill += ceil(fill / capacity);\n        }\n    }\n    return max_fill;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp14yauh6s.d(53): Error: `std.math.ceil` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\n/tmp/tmp14yauh6s.d(60): Error: `std.math.ceil`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp14yauh6s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        for (long\
    \ j = 0; j < cols; j++)\n        {\n            if (grid[i][j] == 1)\n       \
    \     {\n                max_fill = max(max_fill, j);\n            }\n       \
    \ }\n    }\n    return max_fill * capacity;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbxrialda.d(48): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbxrialda.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxw0kx_tz.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmpxw0kx_tz.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmpxw0kx_tz.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0xab1e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                row_fill++;\n            }\n        }\n        max_fill\
    \ = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\nunittest\n{\n  \
    \  alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6d3qq0nm.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6d3qq0nm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity > 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity > 0)\n         \
    \   {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += ceil(row_fill / capacity);\n                    row_fill\
    \ = 0;\n                }\n            }\n        }\n        if(row_fill > 0)\n\
    \        {\n            max_fill += ceil(row_fill / capacity);\n        }\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy241w90f.d(53): Error: `std.math.ceil` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\n/tmp/tmpy241w90f.d(60): Error: `std.math.ceil`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpy241w90f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpqbo01bef.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpqbo01bef.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpqbo01bef.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0x48b94554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpurh9f4ys.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpurh9f4ys.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpurh9f4ys.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long n = grid.length;\n    long m = grid[0].length;\n    long max_fill\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        for (long j = 0; j <\
    \ m; j++) \n        {\n            if (grid[i][j] == 1) \n            {\n    \
    \            max_fill = max(max_fill, j);\n            }\n        }\n    }\n \
    \   return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47b8hrdj.d(48): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47b8hrdj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        for (long\
    \ j = 0; j < cols; j++)\n        {\n            if (grid[i][j] == 1)\n       \
    \     {\n                max_fill = max(max_fill, j);\n            }\n       \
    \ }\n    }\n    return max_fill * capacity;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy_q225nj.d(48): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy_q225nj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill_count = 0;\n    foreach(row; grid)\n    {\n        long\
    \ current_fill_count = 0;\n        foreach(well; row)\n        {\n           \
    \ if(well == 1)\n            {\n                current_fill_count++;\n      \
    \      }\n            else\n            {\n                if(current_fill_count\
    \ > 0)\n                {\n                    max_fill_count += current_fill_count\
    \ / capacity;\n                    if(current_fill_count % capacity != 0)\n  \
    \                  {\n                        max_fill_count++;\n            \
    \        }\n                    current_fill_count = 0;\n                }\n \
    \           }\n        }\n        if(current_fill_count > 0)\n        {\n    \
    \        max_fill_count += current_fill_count / capacity;\n            if(current_fill_count\
    \ % capacity != 0)\n            {\n                max_fill_count++;\n       \
    \     }\n        }\n    }\n    return max_fill_count;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8_nd2pz6.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp8_nd2pz6.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp8_nd2pz6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5l_tzeol.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5l_tzeol.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += ceil(fill / capacity);\n                    fill = 0;\n       \
    \         }\n            }\n        }\n        if(fill > 0)\n        {\n     \
    \       max_fill += ceil(fill / capacity);\n        }\n    }\n    return max_fill;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2d_vdxkw.d(53): Error: `std.math.ceil` called with argument types\
    \ `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\n/tmp/tmp2d_vdxkw.d(60): Error: `std.math.ceil`\
    \ called with argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp2d_vdxkw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += capacity - fill;\n                    fill = 0;\n             \
    \   }\n            }\n        }\n        if(fill > 0)\n        {\n           \
    \ max_fill += capacity - fill;\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxk3ge812.d(69): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429081]\\n??:? void tmpxk3ge812.__unittest_L65_C1()\
    \ [0x427f20]\\n??:? void tmpxk3ge812.__modtest() [0x42826c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db87]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d5e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a82d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8bc]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7b9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d35]\\n??:? runModuleUnitTests [0x42d95d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294d0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429457]\\n??:? _d_run_main [0x4293c2]\\n??:? main [0x42827f]\\\
    n??:? __libc_start_main [0x413ac554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                if(row_fill > 0)\n                {\n          \
    \          max_fill += row_fill / capacity;\n                    if(row_fill %\
    \ capacity != 0)\n                    {\n                        max_fill++;\n\
    \                    }\n                    row_fill = 0;\n                }\n\
    \            }\n        }\n        if(row_fill > 0)\n        {\n            max_fill\
    \ += row_fill / capacity;\n            if(row_fill % capacity != 0)\n        \
    \    {\n                max_fill++;\n            }\n        }\n    }\n    return\
    \ max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm62rk8ol.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpm62rk8ol.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpm62rk8ol.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprqes4emh.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmprqes4emh.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprqes4emh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += min(fill, capacity);\n                    fill = 0;\n         \
    \       }\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyud3f9t.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpcyud3f9t.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcyud3f9t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        long row_fill\
    \ = 0;\n        for (long j = 0; j < cols; j++)\n        {\n            row_fill\
    \ += grid[i][j];\n        }\n        max_fill = max(max_fill, row_fill);\n   \
    \ }\n    return max_fill * capacity;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq0x2k3mz.d(49): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq0x2k3mz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        max_fill\
    \ += row.count!(x => x == 1);\n    }\n    return max_fill * capacity;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm_kbwu66.d(42): Error: no property `count` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm_kbwu66.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4ebf395s.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4ebf395s.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxgxxkbdm.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxgxxkbdm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nlong min_buckets(long[][]\
    \ grid, long capacity) \n{\n    long max_fill = max_fill(grid, capacity);\n  \
    \  return ceil(max_fill / capacity);\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ymk8abl.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp2ymk8abl.d(61): Error: `std.math.ceil` called with\
    \ argument types `(long)` matches both:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4266):\
    \     `std.math.ceil(real x)`\\nand:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/math.d(4363):\
    \     `std.math.ceil(float x)`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp2ymk8abl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            fill += grid[i][j];\n        }\n        max_fill =\
    \ max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8gvabncy.d(47): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8gvabncy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        max_fill\
    \ += max(row);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvsd4m4e0.d(42): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvsd4m4e0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz007k90x.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpz007k90x.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz007k90x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += min(fill, capacity);\n                    fill = 0;\n         \
    \       }\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpns8pih0n.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpns8pih0n.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpns8pih0n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp6n07zo25.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmp6n07zo25.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmp6n07zo25.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0x1f762554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpob8ljmk7.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpob8ljmk7.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpob8ljmk7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcbjsu9d6.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpcbjsu9d6.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcbjsu9d6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0q8nqugm.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp0q8nqugm.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp0q8nqugm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        long fill = 0;\n        for (int j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv3bfv6en.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv3bfv6en.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzv84jgfu.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpzv84jgfu.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpzv84jgfu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid) \n    {\n        long fill\
    \ = 0;\n        foreach(well; row) \n        {\n            if(well == 1) \n \
    \           {\n                fill++;\n            }\n            else \n   \
    \         {\n                max_fill = max(max_fill, fill);\n               \
    \ fill = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9nli4a2s.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp9nli4a2s.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9nli4a2s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            if (grid[i][j] == 1) \n            {\n            \
    \    fill++;\n            }\n        }\n        max_fill = max(max_fill, fill);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3heixnfz.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3heixnfz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl3rccqdl.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpl3rccqdl.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpl3rccqdl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        foreach(well;\
    \ row)\n        {\n            if(well == 1)\n            {\n                max_fill\
    \ += capacity;\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpryfhkc_b.d(57): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429041]\\n??:? void tmpryfhkc_b.__unittest_L52_C1()\
    \ [0x428019]\\n??:? void tmpryfhkc_b.__modtest() [0x428230]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db47]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d1e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a7ed]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a87c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a779]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428cf5]\\n??:? runModuleUnitTests [0x42d91d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429490]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429417]\\n??:? _d_run_main [0x429382]\\n??:? main [0x428243]\\\
    n??:? __libc_start_main [0x8a12e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp13gz1fnj.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp13gz1fnj.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp13gz1fnj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                max_fill += min(row_fill, capacity);\n         \
    \       row_fill = 0;\n            }\n        }\n        max_fill += min(row_fill,\
    \ capacity);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkzb_wt9d.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpkzb_wt9d.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpkzb_wt9d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long n = grid.length;\n    long m = grid[0].length;\n    long max_fill\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        long fill = 0;\n   \
    \     for (long j = 0; j < m; j++) \n        {\n            fill += grid[i][j];\n\
    \        }\n        max_fill = max(max_fill, fill);\n    }\n    return max_fill\
    \ * capacity;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpthd5sl6r.d(49): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpthd5sl6r.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long sum\
    \ = 0;\n        foreach(well; row)\n        {\n            sum += well;\n    \
    \        if(sum > capacity)\n            {\n                max_fill += capacity;\n\
    \                sum = well;\n            }\n        }\n        max_fill += sum;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxwxb3fr5.d(61): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429071]\\n??:? void tmpxwxb3fr5.__unittest_L56_C1()\
    \ [0x428045]\\n??:? void tmpxwxb3fr5.__modtest() [0x42825c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db77]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d4e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a81d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8ac]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a9]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d25]\\n??:? runModuleUnitTests [0x42d94d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294c0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429447]\\n??:? _d_run_main [0x4293b2]\\n??:? main [0x42826f]\\\
    n??:? __libc_start_main [0xfeaf554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7vzcr5op.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7vzcr5op.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_f548xf.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpz_f548xf.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz_f548xf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        for (int j = 0; j < grid[i].length; j++)\n        {\n           \
    \ if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ j + 1);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl7wrmjjn.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl7wrmjjn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf15qw7w0.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf15qw7w0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill++;\n            }\n            else\n  \
    \          {\n                row_fill = 0;\n            }\n            max_fill\
    \ = max(max_fill, row_fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxghixpw5.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxghixpw5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        for (long j = 0; j < grid[i].length; j++)\n        {\n         \
    \   if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n\
    \    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_gwoe4t.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_gwoe4t.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjwccztn.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjwccztn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        for (long\
    \ j = 0; j < cols; j++)\n        {\n            if (grid[i][j] == 1)\n       \
    \     {\n                max_fill = max(max_fill, j);\n            }\n       \
    \ }\n    }\n    return min(max_fill + 1, capacity);\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfeqzm6mh.d(48): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpfeqzm6mh.d(52): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfeqzm6mh.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    long row_count = grid.length;\n    long col_count\
    \ = grid[0].length;\n    long[][] max_fill_grid = new long[row_count][col_count];\n\
    \    foreach(row; grid)\n    {\n        foreach(col; row)\n        {\n       \
    \     if(col == 1)\n            {\n                max_fill_grid[row][col] = capacity;\n\
    \            }\n            else\n            {\n                max_fill_grid[row][col]\
    \ = 0;\n            }\n        }\n    }\n    foreach(row; max_fill_grid)\n   \
    \ {\n        foreach(col; row)\n        {\n            if(col == 1)\n        \
    \    {\n                max_fill += capacity;\n            }\n        }\n    }\n\
    \    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n   \
    \ assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L)\
    \ == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L,\
    \ 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L, 0L],\
    \ [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L, 1L,\
    \ 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnqpc3rwt.d(42): Error: variable `row_count` cannot be read at\
    \ compile time\\n/tmp/tmpnqpc3rwt.d(49): Error: cannot implicitly convert expression\
    \ `row` of type `long[]` to `ulong`\\n/tmp/tmpnqpc3rwt.d(53): Error: cannot implicitly\
    \ convert expression `row` of type `long[]` to `ulong`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpnqpc3rwt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxg2litxt.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmpxg2litxt.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmpxg2litxt.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0xb4690554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpebns8qdi.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpebns8qdi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    return max_fill;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnz3h1z87.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnz3h1z87.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp657d5kfl.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp657d5kfl.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp657d5kfl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwmknyeze.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpwmknyeze.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpwmknyeze.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xa5d20554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi7y3q7f6.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpi7y3q7f6.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpi7y3q7f6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(col; row)\n        {\n            if(col == 1)\n     \
    \       {\n                row_fill += capacity;\n            }\n        }\n \
    \       max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp99olhulg.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp99olhulg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++)\n  \
    \  {\n        long fill = 0;\n        for (long j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, fill);\n    }\n  \
    \  return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphzgoba2n.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphzgoba2n.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt0clmj3l.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt0clmj3l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpn630sm53.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpn630sm53.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpn630sm53.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0x4cd2e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprwo0rs7f.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprwo0rs7f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppikyx5pv.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmppikyx5pv.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppikyx5pv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprhm9ggts.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmprhm9ggts.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprhm9ggts.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpctdrzf8e.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpctdrzf8e.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpctdrzf8e.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0x7df37554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmbp76645.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpmbp76645.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpmbp76645.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        long row_fill = 0;\n        for (int j = 0; j < grid[i].length; j++)\n\
    \        {\n            if (grid[i][j] == 1)\n            {\n                row_fill++;\n\
    \            }\n        }\n        max_fill = max(max_fill, row_fill);\n    }\n\
    \    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n   \
    \ assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L)\
    \ == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L,\
    \ 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L, 0L],\
    \ [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L, 1L,\
    \ 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpykja5ap6.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpykja5ap6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptmsxf8eg.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptmsxf8eg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            fill += cell;\n   \
    \         if(fill > capacity)\n            {\n                max_fill += capacity;\n\
    \                fill = 0;\n            }\n        }\n        max_fill += fill;\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1hq2p60c.d(60): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429069]\\n??:? void tmp1hq2p60c.__unittest_L56_C1()\
    \ [0x427f0c]\\n??:? void tmp1hq2p60c.__modtest() [0x428258]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db6f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d46]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a815]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8a4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7a1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d1d]\\n??:? runModuleUnitTests [0x42d945]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294b8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42943f]\\n??:? _d_run_main [0x4293aa]\\n??:? main [0x42826b]\\\
    n??:? __libc_start_main [0x9391f554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill += capacity;\n            }\n        }\n   \
    \     max_fill = max(max_fill, fill);\n    }\n    return max_fill;\n}\nlong min_fill(long[][]\
    \ grid, long capacity) \n{\n    long min_fill = max_fill(grid, capacity);\n  \
    \  foreach(row; grid)\n    {\n        long fill = 0;\n        foreach(well; row)\n\
    \        {\n            if(well == 1)\n            {\n                fill +=\
    \ capacity;\n            }\n            else\n            {\n                fill\
    \ = 0;\n            }\n            min_fill = min(min_fill, fill);\n        }\n\
    \    }\n    return min_fill;\n}\nlong min_buckets(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = max_fill(grid, capacity);\n    long min_fill = min_fill(grid,\
    \ capacity);\n    return (max_fill - min_fill) / capacity + 1;\n}\nunittest\n\
    {\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L],\
    \ [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps13_6uq4.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmps13_6uq4.d(70): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmps13_6uq4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq3n6gue6.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpq3n6gue6.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpq3n6gue6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        for (int j = 0; j < grid[i].length; j++)\n        {\n           \
    \ if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ j);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n\
    \    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpho6qwp6o.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpho6qwp6o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0157jgop.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0157jgop.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long rows = grid.length;\n    long cols = grid[0].length;\n    long\
    \ max_fill = 0;\n    for (long i = 0; i < rows; i++)\n    {\n        long fill\
    \ = 0;\n        for (long j = 0; j < cols; j++)\n        {\n            if (grid[i][j]\
    \ == 1)\n            {\n                fill++;\n            }\n        }\n  \
    \      max_fill = max(max_fill, fill);\n    }\n    return max_fill * capacity;\n\
    }\nunittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L,\
    \ 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2u434vjh.d(52): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2u434vjh.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill += min(fill, capacity);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n \
    \   }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1r8m9j3.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpr1r8m9j3.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpr1r8m9j3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long result = 0;\n    long row_count = grid.length;\n    long col_count\
    \ = grid[0].length;\n    long[][] buckets = new long[row_count][col_count];\n\
    \    long[][] visited = new long[row_count][col_count];\n    long[][] directions\
    \ = [\n        [0, 1],\n        [0, -1],\n        [1, 0],\n        [-1, 0]\n \
    \   ];\n    long[] start = [0, 0];\n    long[] end = [row_count - 1, col_count\
    \ - 1];\n    long[] current = start;\n    long[] next = start;\n    long[] direction\
    \ = [0, 0];\n    long[] next_direction = [0, 0];\n    long row = 0;\n    long\
    \ col = 0;\n    long next_row = 0;\n    long next_col = 0;\n    long next_bucket\
    \ = 0;\n    long next_water = 0;\n    long water = 0;\n    long bucket = 0;\n\
    \    long max_water = 0;\n    long max_bucket = 0;\n    long max_row = 0;\n  \
    \  long max_col = 0;\n    long max_direction = 0;\n    long max_next_bucket =\
    \ 0;\n    long max_next_water = 0;\n    long max_next_row = 0;\n    long max_next_col\
    \ = 0;\n    long max_next_direction = 0;\n    long max_result = 0;\n    long max_visited\
    \ = 0;\n    long max_buckets = 0;\n    long max_grid = 0;\n    long max_directions\
    \ = 0;\n    long max_start = 0;\n    long max_end = 0;\n    long max_current =\
    \ 0;\n    long max_next = 0;\n    long max_direction = 0;\n    long max_next_direction\
    \ = 0;\n    long max_row = 0;\n    long max_col = 0;\n    long max_next_row =\
    \ 0;\n    long max_next_col = 0;\n    long max_next_bucket = 0;\n    long max_next_\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnrn0jjfv.d(91): Error: semicolon expected, not `unittest`\\n/tmp/tmpnrn0jjfv.d(91):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpnrn0jjfv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxs8c26tv.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpxs8c26tv.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpxs8c26tv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                if(fill > 0)\n                {\n               \
    \     max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp6epyj23.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpp6epyj23.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpp6epyj23.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xdcb95554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppctqlc_o.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmppctqlc_o.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmppctqlc_o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (long i = 0; i < grid.length; i++) \n \
    \   {\n        long sum = 0;\n        for (long j = 0; j < grid[i].length; j++)\
    \ \n        {\n            sum += grid[i][j];\n        }\n        max_fill = max(max_fill,\
    \ sum);\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpame63wir.d(47): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpame63wir.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    for (int i = 0; i < grid.length; i++)\n   \
    \ {\n        for (int j = 0; j < grid[i].length; j++)\n        {\n           \
    \ if (grid[i][j] == 1)\n            {\n                max_fill = max(max_fill,\
    \ i);\n            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n\
    \    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl0zvis8o.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl0zvis8o.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdbnb5o6v.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpdbnb5o6v.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpdbnb5o6v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += min(fill, capacity);\n                    fill = 0;\n         \
    \       }\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9p6bue67.d(53): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp9p6bue67.d(58): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9p6bue67.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                max_fill += min(fill, capacity);\n              \
    \  fill = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprsf7fwqs.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmprsf7fwqs.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprsf7fwqs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj74r4gth.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj74r4gth.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                row_fill++;\n            }\n        }\n        max_fill\
    \ = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\nunittest\n{\n  \
    \  alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L,\
    \ 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L,\
    \ 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr_f7hh15.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_f7hh15.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbqsx5y_w.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbqsx5y_w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity != 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity != 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc3vz0l70.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmpc3vz0l70.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc3vz0l70.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    if(fill % capacity > 0)\n\
    \                    {\n                        max_fill++;\n                \
    \    }\n                    fill = 0;\n                }\n            }\n    \
    \    }\n        if(fill > 0)\n        {\n            max_fill += fill / capacity;\n\
    \            if(fill % capacity > 0)\n            {\n                max_fill++;\n\
    \            }\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias\
    \ candidate = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L,\
    \ 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L],\
    \ [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5oyhp363.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5oyhp363.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                max_fill += min(fill, capacity);\n              \
    \  fill = 0;\n            }\n        }\n        max_fill += min(fill, capacity);\n\
    \    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\
    \n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3sodvazd.d(51): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmp3sodvazd.d(55): Error: undefined identifier `min`,\
    \ did you mean function `main`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3sodvazd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ka6g78a.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp3ka6g78a.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3ka6g78a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill += 1;\n            }\n            else\n   \
    \         {\n                if(fill > 0)\n                {\n               \
    \     max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpdiztkzqf.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpdiztkzqf.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpdiztkzqf.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xc08ae554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                fill = 0;\n            }\n            max_fill = max(max_fill,\
    \ fill);\n        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpt89rhu1e.d(53): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpt89rhu1e.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzpjzk8yq.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzpjzk8yq.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long n = grid.length;\n    long m = grid[0].length;\n    long max_fill\
    \ = 0;\n    for (long i = 0; i < n; i++) \n    {\n        for (long j = 0; j <\
    \ m; j++) \n        {\n            max_fill = max(max_fill, grid[i][j]);\n   \
    \     }\n    }\n    return max_fill * capacity;\n}\nunittest\n{\n    alias candidate\
    \ = max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphyl3b7es.d(46): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphyl3b7es.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpglcfb3mc.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpglcfb3mc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long row_fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                row_fill += capacity;\n            }\n        }\n\
    \        max_fill = max(max_fill, row_fill);\n    }\n    return max_fill;\n}\n\
    unittest\n{\n    alias candidate = max_fill;\n\n    assert(candidate([[0L, 0L,\
    \ 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L,\
    \ 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n\
    \    assert(candidate([[0L, 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L,\
    \ 1L, 1L, 1L], [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L,\
    \ 1L, 1L], [1L, 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_hvi0kxn.d(50): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_hvi0kxn.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(cell; row)\n        {\n            if(cell == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                max_fill = max(max_fill, fill);\n                fill\
    \ = 0;\n            }\n        }\n        max_fill = max(max_fill, fill);\n  \
    \  }\n    return max_fill;\n}\nunittest\n{\n    alias candidate = max_fill;\n\n\
    \    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L, 1L, 1L, 1L]],\
    \ 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L, 0L,\
    \ 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L, 1L,\
    \ 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0k4oqfgm.d(51): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\n/tmp/tmp0k4oqfgm.d(55): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp0k4oqfgm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n\n    You are given a rectangular grid of wells.\
    \ Each row represents a single well,\n    and each 1 in a row represents a single\
    \ unit of water.\n    Each well has a corresponding bucket that can be used to\
    \ extract water from it, \n    and all buckets have the same capacity.\n    Your\
    \ task is to use the buckets to empty the wells.\n    Output the number of times\
    \ you need to lower the buckets.\n\n    Example 1:\n        Input: \n        \
    \    grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n\
    \        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1],\
    \ [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output:\
    \ 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n\
    \            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n    \
    \    * all wells have the same length\n        * 1 <= grid.length <= 10^2\n  \
    \      * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n      \
    \  * 1 <= capacity <= 10\n    \n*/\nlong max_fill(long[][] grid, long capacity)\
    \ \n{\n    long max_fill = 0;\n    foreach(row; grid)\n    {\n        long fill\
    \ = 0;\n        foreach(well; row)\n        {\n            if(well == 1)\n   \
    \         {\n                fill++;\n            }\n            else\n      \
    \      {\n                if(fill > 0)\n                {\n                  \
    \  max_fill += fill / capacity;\n                    fill = fill % capacity;\n\
    \                }\n            }\n        }\n        if(fill > 0)\n        {\n\
    \            max_fill += fill / capacity;\n            fill = fill % capacity;\n\
    \        }\n    }\n    return max_fill;\n}\nunittest\n{\n    alias candidate =\
    \ max_fill;\n\n    assert(candidate([[0L, 0L, 1L, 0L], [0L, 1L, 0L, 0L], [1L,\
    \ 1L, 1L, 1L]], 1L) == 6L);\n    assert(candidate([[0L, 0L, 1L, 1L], [0L, 0L,\
    \ 0L, 0L], [1L, 1L, 1L, 1L], [0L, 1L, 1L, 1L]], 2L) == 5L);\n    assert(candidate([[0L,\
    \ 0L, 0L], [0L, 0L, 0L]], 5L) == 0L);\n    assert(candidate([[1L, 1L, 1L, 1L],\
    \ [1L, 1L, 1L, 1L]], 2L) == 4L);\n    assert(candidate([[1L, 1L, 1L, 1L], [1L,\
    \ 1L, 1L, 1L]], 9L) == 2L);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc1zjass1.d(71): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429099]\\n??:? void tmpc1zjass1.__unittest_L66_C1()\
    \ [0x42806d]\\n??:? void tmpc1zjass1.__modtest() [0x428284]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42db9f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x428d76]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42a845]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42a8d4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42a7d1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x428d4d]\\n??:? runModuleUnitTests [0x42d975]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x4294e8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x42946f]\\n??:? _d_run_main [0x4293da]\\n??:? main [0x428297]\\\
    n??:? __libc_start_main [0xc9ee7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
