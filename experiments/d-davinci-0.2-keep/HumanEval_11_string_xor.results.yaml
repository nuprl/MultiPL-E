name: HumanEval_11_string_xor
language: humaneval_to_dlang.py
results:
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn_33x7ws.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn_33x7ws.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        }\n        else \n        {\n            result += \"1\";\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpak0xkqs1.d(16): Error: slice `result` is not mutable\\n/tmp/tmpak0xkqs1.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpak0xkqs1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       if (c == b[i])\n            result ~= \"0\";\n        else\n         \
    \   result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    int len = max(a.length, b.length);\n\
    \    for (int i = 0; i < len; i++)\n    {\n        if (a[i] == b[i])\n       \
    \     result ~= \"0\";\n        else\n            result ~= \"1\";\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4w09la3f.d(12): Error: undefined identifier `max`, did you mean\
    \ function `fmax`?\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4w09la3f.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       if(c == b[i])\n            result ~= \"0\";\n        else\n          \
    \  result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        res += ((a[i] == '1') ^ (b[i] == '1')) ? '1' : '0';\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n\
    \    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwh29ksl1.d(14): Error: slice `res` is not mutable\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwh29ksl1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbo4sbhz2.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbo4sbhz2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpms0ip_xl.d(16): Error: slice `result` is not mutable\\n/tmp/tmpms0ip_xl.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpms0ip_xl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7wbt3nph.d(16): Error: slice `result` is not mutable\\n/tmp/tmp7wbt3nph.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7wbt3nph.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if\
    \ (c == b[i])\n            result ~= '0';\n        else\n            result ~=\
    \ '1';\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(a[i]\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2b3xrpm4.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp2b3xrpm4.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp2b3xrpm4.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x1bbb4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4kxxhpl_.d(16): Error: slice `result` is not mutable\\n/tmp/tmp4kxxhpl_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4kxxhpl_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu30a9x56.d(16): Error: slice `result` is not mutable\\n/tmp/tmpu30a9x56.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpu30a9x56.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_vyfac5p.d(16): Error: slice `result` is not mutable\\n/tmp/tmp_vyfac5p.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_vyfac5p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, char; a)\n    {\n\
    \        if(a[i] == b[i])\n            result ~= \"0\";\n        else\n      \
    \      result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcle6pee6.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcle6pee6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp2ugvtdfv.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp2ugvtdfv.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp2ugvtdfv.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x3a2bc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp686kybxe.d(16): Error: slice `result` is not mutable\\n/tmp/tmp686kybxe.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp686kybxe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmphbgrxjgq.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmphbgrxjgq.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmphbgrxjgq.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xa8b05554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, aa; a)\n    {\n       \
    \ int ai = aa - '0';\n        int bi = b[i] - '0';\n        result ~= (ai ^ bi)\
    \ + '0';\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa8tsahtl.d(16): Error: slice `result` is not mutable\\n/tmp/tmpa8tsahtl.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpa8tsahtl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw4q20lgs.d(16): Error: slice `result` is not mutable\\n/tmp/tmpw4q20lgs.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpw4q20lgs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp8gdrhxm5.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp8gdrhxm5.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp8gdrhxm5.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x4f8c6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjblyqrzm.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpjblyqrzm.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpjblyqrzm.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x3113b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0y3otrr.d(16): Error: slice `result` is not mutable\\n/tmp/tmpp0y3otrr.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpp0y3otrr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprszhd04s.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmprszhd04s.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmprszhd04s.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x1c173554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    foreach(i, c; a)\n    {\n    \
    \    res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpk7ay8ih7.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpk7ay8ih7.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpk7ay8ih7.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xc73c6554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp95st1di9.d(16): Error: slice `result` is not mutable\\n/tmp/tmp95st1di9.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp95st1di9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string ret;\n    foreach(i, c; a)\n    {\n        ret\
    \ ~= (c == b[i]) ? '0' : '1';\n    }\n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a) \n    {\n\
    \        result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxckuxjys.d(16): Error: slice `result` is not mutable\\n/tmp/tmpxckuxjys.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxckuxjys.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpedfo55jj.d(16): Error: slice `result` is not mutable\\n/tmp/tmpedfo55jj.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpedfo55jj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(int i; 0 .. a.length)\n\
    \    {\n        result ~= (a[i] ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8m0wd1l1.d(12): Error: cannot implicitly convert expression `a.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp8m0wd1l1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(immutable i, immutable\
    \ c; a)\n    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpzmmurpgr.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427fa5]\\n??:? void tmpzmmurpgr.__unittest_L18_C1()\
    \ [0x427bb5]\\n??:? void tmpzmmurpgr.__modtest() [0x427d28]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6af]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5be]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff95]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430444]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff21]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b595]\\n??:? runModuleUnitTests [0x42c485]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428468]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283ef]\\n??:? _d_run_main [0x42835a]\\n??:? main [0x427d3b]\\\
    n??:? __libc_start_main [0xbb89554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(int i; 0 .. a.length)\n\
    \    {\n        result ~= (a[i] ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvfjtd8k5.d(12): Error: cannot implicitly convert expression `a.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpvfjtd8k5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, char; a)\n    {\n\
    \        if(a[i] == b[i])\n            result ~= \"0\";\n        else\n      \
    \      result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbwet9dq4.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbwet9dq4.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       if(c == b[i])\n            result ~= \"0\";\n        else\n          \
    \  result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        }\n        else \n        {\n            result += \"1\";\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw6cdqdze.d(16): Error: slice `result` is not mutable\\n/tmp/tmpw6cdqdze.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpw6cdqdze.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, char; a)\n    {\n\
    \        if(a[i] == b[i])\n            result ~= \"0\";\n        else\n      \
    \      result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg91s6x3n.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg91s6x3n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkctkyimj.d(16): Error: slice `result` is not mutable\\n/tmp/tmpkctkyimj.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpkctkyimj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkfoidyvm.d(16): Error: slice `result` is not mutable\\n/tmp/tmpkfoidyvm.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpkfoidyvm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp453ud5wa.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp453ud5wa.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    int len = a.length;\n    string result = \"\";\n    for\
    \ (int i = 0; i < len; i++)\n    {\n        if (a[i] == b[i])\n        {\n   \
    \         result ~= \"0\";\n        }\n        else\n        {\n            result\
    \ ~= \"1\";\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1v7jqfu.d(11): Error: cannot implicitly convert expression `a.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpr1v7jqfu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i])\n            result += \"0\";\n    \
    \    else\n            result += \"1\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv65syvjk.d(15): Error: slice `result` is not mutable\\n/tmp/tmpv65syvjk.d(17):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpv65syvjk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpljdojawz.d(16): Error: slice `result` is not mutable\\n/tmp/tmpljdojawz.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpljdojawz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(int i, char c; a)\n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_rhqjazb.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f9d]\\n??:? void tmp_rhqjazb.__unittest_L18_C1()\
    \ [0x427ba9]\\n??:? void tmp_rhqjazb.__modtest() [0x427d1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff8d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43043c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff19]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c47d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428460]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283e7]\\n??:? _d_run_main [0x428352]\\n??:? main [0x427d2f]\\\
    n??:? __libc_start_main [0xe0c38554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo4e109ww.d(16): Error: slice `result` is not mutable\\n/tmp/tmpo4e109ww.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpo4e109ww.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpycq__phq.d(16): Error: slice `result` is not mutable\\n/tmp/tmpycq__phq.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpycq__phq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpokb8w60k.d(16): Error: slice `result` is not mutable\\n/tmp/tmpokb8w60k.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpokb8w60k.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    foreach(i, c; a)\n    {\n    \
    \    res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxa1s61_1.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpxa1s61_1.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpxa1s61_1.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x1833e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp1kcknppl.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp1kcknppl.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp1kcknppl.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x3f23e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqtkulifg.d(16): Error: slice `result` is not mutable\\n/tmp/tmpqtkulifg.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpqtkulifg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz5xkns7v.d(16): Error: slice `result` is not mutable\\n/tmp/tmpz5xkns7v.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpz5xkns7v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx7mc5lzb.d(16): Error: slice `result` is not mutable\\n/tmp/tmpx7mc5lzb.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpx7mc5lzb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfc6e5_ah.d(16): Error: slice `result` is not mutable\\n/tmp/tmpfc6e5_ah.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpfc6e5_ah.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp0fm1l19d.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp0fm1l19d.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp0fm1l19d.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x99b51554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppj3hpema.d(16): Error: slice `result` is not mutable\\n/tmp/tmppj3hpema.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppj3hpema.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoe5rtlxm.d(16): Error: slice `result` is not mutable\\n/tmp/tmpoe5rtlxm.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpoe5rtlxm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            res += \"0\"\
    ;\n        }\n        else \n        {\n            res += \"1\";\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n\
    \    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi5besbr7.d(16): Error: slice `res` is not mutable\\n/tmp/tmpi5besbr7.d(20):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpi5besbr7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprqms5bk9.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprqms5bk9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz1y24_ct.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz1y24_ct.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu90xl4us.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu90xl4us.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyjw6e73f.d(16): Error: slice `result` is not mutable\\n/tmp/tmpyjw6e73f.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpyjw6e73f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(int i, char c; a) \n\
    \    {\n        result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph3ysus1r.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f9d]\\n??:? void tmph3ysus1r.__unittest_L18_C1()\
    \ [0x427ba9]\\n??:? void tmph3ysus1r.__modtest() [0x427d1c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c6a7]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff8d]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x43043c]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff19]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b58d]\\n??:? runModuleUnitTests [0x42c47d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428460]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283e7]\\n??:? _d_run_main [0x428352]\\n??:? main [0x427d2f]\\\
    n??:? __libc_start_main [0xff926554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, char; a)\n    {\n\
    \        result ~= (a[i] ^ b[i]).to!string;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmhf3lpkb.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmhf3lpkb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprkhvyr40.d(16): Error: slice `result` is not mutable\\n/tmp/tmprkhvyr40.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmprkhvyr40.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2a9u3grg.d(16): Error: slice `result` is not mutable\\n/tmp/tmp2a9u3grg.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2a9u3grg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfxee38_w.d(16): Error: slice `result` is not mutable\\n/tmp/tmpfxee38_w.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpfxee38_w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplrxoq0nj.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmplrxoq0nj.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmplrxoq0nj.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x57da4554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        }\n        else \n        {\n            result += \"1\";\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9iwy6y5d.d(16): Error: slice `result` is not mutable\\n/tmp/tmp9iwy6y5d.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9iwy6y5d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprrfdx4io.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmprrfdx4io.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmprrfdx4io.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xed673554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp20h8z08g.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmp20h8z08g.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmp20h8z08g.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xcfd73554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr3f_zn79.d(16): Error: slice `result` is not mutable\\n/tmp/tmpr3f_zn79.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpr3f_zn79.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4fmu68p5.d(16): Error: slice `result` is not mutable\\n/tmp/tmp4fmu68p5.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp4fmu68p5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7r_39_6b.d(16): Error: slice `result` is not mutable\\n/tmp/tmp7r_39_6b.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp7r_39_6b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmph94qlo26.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmph94qlo26.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmph94qlo26.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x8d350554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpy3iichbn.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpy3iichbn.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpy3iichbn.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x2ea56554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= c ^ b[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpxzm_n0mx.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpxzm_n0mx.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpxzm_n0mx.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x5c9c8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        }\n        else \n        {\n            result += \"1\";\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps7xznab7.d(16): Error: slice `result` is not mutable\\n/tmp/tmps7xznab7.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmps7xznab7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res;\n    foreach(i, c; a)\n    {\n        res\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsa3k_wse.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpsa3k_wse.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpsa3k_wse.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xfc0f1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i])\n            result += \"0\";\n    \
    \    else\n            result += \"1\";\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0unxtsp8.d(15): Error: slice `result` is not mutable\\n/tmp/tmp0unxtsp8.d(17):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp0unxtsp8.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpp5g2715m.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpp5g2715m.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpp5g2715m.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x689c7554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, aa; a)\n    {\n\
    \        result ~= aa ^ b[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmplpt97d5m.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmplpt97d5m.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmplpt97d5m.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x3545b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp37qd1xqq.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp37qd1xqq.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp37qd1xqq.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x88371554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    foreach(i, c; a)\n    {\n    \
    \    res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmprog5e7q3.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmprog5e7q3.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmprog5e7q3.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x9005c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpicyiav0i.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpicyiav0i.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppvymr5hx.d(16): Error: slice `result` is not mutable\\n/tmp/tmppvymr5hx.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppvymr5hx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp7v9gkbnt.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp7v9gkbnt.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp7v9gkbnt.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x4967e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n            res += \"0\";\n        else\n\
    \            res += \"1\";\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1f0stcx2.d(15): Error: slice `res` is not mutable\\n/tmp/tmp1f0stcx2.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp1f0stcx2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphbqisd1r.d(16): Error: slice `result` is not mutable\\n/tmp/tmphbqisd1r.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphbqisd1r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp09h7auhw.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp09h7auhw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpnh2hoq8w.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpnh2hoq8w.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpnh2hoq8w.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x64378554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpql2jp01n.d(16): Error: slice `result` is not mutable\\n/tmp/tmpql2jp01n.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpql2jp01n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplfiluz_i.d(16): Error: slice `result` is not mutable\\n/tmp/tmplfiluz_i.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplfiluz_i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfuf9v7_2.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfuf9v7_2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        res += (a[i] ^ b[i]) + '0';\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0vkodcan.d(14): Error: incompatible types for `(res) += ((cast(int)a[cast(ulong)i]\
    \ ^ cast(int)b[cast(ulong)i]) + 48)`: `string` and `int`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmp0vkodcan.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, aa; a)\n    {\n\
    \        result ~= (aa ^ b[i]).to!string;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk4is79rw.d(14): Error: no property `to` for type `int`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk4is79rw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    foreach(i, c; a)\n    {\n    \
    \    res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpaz627my3.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpaz627my3.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpaz627my3.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xfa47c554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c == b[i]) ? '0' : '1';\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        res += (a[i] == b[i]) ? '0' : '1';\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_g19p6c.d(14): Error: slice `res` is not mutable\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_g19p6c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp171k83lq.d(16): Error: slice `result` is not mutable\\n/tmp/tmp171k83lq.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp171k83lq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_v4twim_.d(16): Error: slice `result` is not mutable\\n/tmp/tmp_v4twim_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_v4twim_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9wehlqrq.d(16): Error: slice `result` is not mutable\\n/tmp/tmp9wehlqrq.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp9wehlqrq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwp8iqdd_.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpwp8iqdd_.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpwp8iqdd_.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xc1eed554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphc5qujt7.d(16): Error: slice `result` is not mutable\\n/tmp/tmphc5qujt7.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphc5qujt7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa3p0ye2p.d(16): Error: slice `result` is not mutable\\n/tmp/tmpa3p0ye2p.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpa3p0ye2p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm9lsnv5j.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm9lsnv5j.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpyhm9zsoe.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpyhm9zsoe.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpyhm9zsoe.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x180af554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzzjmtxtl.d(16): Error: slice `result` is not mutable\\n/tmp/tmpzzjmtxtl.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpzzjmtxtl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, char; a)\n    {\n\
    \        result ~= (a[i] ^ b[i]).to!string;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe8gf5pa6.d(12): Error: no identifier for declarator `char`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe8gf5pa6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpwafy1c01.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpwafy1c01.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpwafy1c01.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x8124d554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       if(c == b[i])\n            result ~= \"0\";\n        else\n          \
    \  result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc75jd5p9.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpc75jd5p9.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpc75jd5p9.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x9d1be554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplailngo1.d(16): Error: slice `result` is not mutable\\n/tmp/tmplailngo1.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmplailngo1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3c1o0bbg.d(16): Error: slice `result` is not mutable\\n/tmp/tmp3c1o0bbg.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3c1o0bbg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpawbz9485.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpawbz9485.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc2dbkdeo.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc2dbkdeo.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvah_ak6f.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvah_ak6f.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5y0plr5r.d(16): Error: slice `result` is not mutable\\n/tmp/tmp5y0plr5r.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5y0plr5r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcjdxbme0.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcjdxbme0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuula42m0.d(16): Error: slice `result` is not mutable\\n/tmp/tmpuula42m0.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpuula42m0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcon6lz92.d(16): Error: slice `result` is not mutable\\n/tmp/tmpcon6lz92.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpcon6lz92.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n            res += \"0\";\n        else\n\
    \            res += \"1\";\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoix42riw.d(15): Error: slice `res` is not mutable\\n/tmp/tmpoix42riw.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpoix42riw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp_c2h1xn.d(16): Error: slice `result` is not mutable\\n/tmp/tmpp_c2h1xn.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpp_c2h1xn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp05m1xptf.d(16): Error: slice `result` is not mutable\\n/tmp/tmp05m1xptf.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp05m1xptf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp59hkoebe.d(16): Error: slice `result` is not mutable\\n/tmp/tmp59hkoebe.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp59hkoebe.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3nu_yn9r.d(16): Error: slice `result` is not mutable\\n/tmp/tmp3nu_yn9r.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3nu_yn9r.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps2qtv0cb.d(16): Error: slice `result` is not mutable\\n/tmp/tmps2qtv0cb.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmps2qtv0cb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8fqji5ll.d(16): Error: slice `result` is not mutable\\n/tmp/tmp8fqji5ll.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp8fqji5ll.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       if(c == b[i])\n            result ~= \"0\";\n        else\n          \
    \  result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1krdajo4.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1krdajo4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps057vc3a.d(16): Error: slice `result` is not mutable\\n/tmp/tmps057vc3a.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmps057vc3a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp869kb8t9.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp869kb8t9.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp869kb8t9.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xa028e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvu9cejdj.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpvu9cejdj.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpvu9cejdj.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x27d87554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n            res += \"0\";\n        else\n\
    \            res += \"1\";\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_mor4jc_.d(15): Error: slice `res` is not mutable\\n/tmp/tmp_mor4jc_.d(17):\
    \ Error: slice `res` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_mor4jc_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdy7kwo0y.d(16): Error: slice `result` is not mutable\\n/tmp/tmpdy7kwo0y.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpdy7kwo0y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk_qp4pdx.d(16): Error: slice `result` is not mutable\\n/tmp/tmpk_qp4pdx.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpk_qp4pdx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(int i; 0 .. a.length)\n\
    \    {\n        if (a[i] == b[i])\n            result ~= \"0\";\n        else\n\
    \            result ~= \"1\";\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaajtgcpm.d(12): Error: cannot implicitly convert expression `a.length`\
    \ of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpaajtgcpm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpkyngka0u.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpkyngka0u.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpkyngka0u.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xefda8554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res;\n    foreach(i, c; a)\n    {\n        res\
    \ ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp417htaio.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp417htaio.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp417htaio.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0xa8c00554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpu7srwm48.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpu7srwm48.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpu7srwm48.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x24f5a554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3h75x12h.d(16): Error: slice `result` is not mutable\\n/tmp/tmp3h75x12h.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3h75x12h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmptxdtcb6o.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmptxdtcb6o.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmptxdtcb6o.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x4e81b554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpc4wkbmn4.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpc4wkbmn4.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpc4wkbmn4.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0x7e279554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        int\
    \ ai = a[i] - '0';\n        int bi = b[i] - '0';\n        result ~= (ai ^ bi)\
    \ + '0';\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string res = \"\";\n    foreach(i, c; a)\n    {\n    \
    \    res ~= (c ^ b[i]);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvu_w78g4.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f85]\\n??:? void tmpvu_w78g4.__unittest_L18_C1()\
    \ [0x427b95]\\n??:? void tmpvu_w78g4.__modtest() [0x427d08]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c68f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b59e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff75]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430424]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff01]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b575]\\n??:? runModuleUnitTests [0x42c465]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428448]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283cf]\\n??:? _d_run_main [0x42833a]\\n??:? main [0x427d1b]\\\
    n??:? __libc_start_main [0xe7b77554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpddpp_gq6.d(16): Error: slice `result` is not mutable\\n/tmp/tmpddpp_gq6.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpddpp_gq6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        result += (a[i] ^ b[i]) ? \"1\" : \"0\";\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"\
    111000\", \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"\
    0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpes9iurgm.d(14): Error: slice `result` is not mutable\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpes9iurgm.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw9_3z1s2.d(16): Error: slice `result` is not mutable\\n/tmp/tmpw9_3z1s2.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpw9_3z1s2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf92p7ksa.d(16): Error: slice `result` is not mutable\\n/tmp/tmpf92p7ksa.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpf92p7ksa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp854udcom.d(16): Error: slice `result` is not mutable\\n/tmp/tmp854udcom.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp854udcom.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(c\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        if(a[i]\
    \ == b[i])\n            result ~= '0';\n        else\n            result ~= '1';\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3sdac0f_.d(16): Error: slice `result` is not mutable\\n/tmp/tmp3sdac0f_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp3sdac0f_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpsd8_brai.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmpsd8_brai.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmpsd8_brai.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x71121554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"\
    010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        }\n        else \n        {\n            result += \"1\";\n    \
    \    }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp11_9ej_6.d(16): Error: slice `result` is not mutable\\n/tmp/tmp11_9ej_6.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp11_9ej_6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvdiw0kmc.d(16): Error: slice `result` is not mutable\\n/tmp/tmpvdiw0kmc.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpvdiw0kmc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result;\n    foreach(i, c; a)\n    {\n        result\
    \ ~= (c ^ b[i]);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = string_xor;\n\n    assert(candidate(\"111000\", \"101010\") == \"010010\"\
    );\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"0101\"\
    , \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp3scb9460.d(22): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x427f95]\\n??:? void tmp3scb9460.__unittest_L18_C1()\
    \ [0x427ba1]\\n??:? void tmp3scb9460.__modtest() [0x427d14]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c69f]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b5ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42ff85]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430434]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42ff11]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b585]\\n??:? runModuleUnitTests [0x42c475]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428458]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x4283df]\\n??:? _d_run_main [0x42834a]\\n??:? main [0x427d27]\\\
    n??:? __libc_start_main [0x86243554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    foreach(i, c; a)\n    {\n \
    \       result ~= (c ^ b[i]) ? '1' : '0';\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\", \"101010\"\
    ) == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n    assert(candidate(\"\
    0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyzg2rn95.d(16): Error: slice `result` is not mutable\\n/tmp/tmpyzg2rn95.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpyzg2rn95.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc0byog6_.d(16): Error: slice `result` is not mutable\\n/tmp/tmpc0byog6_.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpc0byog6_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2ncbxmd3.d(16): Error: slice `result` is not mutable\\n/tmp/tmp2ncbxmd3.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2ncbxmd3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppelgvzst.d(16): Error: slice `result` is not mutable\\n/tmp/tmppelgvzst.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppelgvzst.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        if (a[i] == b[i])\n        {\n            result += \"\
    0\";\n        }\n        else\n        {\n            result += \"1\";\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas35wt8a.d(16): Error: slice `result` is not mutable\\n/tmp/tmpas35wt8a.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpas35wt8a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++)\n    {\n        result += (a[i] ^ b[i]) + '0';\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = string_xor;\n\n    assert(candidate(\"111000\"\
    , \"101010\") == \"010010\");\n    assert(candidate(\"1\", \"1\") == \"0\");\n\
    \    assert(candidate(\"0101\", \"0000\") == \"0101\");\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzbh9cxfo.d(14): Error: incompatible types for `(result) += ((cast(int)a[cast(ulong)i]\
    \ ^ cast(int)b[cast(ulong)i]) + 48)`: `string` and `int`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpzbh9cxfo.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.math;\n/*\n Input are two strings a and b consisting only of\
    \ 1s and 0s.\n    Perform binary XOR on these inputs and return result also as\
    \ a string.\n    >>> string_xor('010', '110')\n    '100'\n    \n*/\nstring string_xor(string\
    \ a, string b) \n{\n    string result = \"\";\n    for (int i = 0; i < a.length;\
    \ i++) \n    {\n        if (a[i] == b[i]) \n        {\n            result += \"\
    0\";\n        } \n        else \n        {\n            result += \"1\";\n   \
    \     }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = string_xor;\n\
    \n    assert(candidate(\"111000\", \"101010\") == \"010010\");\n    assert(candidate(\"\
    1\", \"1\") == \"0\");\n    assert(candidate(\"0101\", \"0000\") == \"0101\");\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkfg9vz0z.d(16): Error: slice `result` is not mutable\\n/tmp/tmpkfg9vz0z.d(20):\
    \ Error: slice `result` is not mutable\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpkfg9vz0z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
