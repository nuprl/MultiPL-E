name: HumanEval_70_strange_sort_list
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    while (lst.length != 0)\n    {\n        long min = lst[0];\n   \
    \     long max = lst[0];\n        foreach (item; lst)\n        {\n           \
    \ if (item < min)\n                min = item;\n            if (item > max)\n\
    \                max = item;\n        }\n        res[i] = min;\n        res[i\
    \ + 1] = max;\n        i += 2;\n        lst = lst.filter!(x => x != min && x !=\
    \ max);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaagfaivm.d(35): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaagfaivm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i : lst)\n    {\n     \
    \   min = min(min, i);\n        max = max(max, i);\n    }\n    long[] lst1 = new\
    \ long[lst.length];\n    long[] lst2 = new long[lst.length];\n    long j = 0;\n\
    \    long k = 0;\n    for (long i : lst)\n    {\n        if (i != min && i !=\
    \ max)\n        {\n            if (i < min)\n            {\n                lst1[j]\
    \ = i;\n                j++;\n            }\n            else\n            {\n\
    \                lst2[k] = i;\n                k++;\n            }\n        }\n\
    \    }\n    res[0] = min;\n    res[1] = max;\n    for (long i = 2; i < lst.length;\
    \ i += 2)\n    {\n        res[i] = lst1[i / 2 - 1];\n        res[i + 1] = lst2[i\
    \ / 2 - 1];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqd_ywywo.d(22): Error: semicolon expected, not `:`\\n/tmp/tmpqd_ywywo.d(22):\
    \ Error: expression expected, not `:`\\n/tmp/tmpqd_ywywo.d(22): Error: found `lst`\
    \ when expecting `;` following `for` condition\\n/tmp/tmpqd_ywywo.d(31): Error:\
    \ semicolon expected, not `:`\\n/tmp/tmpqd_ywywo.d(31): Error: expression expected,\
    \ not `:`\\n/tmp/tmpqd_ywywo.d(31): Error: found `lst` when expecting `;` following\
    \ `for` condition\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqd_ywywo.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 =\
    \ lst.dup;\n    lst2.sort();\n    int i = 0;\n    int j = lst2.length - 1;\n \
    \   int k = 0;\n    while (k < lst.length)\n    {\n        res[k] = lst2[i];\n\
    \        i++;\n        k++;\n        if (k < lst.length)\n        {\n        \
    \    res[k] = lst2[j];\n            j--;\n            k++;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvdq7ip5a.d(20): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpvdq7ip5a.d(22): Error: cannot implicitly convert expression `lst2.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpvdq7ip5a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[lst.length - 1] = max;\n    for (int i = 1; i < lst.length\
    \ - 1; i++)\n    {\n        if (i % 2 == 1)\n        {\n            res[i] = lst2[lst2.length\
    \ - 1];\n            lst2.remove(lst2[lst2.length - 1]);\n        }\n        else\n\
    \        {\n            res[i] = lst2[0];\n            lst2.remove(lst2[0]);\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2of2mx9y.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp2of2mx9y.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmp2of2mx9y.d(39):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp2of2mx9y.d(44): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2of2mx9y.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3dngrmhn.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp3dngrmhn.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp3dngrmhn.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp3dngrmhn.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmp3dngrmhn.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3dngrmhn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool is_even = true;\n    foreach (i, v; sorted)\n  \
    \  {\n        if (is_even)\n        {\n            result[i] = v;\n        }\n\
    \        else\n        {\n            result[lst.length - i - 1] = v;\n      \
    \  }\n        is_even = !is_even;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmputwx0aku.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmputwx0aku.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort;\n    bool is_min = true;\n    foreach (i, v;\
    \ temp)\n    {\n        if (is_min)\n        {\n            result[i] = v;\n \
    \           is_min = false;\n        }\n        else\n        {\n            result[lst.length\
    \ - i - 1] = v;\n            is_min = true;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg9u50gni.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg9u50gni.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n     \
    \   else\n        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmap_zw1n.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmap_zw1n.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_index = 0;\n   \
    \ auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (lst[i] == min)\n\
    \            min_index = i;\n        if (lst[i] == max)\n            max_index\
    \ = i;\n    }\n    auto lst_copy = lst.dup;\n    lst_copy.remove(min_index);\n\
    \    lst_copy.remove(max_index);\n    auto result = [min, max];\n    while (lst_copy.length\
    \ > 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n      \
    \  foreach (i; lst_copy)\n        {\n            if (i < min)\n              \
    \  min = i;\n            if (i > max)\n                max = i;\n        }\n \
    \       min_index = 0;\n        max_index = 0;\n        foreach (i; lst_copy)\n\
    \        {\n            if (lst_copy[i] == min)\n                min_index = i;\n\
    \            if (lst_copy[i] == max)\n                max_index = i;\n       \
    \ }\n        lst_copy.remove(min_index);\n        lst_copy.remove(max_index);\n\
    \        result ~= min;\n        result ~= max;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7661kw9p.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmp7661kw9p.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\n/tmp/tmp7661kw9p.d(38): Error: no property\
    \ `remove` for type `long[]`\\n/tmp/tmp7661kw9p.d(39): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp7661kw9p.d(57): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\n/tmp/tmp7661kw9p.d(59): Error: cannot\
    \ implicitly convert expression `i` of type `long` to `int`\\n/tmp/tmp7661kw9p.d(61):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp7661kw9p.d(62): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp7661kw9p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    lst_copy.sort();\n    bool is_min = true;\n    foreach\
    \ (i, ref e; res)\n    {\n        if (is_min)\n        {\n            e = lst_copy[0];\n\
    \            lst_copy = lst_copy[1..$];\n        }\n        else\n        {\n\
    \            e = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n  \
    \      }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk45_3n7k.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk45_3n7k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ tmp = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = tmp.min;\n      \
    \      tmp.remove(tmp.min);\n        }\n        else\n        {\n            res[i]\
    \ = tmp.max;\n            tmp.remove(tmp.max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuj5vs_4w.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpuj5vs_4w.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpuj5vs_4w.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpuj5vs_4w.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpuj5vs_4w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = 0;\n    int\
    \ k = sorted.length - 1;\n    int dir = 1;\n    while (i < res.length)\n    {\n\
    \        res[i] = sorted[j];\n        if (dir == 1)\n            j++;\n      \
    \  else\n            k--;\n        dir *= -1;\n        i++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ldtcfce.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6ldtcfce.d(24): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp6ldtcfce.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    long min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n\
    \    {\n        if (e < min)\n            min = e;\n        if (e > max)\n   \
    \         max = e;\n    }\n    res[i++] = min;\n    lst -= min;\n    res[i++]\
    \ = max;\n    lst -= max;\n    while (lst.length > 0)\n    {\n        min = lst[0];\n\
    \        max = lst[0];\n        foreach (e; lst)\n        {\n            if (e\
    \ < min)\n                min = e;\n            if (e > max)\n               \
    \ max = e;\n        }\n        res[i++] = min;\n        lst -= min;\n        res[i++]\
    \ = max;\n        lst -= max;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv5srgq50.d(31): Error: invalid array operation `lst -= min` (possible\
    \ missing [])\\n/tmp/tmpv5srgq50.d(33): Error: invalid array operation `lst -=\
    \ max` (possible missing [])\\n/tmp/tmpv5srgq50.d(46): Error: invalid array operation\
    \ `lst -= min` (possible missing [])\\n/tmp/tmpv5srgq50.d(48): Error: invalid\
    \ array operation `lst -= max` (possible missing [])\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpv5srgq50.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort();\n    int i = 0;\n    int j = temp.length -\
    \ 1;\n    while (i <= j)\n    {\n        result[i] = temp[i];\n        if (i !=\
    \ j)\n            result[j] = temp[j];\n        i++;\n        j--;\n    }\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3cln3zqk.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3cln3zqk.d(23): Error: cannot implicitly convert expression `temp.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3cln3zqk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    bool\
    \ asc = true;\n    int i = 0;\n    while (lst.length > 0)\n    {\n        if (asc)\n\
    \        {\n            res[i] = lst[0];\n            lst = lst[1..$];\n     \
    \   }\n        else\n        {\n            res[i] = lst[$-1];\n            lst\
    \ = lst[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpfc87kxft.d(46): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x42893d]\\n??:? void tmpfc87kxft.__unittest_L39_C1()\
    \ [0x4282bf]\\n??:? void tmpfc87kxft.__modtest() [0x4286c0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ca1b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b8ae]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430b39]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430fe8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430ac5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b885]\\n??:? runModuleUnitTests [0x42c7f1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428e00]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428d87]\\n??:? _d_run_main [0x428cf2]\\n??:? main [0x4286d3]\\\
    n??:? __libc_start_main [0xc787e554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    bool asc = true;\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2iwsc96a.d(25): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp2iwsc96a.d(26): Error: no property `remove` for type `long[]`\\n/tmp/tmp2iwsc96a.d(30):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp2iwsc96a.d(31): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2iwsc96a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst[i];\n          \
    \  i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n  \
    \          j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9_pvhew7.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9_pvhew7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <=\
    \ j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n    \
    \        i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf4xek_yn.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpf4xek_yn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    foreach (e; lst)\n    {\n        if (i < j)\n        {\n         \
    \   result[i] = sorted[i];\n            result[j] = sorted[j];\n            i++;\n\
    \            j--;\n        }\n        else\n        {\n            result[i] =\
    \ sorted[i];\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprjhbs9et.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmprjhbs9et.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprjhbs9et.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <=\
    \ j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n    \
    \        i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpingglupf.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpingglupf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] min = new long[1];\n    long[] max =\
    \ new long[1];\n    long[] result = new long[lst.length];\n    long[] remaining\
    \ = new long[lst.length];\n    bool[] used = new bool[lst.length];\n    long[]\
    \ tmp = new long[lst.length];\n    long[] tmp2 = new long[lst.length];\n    long[]\
    \ tmp3 = new long[lst.length];\n    long[] tmp4 = new long[lst.length];\n    long[]\
    \ tmp5 = new long[lst.length];\n    long[] tmp6 = new long[lst.length];\n    long[]\
    \ tmp7 = new long[lst.length];\n    long[] tmp8 = new long[lst.length];\n    long[]\
    \ tmp9 = new long[lst.length];\n    long[] tmp10 = new long[lst.length];\n   \
    \ long[] tmp11 = new long[lst.length];\n    long[] tmp12 = new long[lst.length];\n\
    \    long[] tmp13 = new long[lst.length];\n    long[] tmp14 = new long[lst.length];\n\
    \    long[] tmp15 = new long[lst.length];\n    long[] tmp16 = new long[lst.length];\n\
    \    long[] tmp17 = new long[lst.length];\n    long[] tmp18 = new long[lst.length];\n\
    \    long[] tmp19 = new long[lst.length];\n    long[] tmp20 = new long[lst.length];\n\
    \    long[] tmp21 = new long[lst.length];\n    long[] tmp22 = new long[lst.length];\n\
    \    long[] tmp23 = new long[lst.length];\n    long[] tmp24 = new long[lst.length];\n\
    \    long[] tmp25 = new long[lst.length];\n    long[] tmp26 = new long[lst.length];\n\
    \    long[] tmp27 = new long[lst.length];\n    long[] tmp28 = new long[lst.length];\n\
    \    long[] tmp29 = new long[\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpafqx4213.d(53): Error: expression expected, not `unittest`\\\
    n/tmp/tmpafqx4213.d(54): Error: found `{` when expecting `]`\\n/tmp/tmpafqx4213.d(55):\
    \ Error: semicolon expected, not `alias`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpafqx4213.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    long min = sorted[0];\n    long max = sorted[sorted.length\
    \ - 1];\n    long i = 0;\n    while (i < lst.length)\n    {\n        res[i] =\
    \ min;\n        i += 1;\n        if (i < lst.length)\n        {\n            res[i]\
    \ = max;\n            i += 1;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2q4fsa_b.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2q4fsa_b.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnwfv7i4o.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpnwfv7i4o.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmpnwfv7i4o.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmpnwfv7i4o.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmpnwfv7i4o.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnwfv7i4o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    bool min_flag = true;\n    foreach (i, ref\
    \ x; lst)\n    {\n        if (min_flag)\n        {\n            result[i] = min;\n\
    \            min_flag = false;\n        }\n        else\n        {\n         \
    \   result[i] = max;\n            min_flag = true;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_00140tl.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_00140tl.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n  \
    \  {\n        if (is_min)\n        {\n            res[i] = lst[i];\n         \
    \   i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n \
    \           j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv45m4gsx.d(20): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpv45m4gsx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_index = 0;\n   \
    \ auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (i == min)\n  \
    \          min_index = i;\n        if (i == max)\n            max_index = i;\n\
    \    }\n    long[] res = new long[lst.length];\n    res[0] = min;\n    res[1]\
    \ = max;\n    long[] lst_copy = lst[2..$];\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n\
    \    auto i = 2;\n    while (lst_copy.length > 0)\n    {\n        min = lst_copy[0];\n\
    \        max = lst_copy[0];\n        foreach (i; lst_copy)\n        {\n      \
    \      if (i < min)\n                min = i;\n            if (i > max)\n    \
    \            max = i;\n        }\n        res[i] = min;\n        res[i + 1] =\
    \ max;\n        lst_copy.remove(min);\n        lst_copy.remove(max);\n       \
    \ i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_osyuyxg.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmp_osyuyxg.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\n/tmp/tmp_osyuyxg.d(41): Error: no property\
    \ `remove` for type `long[]`\\n/tmp/tmp_osyuyxg.d(42): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp_osyuyxg.d(48): Error: variable `i` is shadowing\
    \ variable `tmp_osyuyxg.strange_sort_list.i`\\n/tmp/tmp_osyuyxg.d(57): Error:\
    \ no property `remove` for type `long[]`\\n/tmp/tmp_osyuyxg.d(58): Error: no property\
    \ `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_osyuyxg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp80jmtxsa.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp80jmtxsa.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp80jmtxsa.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp80jmtxsa.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmp80jmtxsa.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp80jmtxsa.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    \n    long[] result = new long[lst.length];\n\
    \    long[] sorted = lst.dup;\n    sorted.sort();\n    long[] reversed = sorted.dup;\n\
    \    reversed.reverse();\n    \n    foreach (i, e; lst)\n    {\n        if (i\
    \ % 2 == 0)\n            result[i] = sorted[i / 2];\n        else\n          \
    \  result[i] = reversed[i / 2];\n    }\n    \n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprptl2idn.d(22): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmprptl2idn.d(24): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmprptl2idn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    int j = lst.length - 1;\n    while\
    \ (i <= j)\n    {\n        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n\
    \        if (i != j)\n        {\n            result[j] = lst_copy.max;\n     \
    \       lst_copy.remove(lst_copy.max);\n        }\n        i++;\n        j--;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7sa1i6k9.d(22): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp7sa1i6k9.d(25): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp7sa1i6k9.d(26): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp7sa1i6k9.d(29): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmp7sa1i6k9.d(30): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7sa1i6k9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool asc = true;\n    foreach (e; lst)\n    {\n        if (asc)\n\
    \        {\n            result[i] = sorted[i];\n            i++;\n        }\n\
    \        else\n        {\n            result[j] = sorted[j];\n            j--;\n\
    \        }\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn_abi_0c.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpn_abi_0c.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpn_abi_0c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    foreach (e; lst)\n    {\n        if (i == j)\n        {\n        \
    \    result[i] = sorted[i];\n            break;\n        }\n        result[i]\
    \ = sorted[i];\n        result[j] = sorted[j];\n        i++;\n        j--;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18it2bg1.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp18it2bg1.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp18it2bg1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        min = min(min, lst[i]);\n        max = max(max, lst[i]);\n\
    \    }\n    long min_i = 0;\n    long max_i = lst.length - 1;\n    bool is_min\
    \ = true;\n    while (min_i <= max_i)\n    {\n        if (is_min)\n        {\n\
    \            res[min_i] = min;\n            min_i++;\n        }\n        else\n\
    \        {\n            res[max_i] = max;\n            max_i--;\n        }\n \
    \       is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdvcv1xmr.d(24): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpdvcv1xmr.d(25): Error: function expected before `()`,\
    \ not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpdvcv1xmr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <=\
    \ j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n    \
    \        i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmkxc05xr.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpmkxc05xr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    long min = sorted[0];\n    long max = sorted[^1];\n   \
    \ int i = 0;\n    int j = 0;\n    while (i < lst.length)\n    {\n        res[i]\
    \ = min;\n        i += 2;\n        if (i >= lst.length) break;\n        res[i]\
    \ = max;\n        i += 2;\n    }\n    i = 1;\n    while (i < lst.length)\n   \
    \ {\n        res[i] = sorted[j];\n        i += 2;\n        j++;\n        if (i\
    \ >= lst.length) break;\n        res[i] = sorted[j];\n        i += 2;\n      \
    \  j++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5nbnx014.d(21): Error: expression expected, not `^`\\n/tmp/tmp5nbnx014.d(21):\
    \ Error: found `1` when expecting `,`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp5nbnx014.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool is_min = true;\n    foreach (e; lst)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = sorted[i];\n            i++;\n        }\n\
    \        else\n        {\n            result[j] = sorted[j];\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3mizeiaz.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp3mizeiaz.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3mizeiaz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2dlul5rt.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp2dlul5rt.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp2dlul5rt.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp2dlul5rt.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmp2dlul5rt.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2dlul5rt.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        min = min(min, e);\n        max = max(max,\
    \ e);\n    }\n    long[] result = new long[lst.length];\n    long[] remaining\
    \ = lst.dup;\n    long[] min_remaining = remaining.filter!(e => e == min).dup;\n\
    \    long[] max_remaining = remaining.filter!(e => e == max).dup;\n    long[]\
    \ mid_remaining = remaining.filter!(e => e != min && e != max).dup;\n    bool\
    \ min_first = true;\n    foreach (e; remaining)\n    {\n        if (min_first)\n\
    \        {\n            if (min_remaining.length > 0)\n            {\n       \
    \         result ~= min_remaining[0];\n                min_remaining = min_remaining[1..$];\n\
    \            }\n            else if (max_remaining.length > 0)\n            {\n\
    \                result ~= max_remaining[0];\n                max_remaining =\
    \ max_remaining[1..$];\n            }\n            else\n            {\n     \
    \           result ~= mid_remaining[0];\n                mid_remaining = mid_remaining[1..$];\n\
    \            }\n        }\n        else\n        {\n            if (max_remaining.length\
    \ > 0)\n            {\n                result ~= max_remaining[0];\n         \
    \       max_remaining = max_remaining[1..$];\n            }\n            else\
    \ if (min_remaining.length > 0)\n            {\n                result ~= min_remaining[0];\n\
    \                min_remaining = min_remaining[1..$];\n            }\n       \
    \     else\n            {\n                result ~= mid_remaining[0];\n     \
    \           mid_remaining = mid_remaining[1..$];\n            }\n        }\n \
    \       min_first = !min_first;\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcdo2mtbi.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpcdo2mtbi.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpcdo2mtbi.d(28): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmpcdo2mtbi.d(29): Error: no property `filter` for\
    \ type `long[]`\\n/tmp/tmpcdo2mtbi.d(30): Error: no property `filter` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcdo2mtbi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   result[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n  \
    \      else\n        {\n            result[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        asc = !asc;\n        i++;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2z9im61i.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2z9im61i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    int i =\
    \ 0;\n    int j = 0;\n    while (i < lst.length)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = sorted[j];\n            j++;\n        }\n\
    \        else\n        {\n            result[i] = sorted[sorted.length - j];\n\
    \        }\n        is_min = !is_min;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm5m2v2i2.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm5m2v2i2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort();\n    long min = temp[0];\n    long max = temp[temp.length\
    \ - 1];\n    int i = 0;\n    while (temp.length != 0)\n    {\n        result[i]\
    \ = min;\n        temp.remove(min);\n        i++;\n        if (temp.length ==\
    \ 0)\n            break;\n        result[i] = max;\n        temp.remove(max);\n\
    \        i++;\n        if (temp.length == 0)\n            break;\n        min\
    \ = temp[0];\n        max = temp[temp.length - 1];\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd3bo879g.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpd3bo879g.d(28): Error: no property `remove` for type `long[]`\\n/tmp/tmpd3bo879g.d(33):\
    \ Error: no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpd3bo879g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = new long[lst.length];\n\
    \    long[] lst3 = new long[lst.length];\n    long j = 0;\n    long k = 0;\n \
    \   for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == min)\n\
    \            continue;\n        lst2[j] = lst[i];\n        j++;\n    }\n    for\
    \ (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] == max)\n     \
    \       continue;\n        lst3[k] = lst[i];\n        k++;\n    }\n    res[0]\
    \ = min;\n    res[1] = max;\n    long[] lst4 = new long[lst.length];\n    long[]\
    \ lst5 = new long[lst.length];\n    long[] lst6 = new long[lst.length];\n    long[]\
    \ lst7 = new long[lst.length];\n    long[] lst8 = new long[lst.length];\n    long[]\
    \ lst9 = new long[lst.length];\n    long[] lst10 = new long[lst.length];\n   \
    \ long[] lst11 = new long[lst.length];\n    long[] lst12 = new long[lst.length];\n\
    \    long[] lst13 = new long[lst.length];\n    long[] lst14 = new long[lst.length];\n\
    \    long[] lst15 = new long[lst.length];\n    long[] lst16 = new long[lst.length];\n\
    \    long[] l\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz40fib9f.d(63): Error: semicolon expected, not `unittest`\\n/tmp/tmpz40fib9f.d(63):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpz40fib9f.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool isMin = true;\n    while (i <= j)\n    {\n     \
    \   if (isMin)\n        {\n            res[i] = min;\n            isMin = false;\n\
    \            i++;\n        }\n        else\n        {\n            res[j] = max;\n\
    \            isMin = true;\n            j--;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_asunqp6.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp_asunqp6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    res[0] = min;\n    res[1] = max;\n    long[] lst_ = lst.dup;\n\
    \    lst_.remove(min);\n    lst_.remove(max);\n    int i = 2;\n    while (lst_.length\
    \ > 0)\n    {\n        min = lst_[0];\n        max = lst_[0];\n        foreach\
    \ (j; lst_)\n        {\n            if (j < min)\n                min = j;\n \
    \           if (j > max)\n                max = j;\n        }\n        res[i]\
    \ = min;\n        res[i + 1] = max;\n        lst_.remove(min);\n        lst_.remove(max);\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7ye_d5t4.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp7ye_d5t4.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmp7ye_d5t4.d(48):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp7ye_d5t4.d(49): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp7ye_d5t4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    long[] reversed = sorted.dup;\n   \
    \ reversed.reverse;\n    bool is_reversed = false;\n    foreach (i, val; lst)\n\
    \    {\n        if (is_reversed)\n        {\n            result[i] = reversed[0];\n\
    \            reversed = reversed[1..$];\n        }\n        else\n        {\n\
    \            result[i] = sorted[0];\n            sorted = sorted[1..$];\n    \
    \    }\n        is_reversed = !is_reversed;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw35zn6ml.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpw35zn6ml.d(23): Error: template `std.typecons.reverse` cannot deduce\
    \ function from argument types `!()(long[])`, candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\nFailed: [\"dmd\", \"\
    -unittest\", \"-v\", \"-o-\", \"/tmp/tmpw35zn6ml.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        min = min(min, e);\n        max = max(max,\
    \ e);\n    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n  \
    \      if (is_min)\n        {\n            res[i] = min;\n            i++;\n \
    \       }\n        else\n        {\n            res[j] = max;\n            j--;\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4yejf6bm.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmp4yejf6bm.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmp4yejf6bm.d(28): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4yejf6bm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (is_min)\n        {\n      \
    \      result[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n\
    \        else\n        {\n            result[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        is_min = !is_min;\n        i++;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpla1sonrc.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpla1sonrc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (e; lst) {\n        min = min(min, e);\n\
    \        max = max(max, e);\n    }\n    bool is_min = true;\n    int i = 0;\n\
    \    while (lst.length > 0) {\n        if (is_min) {\n            res[i] = min;\n\
    \            lst = lst.filter!(e => e != min);\n            min = lst[0];\n  \
    \          foreach (e; lst) {\n                min = min(min, e);\n          \
    \  }\n        } else {\n            res[i] = max;\n            lst = lst.filter!(e\
    \ => e != max);\n            max = lst[0];\n            foreach (e; lst) {\n \
    \               max = max(max, e);\n            }\n        }\n        is_min =\
    \ !is_min;\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq51nsuk6.d(22): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpq51nsuk6.d(23): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpq51nsuk6.d(30): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmpq51nsuk6.d(33): Error: function expected before\
    \ `()`, not `min` of type `long`\\n/tmp/tmpq51nsuk6.d(37): Error: no property\
    \ `filter` for type `long[]`\\n/tmp/tmpq51nsuk6.d(40): Error: function expected\
    \ before `()`, not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpq51nsuk6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    int i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n\
    \    while (i <= j)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = min;\n            i++;\n            is_min = false;\n        }\n        else\n\
    \        {\n            res[j] = max;\n            j--;\n            is_min =\
    \ true;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3bwwkvr5.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp3bwwkvr5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto new_lst = new long[](lst.length);\n\
    \    new_lst[0] = min;\n    new_lst[1] = max;\n    auto min_index = 1;\n    auto\
    \ max_index = 1;\n    for (int i = 2; i < lst.length; i++)\n    {\n        if\
    \ (i % 2 == 0)\n        {\n            new_lst[i] = lst[min_index];\n        \
    \    min_index++;\n        }\n        else\n        {\n            new_lst[i]\
    \ = lst[max_index];\n            max_index++;\n        }\n    }\n    return new_lst;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp39jof3ur.d(52): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4289dd]\\n??:? void tmp39jof3ur.__unittest_L48_C1()\
    \ [0x428106]\\n??:? void tmp39jof3ur.__modtest() [0x42875c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cabb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b94e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430bd9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431088]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430b65]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b925]\\n??:? runModuleUnitTests [0x42c891]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ea0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e27]\\n??:? _d_run_main [0x428d92]\\n??:? main [0x42876f]\\\
    n??:? __libc_start_main [0x50557554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n  \
    \  {\n        if (asc)\n        {\n            res[i] = lst2.min;\n          \
    \  lst2.remove(lst2.min);\n        }\n        else\n        {\n            res[i]\
    \ = lst2.max;\n            lst2.remove(lst2.max);\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxfmocxva.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpxfmocxva.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpxfmocxva.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpxfmocxva.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxfmocxva.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    bool is_max = true;\n    int i = 0;\n    foreach (e; sorted)\n\
    \    {\n        if (is_max)\n        {\n            result[i] = e;\n         \
    \   is_max = false;\n        }\n        else\n        {\n            result[lst.length\
    \ - i - 1] = e;\n            is_max = true;\n            i++;\n        }\n   \
    \ }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeh_5yvfc.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeh_5yvfc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach (el;\
    \ lst_copy)\n        {\n            min = min(min, el);\n            max = max(max,\
    \ el);\n        }\n        res[i] = min;\n        res[i + 1] = max;\n        lst_copy\
    \ = lst_copy.filter!(el => el != min && el != max);\n        i += 2;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpur34y9lm.d(27): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpur34y9lm.d(28): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpur34y9lm.d(32): Error: no property `filter`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpur34y9lm.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n  \
    \  {\n        if (is_min)\n        {\n            res[i] = lst[i];\n         \
    \   i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n \
    \           j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp79_khgq9.d(20): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp79_khgq9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] sorted = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        long min = lst_copy[0];\n        long max = lst_copy[0];\n\
    \        int min_index = 0;\n        int max_index = 0;\n        for (int j =\
    \ 0; j < lst_copy.length; j++)\n        {\n            if (lst_copy[j] < min)\n\
    \            {\n                min = lst_copy[j];\n                min_index\
    \ = j;\n            }\n            if (lst_copy[j] > max)\n            {\n   \
    \             max = lst_copy[j];\n                max_index = j;\n           \
    \ }\n        }\n        if (is_min)\n        {\n            sorted[i] = min;\n\
    \            lst_copy = lst_copy[0..min_index] ~ lst_copy[min_index+1..$];\n \
    \       }\n        else\n        {\n            sorted[i] = max;\n           \
    \ lst_copy = lst_copy[0..max_index] ~ lst_copy[max_index+1..$];\n        }\n \
    \       is_min = !is_min;\n    }\n    return sorted;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    int i =\
    \ 0;\n    while (sorted.length > 0)\n    {\n        if (is_min)\n        {\n \
    \           result[i] = sorted[0];\n            sorted = sorted[1..$];\n     \
    \   }\n        else\n        {\n            result[i] = sorted[$-1];\n       \
    \     sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n       \
    \ i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvzx7c7_y.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvzx7c7_y.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = min(lst);\n    long max = max(lst);\n    long min_index = 0;\n    long\
    \ max_index = lst.length - 1;\n    foreach (i; 0 .. lst.length)\n    {\n     \
    \   if (i % 2 == 0)\n        {\n            res[i] = min;\n            min_index++;\n\
    \            min = min(lst[min_index .. $]);\n        }\n        else\n      \
    \  {\n            res[i] = max;\n            max_index--;\n            max = max(lst[0\
    \ .. max_index]);\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph3biohkn.d(20): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmph3biohkn.d(21): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmph3biohkn.d(30): Error: function expected\
    \ before `()`, not `min` of type `long`\\n/tmp/tmph3biohkn.d(36): Error: function\
    \ expected before `()`, not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmph3biohkn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    long[] tmp = lst.dup;\n    tmp.remove(min);\n    tmp.remove(max);\n\
    \    result[0] = min;\n    result[result.length - 1] = max;\n    int i = 1;\n\
    \    int j = result.length - 2;\n    while (tmp.length > 0)\n    {\n        result[i]\
    \ = tmp[0];\n        result[j] = tmp[tmp.length - 1];\n        tmp.remove(tmp[0]);\n\
    \        tmp.remove(tmp[tmp.length - 1]);\n        i++;\n        j--;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpflzko8s5.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpflzko8s5.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpflzko8s5.d(35):\
    \ Error: cannot implicitly convert expression `result.length - 2LU` of type `ulong`\
    \ to `int`\\n/tmp/tmpflzko8s5.d(40): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpflzko8s5.d(41): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpflzko8s5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            auto min = remaining.min;\n\
    \            result[i] = min;\n            remaining.remove(min);\n        }\n\
    \        else\n        {\n            auto max = remaining.max;\n            result[i]\
    \ = max;\n            remaining.remove(max);\n        }\n        is_min = !is_min;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1xli5mpw.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp1xli5mpw.d(28): Error: no property `remove` for type `long[]`\\n/tmp/tmp1xli5mpw.d(32):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp1xli5mpw.d(34): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1xli5mpw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] lst_copy = lst.dup;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n\
    \    res[0] = min;\n    res[res.length - 1] = max;\n    long[] lst_copy_sorted\
    \ = lst_copy.dup;\n    lst_copy_sorted.sort;\n    long[] lst_copy_sorted_reversed\
    \ = lst_copy_sorted.dup;\n    lst_copy_sorted_reversed.reverse;\n    bool is_odd\
    \ = false;\n    foreach (i; 1 .. res.length - 1)\n    {\n        if (is_odd)\n\
    \        {\n            res[i] = lst_copy_sorted.popFront;\n            is_odd\
    \ = false;\n        }\n        else\n        {\n            res[i] = lst_copy_sorted_reversed.popFront;\n\
    \            is_odd = true;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl4icp07g.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpl4icp07g.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpl4icp07g.d(35):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmpl4icp07g.d(37): Error:\
    \ template `std.typecons.reverse` cannot deduce function from argument types `!()(long[])`,\
    \ candidates are:\\n/home/zi.ya/spack/opt/spack/linux-centos7-haswell/gcc-4.8.5/dmd-2.081.1-uf6xyx53fosvucuy7fkpiod2bnffx7of/linux/bin64/../../src/phobos/std/typecons.d(1486):\
    \        `std.typecons.reverse(T)(T t) if (isTuple!T)`\\n/tmp/tmpl4icp07g.d(43):\
    \ Error: no property `popFront` for type `long[]`\\n/tmp/tmpl4icp07g.d(48): Error:\
    \ no property `popFront` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpl4icp07g.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    bool is_min = true;\n\
    \    foreach (el; lst_copy)\n    {\n        if (is_min)\n        {\n         \
    \   res ~= min;\n            lst_copy = lst_copy.filter!(a => a != min);\n   \
    \         is_min = false;\n        }\n        else\n        {\n            res\
    \ ~= max;\n            lst_copy = lst_copy.filter!(a => a != max);\n         \
    \   is_min = true;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_byxo2tq.d(36): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmp_byxo2tq.d(42): Error: no property `filter` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_byxo2tq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ e; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprpyvxlut.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmprpyvxlut.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst2.length\
    \ > 0)\n    {\n        min = lst2[0];\n        max = lst2[0];\n        foreach\
    \ (j; lst2)\n        {\n            if (j < min)\n                min = j;\n \
    \           if (j > max)\n                max = j;\n        }\n        res[i]\
    \ = min;\n        res[i+1] = max;\n        lst2.remove(min);\n        lst2.remove(max);\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp01sgr8e7.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp01sgr8e7.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmp01sgr8e7.d(48):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp01sgr8e7.d(49): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp01sgr8e7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n \
    \           lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprgp8a68j.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmprgp8a68j.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmprgp8a68j.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmprgp8a68j.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmprgp8a68j.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto res = new long[](lst.length);\n\
    \    res[0] = min;\n    res[1] = max;\n    auto i = 2;\n    while (i < lst.length)\n\
    \    {\n        min = max;\n        max = lst[0];\n        foreach (j; lst)\n\
    \        {\n            if (j < min && j > res[i - 2])\n                min =\
    \ j;\n            if (j > max && j < res[i - 1])\n                max = j;\n \
    \       }\n        res[i] = min;\n        res[i + 1] = max;\n        i += 2;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.RangeError@/tmp/tmptf4txm1n.d(44): Range violation\\n----------------\\\
    n??:? _d_arrayboundsp [0x428b2e]\\n??:? long[] tmptf4txm1n.strange_sort_list(long[])\
    \ [0x4280b7]\\n??:? void tmptf4txm1n.__unittest_L49_C1() [0x4281f6]\\n??:? void\
    \ tmptf4txm1n.__modtest() [0x428800]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cb5b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b9ee]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430c79]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431128]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430c05]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b9c5]\\n??:? runModuleUnitTests [0x42c931]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428f40]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428ec7]\\n??:? _d_run_main [0x428e32]\\n??:? main [0x428813]\\\
    n??:? __libc_start_main [0x9e1f0554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr03jeoi2.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpr03jeoi2.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmpr03jeoi2.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmpr03jeoi2.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmpr03jeoi2.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr03jeoi2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_ = lst.dup;\n    int i = 0;\n    while (lst_.length > 0)\n    {\n      \
    \  res[i] = lst_.min;\n        lst_.remove(lst_.min);\n        if (lst_.length\
    \ == 0)\n            break;\n        res[i + 1] = lst_.max;\n        lst_.remove(lst_.max);\n\
    \        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvtz51_yd.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpvtz51_yd.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpvtz51_yd.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpvtz51_yd.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpvtz51_yd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n\
    \            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    long[] result = new long[lst.length];\n    long[] temp = new long[lst.length];\n\
    \    long[] temp2 = new long[lst.length];\n    long j = 0;\n    long k = 0;\n\
    \    for (long i = 0; i < lst.length; i++)\n    {\n        if (lst[i] != min &&\
    \ lst[i] != max)\n        {\n            temp[j] = lst[i];\n            j++;\n\
    \        }\n        else\n        {\n            temp2[k] = lst[i];\n        \
    \    k++;\n        }\n    }\n    long[] temp3 = new long[j];\n    long[] temp4\
    \ = new long[k];\n    for (long i = 0; i < j; i++)\n        temp3[i] = temp[i];\n\
    \    for (long i = 0; i < k; i++)\n        temp4[i] = temp2[i];\n    long[] temp5\
    \ = strange_sort_list(temp3);\n    long[] temp6 = strange_sort_list(temp4);\n\
    \    long[] temp7 = new long[temp5.length + temp6.length];\n    for (long i =\
    \ 0; i < temp5.length; i++)\n        temp7[i] = temp5[i];\n    for (long i = 0;\
    \ i < temp6.length; i++)\n        temp7[i + temp5.length] = temp6[i];\n    for\
    \ (long i = 0; i < temp7.length; i++)\n    {\n        if (i % 2 == 0)\n      \
    \      result[i] = temp7[i / 2];\n        else\n            result[i] = temp7[temp7\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjkzb5yks.d(65): Error: found `unittest` when expecting `,`\\\
    n/tmp/tmpjkzb5yks.d(79): Error: found `void` when expecting `,`\\n/tmp/tmpjkzb5yks.d(79):\
    \ Error: found `{` when expecting `,`\\n/tmp/tmpjkzb5yks.d(79): Error: expression\
    \ expected, not `}`\\n/tmp/tmpjkzb5yks.d(79): Error: found `End of File` when\
    \ expecting `,`\\n/tmp/tmpjkzb5yks.d(79): Error: found `End of File` when expecting\
    \ `]`\\n/tmp/tmpjkzb5yks.d(79): Error: found `End of File` when expecting `;`\
    \ following statement\\n/tmp/tmpjkzb5yks.d(79): Error: found `End of File` when\
    \ expecting `}` following compound statement\\n/tmp/tmpjkzb5yks.d(79): Error:\
    \ found `End of File` when expecting `}` following compound statement\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjkzb5yks.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length != 0)\n    {\n\
    \        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n    \
    \    i++;\n        if (lst_copy.length == 0)\n            break;\n        res[i]\
    \ = lst_copy.max;\n        lst_copy.remove(lst_copy.max);\n        i++;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzr07ohb_.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpzr07ohb_.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpzr07ohb_.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpzr07ohb_.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpzr07ohb_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n    \
    \    i += 1;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i +=\
    \ 1;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdf60hnjk.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpdf60hnjk.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpdf60hnjk.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpdf60hnjk.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpdf60hnjk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n       \
    \ long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach (el;\
    \ lst_copy)\n        {\n            min = min(min, el);\n            max = max(max,\
    \ el);\n        }\n        res[i] = min;\n        res[i + 1] = max;\n        lst_copy\
    \ = lst_copy.filter!(el => el != min && el != max);\n        i += 2;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv_blboj4.d(27): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpv_blboj4.d(28): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpv_blboj4.d(32): Error: no property `filter`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpv_blboj4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ tmp = lst.dup;\n    tmp.sort();\n    bool is_min = true;\n    int i = 0;\n \
    \   while (tmp.length > 0)\n    {\n        if (is_min)\n        {\n          \
    \  res[i] = tmp[0];\n            tmp = tmp[1..$];\n        }\n        else\n \
    \       {\n            res[i] = tmp[$-1];\n            tmp = tmp[0..$-1];\n  \
    \      }\n        is_min = !is_min;\n        i++;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx28sffrn.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx28sffrn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst[i];\n  \
    \          i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqtosouto.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpqtosouto.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] tmp = new long[lst.length];\n\
    \    long j = 0;\n    for (long i = 0; i < lst.length; i++)\n    {\n        if\
    \ (lst[i] != min && lst[i] != max)\n        {\n            tmp[j] = lst[i];\n\
    \            j++;\n        }\n    }\n    res[0] = min;\n    res[1] = max;\n  \
    \  long k = 2;\n    for (long i = 0; i < j; i++)\n    {\n        if (i % 2 ==\
    \ 0)\n        {\n            min = tmp[i];\n            for (long m = i; m < j;\
    \ m++)\n            {\n                if (tmp[m] < min)\n                   \
    \ min = tmp[m];\n            }\n            res[k] = min;\n            k++;\n\
    \        }\n        else\n        {\n            max = tmp[i];\n            for\
    \ (long m = i; m < j; m++)\n            {\n                if (tmp[m] > max)\n\
    \                    max = tmp[m];\n            }\n            res[k] = max;\n\
    \            k++;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpl6j1uvtm.d(74): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428c4d]\\n??:? void tmpl6j1uvtm.__unittest_L69_C1()\
    \ [0x428441]\\n??:? void tmpl6j1uvtm.__modtest() [0x4289cc]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cd2b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bbbe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430e49]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4312f8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430dd5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bb95]\\n??:? runModuleUnitTests [0x42cb01]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429110]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429097]\\n??:? _d_run_main [0x429002]\\n??:? main [0x4289df]\\\
    n??:? __libc_start_main [0xc94dd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[1] =\
    \ max;\n    long i = 2;\n    while (lst2.length > 0)\n    {\n        min = lst2[0];\n\
    \        max = lst2[0];\n        for (long j = 0; j < lst2.length; j++)\n    \
    \    {\n            if (lst2[j] < min)\n                min = lst2[j];\n     \
    \       if (lst2[j] > max)\n                max = lst2[j];\n        }\n      \
    \  res[i] = min;\n        i++;\n        res[i] = max;\n        i++;\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzajr4n5h.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpzajr4n5h.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpzajr4n5h.d(50):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpzajr4n5h.d(51): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpzajr4n5h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_ =\
    \ lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n    {\n  \
    \      if (asc)\n        {\n            res[i] = lst_.min;\n            lst_.remove(lst_.min);\n\
    \        }\n        else\n        {\n            res[i] = lst_.max;\n        \
    \    lst_.remove(lst_.max);\n        }\n        asc = !asc;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4engi1bu.d(25): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp4engi1bu.d(26): Error: no property `remove` for type `long[]`\\n/tmp/tmp4engi1bu.d(30):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp4engi1bu.d(31): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp4engi1bu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach\
    \ (i, ref e; result)\n    {\n        if (is_min)\n        {\n            e = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        e = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n \
    \       is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpikk6halo.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpikk6halo.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i]\
    \ > max)\n            max = lst[i];\n    }\n    int min_i = 0;\n    int max_i\
    \ = lst.length - 1;\n    int i = 0;\n    while (min_i <= max_i)\n    {\n     \
    \   res[i] = min;\n        min_i++;\n        i++;\n        if (min_i <= max_i)\n\
    \        {\n            res[i] = max;\n            max_i--;\n            i++;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpas06ktn4.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpas06ktn4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_yxt09g6.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp_yxt09g6.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmp_yxt09g6.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp_yxt09g6.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_yxt09g6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  result[i] = lst2.min;\n        lst2.remove(lst2.min);\n        if (lst2.length\
    \ > 0)\n        {\n            result[i+1] = lst2.max;\n            lst2.remove(lst2.max);\n\
    \        }\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxqsno15a.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpxqsno15a.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpxqsno15a.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpxqsno15a.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpxqsno15a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n \
    \           lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnhr32rzw.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpnhr32rzw.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpnhr32rzw.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpnhr32rzw.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpnhr32rzw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n    \
    \    if (lst_copy.length > 0)\n        {\n            res[i + 1] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9capn86p.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp9capn86p.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmp9capn86p.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp9capn86p.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp9capn86p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    lst_copy.sort;\n    bool is_min = true;\n    foreach\
    \ (i, ref e; res)\n    {\n        if (is_min)\n        {\n            e = lst_copy[0];\n\
    \            lst_copy = lst_copy[1..$];\n        }\n        else\n        {\n\
    \            e = lst_copy[$-1];\n            lst_copy = lst_copy[0..$-1];\n  \
    \      }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7nbtcl4i.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7nbtcl4i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst[i];\n          \
    \  i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n  \
    \          j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmped8yktnm.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmped8yktnm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        long min_max = is_min ? lst_copy.min : lst_copy.max;\n\
    \        result[i] = min_max;\n        lst_copy.remove(min_max);\n        is_min\
    \ = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7wdmqisf.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp7wdmqisf.d(24): Error: no property `max` for type `long[]`\\n/tmp/tmp7wdmqisf.d(26):\
    \ Error: no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7wdmqisf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst_copy.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n\
    \            lst_copy = lst_copy.filter!(x => x != lst_copy.min)();\n        }\n\
    \        else\n        {\n            res[i] = lst_copy.max;\n            lst_copy\
    \ = lst_copy.filter!(x => x != lst_copy.max)();\n        }\n        asc = !asc;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoalxdx3w.d(27): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpoalxdx3w.d(28): Error: no property `filter` for type `long[]`\\n/tmp/tmpoalxdx3w.d(32):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpoalxdx3w.d(33): Error:\
    \ no property `filter` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpoalxdx3w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        result[i] = sorted[0];\n        sorted = sorted[1..$];\n\
    \        if (sorted.length > 0)\n        {\n            result[i+1] = sorted[$-1];\n\
    \            sorted = sorted[0..$-2];\n        }\n        i += 2;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp833282r5.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp833282r5.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    res[0] = min;\n    res[1]\
    \ = max;\n    int i = 2;\n    int j = 0;\n    while (i < lst.length)\n    {\n\
    \        if (lst[j] != min && lst[j] != max)\n        {\n            res[i] =\
    \ lst[j];\n            i++;\n        }\n        j++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmped3p6ghy.d(49): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428a45]\\n??:? void tmped3p6ghy.__unittest_L44_C1()\
    \ [0x428239]\\n??:? void tmped3p6ghy.__modtest() [0x4287c4]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cb23]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b9b6]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430c41]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4310f0]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430bcd]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b98d]\\n??:? runModuleUnitTests [0x42c8f9]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428f08]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e8f]\\n??:? _d_run_main [0x428dfa]\\n??:? main [0x4287d7]\\\
    n??:? __libc_start_main [0xcaafc554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if\
    \ (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpos4_7lrt.d(19): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpos4_7lrt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    int i = 0;\n    int j = sorted.length - 1;\n    bool asc\
    \ = true;\n    foreach (e; lst)\n    {\n        if (asc)\n        {\n        \
    \    res[i] = sorted[i];\n            i++;\n        }\n        else\n        {\n\
    \            res[j] = sorted[j];\n            j--;\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjt2d2t9t.d(19): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjt2d2t9t.d(21): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpjt2d2t9t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            res[i] = lst_copy.min;\n \
    \           lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8r3cymwb.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp8r3cymwb.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmp8r3cymwb.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp8r3cymwb.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp8r3cymwb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_index = 0;\n   \
    \ auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (i == min)\n  \
    \          min_index = i;\n        if (i == max)\n            max_index = i;\n\
    \    }\n    long[] result = new long[lst.length];\n    result[0] = min;\n    result[1]\
    \ = max;\n    long[] lst_without_min_max = lst[1..$-1];\n    lst_without_min_max\
    \ ~= lst[0];\n    lst_without_min_max ~= lst[$-1];\n    lst_without_min_max =\
    \ lst_without_min_max.sort();\n    foreach (i; 2..lst.length)\n    {\n       \
    \ result[i] = lst_without_min_max[i-2];\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjl59vbaz.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmpjl59vbaz.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\n/tmp/tmpjl59vbaz.d(43): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpjl59vbaz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) \n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst) \n    {\n        min = min(min, i);\n        max = max(max,\
    \ i);\n    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    bool\
    \ is_min = true;\n    while (i < lst.length) \n    {\n        if (is_min) \n \
    \       {\n            res[i] = min;\n            lst = lst.filter!(a => a !=\
    \ min);\n            is_min = false;\n        } \n        else \n        {\n \
    \           res[i] = max;\n            lst = lst.filter!(a => a != max);\n   \
    \         is_min = true;\n        }\n        i++;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp676kl8iw.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmp676kl8iw.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmp676kl8iw.d(34): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmp676kl8iw.d(40): Error: no property `filter` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp676kl8iw.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ _; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp77b_ggwm.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp77b_ggwm.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (el; lst)\n    {\n      \
    \  if (el < min)\n            min = el;\n        if (el > max)\n            max\
    \ = el;\n    }\n    res[0] = min;\n    res[1] = max;\n    long[] lst_ = lst.dup;\n\
    \    lst_.remove(min);\n    lst_.remove(max);\n    bool is_min = true;\n    foreach\
    \ (i; 2..res.length)\n    {\n        if (is_min)\n        {\n            min =\
    \ lst_[0];\n            foreach (el; lst_)\n            {\n                if\
    \ (el < min)\n                    min = el;\n            }\n            res[i]\
    \ = min;\n            lst_.remove(min);\n            is_min = false;\n       \
    \ }\n        else\n        {\n            max = lst_[0];\n            foreach\
    \ (el; lst_)\n            {\n                if (el > max)\n                 \
    \   max = el;\n            }\n            res[i] = max;\n            lst_.remove(max);\n\
    \            is_min = true;\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbny17hda.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpbny17hda.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmpbny17hda.d(46):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpbny17hda.d(58): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpbny17hda.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ copy = lst.dup;\n    int i = 0;\n    while (copy.length > 0)\n    {\n      \
    \  auto min = copy.min;\n        auto max = copy.max;\n        result[i] = min;\n\
    \        result[i + 1] = max;\n        copy = copy.filter!(x => x != min && x\
    \ != max);\n        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplg19ctl9.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmplg19ctl9.d(25): Error: no property `max` for type `long[]`\\n/tmp/tmplg19ctl9.d(28):\
    \ Error: no property `filter` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmplg19ctl9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    bool is_min = true;\n    int i = 0;\n    while (remaining.length\
    \ > 0)\n    {\n        if (is_min)\n        {\n            result[i] = remaining.min;\n\
    \            remaining = remaining.remove(remaining.min);\n        }\n       \
    \ else\n        {\n            result[i] = remaining.max;\n            remaining\
    \ = remaining.remove(remaining.max);\n        }\n        is_min = !is_min;\n \
    \       i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1d65vqdf.d(27): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp1d65vqdf.d(28): Error: no property `remove` for type `long[]`\\n/tmp/tmp1d65vqdf.d(32):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp1d65vqdf.d(33): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1d65vqdf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        result[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n \
    \       if (lst_copy.length > 0)\n        {\n            result[i+1] = lst_copy.max;\n\
    \            lst_copy.remove(lst_copy.max);\n        }\n        i += 2;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptb95mynp.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmptb95mynp.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmptb95mynp.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmptb95mynp.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptb95mynp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] temp = lst.dup;\n\
    \    temp.remove(min);\n    temp.remove(max);\n    res[0] = min;\n    res[1] =\
    \ max;\n    int i = 2;\n    while (temp.length > 0)\n    {\n        min = temp[0];\n\
    \        max = temp[0];\n        for (long j = 0; j < temp.length; j++)\n    \
    \    {\n            if (temp[j] < min)\n                min = temp[j];\n     \
    \       if (temp[j] > max)\n                max = temp[j];\n        }\n      \
    \  res[i] = min;\n        i++;\n        res[i] = max;\n        i++;\n        temp.remove(min);\n\
    \        temp.remove(max);\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8lqhx5ll.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp8lqhx5ll.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmp8lqhx5ll.d(50):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp8lqhx5ll.d(51): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp8lqhx5ll.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        min = min(min, e);\n        max = max(max,\
    \ e);\n    }\n    long[] result = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n     \
    \   if (asc)\n        {\n            result[i] = min;\n            min++;\n  \
    \          i++;\n        }\n        else\n        {\n            result[j] = max;\n\
    \            max--;\n            j--;\n        }\n        asc = !asc;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphncoev_l.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmphncoev_l.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmphncoev_l.d(28): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphncoev_l.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    res[$\
    \ - 1] = max;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n    for (int\
    \ i = 1; i < res.length - 1; i++)\n    {\n        if (i % 2 == 1)\n        {\n\
    \            res[i] = lst_copy[0];\n            lst_copy.remove(lst_copy[0]);\n\
    \        }\n        else\n        {\n            res[i] = lst_copy[$ - 1];\n \
    \           lst_copy.remove(lst_copy[$ - 1]);\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp4k38g4s.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpp4k38g4s.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmpp4k38g4s.d(39):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpp4k38g4s.d(44): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpp4k38g4s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n    lst2.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst2.length\
    \ > 0)\n    {\n        min = lst2[0];\n        max = lst2[0];\n        foreach\
    \ (e; lst2)\n        {\n            if (e < min)\n                min = e;\n \
    \           if (e > max)\n                max = e;\n        }\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n        res[i] = min;\n        i++;\n        if (lst2.length\
    \ > 0)\n        {\n            res[i] = max;\n            i++;\n        }\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfiedumcj.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpfiedumcj.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpfiedumcj.d(46):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpfiedumcj.d(47): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpfiedumcj.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto result = new long[lst.length];\n\
    \    auto index = 0;\n    auto min_index = 0;\n    auto max_index = lst.length\
    \ - 1;\n    while (index < lst.length)\n    {\n        if (index % 2 == 0)\n \
    \       {\n            result[index] = min;\n            min_index++;\n      \
    \      min = lst[min_index];\n            foreach (i; lst[min_index..$])\n   \
    \         {\n                if (i < min)\n                    min = i;\n    \
    \        }\n        }\n        else\n        {\n            result[index] = max;\n\
    \            max_index--;\n            max = lst[max_index];\n            foreach\
    \ (i; lst[0..max_index])\n            {\n                if (i > max)\n      \
    \              max = i;\n            }\n        }\n        index++;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpvyxwnjb1.d(67): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428ab5]\\n??:? void tmpvyxwnjb1.__unittest_L60_C1()\
    \ [0x428433]\\n??:? void tmpvyxwnjb1.__modtest() [0x428834]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cb93]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42ba26]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430cb1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431160]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430c3d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b9fd]\\n??:? runModuleUnitTests [0x42c969]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428f78]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428eff]\\n??:? _d_run_main [0x428e6a]\\n??:? main [0x428847]\\\
    n??:? __libc_start_main [0x692fe554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    while (i <= j)\n    {\n        result[i] = sorted[i];\n        i++;\n\
    \        if (i > j)\n            break;\n        result[j] = sorted[i];\n    \
    \    j--;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmprda5ddu4.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmprda5ddu4.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmprda5ddu4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool asc = true;\n    int i = 0;\n    foreach (e; sorted)\n\
    \    {\n        res[i] = e;\n        if (asc)\n        {\n            i++;\n \
    \           asc = false;\n        }\n        else\n        {\n            i--;\n\
    \            asc = true;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0v6f6s_a.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0v6f6s_a.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_ = lst.dup;\n    int i = 0;\n    while (lst_.length > 0)\n    {\n      \
    \  res[i] = lst_.min;\n        lst_.remove(lst_.min);\n        if (lst_.length\
    \ > 0)\n        {\n            res[i + 1] = lst_.max;\n            lst_.remove(lst_.max);\n\
    \        }\n        i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3b1i4v4m.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp3b1i4v4m.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmp3b1i4v4m.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp3b1i4v4m.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp3b1i4v4m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ e; lst)\n    {\n        if (is_min)\n        {\n            result[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n    \
    \    }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoaravtmk.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoaravtmk.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    temp.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (temp.length > 0)\n    {\n        if (asc)\n        {\n            result[i]\
    \ = temp[0];\n            temp = temp[1..$];\n        }\n        else\n      \
    \  {\n            result[i] = temp[$-1];\n            temp = temp[0..$-1];\n \
    \       }\n        i++;\n        asc = !asc;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzgesvq1g.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzgesvq1g.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach\
    \ (i; lst)\n    {\n        min = min(min, i);\n        max = max(max, i);\n  \
    \  }\n    auto res = new long[](lst.length);\n    auto min_i = 0;\n    auto max_i\
    \ = lst.length - 1;\n    foreach (i; lst)\n    {\n        if (i == min)\n    \
    \    {\n            res[min_i] = i;\n            min_i += 2;\n        }\n    \
    \    else if (i == max)\n        {\n            res[max_i] = i;\n            max_i\
    \ -= 2;\n        }\n    }\n    foreach (i; lst)\n    {\n        if (i != min &&\
    \ i != max)\n        {\n            if (min_i < lst.length)\n            {\n \
    \               res[min_i] = i;\n                min_i += 2;\n            }\n\
    \            else\n            {\n                res[max_i] = i;\n          \
    \      max_i -= 2;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxza66xto.d(22): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpxza66xto.d(23): Error: function expected before `()`,\
    \ not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpxza66xto.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    int index = 0;\n    int direction = 1;\n    while\
    \ (remaining.length > 0)\n    {\n        long min = remaining[0];\n        long\
    \ max = remaining[0];\n        foreach (el; remaining)\n        {\n          \
    \  min = min(min, el);\n            max = max(max, el);\n        }\n        if\
    \ (direction == 1)\n        {\n            result[index] = min;\n            remaining\
    \ = remaining.filter!(a => a != min);\n        }\n        else\n        {\n  \
    \          result[index] = max;\n            remaining = remaining.filter!(a =>\
    \ a != max);\n        }\n        direction *= -1;\n        index++;\n    }\n \
    \   return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdb_h2133.d(29): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpdb_h2133.d(30): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpdb_h2133.d(35): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmpdb_h2133.d(40): Error: no property `filter` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdb_h2133.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ min = 0;\n    int max = lst.length - 1;\n    bool is_min = true;\n    foreach\
    \ (i; 0 .. lst.length)\n    {\n        if (is_min)\n        {\n            res[i]\
    \ = lst[min];\n            min++;\n        }\n        else\n        {\n      \
    \      res[i] = lst[max];\n            max--;\n        }\n        is_min = !is_min;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc40vnpos.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpc40vnpos.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 =\
    \ lst.dup;\n    bool asc = true;\n    int i = 0;\n    while (lst2.length > 0)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst2.min;\n        \
    \    lst2.remove(lst2.min);\n        }\n        else\n        {\n            res[i]\
    \ = lst2.max;\n            lst2.remove(lst2.max);\n        }\n        i++;\n \
    \       asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_h5j2oe5.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp_h5j2oe5.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmp_h5j2oe5.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp_h5j2oe5.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_h5j2oe5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            res[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo46f2mb0.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpo46f2mb0.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmpo46f2mb0.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmpo46f2mb0.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmpo46f2mb0.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo46f2mb0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n    foreach\
    \ (i; lst) {\n        min = min(min, i);\n        max = max(max, i);\n    }\n\
    \    long[] result = new long[lst.length];\n    int i = 0;\n    while (i < lst.length)\
    \ {\n        result[i] = min;\n        min = max;\n        foreach (j; lst) {\n\
    \            if (j != result[i]) {\n                min = min(min, j);\n     \
    \       }\n        }\n        i++;\n        if (i < lst.length) {\n          \
    \  result[i] = max;\n            max = min;\n            foreach (j; lst) {\n\
    \                if (j != result[i]) {\n                    max = max(max, j);\n\
    \                }\n            }\n            i++;\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjbku5pjw.d(21): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpjbku5pjw.d(22): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpjbku5pjw.d(31): Error: function expected\
    \ before `()`, not `min` of type `long`\\n/tmp/tmpjbku5pjw.d(40): Error: function\
    \ expected before `()`, not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpjbku5pjw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst[i];\n          \
    \  i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n  \
    \          j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm5crwn0w.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpm5crwn0w.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    int i =\
    \ 0;\n    while (sorted.length > 0)\n    {\n        if (is_min)\n        {\n \
    \           result[i] = sorted[0];\n            sorted = sorted[1..$];\n     \
    \   }\n        else\n        {\n            result[i] = sorted[$-1];\n       \
    \     sorted = sorted[0..$-1];\n        }\n        is_min = !is_min;\n       \
    \ i++;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpepnz2s4r.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepnz2s4r.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    res[0] = min;\n    lst_copy.remove(min);\n\
    \    res[1] = max;\n    lst_copy.remove(max);\n    int i = 2;\n    while (lst_copy.length\
    \ > 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n      \
    \  foreach (el; lst_copy)\n        {\n            if (el < min)\n            \
    \    min = el;\n            if (el > max)\n                max = el;\n       \
    \ }\n        res[i] = min;\n        lst_copy.remove(min);\n        i++;\n    \
    \    res[i] = max;\n        lst_copy.remove(max);\n        i++;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa0aeh63c.d(31): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpa0aeh63c.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmpa0aeh63c.d(47):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpa0aeh63c.d(50): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpa0aeh63c.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    res[0] = min;\n    res[1]\
    \ = max;\n    long[] lst_copy = lst.dup;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n\
    \    long[] lst_copy2 = lst_copy.dup;\n    lst_copy2.sort;\n    long[] lst_copy3\
    \ = lst_copy.dup;\n    lst_copy3.sort(std.math.greater);\n    long[] lst_copy4\
    \ = new long[lst_copy.length];\n    for (long i = 0; i < lst_copy.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n            lst_copy4[i] = lst_copy2[i / 2];\n\
    \        else\n            lst_copy4[i] = lst_copy3[i / 2];\n    }\n    for (long\
    \ i = 2; i < res.length; i++)\n        res[i] = lst_copy4[i - 2];\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphdfvt20i.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmphdfvt20i.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmphdfvt20i.d(35):\
    \ Error: no property `sort` for type `long[]`\\n/tmp/tmphdfvt20i.d(37): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmphdfvt20i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst1 = lst.dup;\n    long[] lst2 = lst.dup;\n    lst1.sort;\n    lst2.sort(std.numeric.comparisonFunctor!(\"\
    a > b\"));\n    bool flag = true;\n    foreach (i, ref e; res)\n    {\n      \
    \  if (flag)\n        {\n            e = lst1[0];\n            lst1 = lst1[1..$];\n\
    \        }\n        else\n        {\n            e = lst2[0];\n            lst2\
    \ = lst2[1..$];\n        }\n        flag = !flag;\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp90p792kw.d(22): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp90p792kw.d(23): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp90p792kw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            long min = lst_copy[0];\n\
    \            long min_index = 0;\n            foreach (j; 0 .. lst_copy.length)\n\
    \            {\n                if (lst_copy[j] < min)\n                {\n  \
    \                  min = lst_copy[j];\n                    min_index = j;\n  \
    \              }\n            }\n            result[i] = min;\n            lst_copy\
    \ = lst_copy[0 .. min_index] ~ lst_copy[min_index + 1 .. $];\n        }\n    \
    \    else\n        {\n            long max = lst_copy[0];\n            long max_index\
    \ = 0;\n            foreach (j; 0 .. lst_copy.length)\n            {\n       \
    \         if (lst_copy[j] > max)\n                {\n                    max =\
    \ lst_copy[j];\n                    max_index = j;\n                }\n      \
    \      }\n            result[i] = max;\n            lst_copy = lst_copy[0 .. max_index]\
    \ ~ lst_copy[max_index + 1 .. $];\n        }\n        is_min = !is_min;\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: b''
  exit_code: 0
  status: OK
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool ascending = true;\n    int i =\
    \ 0;\n    while (sorted.length > 0)\n    {\n        if (ascending)\n        {\n\
    \            result[i] = sorted[0];\n            sorted = sorted[1..$];\n    \
    \    }\n        else\n        {\n            result[i] = sorted[$-1];\n      \
    \      sorted = sorted[0..$-1];\n        }\n        i++;\n        ascending =\
    \ !ascending;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiu5srn9z.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiu5srn9z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_idx = 0;\n    auto\
    \ max_idx = 0;\n    foreach (i; lst)\n    {\n        if (i == min)\n         \
    \   min_idx = i;\n        if (i == max)\n            max_idx = i;\n    }\n   \
    \ auto min_lst = lst[0..min_idx];\n    auto max_lst = lst[min_idx+1..$];\n   \
    \ auto res = [min];\n    foreach (i; max_lst)\n    {\n        res ~= i;\n    \
    \    res ~= min_lst[0];\n        min_lst = min_lst[1..$];\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpos093mko.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmpos093mko.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpos093mko.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] ret = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    ret[0] = min;\n    ret[1]\
    \ = max;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n    for (int i\
    \ = 2; i < lst.length; i += 2)\n    {\n        min = lst_copy[0];\n        max\
    \ = lst_copy[0];\n        foreach (el; lst_copy)\n        {\n            if (el\
    \ < min)\n                min = el;\n            if (el > max)\n             \
    \   max = el;\n        }\n        ret[i] = min;\n        ret[i + 1] = max;\n \
    \       lst_copy.remove(min);\n        lst_copy.remove(max);\n    }\n    return\
    \ ret;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3m1mpbtl.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp3m1mpbtl.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmp3m1mpbtl.d(47):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp3m1mpbtl.d(48): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp3m1mpbtl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] sorted = lst.dup;\n\
    \    sorted.sort;\n    long[] sorted_min = sorted.filter!(a => a == min).dup;\n\
    \    long[] sorted_max = sorted.filter!(a => a == max).dup;\n    long[] sorted_other\
    \ = sorted.filter!(a => a != min && a != max).dup;\n    long[] sorted_other_min\
    \ = sorted_other.filter!(a => a < max).dup;\n    long[] sorted_other_max = sorted_other.filter!(a\
    \ => a > min).dup;\n    long[] sorted_other_min_max = sorted_other_min.filter!(a\
    \ => a > min).dup;\n    long[] sorted_other_max_min = sorted_other_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other_min_max_min = sorted_other_min_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other_max_min_max = sorted_other_max_min.filter!(a\
    \ => a > min).dup;\n    long[] sorted_other_min_max_min_max = sorted_other_min_max_min.filter!(a\
    \ => a > min).dup;\n    long[] sorted_other_max_min_max_min = sorted_other_max_min_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other_min_max_min_max_min = sorted_other_min_max_min_max.filter!(a\
    \ => a < max).dup;\n    long[] sorted_other\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpylrapnxv.d(44): Error: semicolon expected, not `unittest`\\n/tmp/tmpylrapnxv.d(44):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpylrapnxv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  res[i] = lst2.min;\n        lst2 = lst2.remove(lst2.min);\n        i++;\n \
    \       if (lst2.length > 0)\n        {\n            res[i] = lst2.max;\n    \
    \        lst2 = lst2.remove(lst2.max);\n            i++;\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps79yhs1v.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmps79yhs1v.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmps79yhs1v.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmps79yhs1v.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmps79yhs1v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] tmp = lst.dup;\n\
    \    tmp.remove(min);\n    tmp.remove(max);\n    res[0] = min;\n    res[1] = max;\n\
    \    for (long i = 2; i < lst.length; i++)\n    {\n        if (i % 2 == 0)\n \
    \       {\n            min = tmp[0];\n            for (long j = 0; j < tmp.length;\
    \ j++)\n            {\n                if (tmp[j] < min)\n                   \
    \ min = tmp[j];\n            }\n            res[i] = min;\n            tmp.remove(min);\n\
    \        }\n        else\n        {\n            max = tmp[0];\n            for\
    \ (long j = 0; j < tmp.length; j++)\n            {\n                if (tmp[j]\
    \ > max)\n                    max = tmp[j];\n            }\n            res[i]\
    \ = max;\n            tmp.remove(max);\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbmpy36m_.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpbmpy36m_.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpbmpy36m_.d(45):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpbmpy36m_.d(56): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpbmpy36m_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            result[i] = lst.min();\n\
    \            lst.remove(lst.min());\n            i++;\n        }\n        else\n\
    \        {\n            result[j] = lst.max();\n            lst.remove(lst.max());\n\
    \            j--;\n        }\n        is_min = !is_min;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7x3ypjcg.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp7x3ypjcg.d(27): Error: no property\
    \ `min` for type `long[]`\\n/tmp/tmp7x3ypjcg.d(28): Error: no property `remove`\
    \ for type `long[]`\\n/tmp/tmp7x3ypjcg.d(33): Error: no property `max` for type\
    \ `long[]`\\n/tmp/tmp7x3ypjcg.d(34): Error: no property `remove` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7x3ypjcg.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool is_min = true;\n    foreach (i, e; sorted)\n   \
    \ {\n        if (is_min)\n        {\n            res[i] = e;\n            is_min\
    \ = false;\n        }\n        else\n        {\n            res[lst.length - i\
    \ - 1] = e;\n            is_min = true;\n        }\n    }\n    return res;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn3fi0cjn.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn3fi0cjn.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    for (auto i = 0; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n\
    \            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    auto res = new long[lst.length];\n    auto min_idx = 0;\n    auto\
    \ max_idx = lst.length - 1;\n    for (auto i = 0; i < lst.length; i++)\n    {\n\
    \        if (i % 2 == 0)\n        {\n            res[i] = min;\n            min_idx++;\n\
    \        }\n        else\n        {\n            res[i] = max;\n            max_idx--;\n\
    \        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpak34m8y9.d(50): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4289c5]\\n??:? void tmpak34m8y9.__unittest_L46_C1()\
    \ [0x4280ee]\\n??:? void tmpak34m8y9.__modtest() [0x428744]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42caa3]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b936]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430bc1]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431070]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430b4d]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b90d]\\n??:? runModuleUnitTests [0x42c879]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428e88]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e0f]\\n??:? _d_run_main [0x428d7a]\\n??:? main [0x428757]\\\
    n??:? __libc_start_main [0xb66fd554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (el; lst_copy)\n    {\n        if (el < min)\n            min = el;\n\
    \        if (el > max)\n            max = el;\n    }\n    int i = 0;\n    while\
    \ (lst_copy.length > 0)\n    {\n        if (i % 2 == 0)\n        {\n         \
    \   res[i] = min;\n            lst_copy = lst_copy.filter!(el => el != min);\n\
    \            if (lst_copy.length == 0)\n                break;\n            min\
    \ = lst_copy[0];\n            foreach (el; lst_copy)\n            {\n        \
    \        if (el < min)\n                    min = el;\n            }\n       \
    \ }\n        else\n        {\n            res[i] = max;\n            lst_copy\
    \ = lst_copy.filter!(el => el != max);\n            if (lst_copy.length == 0)\n\
    \                break;\n            max = lst_copy[0];\n            foreach (el;\
    \ lst_copy)\n            {\n                if (el > max)\n                  \
    \  max = el;\n            }\n        }\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmx04ys0t.d(36): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpmx04ys0t.d(49): Error: no property `filter` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmx04ys0t.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  result[i] = lst2.min;\n        lst2.remove(lst2.min);\n        if (lst2.length\
    \ == 0)\n            break;\n        result[i + 1] = lst2.max;\n        lst2.remove(lst2.max);\n\
    \        i += 2;\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpag6wf3p3.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpag6wf3p3.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpag6wf3p3.d(28):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpag6wf3p3.d(29): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpag6wf3p3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        min = min(min, e);\n        max = max(max,\
    \ e);\n    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    bool asc = true;\n    while (i <= j)\n    {\n     \
    \   if (asc)\n        {\n            res[i] = min;\n            min = max;\n \
    \           foreach (e; lst)\n            {\n                if (e != res[i])\n\
    \                    min = min(min, e);\n            }\n            i++;\n   \
    \     }\n        else\n        {\n            res[j] = max;\n            max =\
    \ min;\n            foreach (e; lst)\n            {\n                if (e !=\
    \ res[j])\n                    max = max(max, e);\n            }\n           \
    \ j--;\n        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgck92th4.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpgck92th4.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpgck92th4.d(28): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\n/tmp/tmpgck92th4.d(39):\
    \ Error: function expected before `()`, not `min` of type `long`\\n/tmp/tmpgck92th4.d(50):\
    \ Error: function expected before `()`, not `max` of type `long`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgck92th4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    int i = 0;\n\
    \    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n    {\n    \
    \    res[k++] = lst[i++];\n        if (i <= j)\n            res[k++] = lst[j--];\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfn6nb7st.d(20): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpfn6nb7st.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool is_min = true;\n    foreach (i,\
    \ ref e; lst)\n    {\n        if (is_min)\n        {\n            result[i] =\
    \ sorted[0];\n            sorted = sorted[1..$];\n        }\n        else\n  \
    \      {\n            result[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx7ab72t8.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx7ab72t8.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    int i = 0;\n    while (lst2.length > 0)\n    {\n      \
    \  res[i] = lst2.min;\n        lst2.remove(lst2.min);\n        i++;\n        if\
    \ (lst2.length == 0)\n            break;\n        res[i] = lst2.max;\n       \
    \ lst2.remove(lst2.max);\n        i++;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3zyvfiv.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpu3zyvfiv.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpu3zyvfiv.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpu3zyvfiv.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpu3zyvfiv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] result = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool asc = true;\n    foreach (i, item; sorted)\n   \
    \ {\n        if (asc)\n        {\n            result[i] = item;\n            asc\
    \ = false;\n        }\n        else\n        {\n            result[lst.length\
    \ - i - 1] = item;\n            asc = true;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfnipkowc.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfnipkowc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ywpjkqs.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp_ywpjkqs.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmp_ywpjkqs.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp_ywpjkqs.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp_ywpjkqs.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpa14sa4ln.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpa14sa4ln.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpa14sa4ln.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpa14sa4ln.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpa14sa4ln.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqw806c7t.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpqw806c7t.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpqw806c7t.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpqw806c7t.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpqw806c7t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    lst2.sort();\n    int i = 0;\n    int j = lst2.length -\
    \ 1;\n    int k = 0;\n    while (i <= j)\n    {\n        result[k++] = lst2[i++];\n\
    \        if (i <= j)\n            result[k++] = lst2[j--];\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8__8117z.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp8__8117z.d(23): Error: cannot implicitly convert expression `lst2.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp8__8117z.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ temp = lst.dup;\n    int i = 0;\n    while (temp.length > 0)\n    {\n      \
    \  res[i] = temp.min;\n        temp = temp.remove(temp.min);\n        i++;\n \
    \       if (temp.length == 0)\n            break;\n        res[i] = temp.max;\n\
    \        temp = temp.remove(temp.max);\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp514zrew1.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp514zrew1.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmp514zrew1.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp514zrew1.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp514zrew1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        res[i] = sorted[0];\n        sorted = sorted[1..$];\n \
    \       if (sorted.length > 0)\n        {\n            res[i + 1] = sorted[$ -\
    \ 1];\n            sorted = sorted[0..$ - 1];\n        }\n        i += 2;\n  \
    \  }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzp1c8xyc.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzp1c8xyc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach\
    \ (i, ref el; res)\n    {\n        if (is_min)\n        {\n            el = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        el = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n\
    \        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp40lwt3ng.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp40lwt3ng.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst2 = lst.dup;\n    long min = lst2[0];\n    long max = lst2[0];\n    foreach\
    \ (e; lst2)\n    {\n        if (e < min)\n            min = e;\n        if (e\
    \ > max)\n            max = e;\n    }\n    res[0] = min;\n    res[1] = max;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    bool asc = true;\n    for (int\
    \ i = 2; i < res.length; i++)\n    {\n        if (asc)\n        {\n          \
    \  min = lst2[0];\n            foreach (e; lst2)\n            {\n            \
    \    if (e < min)\n                    min = e;\n            }\n            res[i]\
    \ = min;\n            lst2.remove(min);\n            asc = false;\n        }\n\
    \        else\n        {\n            max = lst2[0];\n            foreach (e;\
    \ lst2)\n            {\n                if (e > max)\n                    max\
    \ = e;\n            }\n            res[i] = max;\n            lst2.remove(max);\n\
    \            asc = true;\n        }\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpylz0n_wa.d(32): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpylz0n_wa.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmpylz0n_wa.d(46):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpylz0n_wa.d(58): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpylz0n_wa.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst2 =\
    \ lst.dup;\n    long min = lst2[0];\n    long max = lst2[0];\n    foreach (e;\
    \ lst2)\n    {\n        if (e < min) min = e;\n        if (e > max) max = e;\n\
    \    }\n    int i = 0;\n    bool asc = true;\n    while (lst2.length > 0)\n  \
    \  {\n        if (asc)\n        {\n            res[i] = min;\n            lst2.remove(min);\n\
    \            if (lst2.length > 0)\n            {\n                min = lst2[0];\n\
    \                foreach (e; lst2)\n                {\n                    if\
    \ (e < min) min = e;\n                }\n            }\n        }\n        else\n\
    \        {\n            res[i] = max;\n            lst2.remove(max);\n       \
    \     if (lst2.length > 0)\n            {\n                max = lst2[0];\n  \
    \              foreach (e; lst2)\n                {\n                    if (e\
    \ > max) max = e;\n                }\n            }\n        }\n        i++;\n\
    \        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpib264br1.d(34): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpib264br1.d(47): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpib264br1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    int i = 0;\n    int j\
    \ = lst.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n    \
    \    if (is_min)\n        {\n            res[i] = min;\n            i++;\n   \
    \         is_min = false;\n        }\n        else\n        {\n            res[j]\
    \ = max;\n            j--;\n            is_min = true;\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n  \
    \  assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7w8lmoxx.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp7w8lmoxx.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    long min = sorted[0];\n    long max = sorted[sorted.length\
    \ - 1];\n    long min_idx = 0;\n    long max_idx = sorted.length - 1;\n    bool\
    \ min_first = true;\n    foreach (i; 0 .. res.length)\n    {\n        if (min_first)\n\
    \        {\n            res[i] = min;\n            min_idx++;\n            min\
    \ = sorted[min_idx];\n        }\n        else\n        {\n            res[i] =\
    \ max;\n            max_idx--;\n            max = sorted[max_idx];\n        }\n\
    \        min_first = !min_first;\n    }\n    return res;\n}\nunittest\n{\n   \
    \ alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L])\
    \ == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L,\
    \ 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L,\
    \ 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpioh_okyw.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpioh_okyw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    int i = 0;\n    int j = sorted.length\
    \ - 1;\n    bool is_min = true;\n    foreach (el; lst)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = sorted[i];\n            i++;\n        }\n   \
    \     else\n        {\n            res[j] = sorted[j];\n            j--;\n   \
    \     }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcrhao7nl.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpcrhao7nl.d(23): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpcrhao7nl.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (e; lst)\n    {\n       \
    \ if (e < min)\n            min = e;\n        if (e > max)\n            max =\
    \ e;\n    }\n    long[] lst_ = lst.dup;\n    lst_.remove(min);\n    lst_.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    int i = 2;\n    while (lst_.length\
    \ > 0)\n    {\n        min = lst_[0];\n        max = lst_[0];\n        foreach\
    \ (e; lst_)\n        {\n            if (e < min)\n                min = e;\n \
    \           if (e > max)\n                max = e;\n        }\n        lst_.remove(min);\n\
    \        lst_.remove(max);\n        res[i] = min;\n        res[i+1] = max;\n \
    \       i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplomwgpu6.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmplomwgpu6.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmplomwgpu6.d(46):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmplomwgpu6.d(47): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmplomwgpu6.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[$ - 1];\n    long i = 0;\n    while (i < lst.length)\n    {\n     \
    \   result[i] = min;\n        i++;\n        if (i == lst.length)\n           \
    \ break;\n        result[i] = max;\n        i++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6ng7zehq.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6ng7zehq.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool is_min = true;\n    for (int i = 0; i < lst.length;\
    \ i++)\n    {\n        if (is_min)\n        {\n            result[i] = lst_copy.min;\n\
    \            lst_copy.remove(lst_copy.min);\n        }\n        else\n       \
    \ {\n            result[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7ier6ie.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpb7ier6ie.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpb7ier6ie.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpb7ier6ie.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpb7ier6ie.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i]\
    \ > max)\n            max = lst[i];\n    }\n    int index = 0;\n    int minIndex\
    \ = 0;\n    int maxIndex = lst.length - 1;\n    while (index < lst.length)\n \
    \   {\n        if (index % 2 == 0)\n        {\n            result[index] = min;\n\
    \            minIndex++;\n            min = lst[minIndex];\n            for (int\
    \ i = minIndex; i < lst.length; i++)\n            {\n                if (lst[i]\
    \ < min)\n                    min = lst[i];\n            }\n        }\n      \
    \  else\n        {\n            result[index] = max;\n            maxIndex--;\n\
    \            max = lst[maxIndex];\n            for (int i = maxIndex; i >= 0;\
    \ i--)\n            {\n                if (lst[i] > max)\n                   \
    \ max = lst[i];\n            }\n        }\n        index++;\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx1rofmss.d(31): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpx1rofmss.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (el; lst)\n    {\n      \
    \  if (el < min)\n            min = el;\n        if (el > max)\n            max\
    \ = el;\n    }\n    int i = 0;\n    int j = lst.length - 1;\n    while (i <= j)\n\
    \    {\n        if (i == j)\n        {\n            res[i] = min;\n          \
    \  break;\n        }\n        res[i] = min;\n        res[j] = max;\n        i++;\n\
    \        j--;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0ak35fju.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp0ak35fju.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool is_min = true;\n    while (i <=\
    \ j)\n    {\n        if (is_min)\n        {\n            result[i] = lst[lst.minIndex];\n\
    \            lst[lst.minIndex] = lst[lst.maxIndex];\n            lst[lst.maxIndex]\
    \ = result[i];\n            i++;\n        }\n        else\n        {\n       \
    \     result[j] = lst[lst.maxIndex];\n            lst[lst.maxIndex] = lst[lst.minIndex];\n\
    \            lst[lst.minIndex] = result[j];\n            j--;\n        }\n   \
    \     is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgwbgpcik.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmpgwbgpcik.d(27): Error: no property\
    \ `minIndex` for type `long[]`\\n/tmp/tmpgwbgpcik.d(28): Error: no property `minIndex`\
    \ for type `long[]`\\n/tmp/tmpgwbgpcik.d(29): Error: no property `maxIndex` for\
    \ type `long[]`\\n/tmp/tmpgwbgpcik.d(34): Error: no property `maxIndex` for type\
    \ `long[]`\\n/tmp/tmpgwbgpcik.d(35): Error: no property `maxIndex` for type `long[]`\\\
    n/tmp/tmpgwbgpcik.d(36): Error: no property `minIndex` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgwbgpcik.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    int i = 0;\n    int j = sorted.length - 1;\n\
    \    bool asc = true;\n    foreach (el; lst)\n    {\n        if (asc)\n      \
    \  {\n            res[i] = min;\n            min = sorted[++i];\n        }\n \
    \       else\n        {\n            res[j] = max;\n            max = sorted[--j];\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz065iylb.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpz065iylb.d(25): Error: cannot implicitly convert expression `sorted.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpz065iylb.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach\
    \ (el; lst_copy)\n        {\n            min = min(min, el);\n            max\
    \ = max(max, el);\n        }\n        res[i] = min;\n        i++;\n        lst_copy\
    \ = lst_copy.filter!(x => x != min);\n        if (lst_copy.length == 0)\n    \
    \        break;\n        res[i] = max;\n        i++;\n        lst_copy = lst_copy.filter!(x\
    \ => x != max);\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz_fnfykj.d(28): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpz_fnfykj.d(29): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpz_fnfykj.d(33): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmpz_fnfykj.d(38): Error: no property `filter` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz_fnfykj.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort;\n    bool asc = true;\n    int i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   res[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n     \
    \   else\n        {\n            res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n\
    \        }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp77ou6csh.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp77ou6csh.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    bool\
    \ is_min = true;\n    int i = 0;\n    while (lst.length != 0)\n    {\n       \
    \ if (is_min)\n        {\n            result[i] = lst.min();\n            lst\
    \ = lst.remove(lst.min());\n        }\n        else\n        {\n            result[i]\
    \ = lst.max();\n            lst = lst.remove(lst.max());\n        }\n        is_min\
    \ = !is_min;\n        i++;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4uxj7dst.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp4uxj7dst.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmp4uxj7dst.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmp4uxj7dst.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp4uxj7dst.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        res[i] = lst_copy.min;\n        lst_copy.remove(lst_copy.min);\n    \
    \    i += 1;\n        if (lst_copy.length > 0)\n        {\n            res[i]\
    \ = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n            i +=\
    \ 1;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz6wbrz6_.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpz6wbrz6_.d(25): Error: no property `remove` for type `long[]`\\n/tmp/tmpz6wbrz6_.d(29):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpz6wbrz6_.d(30): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpz6wbrz6_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    long i = 0;\n\
    \    while (sorted.length > 0)\n    {\n        if (asc)\n        {\n         \
    \   result[i] = sorted[0];\n            sorted = sorted[1..$];\n        }\n  \
    \      else\n        {\n            result[i] = sorted[$-1];\n            sorted\
    \ = sorted[0..$-1];\n        }\n        i++;\n        asc = !asc;\n    }\n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppq_xlkf7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppq_xlkf7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    long[] result = new long[lst.length];\n\
    \    bool is_min = true;\n    int index = 0;\n    while (lst.length != 0)\n  \
    \  {\n        if (is_min)\n        {\n            result[index] = min;\n     \
    \       lst = lst.filter!(a => a != min);\n            min = lst[0];\n       \
    \     foreach (i; lst)\n            {\n                if (i < min)\n        \
    \            min = i;\n            }\n        }\n        else\n        {\n   \
    \         result[index] = max;\n            lst = lst.filter!(a => a != max);\n\
    \            max = lst[0];\n            foreach (i; lst)\n            {\n    \
    \            if (i > max)\n                    max = i;\n            }\n     \
    \   }\n        is_min = !is_min;\n        index++;\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy_yulkyu.d(36): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmpy_yulkyu.d(47): Error: no property `filter` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy_yulkyu.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (int i = 0; i < lst.length; i++)\n\
    \    {\n        if (lst[i] < min)\n            min = lst[i];\n        if (lst[i]\
    \ > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n    lst2.remove(min);\n\
    \    lst2.remove(max);\n    res[0] = min;\n    res[1] = max;\n    int i = 2;\n\
    \    while (lst2.length > 0)\n    {\n        min = lst2[0];\n        max = lst2[0];\n\
    \        for (int j = 0; j < lst2.length; j++)\n        {\n            if (lst2[j]\
    \ < min)\n                min = lst2[j];\n            if (lst2[j] > max)\n   \
    \             max = lst2[j];\n        }\n        res[i] = min;\n        i++;\n\
    \        res[i] = max;\n        i++;\n        lst2.remove(min);\n        lst2.remove(max);\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk2s10g0i.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpk2s10g0i.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmpk2s10g0i.d(50):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmpk2s10g0i.d(51): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpk2s10g0i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    bool min_first = true;\n    foreach (i; 0\
    \ .. lst.length)\n    {\n        if (min_first)\n        {\n            result[i]\
    \ = min;\n            min_first = false;\n        }\n        else\n        {\n\
    \            result[i] = max;\n            min_first = true;\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpme4c4vjc.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpme4c4vjc.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    res[0]\
    \ = lst[0];\n    lst = lst[1..$];\n    bool asc = false;\n    foreach (i; 1..lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst[0];\n          \
    \  lst = lst[1..$];\n        }\n        else\n        {\n            res[i] =\
    \ lst[$-1];\n            lst = lst[0..$-1];\n        }\n        asc = !asc;\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpjc7xhz2f.d(43): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4289bd]\\n??:? void tmpjc7xhz2f.__unittest_L39_C1()\
    \ [0x4280e6]\\n??:? void tmpjc7xhz2f.__modtest() [0x42873c]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42ca9b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b92e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430bb9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431068]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430b45]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b905]\\n??:? runModuleUnitTests [0x42c871]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428e80]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e07]\\n??:? _d_run_main [0x428d72]\\n??:? main [0x42874f]\\\
    n??:? __libc_start_main [0xd5b18554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] lst_copy\
    \ = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n    {\n\
    \        if (is_min)\n        {\n            res[i] = lst_copy.min;\n        \
    \    lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n    \
    \        res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        is_min = !is_min;\n    }\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpomgntqb1.d(25): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpomgntqb1.d(26): Error: no property `remove` for type `long[]`\\n/tmp/tmpomgntqb1.d(30):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpomgntqb1.d(31): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpomgntqb1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_index = 0;\n   \
    \ auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (lst[i] == min)\n\
    \            min_index = i;\n        if (lst[i] == max)\n            max_index\
    \ = i;\n    }\n    auto new_lst = lst[0..min_index] ~ lst[min_index+1..$];\n \
    \   auto new_lst2 = new_lst[0..max_index-1] ~ new_lst[max_index..$];\n    auto\
    \ new_lst3 = new_lst2[0..min_index-1] ~ new_lst2[min_index..$];\n    auto new_lst4\
    \ = new_lst3[0..max_index-2] ~ new_lst3[max_index-1..$];\n    return [min, max]\
    \ ~ strange_sort_list(new_lst4);\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2vkhis_t.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmp2vkhis_t.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp2vkhis_t.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = min(lst);\n    long max = max(lst);\n    int i = 0;\n    while (i < lst.length)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            res[i] = min;\n      \
    \      lst = lst.filter!(a => a != min);\n        }\n        else\n        {\n\
    \            res[i] = max;\n            lst = lst.filter!(a => a != max);\n  \
    \      }\n        min = min(lst);\n        max = max(lst);\n        i++;\n   \
    \ }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvs8wxa8v.d(20): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpvs8wxa8v.d(21): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmpvs8wxa8v.d(28): Error: no property `filter`\
    \ for type `long[]`\\n/tmp/tmpvs8wxa8v.d(33): Error: no property `filter` for\
    \ type `long[]`\\n/tmp/tmpvs8wxa8v.d(35): Error: function expected before `()`,\
    \ not `min` of type `long`\\n/tmp/tmpvs8wxa8v.d(36): Error: function expected\
    \ before `()`, not `max` of type `long`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpvs8wxa8v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    bool flag = true;\n    while (i <=\
    \ j)\n    {\n        if (flag)\n        {\n            res[i] = lst[i];\n    \
    \        i++;\n        }\n        else\n        {\n            res[j] = lst[i];\n\
    \            j--;\n        }\n        flag = !flag;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9mh6cci0.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp9mh6cci0.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    bool\
    \ asc = true;\n    int i = 0;\n    while (lst.length > 0)\n    {\n        auto\
    \ min = lst[0];\n        auto max = lst[0];\n        foreach (el; lst)\n     \
    \   {\n            if (el < min)\n                min = el;\n            if (el\
    \ > max)\n                max = el;\n        }\n        lst = lst.filter!(el =>\
    \ el != min && el != max);\n        if (asc)\n        {\n            res[i] =\
    \ min;\n            res[i + 1] = max;\n        }\n        else\n        {\n  \
    \          res[i] = max;\n            res[i + 1] = min;\n        }\n        i\
    \ += 2;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoypucl5m.d(33): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoypucl5m.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (l; lst)\n    {\n        if (l < min)\n            min = l;\n   \
    \     if (l > max)\n            max = l;\n    }\n    long[] res = new long[lst.length];\n\
    \    bool asc = true;\n    long i = 0;\n    while (i < lst.length)\n    {\n  \
    \      if (asc)\n        {\n            res[i] = min;\n            min = max;\n\
    \            foreach (l; lst)\n            {\n                if (l < min && l\
    \ != res[i])\n                    min = l;\n            }\n        }\n       \
    \ else\n        {\n            res[i] = max;\n            max = min;\n       \
    \     foreach (l; lst)\n            {\n                if (l > max && l != res[i])\n\
    \                    max = l;\n            }\n        }\n        asc = !asc;\n\
    \        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpelvv52ou.d(63): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428a8d]\\n??:? void tmpelvv52ou.__unittest_L58_C1()\
    \ [0x428285]\\n??:? void tmpelvv52ou.__modtest() [0x428810]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cb6b]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b9fe]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430c89]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x431138]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430c15]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b9d5]\\n??:? runModuleUnitTests [0x42c941]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428f50]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428ed7]\\n??:? _d_run_main [0x428e42]\\n??:? main [0x428823]\\\
    n??:? __libc_start_main [0xf4271554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (e; lst_copy)\n    {\n        if (e < min)\n            min = e;\n\
    \        if (e > max)\n            max = e;\n    }\n    int i = 0;\n    int j\
    \ = lst_copy.length - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n\
    \        if (is_min)\n        {\n            result[i] = min;\n            lst_copy.remove(min);\n\
    \            min = lst_copy[0];\n            foreach (e; lst_copy)\n         \
    \   {\n                if (e < min)\n                    min = e;\n          \
    \  }\n            i++;\n        }\n        else\n        {\n            result[j]\
    \ = max;\n            lst_copy.remove(max);\n            max = lst_copy[0];\n\
    \            foreach (e; lst_copy)\n            {\n                if (e > max)\n\
    \                    max = e;\n            }\n            j--;\n        }\n  \
    \      is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7onxht4j.d(31): Error: cannot implicitly convert expression `lst_copy.length\
    \ - 1LU` of type `ulong` to `int`\\n/tmp/tmp7onxht4j.d(38): Error: no property\
    \ `remove` for type `long[]`\\n/tmp/tmp7onxht4j.d(50): Error: no property `remove`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7onxht4j.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    int i = 0;\n    while (remaining.length > 0)\n   \
    \ {\n        result[i] = remaining[0];\n        remaining = remaining[1..$];\n\
    \        if (remaining.length == 0)\n            break;\n        result[i+1] =\
    \ remaining[$-1];\n        remaining = remaining[0..$-2];\n        i += 2;\n \
    \   }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp12t887r7.d(38): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x429ab1]\\n??:? void tmp12t887r7.__unittest_L34_C1()\
    \ [0x42825e]\\n??:? void tmp12t887r7.__modtest() [0x428a28]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42e6ef]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42973a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x42b479]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x42b508]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x42b405]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x429711]\\n??:? runModuleUnitTests [0x42e4c5]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x429fc8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x429f4f]\\n??:? _d_run_main [0x429eba]\\n??:? main [0x428a3b]\\\
    n??:? __libc_start_main [0x8c885554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = lst[0];\n    auto max = lst[0];\n\
    \    foreach (i; lst)\n    {\n        if (i < min)\n            min = i;\n   \
    \     if (i > max)\n            max = i;\n    }\n    auto min_index = 0;\n   \
    \ auto max_index = 0;\n    foreach (i; lst)\n    {\n        if (i == min)\n  \
    \          min_index = i;\n        if (i == max)\n            max_index = i;\n\
    \    }\n    auto result = new long[lst.length];\n    result[0] = min;\n    result[1]\
    \ = max;\n    auto index = 2;\n    foreach (i; lst)\n    {\n        if (i != min\
    \ && i != max)\n        {\n            result[index] = i;\n            index++;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7d6s9c2h.d(33): Error: cannot implicitly convert expression `i`\
    \ of type `long` to `int`\\n/tmp/tmp7d6s9c2h.d(35): Error: cannot implicitly convert\
    \ expression `i` of type `long` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp7d6s9c2h.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long min_index = 0;\n\
    \    long max_index = lst.length - 1;\n    for (long i = 0; i < lst.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            res[i] = min;\n      \
    \      min_index++;\n            min = lst[min_index];\n        }\n        else\n\
    \        {\n            res[i] = max;\n            max_index--;\n            max\
    \ = lst[max_index];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp_tykwp0x.d(55): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428a1d]\\n??:? void tmp_tykwp0x.__unittest_L48_C1()\
    \ [0x42839f]\\n??:? void tmp_tykwp0x.__modtest() [0x4287a0]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42cafb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b98e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430c19]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x4310c8]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430ba5]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b965]\\n??:? runModuleUnitTests [0x42c8d1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ee0]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428e67]\\n??:? _d_run_main [0x428dd2]\\n??:? main [0x4287b3]\\\
    n??:? __libc_start_main [0xa9e75554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = min(lst);\n    long max = max(lst);\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = min;\n            i++;\n            is_min =\
    \ false;\n        }\n        else\n        {\n            res[j] = max;\n    \
    \        j--;\n            is_min = true;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqd01gw_s.d(20): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpqd01gw_s.d(21): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmpqd01gw_s.d(23): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqd01gw_s.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long min = lst[0];\n\
    \    long max = lst[0];\n    foreach (e; lst)\n    {\n        if (e < min) min\
    \ = e;\n        if (e > max) max = e;\n    }\n    long[] lst2 = lst.dup;\n   \
    \ lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[1] = max;\n\
    \    int i = 2;\n    while (lst2.length > 0)\n    {\n        min = lst2[0];\n\
    \        max = lst2[0];\n        foreach (e; lst2)\n        {\n            if\
    \ (e < min) min = e;\n            if (e > max) max = e;\n        }\n        lst2.remove(min);\n\
    \        lst2.remove(max);\n        res[i] = min;\n        res[i+1] = max;\n \
    \       i += 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp11p2vp6p.d(27): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp11p2vp6p.d(28): Error: no property `remove` for type `long[]`\\n/tmp/tmp11p2vp6p.d(41):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp11p2vp6p.d(42): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp11p2vp6p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    foreach (e; lst)\n    {\n        min = min(min, e);\n        max = max(max,\
    \ e);\n    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    int\
    \ j = lst.length - 1;\n    foreach (e; lst)\n    {\n        if (e == min)\n  \
    \      {\n            res[i] = e;\n            i++;\n        }\n        else if\
    \ (e == max)\n        {\n            res[j] = e;\n            j--;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpue70m7bd.d(23): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpue70m7bd.d(24): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpue70m7bd.d(28): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpue70m7bd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    while (lst.length > 0)\n    {\n        long min = lst[0];\n    \
    \    long max = lst[0];\n        foreach (long e; lst)\n        {\n          \
    \  if (e < min)\n                min = e;\n            if (e > max)\n        \
    \        max = e;\n        }\n        result[i++] = min;\n        lst = lst.remove(min);\n\
    \        if (lst.length > 0)\n        {\n            result[i++] = max;\n    \
    \        lst = lst.remove(max);\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx_5anyfz.d(33): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpx_5anyfz.d(37): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx_5anyfz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    foreach (i; lst)\n    {\n       \
    \ if (i < min)\n            min = i;\n        if (i > max)\n            max =\
    \ i;\n    }\n    long[] lst_copy = lst.dup;\n    lst_copy.remove(min);\n    lst_copy.remove(max);\n\
    \    res[0] = min;\n    res[1] = max;\n    for (int i = 2; i < res.length; i++)\n\
    \    {\n        if (i % 2 == 0)\n        {\n            min = lst_copy[0];\n \
    \           foreach (j; lst_copy)\n            {\n                if (j < min)\n\
    \                    min = j;\n            }\n            res[i] = min;\n    \
    \        lst_copy.remove(min);\n        }\n        else\n        {\n         \
    \   max = lst_copy[0];\n            foreach (j; lst_copy)\n            {\n   \
    \             if (j > max)\n                    max = j;\n            }\n    \
    \        res[i] = max;\n            lst_copy.remove(max);\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n\
    \    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8_n6egmt.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp8_n6egmt.d(31): Error: no property `remove` for type `long[]`\\n/tmp/tmp8_n6egmt.d(45):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp8_n6egmt.d(56): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp8_n6egmt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    int\
    \ i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n    while (i <= j)\n  \
    \  {\n        res[k++] = lst[i++];\n        if (i <= j)\n            res[k++]\
    \ = lst[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5rw7i4zk.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5rw7i4zk.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (int i = 1; i < lst.length; i++)\n    {\n        if (lst[i] < min)\n\
    \            min = lst[i];\n        if (lst[i] > max)\n            max = lst[i];\n\
    \    }\n    long[] res = new long[lst.length];\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    while (i <= j)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = min;\n            i++;\n        }\n        else\n\
    \        {\n            res[j] = max;\n            j--;\n        }\n        is_min\
    \ = !is_min;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqyz_nkfn.d(30): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmpqyz_nkfn.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool asc = true;\n    int i = 0;\n\
    \    int j = 0;\n    while (i < sorted.length)\n    {\n        if (asc)\n    \
    \    {\n            result[j] = sorted[i];\n            i++;\n        }\n    \
    \    else\n        {\n            result[j] = sorted[sorted.length - i - 1];\n\
    \        }\n        j++;\n        asc = !asc;\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyjdz95d7.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpyjdz95d7.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    int i = 0;\n    int j = lst.length - 1;\n    int k = 0;\n\
    \    while (i <= j)\n    {\n        res[k++] = sorted[i++];\n        if (i <=\
    \ j) res[k++] = sorted[j--];\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1wqk6jxp.d(19): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp1wqk6jxp.d(21): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp1wqk6jxp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ tmp = lst.dup;\n    tmp.sort;\n    int i = 0;\n    int j = tmp.length - 1;\n\
    \    bool flag = true;\n    foreach (e; lst)\n    {\n        if (flag)\n     \
    \   {\n            res[i] = tmp[j];\n            j--;\n        }\n        else\n\
    \        {\n            res[i] = tmp[j];\n            j++;\n        }\n      \
    \  i++;\n        flag = !flag;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5ervz6ws.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5ervz6ws.d(23): Error: cannot implicitly convert expression `tmp.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp5ervz6ws.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[res.length\
    \ - 1] = max;\n    long[] lst3 = strange_sort_list(lst2);\n    for (long i = 0;\
    \ i < lst3.length; i++)\n    {\n        if (i % 2 == 0)\n            res[i + 1]\
    \ = lst3[i];\n        else\n            res[res.length - 2 - i] = lst3[i];\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsc32_ztb.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpsc32_ztb.d(31): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsc32_ztb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    bool asc = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        if (asc)\n        {\n            res[i] = lst_copy.min;\n    \
    \        lst_copy.remove(lst_copy.min);\n        }\n        else\n        {\n\
    \            res[i] = lst_copy.max;\n            lst_copy.remove(lst_copy.max);\n\
    \        }\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmgswjy3p.d(26): Error: no property `min` for type `long[]`\\\
    n/tmp/tmpmgswjy3p.d(27): Error: no property `remove` for type `long[]`\\n/tmp/tmpmgswjy3p.d(31):\
    \ Error: no property `max` for type `long[]`\\n/tmp/tmpmgswjy3p.d(32): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpmgswjy3p.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    int i = 0;\n    while (lst_copy.length > 0)\n    {\n\
    \        long min = lst_copy[0];\n        long max = lst_copy[0];\n        foreach\
    \ (el; lst_copy)\n        {\n            min = min(min, el);\n            max\
    \ = max(max, el);\n        }\n        res[i] = min;\n        res[i + 1] = max;\n\
    \        lst_copy = lst_copy.filter!(a => a != min && a != max);\n        i +=\
    \ 2;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpepjkf5xx.d(28): Error: function expected before `()`, not `min`\
    \ of type `long`\\n/tmp/tmpepjkf5xx.d(29): Error: function expected before `()`,\
    \ not `max` of type `long`\\n/tmp/tmpepjkf5xx.d(33): Error: no property `filter`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpepjkf5xx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort;\n    bool asc = true;\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n       \
    \ }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2qzyhjc3.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2qzyhjc3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    long[] res =\
    \ new long[lst.length];\n    int i = 0;\n    int j = lst.length - 1;\n    int\
    \ k = 0;\n    while (i <= j)\n    {\n        res[k++] = lst[i++];\n        if\
    \ (i <= j)\n            res[k++] = lst[j--];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp292vsvhf.d(19): Error: cannot implicitly convert expression `lst.length\
    \ - 1LU` of type `ulong` to `int`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"\
    -o-\", \"/tmp/tmp292vsvhf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long\
    \ min = min(lst);\n    long max = max(lst);\n    int i = 0;\n    int j = lst.length\
    \ - 1;\n    bool is_min = true;\n    foreach (el; lst)\n    {\n        if (is_min)\n\
    \        {\n            result[i] = el;\n            i++;\n        }\n       \
    \ else\n        {\n            result[j] = el;\n            j--;\n        }\n\
    \        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq3shbhdp.d(20): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmpq3shbhdp.d(21): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmpq3shbhdp.d(23): Error: cannot implicitly\
    \ convert expression `lst.length - 1LU` of type `ulong` to `int`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq3shbhdp.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    bool is_min = true;\n    foreach\
    \ (i, ref e; result)\n    {\n        if (is_min)\n        {\n            e = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        e = sorted[$-1];\n            sorted = sorted[0..$-1];\n        }\n \
    \       is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpq5uuqgjp.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpq5uuqgjp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    int\
    \ i = 0;\n    while (lst.length > 0)\n    {\n        long min = lst[0];\n    \
    \    long max = lst[0];\n        foreach (long x; lst)\n        {\n          \
    \  if (x < min)\n                min = x;\n            if (x > max)\n        \
    \        max = x;\n        }\n        result[i] = min;\n        i++;\n       \
    \ result[i] = max;\n        i++;\n        lst = lst.filter!(x => x != min && x\
    \ != max);\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkcc2jg1x.d(36): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcc2jg1x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_c = lst.dup;\n    long min = lst_c[0];\n    long max = lst_c[0];\n    foreach\
    \ (el; lst_c)\n    {\n        if (el < min)\n            min = el;\n        if\
    \ (el > max)\n            max = el;\n    }\n    res[0] = min;\n    lst_c.remove(min);\n\
    \    bool is_min = true;\n    foreach (i; 1..lst.length)\n    {\n        if (is_min)\n\
    \        {\n            res[i] = lst_c[0];\n            lst_c.remove(lst_c[0]);\n\
    \            is_min = false;\n        }\n        else\n        {\n           \
    \ res[i] = lst_c[$-1];\n            lst_c.remove(lst_c[$-1]);\n            is_min\
    \ = true;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5_m6tqz9.d(31): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp5_m6tqz9.d(38): Error: no property `remove` for type `long[]`\\n/tmp/tmp5_m6tqz9.d(44):\
    \ Error: no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp5_m6tqz9.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i = 0; i < lst.length;\
    \ i++)\n    {\n        if (lst[i] < min)\n            min = lst[i];\n        if\
    \ (lst[i] > max)\n            max = lst[i];\n    }\n    long[] lst2 = lst.dup;\n\
    \    lst2.remove(min);\n    lst2.remove(max);\n    res[0] = min;\n    res[res.length\
    \ - 1] = max;\n    long[] res2 = strange_sort_list(lst2);\n    for (long i = 0;\
    \ i < res2.length; i++)\n        res[i + 1] = res2[i];\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmm_yfbxj.d(30): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmpmm_yfbxj.d(31): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmm_yfbxj.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ remaining = lst.dup;\n    bool is_min = true;\n    foreach (i; 0 .. lst.length)\n\
    \    {\n        long min_max = is_min ? remaining.min : remaining.max;\n     \
    \   result[i] = min_max;\n        remaining = remaining.filter!(a => a != min_max);\n\
    \        is_min = !is_min;\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) ==\
    \ [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L,\
    \ 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n\
    \    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n\
    \    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([])\
    \ == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L,\
    \ 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L, 2L, 2L, 5L, 5L, -5L,\
    \ -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7aad28so.d(24): Error: no property `min` for type `long[]`\\\
    n/tmp/tmp7aad28so.d(24): Error: no property `max` for type `long[]`\\n/tmp/tmp7aad28so.d(26):\
    \ Error: no property `filter` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp7aad28so.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ lst_copy = lst.dup;\n    long min = lst_copy[0];\n    long max = lst_copy[0];\n\
    \    foreach (i; lst_copy)\n    {\n        if (i < min)\n            min = i;\n\
    \        if (i > max)\n            max = i;\n    }\n    res[0] = min;\n    lst_copy.remove(min);\n\
    \    res[1] = max;\n    lst_copy.remove(max);\n    int i = 2;\n    while (lst_copy.length\
    \ != 0)\n    {\n        min = lst_copy[0];\n        max = lst_copy[0];\n     \
    \   foreach (j; lst_copy)\n        {\n            if (j < min)\n             \
    \   min = j;\n            if (j > max)\n                max = j;\n        }\n\
    \        res[i] = min;\n        lst_copy.remove(min);\n        i++;\n        res[i]\
    \ = max;\n        lst_copy.remove(max);\n        i++;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplv3uwy1a.d(31): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmplv3uwy1a.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmplv3uwy1a.d(47):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmplv3uwy1a.d(50): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmplv3uwy1a.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ tmp = lst.dup;\n    tmp.sort;\n    bool asc = true;\n    int i = 0;\n    while\
    \ (tmp.length > 0)\n    {\n        if (asc)\n        {\n            res[i] = tmp[0];\n\
    \            tmp = tmp[1..$];\n        }\n        else\n        {\n          \
    \  res[i] = tmp[$-1];\n            tmp = tmp[0..$-1];\n        }\n        asc\
    \ = !asc;\n        i++;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L,\
    \ 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n\
    \    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L,\
    \ 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmmy7pkrs.d(21): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmmy7pkrs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    auto min = min(lst);\n    auto max = max(lst);\n\
    \    auto min_index = indexOf(lst, min);\n    auto max_index = indexOf(lst, max);\n\
    \    auto lst_copy = lst.dup;\n    lst_copy.removeAt(min_index);\n    lst_copy.removeAt(max_index);\n\
    \    auto new_lst = [min, max];\n    while (lst_copy.length != 0)\n    {\n   \
    \     min = min(lst_copy);\n        max = max(lst_copy);\n        min_index =\
    \ indexOf(lst_copy, min);\n        max_index = indexOf(lst_copy, max);\n     \
    \   new_lst ~= [min, max];\n        lst_copy.removeAt(min_index);\n        lst_copy.removeAt(max_index);\n\
    \    }\n    return new_lst;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\
    \n    assert(candidate([1L, 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L,\
    \ 6L, 7L, 8L, 9L]) == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L,\
    \ 4L, 5L]) == [1L, 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L,\
    \ 1L]) == [1L, 9L, 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) ==\
    \ [5L, 5L, 5L, 5L]);\n    assert(candidate([]) == []);\n    assert(candidate([1L,\
    \ 2L, 3L, 4L, 5L, 6L, 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L,\
    \ 2L, 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n   \
    \ assert(candidate([111111L]) == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphclqqnce.d(19): Error: undefined identifier `min`, did you mean\
    \ function `main`?\\n/tmp/tmphclqqnce.d(20): Error: undefined identifier `max`,\
    \ did you mean function `fmax`?\\n/tmp/tmphclqqnce.d(21): Error: undefined identifier\
    \ `indexOf`\\n/tmp/tmphclqqnce.d(22): Error: undefined identifier `indexOf`\\\
    n/tmp/tmphclqqnce.d(24): Error: no property `removeAt` for type `long[]`\\n/tmp/tmphclqqnce.d(25):\
    \ Error: no property `removeAt` for type `long[]`\\n/tmp/tmphclqqnce.d(34): Error:\
    \ no property `removeAt` for type `long[]`\\n/tmp/tmphclqqnce.d(35): Error: no\
    \ property `removeAt` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmphclqqnce.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0) return lst;\n    long[] res = new long[lst.length];\n    long[] sorted\
    \ = lst.dup.sort();\n    bool asc = true;\n    int i = 0;\n    while (sorted.length\
    \ > 0)\n    {\n        if (asc)\n        {\n            res[i] = sorted[0];\n\
    \            sorted = sorted[1..$];\n        }\n        else\n        {\n    \
    \        res[i] = sorted[$-1];\n            sorted = sorted[0..$-1];\n       \
    \ }\n        i++;\n        asc = !asc;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptokhleyu.d(19): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptokhleyu.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] result = new long[lst.length];\n    long[]\
    \ copy = lst.dup;\n    long min = copy[0];\n    long max = copy[0];\n    foreach\
    \ (long i; copy)\n    {\n        if (i < min)\n            min = i;\n        if\
    \ (i > max)\n            max = i;\n    }\n    result[0] = min;\n    copy.remove(min);\n\
    \    result[1] = max;\n    copy.remove(max);\n    for (long i = 2; i < result.length;\
    \ i++)\n    {\n        if (i % 2 == 0)\n        {\n            min = copy[0];\n\
    \            foreach (long j; copy)\n            {\n                if (j < min)\n\
    \                    min = j;\n            }\n            result[i] = min;\n \
    \           copy.remove(min);\n        }\n        else\n        {\n          \
    \  max = copy[0];\n            foreach (long j; copy)\n            {\n       \
    \         if (j > max)\n                    max = j;\n            }\n        \
    \    result[i] = max;\n            copy.remove(max);\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L,\
    \ 2L, 3L, 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L])\
    \ == [5L, 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L,\
    \ 5L, 2L, 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L,\
    \ 5L, 8L, 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n\
    \    assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp309tcuf5.d(31): Error: no property `remove` for type `long[]`\\\
    n/tmp/tmp309tcuf5.d(33): Error: no property `remove` for type `long[]`\\n/tmp/tmp309tcuf5.d(45):\
    \ Error: no property `remove` for type `long[]`\\n/tmp/tmp309tcuf5.d(56): Error:\
    \ no property `remove` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp309tcuf5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\n\n    Given list of integers,\
    \ return list in strange order.\n    Strange sorting, is when you start with the\
    \ minimum value,\n    then maximum of the remaining integers, then minimum and\
    \ so on.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n\
    \    strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n    strange_sort_list([])\
    \ == []\n    \n*/\nlong[] strange_sort_list(long[] lst) \n{\n    if (lst.length\
    \ == 0)\n        return lst;\n    long[] res = new long[lst.length];\n    long[]\
    \ sorted = lst.dup;\n    sorted.sort();\n    long min = sorted[0];\n    long max\
    \ = sorted[sorted.length - 1];\n    bool min_first = true;\n    foreach (i, val;\
    \ lst)\n    {\n        if (min_first)\n        {\n            res[i] = min;\n\
    \            min_first = false;\n        }\n        else\n        {\n        \
    \    res[i] = max;\n            min_first = true;\n        }\n        sorted.remove(val);\n\
    \        if (sorted.length == 0)\n            break;\n        min = sorted[0];\n\
    \        max = sorted[sorted.length - 1];\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = strange_sort_list;\n\n    assert(candidate([1L, 2L, 3L,\
    \ 4L]) == [1L, 4L, 2L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L]) == [5L,\
    \ 9L, 6L, 8L, 7L]);\n    assert(candidate([1L, 2L, 3L, 4L, 5L]) == [1L, 5L, 2L,\
    \ 4L, 3L]);\n    assert(candidate([5L, 6L, 7L, 8L, 9L, 1L]) == [1L, 9L, 5L, 8L,\
    \ 6L, 7L]);\n    assert(candidate([5L, 5L, 5L, 5L]) == [5L, 5L, 5L, 5L]);\n  \
    \  assert(candidate([]) == []);\n    assert(candidate([1L, 2L, 3L, 4L, 5L, 6L,\
    \ 7L, 8L]) == [1L, 8L, 2L, 7L, 3L, 6L, 4L, 5L]);\n    assert(candidate([0L, 2L,\
    \ 2L, 2L, 5L, 5L, -5L, -5L]) == [-5L, 5L, -5L, 5L, 0L, 2L, 2L, 2L]);\n    assert(candidate([111111L])\
    \ == [111111L]);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnn8hmv99.d(21): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpnn8hmv99.d(37): Error: no property `remove` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnn8hmv99.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
