name: HumanEval_58_common
language: humaneval_to_dlang.py
results:
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfqq8_eaa.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpfqq8_eaa.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpfqq8_eaa.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfqq8_eaa.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[] temp4;\n \
    \   long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[] temp8;\n \
    \   long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[] temp12;\n\
    \    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[] temp16;\n\
    \    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[] temp20;\n\
    \    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[] temp24;\n\
    \    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[] temp28;\n\
    \    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[] temp32;\n\
    \    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[] temp36;\n\
    \    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[] temp40;\n\
    \    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[] temp44;\n\
    \    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[] temp48;\n\
    \    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[] temp52;\n\
    \    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[] temp56;\n\
    \    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[] temp60;\n\
    \    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[] temp64;\n\
    \    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[] temp68;\n\
    \    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n    long[] temp72;\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpohb0_dbp.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpohb0_dbp.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplxt60qxs.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmplxt60qxs.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmplxt60qxs.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplxt60qxs.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphtqqqil7.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmphtqqqil7.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphtqqqil7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw0f7849_.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpw0f7849_.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpw0f7849_.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpw0f7849_.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpw0f7849_.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn9wb3kf4.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpn9wb3kf4.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpn9wb3kf4.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long l; l1)\n    {\n        if(l2.canFind(l))\n \
    \       {\n            result ~= l;\n        }\n    }\n    return result.sort().dup;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmparnt_4zv.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmparnt_4zv.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmparnt_4zv.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmparnt_4zv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpaqpijlyq.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpaqpijlyq.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpaqpijlyq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            res ~=\
    \ e;\n        }\n    }\n    return res.sort().uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpns5rj2g6.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpns5rj2g6.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpns5rj2g6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length > l2.length) \n    {\n        result = common(l2, l1);\n  \
    \  } \n    else \n    {\n        result = [];\n        foreach (l; l1) \n    \
    \    {\n            if (l in l2) \n            {\n                result ~= l;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5pghxxjp.d(24): Error: incompatible types for `(l) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp5pghxxjp.d(30): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5pghxxjp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            if(!result.canFind(i))\n            {\n                result ~=\
    \ i;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpep9980li.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpep9980li.d(19): Error: no property `canFind` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpep9980li.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort();\n    auto s2 = l2.sort();\n    auto result = new long[];\n    auto\
    \ i = 0;\n    auto j = 0;\n    while (i < s1.length && j < s2.length) \n    {\n\
    \        if (s1[i] == s2[j]) \n        {\n            result ~= s1[i];\n     \
    \       i++;\n            j++;\n        } \n        else if (s1[i] < s2[j]) \n\
    \        {\n            i++;\n        } \n        else \n        {\n         \
    \   j++;\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcyy9ldls.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpcyy9ldls.d(15): Error: no property `sort` for type `long[]`\\n/tmp/tmpcyy9ldls.d(16):\
    \ Error: new can only create structs, dynamic arrays or class objects, not `long[]`\\\
    's\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcyy9ldls.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long x; l1)\n    {\n        foreach(long y; l2)\n\
    \        {\n            if(x == y)\n            {\n                result ~= x;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8b2tfb0i.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8b2tfb0i.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l) > 0)\n    \
    \    {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdfja1t8y.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpdfja1t8y.d(17): Error: no property\
    \ `count` for type `long[]`\\n/tmp/tmpdfja1t8y.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdfja1t8y.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            if(!result.canFind(i))\n            {\n                result ~=\
    \ i;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpvp8cdq87.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpvp8cdq87.d(19): Error: no property `canFind` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpvp8cdq87.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp11_ewmzx.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp11_ewmzx.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp11_ewmzx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpljqqi5cg.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpljqqi5cg.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpljqqi5cg.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpljqqi5cg.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n \
    \       {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxkgokru3.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpxkgokru3.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpxkgokru3.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxkgokru3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpms7xafc0.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpms7xafc0.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpms7xafc0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcqqv_wr9.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcqqv_wr9.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    long[] l1_unique_sorted = l1_unique.sort;\n    long[] l2_unique_sorted =\
    \ l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet;\n    long[] l1_unique_sorted_set_intersection\
    \ = l1_unique_sorted_set.intersection(l2_unique_sorted_set);\n    result = l1_unique_sorted_set_intersection.array;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp773du6bt.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp773du6bt.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp773du6bt.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmp773du6bt.d(18): Error:\
    \ no property `unique` for type `long[]`\\n/tmp/tmp773du6bt.d(19): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmp773du6bt.d(20): Error: no property `sort`\
    \ for type `long[]`\\n/tmp/tmp773du6bt.d(21): Error: no property `toSet` for type\
    \ `long[]`\\n/tmp/tmp773du6bt.d(22): Error: no property `toSet` for type `long[]`\\\
    n/tmp/tmp773du6bt.d(23): Error: no property `intersection` for type `long[]`\\\
    n/tmp/tmp773du6bt.d(24): Error: no property `array` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp773du6bt.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length > l2.length) \n    {\n        result = l1.filter!(x => l2.canFind(x)).array.sort().uniq;\n\
    \    } \n    else \n    {\n        result = l2.filter!(x => l1.canFind(x)).array.sort().uniq;\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp47ukabbc.d(17): Error: no property `filter` for type `long[]`\\\
    n/tmp/tmp47ukabbc.d(21): Error: no property `filter` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp47ukabbc.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    long[] result2 = new long[l1.length];\n    long[]\
    \ result3 = new long[l1.length];\n    long[] result4 = new long[l1.length];\n\
    \    long[] result5 = new long[l1.length];\n    long[] result6 = new long[l1.length];\n\
    \    long[] result7 = new long[l1.length];\n    long[] result8 = new long[l1.length];\n\
    \    long[] result9 = new long[l1.length];\n    long[] result10 = new long[l1.length];\n\
    \    long[] result11 = new long[l1.length];\n    long[] result12 = new long[l1.length];\n\
    \    long[] result13 = new long[l1.length];\n    long[] result14 = new long[l1.length];\n\
    \    long[] result15 = new long[l1.length];\n    long[] result16 = new long[l1.length];\n\
    \    long[] result17 = new long[l1.length];\n    long[] result18 = new long[l1.length];\n\
    \    long[] result19 = new long[l1.length];\n    long[] result20 = new long[l1.length];\n\
    \    long[] result21 = new long[l1.length];\n    long[] result22 = new long[l1.length];\n\
    \    long[] result23 = new long[l1.length];\n    long[] result24 = new long[l1.length];\n\
    \    long[] result25 = new long[l1.length];\n    long[] result26 = new long[l1.length];\n\
    \    long[] result27 = new long[l1.length];\n    long[] result28 = new long[l1.length];\n\
    \    long[] result29 = new long[l1.length];\n    long[] result30 = new long[l1.length];\n\
    \    long[] result31 = new long[l1.length];\n    long[] result32 = new long[l1.length];\n\
    \    long[] result33 = new long[l1.length];\n    long[] result34 = new long[l1.length];\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5zd9ezl6.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5zd9ezl6.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    result = l1.filter!(a => l2.canFind(a)).sort().unique();\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_xw__94c.d(15): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_xw__94c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    long[] result2 = new long[l1.length];\n    long[]\
    \ result3 = new long[l1.length];\n    long[] result4 = new long[l1.length];\n\
    \    long[] result5 = new long[l1.length];\n    long[] result6 = new long[l1.length];\n\
    \    long[] result7 = new long[l1.length];\n    long[] result8 = new long[l1.length];\n\
    \    long[] result9 = new long[l1.length];\n    long[] result10 = new long[l1.length];\n\
    \    long[] result11 = new long[l1.length];\n    long[] result12 = new long[l1.length];\n\
    \    long[] result13 = new long[l1.length];\n    long[] result14 = new long[l1.length];\n\
    \    long[] result15 = new long[l1.length];\n    long[] result16 = new long[l1.length];\n\
    \    long[] result17 = new long[l1.length];\n    long[] result18 = new long[l1.length];\n\
    \    long[] result19 = new long[l1.length];\n    long[] result20 = new long[l1.length];\n\
    \    long[] result21 = new long[l1.length];\n    long[] result22 = new long[l1.length];\n\
    \    long[] result23 = new long[l1.length];\n    long[] result24 = new long[l1.length];\n\
    \    long[] result25 = new long[l1.length];\n    long[] result26 = new long[l1.length];\n\
    \    long[] result27 = new long[l1.length];\n    long[] result28 = new long[l1.length];\n\
    \    long[] result29 = new long[l1.length];\n    long[] result30 = new long[l1.length];\n\
    \    long[] result31 = new long[l1.length];\n    long[] result32 = new long[l1.length];\n\
    \    long[] result33 = new long[l1.length];\n    long[] result34 = new long[l1.length];\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpol5btcd3.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpol5btcd3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_unique = l1.unique;\n    long[] l2_unique = l2.unique;\n    foreach(long\
    \ i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n        {\n      \
    \      if(i == j)\n            {\n                result ~= i;\n            }\n\
    \        }\n    }\n    return result.sort;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxs6e0mfu.d(15): Error: no property `unique` for type `long[]`\\\
    n/tmp/tmpxs6e0mfu.d(16): Error: no property `unique` for type `long[]`\\n/tmp/tmpxs6e0mfu.d(27):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxs6e0mfu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    foreach(e; l1_unique)\n    {\n        if(l2_unique.canFind(e))\n        {\n\
    \            result ~= e;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp9h_crvon.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp9h_crvon.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp9h_crvon.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp9h_crvon.d(18): Error:\
    \ no property `uniq` for type `long[]`\\n/tmp/tmp9h_crvon.d(21): Error: no property\
    \ `canFind` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp9h_crvon.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    result = l1.filter!(x => l2.canFind(x)).sort().uniq;\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpabb44z6q.d(15): Error: no property `filter` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpabb44z6q.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[] temp4;\n \
    \   long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[] temp8;\n \
    \   long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[] temp12;\n\
    \    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[] temp16;\n\
    \    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[] temp20;\n\
    \    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[] temp24;\n\
    \    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[] temp28;\n\
    \    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[] temp32;\n\
    \    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[] temp36;\n\
    \    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[] temp40;\n\
    \    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[] temp44;\n\
    \    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[] temp48;\n\
    \    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[] temp52;\n\
    \    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[] temp56;\n\
    \    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[] temp60;\n\
    \    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[] temp64;\n\
    \    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[] temp68;\n\
    \    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n    long[] temp72;\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps8ihxzn2.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps8ihxzn2.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1v6rj423.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp1v6rj423.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1v6rj423.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort();\n    auto s2 = l2.sort();\n    long[] res;\n    foreach(i, e; s1)\n\
    \    {\n        if(s2.canFind(e))\n        {\n            res ~= e;\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = common;\n\n   \
    \ assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpbdp9wlag.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpbdp9wlag.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpbdp9wlag.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(i; l1)\n    {\n        foreach(j; l2)\n        {\n\
    \            if(i == j)\n            {\n                result ~= i;\n       \
    \     }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwaqv5hl3.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwaqv5hl3.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long i = 0;\n    long j = 0;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length) \n    {\n        if (l1_sorted[i] == l2_sorted[j])\
    \ \n        {\n            result ~= l1_sorted[i];\n            i++;\n       \
    \     j++;\n        }\n        else if (l1_sorted[i] < l2_sorted[j]) \n      \
    \  {\n            i++;\n        }\n        else \n        {\n            j++;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpz5wii2kl.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpz5wii2kl.d(16): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpz5wii2kl.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps0ttzna0.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps0ttzna0.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmporin3j7m.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmporin3j7m.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmporin3j7m.d(22): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmporin3j7m.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121,\
    \ 653]\n    >>> unique([5, 3, 2, 8], [3, 2])\n    [2, 3, 5, 8]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] result = new long[];\n    foreach(l; l1)\n  \
    \  {\n        result ~= l;\n    }\n    foreach(l; l2)\n    {\n        result ~=\
    \ l;\n    }\n    return result.sort().uniq;\n}\n/*\nReturn sorted unique elements\
    \ for two lists.\n    >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653,\
    \ 121])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121, 653]\n    >>> unique([5, 3, 2, 8],\
    \ [3, 2])\n    [2, 3, 5, 8]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n   \
    \ long[] result = new long[];\n    foreach(l; l1)\n    {\n        result ~= l;\n\
    \    }\n    foreach(l; l2)\n    {\n        result ~= l;\n    }\n    return result.sort().uniq;\n\
    }\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1, 4, 3,\
    \ 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 3, 4, 5, 7, 9, 34, 121,\
    \ 653]\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnfitwlb7.d(64): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnfitwlb7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e1; l1)\n    {\n        foreach(e2; l2)\n        {\n    \
    \        if(e1 == e2)\n            {\n                result ~= e1;\n        \
    \    }\n        }\n    }\n    return result.sort().unique;\n}\nunittest\n{\n \
    \   alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_ki9c784.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_ki9c784.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[0];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long i = 0;\n    long j = 0;\n    while (i < l1_sorted.length && j < l2_sorted.length)\
    \ \n    {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n           \
    \ res ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n      \
    \  else if (l1_sorted[i] < l2_sorted[j]) \n        {\n            i++;\n     \
    \   }\n        else \n        {\n            j++;\n        }\n    }\n    return\
    \ res;\n}\n/*\nReturn sorted unique elements for two lists.\n    >>> unique([1,\
    \ 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [2, 3, 4, 7, 9, 34, 121]\n\
    \    >>> unique([5, 3, 2, 8], [3, 2])\n    [2, 3, 5, 8]\n*/\nlong[] unique(long[]\
    \ l1, long[] l2) \n{\n    long[] res = new long[0];\n    long[] l1_sorted = sort(l1);\n\
    \    long[] l2_sorted = sort(l2);\n    long i = 0;\n    long j = 0;\n    while\
    \ (i < l1_sorted.length && j < l2_sorted.length) \n    {\n        if (l1_sorted[i]\
    \ == l2_sorted[j]) \n        {\n            i++;\n            j++;\n        }\n\
    \        else if (l1_sorted[i] < l2_sorted[j]) \n        {\n            res ~=\
    \ l1_sorted[i];\n            i++;\n        }\n        else \n        {\n     \
    \       res ~= l2_sorted[j];\n            j++;\n        }\n    }\n    while (i\
    \ < l1_sorted.length\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpdurpqf7d.d(71): Error: found `unittest` when expecting `)`\\\
    n/tmp/tmpdurpqf7d.d(80): Error: found `End of File` when expecting `}` following\
    \ compound statement\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpdurpqf7d.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpx4l07ih1.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpx4l07ih1.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique\
    \ = l2_sorted.unique;\n    foreach(long i; l1_unique)\n    {\n        foreach(long\
    \ j; l2_unique)\n        {\n            if(i == j)\n            {\n          \
    \      result ~= i;\n            }\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1dcnihlu.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp1dcnihlu.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp1dcnihlu.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmp1dcnihlu.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1dcnihlu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2zdw9zr6.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp2zdw9zr6.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2zdw9zr6.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[l1.length];\n    long[] res2 = new long[l1.length];\n    long[] res3\
    \ = new long[l1.length];\n    long[] res4 = new long[l1.length];\n    long[] res5\
    \ = new long[l1.length];\n    long[] res6 = new long[l1.length];\n    long[] res7\
    \ = new long[l1.length];\n    long[] res8 = new long[l1.length];\n    long[] res9\
    \ = new long[l1.length];\n    long[] res10 = new long[l1.length];\n    long[]\
    \ res11 = new long[l1.length];\n    long[] res12 = new long[l1.length];\n    long[]\
    \ res13 = new long[l1.length];\n    long[] res14 = new long[l1.length];\n    long[]\
    \ res15 = new long[l1.length];\n    long[] res16 = new long[l1.length];\n    long[]\
    \ res17 = new long[l1.length];\n    long[] res18 = new long[l1.length];\n    long[]\
    \ res19 = new long[l1.length];\n    long[] res20 = new long[l1.length];\n    long[]\
    \ res21 = new long[l1.length];\n    long[] res22 = new long[l1.length];\n    long[]\
    \ res23 = new long[l1.length];\n    long[] res24 = new long[l1.length];\n    long[]\
    \ res25 = new long[l1.length];\n    long[] res26 = new long[l1.length];\n    long[]\
    \ res27 = new long[l1.length];\n    long[] res28 = new long[l1.length];\n    long[]\
    \ res29 = new long[l1.length];\n    long[] res30 = new long[l1.length];\n    long[]\
    \ res31 = new long[l1.length];\n    long[] res32 = new long[l1.length];\n    long[]\
    \ res33 = new long[l1.length];\n    long[] res34 = new long[l1.length];\n\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppay8vkvw.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppay8vkvw.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n \
    \       {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzqpb0ap2.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpzqpb0ap2.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpzqpb0ap2.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzqpb0ap2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpu3dp7_ks.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpu3dp7_ks.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpu3dp7_ks.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpu3dp7_ks.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjf6yiy88.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpjf6yiy88.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmpjf6yiy88.d(22): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpjf6yiy88.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4c88rbr0.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp4c88rbr0.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4c88rbr0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(l2.canFind(e))\n      \
    \  {\n            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpo5lisbqi.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpo5lisbqi.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpo5lisbqi.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpo5lisbqi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    long[] result2 = new long[l1.length];\n    long[]\
    \ result3 = new long[l1.length];\n    long[] result4 = new long[l1.length];\n\
    \    long[] result5 = new long[l1.length];\n    long[] result6 = new long[l1.length];\n\
    \    long[] result7 = new long[l1.length];\n    long[] result8 = new long[l1.length];\n\
    \    long[] result9 = new long[l1.length];\n    long[] result10 = new long[l1.length];\n\
    \    long[] result11 = new long[l1.length];\n    long[] result12 = new long[l1.length];\n\
    \    long[] result13 = new long[l1.length];\n    long[] result14 = new long[l1.length];\n\
    \    long[] result15 = new long[l1.length];\n    long[] result16 = new long[l1.length];\n\
    \    long[] result17 = new long[l1.length];\n    long[] result18 = new long[l1.length];\n\
    \    long[] result19 = new long[l1.length];\n    long[] result20 = new long[l1.length];\n\
    \    long[] result21 = new long[l1.length];\n    long[] result22 = new long[l1.length];\n\
    \    long[] result23 = new long[l1.length];\n    long[] result24 = new long[l1.length];\n\
    \    long[] result25 = new long[l1.length];\n    long[] result26 = new long[l1.length];\n\
    \    long[] result27 = new long[l1.length];\n    long[] result28 = new long[l1.length];\n\
    \    long[] result29 = new long[l1.length];\n    long[] result30 = new long[l1.length];\n\
    \    long[] result31 = new long[l1.length];\n    long[] result32 = new long[l1.length];\n\
    \    long[] result33 = new long[l1.length];\n    long[] result34 = new long[l1.length];\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpb7bf45r_.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpb7bf45r_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpey9ag01b.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpey9ag01b.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpey9ag01b.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] tmp;\n    long[] tmp2;\n    long[] tmp3;\n    long[] tmp4;\n    long[]\
    \ tmp5;\n    long[] tmp6;\n    long[] tmp7;\n    long[] tmp8;\n    long[] tmp9;\n\
    \    long[] tmp10;\n    long[] tmp11;\n    long[] tmp12;\n    long[] tmp13;\n\
    \    long[] tmp14;\n    long[] tmp15;\n    long[] tmp16;\n    long[] tmp17;\n\
    \    long[] tmp18;\n    long[] tmp19;\n    long[] tmp20;\n    long[] tmp21;\n\
    \    long[] tmp22;\n    long[] tmp23;\n    long[] tmp24;\n    long[] tmp25;\n\
    \    long[] tmp26;\n    long[] tmp27;\n    long[] tmp28;\n    long[] tmp29;\n\
    \    long[] tmp30;\n    long[] tmp31;\n    long[] tmp32;\n    long[] tmp33;\n\
    \    long[] tmp34;\n    long[] tmp35;\n    long[] tmp36;\n    long[] tmp37;\n\
    \    long[] tmp38;\n    long[] tmp39;\n    long[] tmp40;\n    long[] tmp41;\n\
    \    long[] tmp42;\n    long[] tmp43;\n    long[] tmp44;\n    long[] tmp45;\n\
    \    long[] tmp46;\n    long[] tmp47;\n    long[] tmp48;\n    long[] tmp49;\n\
    \    long[] tmp50;\n    long[] tmp51;\n    long[] tmp52;\n    long[] tmp53;\n\
    \    long[] tmp54;\n    long[] tmp55;\n    long[] tmp56;\n    long[] tmp57;\n\
    \    long[] tmp58;\n    long[] tmp59;\n    long[] tmp60;\n    long[] tmp61;\n\
    \    long[] tmp62;\n    long[] tmp63;\n    long[] tmp64;\n    long[] tmp65;\n\
    \    long[] tmp66;\n    long[] tmp67;\n    long[] tmp68;\n    long[] tmp69;\n\
    \    long[] tmp70;\n    long[] tmp71;\n    long[] tmp72;\n\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2vnerrjs.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2vnerrjs.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (long x; l2) \n        {\n            if (x in result) \n            {\n   \
    \             result ~= x;\n            }\n        }\n    } \n    else \n    {\n\
    \        result = l2.dup;\n        foreach (long x; l1) \n        {\n        \
    \    if (x in result) \n            {\n                result ~= x;\n        \
    \    }\n        }\n    }\n    return result.sort.uniq;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4a59kv1d.d(20): Error: incompatible types for `(x) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmp4a59kv1d.d(31): Error: incompatible types for\
    \ `(x) in (result)`: `long` and `long[]`\\n/tmp/tmp4a59kv1d.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp4a59kv1d.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxf8s9_ae.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxf8s9_ae.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpxf8s9_ae.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmpxf8s9_ae.d(18): Error:\
    \ no property `uniq` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpxf8s9_ae.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort();\n    auto s2 = l2.sort();\n    auto r = s1.intersect(s2);\n    return\
    \ r.array();\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpe4obbkd7.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpe4obbkd7.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpe4obbkd7.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().dup.unique;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmployddu28.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmployddu28.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmployddu28.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_s573xhw.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp_s573xhw.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp_s573xhw.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp58onndpz.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp58onndpz.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp58onndpz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] l3\
    \ = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n    long[] l5\
    \ = l3.intersect(l4);\n    return l5;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxnpkzfkf.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpxnpkzfkf.d(17): Error: no property `sort` for type `long[]`\\n/tmp/tmpxnpkzfkf.d(18):\
    \ Error: no property `intersect` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpxnpkzfkf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgj4f_yx5.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpgj4f_yx5.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpgj4f_yx5.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgj4f_yx5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (e; l2) \n        {\n            if (e in result) \n            {\n        \
    \        result ~= e;\n            }\n        }\n    } \n    else \n    {\n  \
    \      result = l2.dup;\n        foreach (e; l1) \n        {\n            if (e\
    \ in result) \n            {\n                result ~= e;\n            }\n  \
    \      }\n    }\n    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp43am__ns.d(20): Error: incompatible types for `(e) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmp43am__ns.d(31): Error: incompatible types for\
    \ `(e) in (result)`: `long` and `long[]`\\n/tmp/tmp43am__ns.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp43am__ns.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[] res;\n    foreach(e1;\
    \ s1)\n    {\n        foreach(e2; s2)\n        {\n            if(e1 == e2)\n \
    \           {\n                res ~= e1;\n            }\n        }\n    }\n \
    \   return res;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj14akj0u.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpj14akj0u.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj14akj0u.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n           \
    \ result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkfmu65ne.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpkfmu65ne.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkfmu65ne.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e1; l1)\n    {\n        foreach(e2; l2)\n        {\n    \
    \        if(e1 == e2)\n            {\n                result ~= e1;\n        \
    \    }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n   \
    \ alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcgo6ws21.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcgo6ws21.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpay_96bhi.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpay_96bhi.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpay_96bhi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpouytk859.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpouytk859.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpouytk859.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (el; l2) \n        {\n            if (el in result) \n            {\n      \
    \          result ~= el;\n            }\n        }\n    } \n    else \n    {\n\
    \        result = l2.dup;\n        foreach (el; l1) \n        {\n            if\
    \ (el in result) \n            {\n                result ~= el;\n            }\n\
    \        }\n    }\n    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2nd99gew.d(20): Error: incompatible types for `(el) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmp2nd99gew.d(31): Error: incompatible types for\
    \ `(el) in (result)`: `long` and `long[]`\\n/tmp/tmp2nd99gew.d(37): Error: no\
    \ property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2nd99gew.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] l3\
    \ = new long[l1.length];\n    long[] l4 = new long[l2.length];\n    long[] l5\
    \ = new long[l1.length];\n    long[] l6 = new long[l2.length];\n    long[] l7\
    \ = new long[l1.length];\n    long[] l8 = new long[l2.length];\n    long[] l9\
    \ = new long[l1.length];\n    long[] l10 = new long[l2.length];\n    long[] l11\
    \ = new long[l1.length];\n    long[] l12 = new long[l2.length];\n    long[] l13\
    \ = new long[l1.length];\n    long[] l14 = new long[l2.length];\n    long[] l15\
    \ = new long[l1.length];\n    long[] l16 = new long[l2.length];\n    long[] l17\
    \ = new long[l1.length];\n    long[] l18 = new long[l2.length];\n    long[] l19\
    \ = new long[l1.length];\n    long[] l20 = new long[l2.length];\n    long[] l21\
    \ = new long[l1.length];\n    long[] l22 = new long[l2.length];\n    long[] l23\
    \ = new long[l1.length];\n    long[] l24 = new long[l2.length];\n    long[] l25\
    \ = new long[l1.length];\n    long[] l26 = new long[l2.length];\n    long[] l27\
    \ = new long[l1.length];\n    long[] l28 = new long[l2.length];\n    long[] l29\
    \ = new long[l1.length];\n    long[] l30 = new long[l2.length];\n    long[] l31\
    \ = new long[l1.length];\n    long[] l32 = new long[l2.length];\n    long[] l33\
    \ = new long[l1.length];\n    long[] l34 = new long[l2.length];\n    long[] l35\
    \ = new long[l1.length];\n    long[] l36 = new long[l2.length];\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpttl6043w.d(48): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpttl6043w.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkcik1zfz.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpkcik1zfz.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkcik1zfz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpla3j6znn.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpla3j6znn.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpla3j6znn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long x; l1)\n    {\n        if(l2.canFind(x))\n \
    \       {\n            result ~= x;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmxc7ls6b.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpmxc7ls6b.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpmxc7ls6b.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmxc7ls6b.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpka4o_ms_.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpka4o_ms_.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpka4o_ms_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         if(!result.canFind(l))\n            {\n                result ~= l;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk82yynjs.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpk82yynjs.d(19): Error: no property `canFind` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk82yynjs.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr8jc4qhc.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpr8jc4qhc.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpr8jc4qhc.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr8jc4qhc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_uniq = l1_sorted.dup.uniq;\n    long[] l2_uniq = l2_sorted.dup.uniq;\n\
    \    foreach(l1_item; l1_uniq)\n    {\n        foreach(l2_item; l2_uniq)\n   \
    \     {\n            if(l1_item == l2_item)\n            {\n                result\
    \ ~= l1_item;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2oglbr4i.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp2oglbr4i.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp2oglbr4i.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp2oglbr4i.d(18): Error:\
    \ no property `uniq` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2oglbr4i.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2,\
    \ 8], [3, 2])\n    [2, 3]\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjqzyn__n.d(27): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjqzyn__n.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort().unique();\n    auto s2 = l2.sort().unique();\n    return s1.intersect(s2);\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpioul9k0o.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpioul9k0o.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpioul9k0o.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpngh6qipf.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpngh6qipf.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpngh6qipf.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpngh6qipf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto l1_set\
    \ = set(l1);\n    auto l2_set = set(l2);\n    auto common_set = l1_set & l2_set;\n\
    \    return common_set.array;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfkvibrsd.d(14): Error: undefined identifier `set`, did you mean\
    \ template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\n/tmp/tmpfkvibrsd.d(15):\
    \ Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K])\
    \ aa, K key, lazy inout(V) defaultValue)`?\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpfkvibrsd.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_016pfra.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp_016pfra.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmp_016pfra.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_016pfra.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp73gptjbt.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp73gptjbt.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmp73gptjbt.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp73gptjbt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto l1_set\
    \ = set(l1);\n    auto l2_set = set(l2);\n    auto common_set = l1_set & l2_set;\n\
    \    return common_set.array;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxf9zqn8b.d(14): Error: undefined identifier `set`, did you mean\
    \ template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\n/tmp/tmpxf9zqn8b.d(15):\
    \ Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K])\
    \ aa, K key, lazy inout(V) defaultValue)`?\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpxf9zqn8b.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[] result;\n    foreach(e1;\
    \ s1)\n    {\n        foreach(e2; s2)\n        {\n            if(e1 == e2)\n \
    \           {\n                result ~= e1;\n            }\n        }\n    }\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr8bm7ah5.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpr8bm7ah5.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr8bm7ah5.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp642p52gv.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp642p52gv.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmp642p52gv.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp642p52gv.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwe2nw0zv.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpwe2nw0zv.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwe2nw0zv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    result = [];\n    foreach(l; l1)\n    {\n        foreach(r; l2)\n       \
    \ {\n            if(l == r)\n            {\n                result ~= l;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf5rav5_l.d(26): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpf5rav5_l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long l1_len = l1_sorted.length;\n    long l2_len = l2_sorted.length;\n\
    \    long i = 0;\n    long j = 0;\n    while (i < l1_len && j < l2_len) \n   \
    \ {\n        if (l1_sorted[i] == l2_sorted[j]) \n        {\n            result\
    \ ~= l1_sorted[i];\n            i++;\n            j++;\n        } \n        else\
    \ if (l1_sorted[i] < l2_sorted[j]) \n        {\n            i++;\n        } \n\
    \        else \n        {\n            j++;\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwhe2ulgb.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpwhe2ulgb.d(16): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwhe2ulgb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n \
    \       {\n            if(!result.canFind(i))\n            {\n               \
    \ result ~= i;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzcqi6jad.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpzcqi6jad.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpzcqi6jad.d(19): Error: no property `canFind`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzcqi6jad.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length > l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (long i; l2) \n        {\n            if (result.canFind(i)) \n            {\n\
    \                result ~= i;\n            }\n        }\n    } \n    else \n \
    \   {\n        result = l2.dup;\n        foreach (long i; l1) \n        {\n  \
    \          if (result.canFind(i)) \n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_v9fucuu.d(20): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp_v9fucuu.d(31): Error: no property `canFind` for type `long[]`\\n/tmp/tmp_v9fucuu.d(37):\
    \ Error: no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp_v9fucuu.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(i; l1)\n    {\n        foreach(j; l2)\n        {\n\
    \            if(i == j)\n            {\n                result ~= i;\n       \
    \     }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy9qm1q93.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpy9qm1q93.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpy9qm1q93.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(l2.canFind(e))\n      \
    \  {\n            res ~= e;\n        }\n    }\n    return res.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr1f281__.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpr1f281__.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpr1f281__.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr1f281__.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (e; l2) \n        {\n            if (e in result) \n            {\n        \
    \        result ~= e;\n            }\n        }\n    } \n    else \n    {\n  \
    \      result = l2.dup;\n        foreach (e; l1) \n        {\n            if (e\
    \ in result) \n            {\n                result ~= e;\n            }\n  \
    \      }\n    }\n    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpyxvb1orz.d(20): Error: incompatible types for `(e) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmpyxvb1orz.d(31): Error: incompatible types for\
    \ `(e) in (result)`: `long` and `long[]`\\n/tmp/tmpyxvb1orz.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpyxvb1orz.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpohggrcmt.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpohggrcmt.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpohggrcmt.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpohggrcmt.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpohggrcmt.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  result = l1_sorted.filter!(a => l2_sorted.canFind(a));\n    return result;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg2us11qr.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpg2us11qr.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpg2us11qr.d(17):\
    \ Error: no property `filter` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg2us11qr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfvn3bly0.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpfvn3bly0.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfvn3bly0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n            result\
    \ ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n  \
    \  alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L,\
    \ 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeksx4pe4.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpeksx4pe4.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeksx4pe4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1yg7nt5r.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp1yg7nt5r.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1yg7nt5r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    if (l1.length > l2.length) \n    {\n        temp = l1;\n\
    \        l1 = l2;\n        l2 = temp;\n    }\n    result = new long[l1.length];\n\
    \    long i = 0;\n    foreach (long item; l1) \n    {\n        if (item in l2)\
    \ \n        {\n            result[i] = item;\n            i++;\n        }\n  \
    \  }\n    return result[0..i];\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5bd0ylgi.d(26): Error: incompatible types for `(item) in (l2)`:\
    \ `long` and `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5bd0ylgi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto result\
    \ = new long[](0);\n    auto l1_set = new long[](0);\n    auto l2_set = new long[](0);\n\
    \    foreach(i; l1)\n    {\n        l1_set ~= i;\n    }\n    foreach(i; l2)\n\
    \    {\n        l2_set ~= i;\n    }\n    foreach(i; l1_set)\n    {\n        foreach(j;\
    \ l2_set)\n        {\n            if(i == j)\n            {\n                result\
    \ ~= i;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpt180ucgy.d(41): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428705]\\n??:? void tmpt180ucgy.__unittest_L37_C1()\
    \ [0x42818e]\\n??:? void tmpt180ucgy.__modtest() [0x428488]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d137]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bfca]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430b15]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430fc4]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430aa1]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bfa1]\\n??:? runModuleUnitTests [0x42cf0d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428b54]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428adb]\\n??:? _d_run_main [0x428a46]\\n??:? main [0x42849b]\\\
    n??:? __libc_start_main [0x441ef554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    long[] l1_unique_set = l1_unique.dup.toHashSet;\n    long[] l2_unique_set\
    \ = l2_unique.dup.toHashSet;\n    long[] l1_unique_set_intersection = l1_unique_set.dup.intersection(l2_unique_set);\n\
    \    result = l1_unique_set_intersection.dup.toArray;\n    return result;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5cltntq0.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp5cltntq0.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp5cltntq0.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp5cltntq0.d(18): Error:\
    \ no property `uniq` for type `long[]`\\n/tmp/tmp5cltntq0.d(19): Error: no property\
    \ `toHashSet` for type `long[]`\\n/tmp/tmp5cltntq0.d(20): Error: no property `toHashSet`\
    \ for type `long[]`\\n/tmp/tmp5cltntq0.d(21): Error: no property `intersection`\
    \ for type `long[]`\\n/tmp/tmp5cltntq0.d(22): Error: no property `toArray` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5cltntq0.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfhhd_prx.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpfhhd_prx.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfhhd_prx.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    long[] l1_unique_sorted = l1_unique.sort;\n    long[] l2_unique_sorted =\
    \ l2_unique.sort;\n    long[] l1_unique_sorted_set = l1_unique_sorted.toSet;\n\
    \    long[] l2_unique_sorted_set = l2_unique_sorted.toSet;\n    long[] l1_unique_sorted_set_intersection\
    \ = l1_unique_sorted_set.intersection(l2_unique_sorted_set);\n    result = l1_unique_sorted_set_intersection.toArray;\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg59xemw3.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpg59xemw3.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpg59xemw3.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpg59xemw3.d(18): Error:\
    \ no property `unique` for type `long[]`\\n/tmp/tmpg59xemw3.d(19): Error: no property\
    \ `sort` for type `long[]`\\n/tmp/tmpg59xemw3.d(20): Error: no property `sort`\
    \ for type `long[]`\\n/tmp/tmpg59xemw3.d(21): Error: no property `toSet` for type\
    \ `long[]`\\n/tmp/tmpg59xemw3.d(22): Error: no property `toSet` for type `long[]`\\\
    n/tmp/tmpg59xemw3.d(23): Error: no property `intersection` for type `long[]`\\\
    n/tmp/tmpg59xemw3.d(24): Error: no property `toArray` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg59xemw3.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        l1\
    \ = l2;\n        l2 = result;\n    }\n    result = [];\n    foreach (e; l1) \n\
    \    {\n        if (e in l2) \n        {\n            result ~= e;\n        }\n\
    \    }\n    return result.sort.uniq;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1kth5rji.d(24): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp1kth5rji.d(29): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1kth5rji.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (e; l2) \n        {\n            if (e in result) \n            {\n        \
    \        result ~= e;\n            }\n        }\n    } \n    else \n    {\n  \
    \      result = l2.dup;\n        foreach (e; l1) \n        {\n            if (e\
    \ in result) \n            {\n                result ~= e;\n            }\n  \
    \      }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphy4ywozc.d(20): Error: incompatible types for `(e) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmphy4ywozc.d(31): Error: incompatible types for\
    \ `(e) in (result)`: `long` and `long[]`\\n/tmp/tmphy4ywozc.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmphy4ywozc.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsxhklgm9.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpsxhklgm9.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsxhklgm9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpi7r0z11w.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpi7r0z11w.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpi7r0z11w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            res ~= l;\n        }\n    }\n    res = res.sort();\n    res\
    \ = res.uniq;\n    return res;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplcbh63mf.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmplcbh63mf.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmplcbh63mf.d(22): Error: no property `sort`\
    \ for type `long[]`\\n/tmp/tmplcbh63mf.d(23): Error: no property `uniq` for type\
    \ `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplcbh63mf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    long[] l1_unique_set = l1_unique.toSet;\n    long[] l2_unique_set = l2_unique.toSet;\n\
    \    long[] l1_unique_set_intersection = l1_unique_set.intersection(l2_unique_set);\n\
    \    result = l1_unique_set_intersection.toArray;\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjnv17cdy.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpjnv17cdy.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpjnv17cdy.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpjnv17cdy.d(18): Error:\
    \ no property `unique` for type `long[]`\\n/tmp/tmpjnv17cdy.d(19): Error: no property\
    \ `toSet` for type `long[]`\\n/tmp/tmpjnv17cdy.d(20): Error: no property `toSet`\
    \ for type `long[]`\\n/tmp/tmpjnv17cdy.d(21): Error: no property `intersection`\
    \ for type `long[]`\\n/tmp/tmpjnv17cdy.d(22): Error: no property `toArray` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjnv17cdy.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(i; 0..l1_unique.length)\n    {\n        foreach(j; 0..l2_unique.length)\n\
    \        {\n            if(l1_unique[i] == l2_unique[j])\n            {\n    \
    \            result ~= l1_unique[i];\n            }\n        }\n    }\n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw7tn02wm.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpw7tn02wm.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpw7tn02wm.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpw7tn02wm.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpw7tn02wm.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique\
    \ = l2_sorted.dup.uniq;\n    long[] l1_unique_sorted = l1_unique.dup.sort;\n \
    \   long[] l2_unique_sorted = l2_unique.dup.sort;\n    long[] l1_unique_sorted_reversed\
    \ = l1_unique_sorted.dup.reverse;\n    long[] l2_unique_sorted_reversed = l2_unique_sorted.dup.reverse;\n\
    \    long[] l1_unique_sorted_reversed_uniq = l1_unique_sorted_reversed.dup.uniq;\n\
    \    long[] l2_unique_sorted_reversed_uniq = l2_unique_sorted_reversed.dup.uniq;\n\
    \    long[] l1_unique_sorted_reversed_uniq_sorted = l1_unique_sorted_reversed_uniq.dup.sort;\n\
    \    long[] l2_unique_sorted_reversed_uniq_sorted = l2_unique_sorted_reversed_uniq.dup.sort;\n\
    \    long[] l1_unique_sorted_reversed_uniq_sorted_reversed = l1_unique_sorted_reversed_uniq_sorted.dup.reverse;\n\
    \    long[] l2_unique_sorted_reversed_uniq_sorted_reversed = l2_unique_sorted_reversed_uniq_sorted.dup.reverse;\n\
    \    long[] l1_unique_sorted_reversed_uniq_sorted_reversed_uniq = l1_unique_sorted_reversed_uniq_sorted_reversed.dup.uniq;\n\
    \    long[] l2\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4lp826p2.d(31): Error: semicolon expected, not `unittest`\\n/tmp/tmp4lp826p2.d(31):\
    \ Error: found `unittest` instead of statement\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmp4lp826p2.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp5v9k621r.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp5v9k621r.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp5v9k621r.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpke7f755z.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpke7f755z.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    int i = 0;\n    foreach(e; l1)\n    {\n        if(e\
    \ in l2)\n        {\n            result[i] = e;\n            i++;\n        }\n\
    \    }\n    return result[0..i];\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppm86yd7w.d(18): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppm86yd7w.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1) \n    {\n        if(e in l2) \n        {\n       \
    \     result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmps6obngle.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmps6obngle.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmps6obngle.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    int i = 0;\n    foreach(long l; l1)\n    {\n   \
    \     if (l2.canFind(l))\n        {\n            result[i] = l;\n            i++;\n\
    \        }\n    }\n    return result[0..i];\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpm1b3866c.d(18): Error: no property `canFind` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpm1b3866c.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_rck4hc3.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp_rck4hc3.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp_rck4hc3.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp_rck4hc3.d(18): Error:\
    \ no property `uniq` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp_rck4hc3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjfhrb0qx.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpjfhrb0qx.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpjfhrb0qx.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjfhrb0qx.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3si91sxt.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp3si91sxt.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmp3si91sxt.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3si91sxt.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[] temp4;\n \
    \   long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[] temp8;\n \
    \   long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[] temp12;\n\
    \    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[] temp16;\n\
    \    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[] temp20;\n\
    \    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[] temp24;\n\
    \    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[] temp28;\n\
    \    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[] temp32;\n\
    \    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[] temp36;\n\
    \    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[] temp40;\n\
    \    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[] temp44;\n\
    \    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[] temp48;\n\
    \    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[] temp52;\n\
    \    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[] temp56;\n\
    \    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[] temp60;\n\
    \    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[] temp64;\n\
    \    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[] temp68;\n\
    \    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n    long[] temp72;\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp8hx4g01x.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp8hx4g01x.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    auto s1 = l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    foreach(i;\
    \ s1)\n    {\n        if(s2.canFind(i))\n        {\n            result ~= i;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqjmb9zxq.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpqjmb9zxq.d(16): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqjmb9zxq.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpoloqt2nb.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpoloqt2nb.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpoloqt2nb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    long[] temp1;\n    long[] temp2;\n    long[] temp3;\n \
    \   long[] temp4;\n    long[] temp5;\n    long[] temp6;\n    long[] temp7;\n \
    \   long[] temp8;\n    long[] temp9;\n    long[] temp10;\n    long[] temp11;\n\
    \    long[] temp12;\n    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n\
    \    long[] temp16;\n    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n\
    \    long[] temp20;\n    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n\
    \    long[] temp24;\n    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n\
    \    long[] temp28;\n    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n\
    \    long[] temp32;\n    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n\
    \    long[] temp36;\n    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n\
    \    long[] temp40;\n    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n\
    \    long[] temp44;\n    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n\
    \    long[] temp48;\n    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n\
    \    long[] temp52;\n    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n\
    \    long[] temp56;\n    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n\
    \    long[] temp60;\n    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n\
    \    long[] temp64;\n    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n\
    \    long[] temp68;\n    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd40c1wdj.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd40c1wdj.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length)\n    {\n        result = l1.dup;\n        foreach\
    \ (e; l2)\n        {\n            if (e in result)\n            {\n          \
    \      result ~= e;\n            }\n        }\n    }\n    else\n    {\n      \
    \  result = l2.dup;\n        foreach (e; l1)\n        {\n            if (e in\
    \ result)\n            {\n                result ~= e;\n            }\n      \
    \  }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqkv37j81.d(20): Error: incompatible types for `(e) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmpqkv37j81.d(31): Error: incompatible types for\
    \ `(e) in (result)`: `long` and `long[]`\\n/tmp/tmpqkv37j81.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpqkv37j81.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpuprndrwi.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpuprndrwi.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpuprndrwi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp55nzaesg.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp55nzaesg.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp55nzaesg.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptzt5s638.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmptzt5s638.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmptzt5s638.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmptzt5s638.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmptzt5s638.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n\
    \            result ~= e;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpw5z9dwt2.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpw5z9dwt2.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpw5z9dwt2.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long i = 0;\n    long j = 0;\n    while (i < l1_sorted.length\
    \ && j < l2_sorted.length) \n    {\n        if (l1_sorted[i] < l2_sorted[j]) \n\
    \        {\n            i++;\n        } \n        else if (l1_sorted[i] > l2_sorted[j])\
    \ \n        {\n            j++;\n        } \n        else \n        {\n      \
    \      result ~= l1_sorted[i];\n            i++;\n            j++;\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpckfianom.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpckfianom.d(16): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpckfianom.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] l3\
    \ = l1.dup;\n    l3.sort;\n    long[] l4 = l2.dup;\n    l4.sort;\n    long[] l5\
    \ = l3.intersect(l4);\n    return l5;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg6ba7sz3.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpg6ba7sz3.d(17): Error: no property `sort` for type `long[]`\\n/tmp/tmpg6ba7sz3.d(18):\
    \ Error: no property `intersect` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\"\
    , \"-v\", \"-o-\", \"/tmp/tmpg6ba7sz3.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd14vb_gc.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpd14vb_gc.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpd14vb_gc.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpd14vb_gc.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfg9xavcb.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfg9xavcb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    int i = 0;\n    foreach(e; l1)\n    {\n        if(e\
    \ in l2)\n        {\n            result[i] = e;\n            i++;\n        }\n\
    \    }\n    return result[0..i];\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp18a61nbp.d(18): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp18a61nbp.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        foreach(r; l2)\n        {\n      \
    \      if(l == r)\n            {\n                result ~= l;\n            }\n\
    \        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsulcaj7o.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsulcaj7o.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp4akkcqed.d(17): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp4akkcqed.d(22): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp4akkcqed.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmphjiew0c4.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmphjiew0c4.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmphjiew0c4.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmphjiew0c4.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpopw2paci.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpopw2paci.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpopw2paci.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpopw2paci.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n         \
    \   result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n/*\nReturn\
    \ sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2,\
    \ 8], [3, 2])\n    [2, 3]\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpjinbu21q.d(24): Error: unterminated /* */ comment\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpjinbu21q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().dup.unique;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkiierdyx.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkiierdyx.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e1; l1)\n    {\n        foreach(e2; l2)\n       \
    \ {\n            if(e1 == e2)\n            {\n                result ~= e1;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpf55mpv27.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpf55mpv27.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpf55mpv27.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp_eezqvm1.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp_eezqvm1.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp_eezqvm1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpprjiew5u.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpprjiew5u.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            if(!result.canFind(l))\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzfv01g4l.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpzfv01g4l.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpzfv01g4l.d(19): Error: no property `canFind`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzfv01g4l.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l1_item; l1)\n    {\n        foreach(l2_item; l2)\n     \
    \   {\n            if(l1_item == l2_item)\n            {\n                result\
    \ ~= l1_item;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0u0j9u58.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0u0j9u58.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpkyym2wht.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpkyym2wht.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpkyym2wht.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpkyym2wht.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpl5tlxznf.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpl5tlxznf.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpl5tlxznf.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpl5tlxznf.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpj43a69j_.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpj43a69j_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(l; l1)\n    {\n        foreach(r; l2)\n        {\n            if(l\
    \ == r)\n            {\n                result ~= l;\n            }\n        }\n\
    \    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate =\
    \ common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L,\
    \ 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L,\
    \ 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L,\
    \ 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpqo9jdlux.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpqo9jdlux.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                res ~= i;\n\
    \            }\n        }\n    }\n    return res.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgffngy1q.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpgffngy1q.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpgffngy1q.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7r34feyn.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp7r34feyn.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7r34feyn.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmjehdq88.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpmjehdq88.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpmjehdq88.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    int i = 0;\n    foreach(long x; l1) {\n        if(l2.canFind(x))\
    \ {\n            result[i] = x;\n            i++;\n        }\n    }\n    return\
    \ result[0..i];\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplvz0zmuy.d(17): Error: no property `canFind` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplvz0zmuy.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto result\
    \ = new long[](0);\n    auto l1_length = l1.length;\n    auto l2_length = l2.length;\n\
    \    auto l1_index = 0;\n    auto l2_index = 0;\n    while (l1_index < l1_length\
    \ && l2_index < l2_length)\n    {\n        if (l1[l1_index] == l2[l2_index])\n\
    \        {\n            result ~= l1[l1_index];\n            l1_index++;\n   \
    \         l2_index++;\n        }\n        else if (l1[l1_index] < l2[l2_index])\n\
    \        {\n            l1_index++;\n        }\n        else\n        {\n    \
    \        l2_index++;\n        }\n    }\n    return result;\n}\nunittest\n{\n \
    \   alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmpm2hxilv9.d(42): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x428625]\\n??:? void tmpm2hxilv9.__unittest_L38_C1()\
    \ [0x4280ae]\\n??:? void tmpm2hxilv9.__modtest() [0x4283a8]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42d0cb]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42bf5e]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430aa9]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430f58]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430a35]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42bf35]\\n??:? runModuleUnitTests [0x42cea1]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428ae8]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428a6f]\\n??:? _d_run_main [0x4289da]\\n??:? main [0x4283bb]\\\
    n??:? __libc_start_main [0xc11c1554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n      \
    \      result ~= i;\n        }\n    }\n    return result.sort().dup;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpizsguwu_.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpizsguwu_.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpizsguwu_.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpigrfoqa7.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpigrfoqa7.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpigrfoqa7.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpigrfoqa7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = sort(l1);\n    long[] l2_sorted = sort(l2);\n\
    \    long[] l1_unique = unique(l1_sorted);\n    long[] l2_unique = unique(l2_sorted);\n\
    \    for (int i = 0; i < l1_unique.length; i++)\n    {\n        for (int j = 0;\
    \ j < l2_unique.length; j++)\n        {\n            if (l1_unique[i] == l2_unique[j])\n\
    \            {\n                result ~= l1_unique[i];\n            }\n     \
    \   }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp3ro1nwr1.d(15): Error: undefined identifier `sort`, did you mean\
    \ function `sqrt`?\\n/tmp/tmp3ro1nwr1.d(16): Error: undefined identifier `sort`,\
    \ did you mean function `sqrt`?\\n/tmp/tmp3ro1nwr1.d(17): Error: undefined identifier\
    \ `unique`, did you mean struct `Unique(T)`?\\n/tmp/tmp3ro1nwr1.d(18): Error:\
    \ undefined identifier `unique`, did you mean struct `Unique(T)`?\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp3ro1nwr1.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n        {\n\
    \            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmplyi927lv.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmplyi927lv.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmplyi927lv.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    int count = 0;\n    foreach(e1; l1)\n    {\n   \
    \     foreach(e2; l2)\n        {\n            if(e1 == e2)\n            {\n  \
    \              result[count] = e1;\n                count++;\n            }\n\
    \        }\n    }\n    return result[0..count];\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'core.exception.AssertError@/tmp/tmp075rh5h9.d(33): unittest failure\\\
    n----------------\\n??:? _d_unittestp [0x4285bd]\\n??:? void tmp075rh5h9.__unittest_L29_C1()\
    \ [0x428046]\\n??:? void tmp075rh5h9.__modtest() [0x428340]\\n??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)\
    \ [0x42c677]\\n??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))\
    \ [0x42b50a]\\n??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref\
    \ rt.sections_elf_shared.DSO) [0x430795]\\n??:? int rt.sections_elf_shared.DSO.opApply(scope\
    \ int delegate(ref rt.sections_elf_shared.DSO)) [0x430c44]\\n??:? int rt.minfo.moduleinfos_apply(scope\
    \ int delegate(immutable(object.ModuleInfo*))) [0x430721]\\n??:? int object.ModuleInfo.opApply(scope\
    \ int delegate(object.ModuleInfo*)) [0x42b4e1]\\n??:? runModuleUnitTests [0x42c44d]\\\
    n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()\
    \ [0x428a80]\\n??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).tryExec(scope\
    \ void delegate()) [0x428a07]\\n??:? _d_run_main [0x428972]\\n??:? main [0x428353]\\\
    n??:? __libc_start_main [0xbc678554]\\n1/1 unittests FAILED\\n'"
  exit_code: 1
  status: Exception
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2p1vg6s9.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp2p1vg6s9.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmp2p1vg6s9.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp2p1vg6s9.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    foreach(e; l1)\n    {\n        if(l2.canFind(e))\n        {\n           \
    \ result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmc5gzag9.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpmc5gzag9.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmc5gzag9.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    long[] temp2;\n    long[] temp3;\n    long[] temp4;\n \
    \   long[] temp5;\n    long[] temp6;\n    long[] temp7;\n    long[] temp8;\n \
    \   long[] temp9;\n    long[] temp10;\n    long[] temp11;\n    long[] temp12;\n\
    \    long[] temp13;\n    long[] temp14;\n    long[] temp15;\n    long[] temp16;\n\
    \    long[] temp17;\n    long[] temp18;\n    long[] temp19;\n    long[] temp20;\n\
    \    long[] temp21;\n    long[] temp22;\n    long[] temp23;\n    long[] temp24;\n\
    \    long[] temp25;\n    long[] temp26;\n    long[] temp27;\n    long[] temp28;\n\
    \    long[] temp29;\n    long[] temp30;\n    long[] temp31;\n    long[] temp32;\n\
    \    long[] temp33;\n    long[] temp34;\n    long[] temp35;\n    long[] temp36;\n\
    \    long[] temp37;\n    long[] temp38;\n    long[] temp39;\n    long[] temp40;\n\
    \    long[] temp41;\n    long[] temp42;\n    long[] temp43;\n    long[] temp44;\n\
    \    long[] temp45;\n    long[] temp46;\n    long[] temp47;\n    long[] temp48;\n\
    \    long[] temp49;\n    long[] temp50;\n    long[] temp51;\n    long[] temp52;\n\
    \    long[] temp53;\n    long[] temp54;\n    long[] temp55;\n    long[] temp56;\n\
    \    long[] temp57;\n    long[] temp58;\n    long[] temp59;\n    long[] temp60;\n\
    \    long[] temp61;\n    long[] temp62;\n    long[] temp63;\n    long[] temp64;\n\
    \    long[] temp65;\n    long[] temp66;\n    long[] temp67;\n    long[] temp68;\n\
    \    long[] temp69;\n    long[] temp70;\n    long[] temp71;\n    long[] temp72;\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpfeh05edz.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpfeh05edz.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n \
    \       {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxxswrmbz.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpxxswrmbz.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpxxswrmbz.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxxswrmbz.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n \
    \       {\n            if(!result.canFind(i))\n            {\n               \
    \ result ~= i;\n            }\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxpenvwl3.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpxpenvwl3.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpxpenvwl3.d(19): Error: no property `canFind`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpxpenvwl3.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    foreach(i; l1_unique)\n    {\n        foreach(j; l2_unique)\n        {\n\
    \            if(i == j)\n            {\n                result ~= i;\n       \
    \     }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgb4ns8eq.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpgb4ns8eq.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpgb4ns8eq.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmpgb4ns8eq.d(18): Error:\
    \ no property `uniq` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpgb4ns8eq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn81zng07.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpn81zng07.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmpn81zng07.d(22): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmpn81zng07.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] tmp;\n    long[] tmp2;\n    long[] tmp3;\n    long[] tmp4;\n    long[]\
    \ tmp5;\n    long[] tmp6;\n    long[] tmp7;\n    long[] tmp8;\n    long[] tmp9;\n\
    \    long[] tmp10;\n    long[] tmp11;\n    long[] tmp12;\n    long[] tmp13;\n\
    \    long[] tmp14;\n    long[] tmp15;\n    long[] tmp16;\n    long[] tmp17;\n\
    \    long[] tmp18;\n    long[] tmp19;\n    long[] tmp20;\n    long[] tmp21;\n\
    \    long[] tmp22;\n    long[] tmp23;\n    long[] tmp24;\n    long[] tmp25;\n\
    \    long[] tmp26;\n    long[] tmp27;\n    long[] tmp28;\n    long[] tmp29;\n\
    \    long[] tmp30;\n    long[] tmp31;\n    long[] tmp32;\n    long[] tmp33;\n\
    \    long[] tmp34;\n    long[] tmp35;\n    long[] tmp36;\n    long[] tmp37;\n\
    \    long[] tmp38;\n    long[] tmp39;\n    long[] tmp40;\n    long[] tmp41;\n\
    \    long[] tmp42;\n    long[] tmp43;\n    long[] tmp44;\n    long[] tmp45;\n\
    \    long[] tmp46;\n    long[] tmp47;\n    long[] tmp48;\n    long[] tmp49;\n\
    \    long[] tmp50;\n    long[] tmp51;\n    long[] tmp52;\n    long[] tmp53;\n\
    \    long[] tmp54;\n    long[] tmp55;\n    long[] tmp56;\n    long[] tmp57;\n\
    \    long[] tmp58;\n    long[] tmp59;\n    long[] tmp60;\n    long[] tmp61;\n\
    \    long[] tmp62;\n    long[] tmp63;\n    long[] tmp64;\n    long[] tmp65;\n\
    \    long[] tmp66;\n    long[] tmp67;\n    long[] tmp68;\n    long[] tmp69;\n\
    \    long[] tmp70;\n    long[] tmp71;\n    long[] tmp72;\n\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpc45v_kxb.d(88): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpc45v_kxb.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1) \n    {\n        if(l2.canFind(l)) \n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpox79k5_4.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpox79k5_4.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpox79k5_4.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpsoebf0xu.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpsoebf0xu.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpsoebf0xu.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpsoebf0xu.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort();\n    long[] l2_sorted = l2.dup.sort();\n\
    \    long[] l1_unique = l1_sorted.dup.uniq;\n    long[] l2_unique = l2_sorted.dup.uniq;\n\
    \    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n        {\n\
    \            result ~= l;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0u998txf.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp0u998txf.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp0u998txf.d(17):\
    \ Error: no property `uniq` for type `long[]`\\n/tmp/tmp0u998txf.d(18): Error:\
    \ no property `uniq` for type `long[]`\\n/tmp/tmp0u998txf.d(21): Error: no property\
    \ `canFind` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmp0u998txf.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n     \
    \   {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1cuxyxpb.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmp1cuxyxpb.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp1cuxyxpb.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp2mqc3ivv.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmp2mqc3ivv.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmp2mqc3ivv.d(22): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmp2mqc3ivv.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    if (l1.length < l2.length) \n    {\n        result = l1.dup;\n        foreach\
    \ (e; l2) \n        {\n            if (e in result) \n            {\n        \
    \        result ~= e;\n            }\n        }\n    } \n    else \n    {\n  \
    \      result = l2.dup;\n        foreach (e; l1) \n        {\n            if (e\
    \ in result) \n            {\n                result ~= e;\n            }\n  \
    \      }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n    alias candidate\
    \ = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L,\
    \ 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L,\
    \ 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L,\
    \ 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n\
    }\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpv2_yqfur.d(20): Error: incompatible types for `(e) in (result)`:\
    \ `long` and `long[]`\\n/tmp/tmpv2_yqfur.d(31): Error: incompatible types for\
    \ `(e) in (result)`: `long` and `long[]`\\n/tmp/tmpv2_yqfur.d(37): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpv2_yqfur.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpziyme60x.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpziyme60x.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpziyme60x.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpziyme60x.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpziyme60x.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[l1.length];\n    long[] result2 = new long[l1.length];\n    long[]\
    \ result3 = new long[l1.length];\n    long[] result4 = new long[l1.length];\n\
    \    long[] result5 = new long[l1.length];\n    long[] result6 = new long[l1.length];\n\
    \    long[] result7 = new long[l1.length];\n    long[] result8 = new long[l1.length];\n\
    \    long[] result9 = new long[l1.length];\n    long[] result10 = new long[l1.length];\n\
    \    long[] result11 = new long[l1.length];\n    long[] result12 = new long[l1.length];\n\
    \    long[] result13 = new long[l1.length];\n    long[] result14 = new long[l1.length];\n\
    \    long[] result15 = new long[l1.length];\n    long[] result16 = new long[l1.length];\n\
    \    long[] result17 = new long[l1.length];\n    long[] result18 = new long[l1.length];\n\
    \    long[] result19 = new long[l1.length];\n    long[] result20 = new long[l1.length];\n\
    \    long[] result21 = new long[l1.length];\n    long[] result22 = new long[l1.length];\n\
    \    long[] result23 = new long[l1.length];\n    long[] result24 = new long[l1.length];\n\
    \    long[] result25 = new long[l1.length];\n    long[] result26 = new long[l1.length];\n\
    \    long[] result27 = new long[l1.length];\n    long[] result28 = new long[l1.length];\n\
    \    long[] result29 = new long[l1.length];\n    long[] result30 = new long[l1.length];\n\
    \    long[] result31 = new long[l1.length];\n    long[] result32 = new long[l1.length];\n\
    \    long[] result33 = new long[l1.length];\n    long[] result34 = new long[l1.length];\n\
    \nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpk0fqvs9k.d(49): Error: found `unittest` instead of statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpk0fqvs9k.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppw_m4_qi.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmppw_m4_qi.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmppw_m4_qi.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmppw_m4_qi.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    if (l1.length < l2.length) \n    {\n        foreach (long\
    \ i; l1) \n        {\n            if (i in l2) \n            {\n             \
    \   result ~= i;\n            }\n        }\n    } \n    else \n    {\n       \
    \ foreach (long i; l2) \n        {\n            if (i in l1) \n            {\n\
    \                result ~= i;\n            }\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcr_3c6at.d(19): Error: incompatible types for `(i) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmpcr_3c6at.d(29): Error: incompatible types for\
    \ `(i) in (l1)`: `long` and `long[]`\\n/tmp/tmpcr_3c6at.d(35): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpcr_3c6at.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l) != 0)\n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpizks3nq7.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpizks3nq7.d(17): Error: no property\
    \ `count` for type `long[]`\\n/tmp/tmpizks3nq7.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpizks3nq7.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpgidvzau0.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpgidvzau0.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpgidvzau0.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         if(!result.canFind(l))\n            {\n                result ~= l;\n\
    \            }\n        }\n    }\n    return result;\n}\n/*\nReturn sorted unique\
    \ elements for two lists.\n    >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [2, 3, 4, 7, 9, 34, 121]\n    >>> unique([5, 3, 2, 8],\
    \ [3, 2])\n    [5, 8]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n    long[]\
    \ result = [];\n    foreach(l; l1)\n    {\n        if(!l2.canFind(l))\n      \
    \  {\n            if(!result.canFind(l))\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    foreach(l; l2)\n    {\n        if(!l1.canFind(l))\n\
    \        {\n            if(!result.canFind(l))\n            {\n              \
    \  result ~= l;\n            }\n        }\n    }\n    return result;\n}\n/*\n\
    Return sorted unique elements for two lists.\n    >>> unique([1, 4, 3, 34, 653,\
    \ 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [2, 3, 4, 7, 9, 34, 121]\n    >>> unique([5,\
    \ 3, 2, 8], [3, 2])\n    [5, 8]\n*/\nlong[] unique(long[] l1, long[] l2) \n{\n\
    \    long[] result = [];\n    foreach(l; l1)\n    {\n        if(!l2.canFind(l))\n\
    \        {\n            if(!result.canFind(l))\n            {\n              \
    \  result ~= l;\n            }\n        }\n    }\n    foreach(l; l2)\n    {\n\
    \        if(!\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpn0qt7z9l.d(82): Error: expression expected, not `unittest`\\\
    n/tmp/tmpn0qt7z9l.d(83): Error: found `{` when expecting `)`\\n/tmp/tmpn0qt7z9l.d(91):\
    \ Error: found `End of File` when expecting `}` following compound statement\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpn0qt7z9l.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         if(!result.canFind(l))\n            {\n                result ~= l;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpwsucedak.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpwsucedak.d(19): Error: no property `canFind` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpwsucedak.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted =\
    \ l2.dup.sort;\n    long[] l1_unique = l1_sorted.dup.unique;\n    long[] l2_unique\
    \ = l2_sorted.dup.unique;\n    foreach(long l1_elem; l1_unique)\n    {\n     \
    \   foreach(long l2_elem; l2_unique)\n        {\n            if(l1_elem == l2_elem)\n\
    \            {\n                result ~= l1_elem;\n            }\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\n\
    \    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp1aegrbaq.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp1aegrbaq.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp1aegrbaq.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmp1aegrbaq.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmp1aegrbaq.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.count(l) != 0)\n   \
    \     {\n            result ~= l;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpxbkucv_v.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpxbkucv_v.d(17): Error: no property\
    \ `count` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpxbkucv_v.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpspfzyrk5.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpspfzyrk5.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpspfzyrk5.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpspfzyrk5.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpspfzyrk5.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n        {\n   \
    \         result ~= l;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpy0zt23hi.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpy0zt23hi.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpy0zt23hi.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(l; l1_unique)\n    {\n        if(l2_unique.canFind(l))\n        {\n\
    \            result ~= l;\n        }\n    }\n    return result;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmph7fob1z7.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmph7fob1z7.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmph7fob1z7.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmph7fob1z7.d(18): Error:\
    \ no property `unique` for type `long[]`\\n/tmp/tmph7fob1z7.d(21): Error: no property\
    \ `canFind` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmph7fob1z7.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           result ~= e;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmppe21x3on.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmppe21x3on.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmppe21x3on.d(22): Error:\
    \ no property `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\"\
    , \"-o-\", \"/tmp/tmppe21x3on.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] temp;\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n\
    \            temp ~= e;\n        }\n    }\n    result = temp.sort().uniq;\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L,\
    \ 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0rdv3s4t.d(18): Error: incompatible types for `(e) in (l2)`:\
    \ `long` and `long[]`\\n/tmp/tmp0rdv3s4t.d(23): Error: no property `sort` for\
    \ type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0rdv3s4t.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmw95xtke.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpmw95xtke.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpmw95xtke.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpmw95xtke.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] res\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            res ~= l;\n        }\n    }\n    return res.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzanujr1m.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpzanujr1m.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpzanujr1m.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpzanujr1m.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(i; l1)\n    {\n        if(l2.count(i) > 0)\n        {\n \
    \           result ~= i;\n        }\n    }\n    return result.sort().uniq;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmptyqrnqa2.d(17): Error: no property `count` for type `long[]`\\\
    n/tmp/tmptyqrnqa2.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmptyqrnqa2.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpiezv6d3_.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpiezv6d3_.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpiezv6d3_.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpiezv6d3_.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    if (l1_unique.length < l2_unique.length) \n    {\n        result = l1_unique.filter!(a\
    \ => l2_unique.canFind(a));\n    }\n    else \n    {\n        result = l2_unique.filter!(a\
    \ => l1_unique.canFind(a));\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp0jsf61d5.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp0jsf61d5.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmp0jsf61d5.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmp0jsf61d5.d(18): Error:\
    \ no property `unique` for type `long[]`\\n/tmp/tmp0jsf61d5.d(21): Error: no property\
    \ `filter` for type `long[]`\\n/tmp/tmp0jsf61d5.d(25): Error: no property `filter`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp0jsf61d5.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            if(!result.canFind(l))\n            {\n                result\
    \ ~= l;\n            }\n        }\n    }\n    return result;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpcswwfq0a.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpcswwfq0a.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpcswwfq0a.d(19): Error: no property `canFind`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpcswwfq0a.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ set(l1);\n    auto s2 = set(l2);\n    return s1.intersection(s2).array;\n}\n\
    unittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L,\
    \ 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpzwupqfka.d(14): Error: undefined identifier `set`, did you mean\
    \ template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\n/tmp/tmpzwupqfka.d(15):\
    \ Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K])\
    \ aa, K key, lazy inout(V) defaultValue)`?\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpzwupqfka.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[] result;\n    foreach(e;\
    \ s1)\n    {\n        if(s2.canFind(e))\n        {\n            result ~= e;\n\
    \        }\n    }\n    return result;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpg6ghhvpw.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpg6ghhvpw.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpg6ghhvpw.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = [];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n       \
    \ {\n            if(i == j)\n            {\n                result ~= i;\n   \
    \         }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n{\n\
    \    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp7y2yi0i_.d(25): Error: no property `sort` for type `long[]`\\\
    nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp7y2yi0i_.d\", \"\
    -I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto l1_set\
    \ = set(l1);\n    auto l2_set = set(l2);\n    auto common_set = l1_set & l2_set;\n\
    \    return common_set.array;\n}\nunittest\n{\n    alias candidate = common;\n\
    \n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L,\
    \ 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L])\
    \ == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L], [3L, 2L, 4L]) == [2L,\
    \ 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpd58kvr35.d(14): Error: undefined identifier `set`, did you mean\
    \ template `get(K, V)(inout(V[K]) aa, K key, lazy inout(V) defaultValue)`?\\n/tmp/tmpd58kvr35.d(15):\
    \ Error: undefined identifier `set`, did you mean template `get(K, V)(inout(V[K])\
    \ aa, K key, lazy inout(V) defaultValue)`?\\nFailed: [\"dmd\", \"-unittest\",\
    \ \"-v\", \"-o-\", \"/tmp/tmpd58kvr35.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[0];\n    foreach(long i; l1)\n    {\n        if(l2.canFind(i))\n\
    \        {\n            result ~= i;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpr_rohmuz.d(17): Error: no property `canFind` for type `long[]`\\\
    n/tmp/tmpr_rohmuz.d(22): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpr_rohmuz.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(long i; l1)\n    {\n        foreach(long j; l2)\n\
    \        {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result.sort().uniq;\n}\nunittest\n\
    {\n    alias candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L,\
    \ 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpmxac9i74.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpmxac9i74.d(25): Error: no property\
    \ `sort` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\"\
    , \"/tmp/tmpmxac9i74.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    auto s1 =\
    \ l1.sort().uniq;\n    auto s2 = l2.sort().uniq;\n    long[] res;\n    foreach(e;\
    \ s1) \n    {\n        if(e in s2)\n            res ~= e;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmp6_2xlxl1.d(14): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmp6_2xlxl1.d(15): Error: no property `sort` for type `long[]`\\nFailed:\
    \ [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmp6_2xlxl1.d\", \"-I/tmp\"\
    ]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(l; l1)\n    {\n        if(l2.canFind(l))\n      \
    \  {\n            result ~= l;\n        }\n    }\n    return result.sort().uniq;\n\
    }\nunittest\n{\n    alias candidate = common;\n\n    assert(candidate([1L, 4L,\
    \ 3L, 34L, 653L, 2L, 5L], [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n\
    \    assert(candidate([5L, 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L,\
    \ 3L, 2L, 8L], [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L,\
    \ 2L, 8L], []) == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpnlq9ox_1.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpnlq9ox_1.d(17): Error: no property\
    \ `canFind` for type `long[]`\\n/tmp/tmpnlq9ox_1.d(22): Error: no property `sort`\
    \ for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpnlq9ox_1.d\"\
    , \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result\
    \ = new long[];\n    foreach(e; l1)\n    {\n        if(e in l2)\n        {\n \
    \           if(e !in result)\n            {\n                result ~= e;\n  \
    \          }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpeevk5ycr.d(14): Error: new can only create structs, dynamic arrays\
    \ or class objects, not `long[]`\\'s\\n/tmp/tmpeevk5ycr.d(17): Error: incompatible\
    \ types for `(e) in (l2)`: `long` and `long[]`\\n/tmp/tmpeevk5ycr.d(19): Error:\
    \ incompatible types for `(e) in (result)`: `long` and `long[]`\\nFailed: [\"\
    dmd\", \"-unittest\", \"-v\", \"-o-\", \"/tmp/tmpeevk5ycr.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
- program: "import std.typecons;\nimport std.math;\n/*\nReturn sorted unique common\
    \ elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1,\
    \ 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n  \
    \  [2, 3]\n\n    \n*/\nlong[] common(long[] l1, long[] l2) \n{\n    long[] result;\n\
    \    long[] l1_sorted = l1.dup.sort;\n    long[] l2_sorted = l2.dup.sort;\n  \
    \  long[] l1_unique = l1_sorted.unique;\n    long[] l2_unique = l2_sorted.unique;\n\
    \    foreach(long i; l1_unique)\n    {\n        foreach(long j; l2_unique)\n \
    \       {\n            if(i == j)\n            {\n                result ~= i;\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = common;\n\n    assert(candidate([1L, 4L, 3L, 34L, 653L, 2L, 5L],\
    \ [5L, 7L, 1L, 5L, 9L, 653L, 121L]) == [1L, 5L, 653L]);\n    assert(candidate([5L,\
    \ 3L, 2L, 8L], [3L, 2L]) == [2L, 3L]);\n    assert(candidate([4L, 3L, 2L, 8L],\
    \ [3L, 2L, 4L]) == [2L, 3L, 4L]);\n    assert(candidate([4L, 3L, 2L, 8L], [])\
    \ == []);\n}\nvoid main(){}"
  stdout: b''
  stderr: "b'/tmp/tmpp0chxm3o.d(15): Error: no property `sort` for type `long[]`\\\
    n/tmp/tmpp0chxm3o.d(16): Error: no property `sort` for type `long[]`\\n/tmp/tmpp0chxm3o.d(17):\
    \ Error: no property `unique` for type `long[]`\\n/tmp/tmpp0chxm3o.d(18): Error:\
    \ no property `unique` for type `long[]`\\nFailed: [\"dmd\", \"-unittest\", \"\
    -v\", \"-o-\", \"/tmp/tmpp0chxm3o.d\", \"-I/tmp\"]\\n'"
  exit_code: 1
  status: SyntaxError
