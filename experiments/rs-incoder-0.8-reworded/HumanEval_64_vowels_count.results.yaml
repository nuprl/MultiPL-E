language: rs
name: HumanEval_64_vowels_count
results:
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().enumerate().filter(|&(i, _)| {\n        if\
    \ i < s.len() - 1 && s[i] == 'a' && s[i+1] == 'e' && s[i+2] == 'i' && s[i+3] ==\
    \ 'o' && s[i+4] == 'u' {\n            true\n        } else {\n            false\n\
    \        }\n    }).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmptdt86fpl.rs:12:31\n\
    \   |\n12 |         if i < s.len() - 1 && s[i] == 'a' && s[i+1] == 'e' && s[i+2]\
    \ == 'i' && s[i+3] == 'o' && s[i+4] == 'u' {\n   |                           \
    \    ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptdt86fpl.rs:12:46\n   |\n12 |         if i < s.len() - 1 && s[i]\
    \ == 'a' && s[i+1] == 'e' && s[i+2] == 'i' && s[i+3] == 'o' && s[i+4] == 'u' {\n\
    \   |                                              ^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmptdt86fpl.rs:12:63\n   |\n12 |         if i < s.len() - 1 && s[i]\
    \ == 'a' && s[i+1] == 'e' && s[i+2] == 'i' && s[i+3] == 'o' && s[i+4] == 'u' {\n\
    \   |                                                               ^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Inde"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || 'e' || 'i' || 'o'\
    \ || 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgg60jzgw.rs:11:39\n   |\n\
    11 |     s.chars().filter(|c| *c == 'a' || 'e' || 'i' || 'o' || 'u').count()\n\
    \   |                                       ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgg60jzgw.rs:11:46\n   |\n11 |\
    \     s.chars().filter(|c| *c == 'a' || 'e' || 'i' || 'o' || 'u').count()\n  \
    \ |                                              ^^^ expected `bool`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgg60jzgw.rs:11:53\n   |\n11 |\
    \     s.chars().filter(|c| *c == 'a' || 'e' || 'i' || 'o' || 'u').count()\n  \
    \ |                                                     ^^^ expected `bool`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgg60jzgw.rs:11:60\n\
    \   |\n11 |     s.chars().filter(|c| *c == 'a' || 'e' || 'i' || 'o' || 'u').count()\n\
    \   |                                                            ^^^ expected\
    \ `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgg60jzgw.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || 'e' || 'i' || 'o' || 'u').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || 'e' || 'i' || 'o' || 'u').count().try_into().unwrap()\n   |   \
    \                                                                     ++++++++++++++++++++\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        match c {\n          \
    \  'a' => true,\n            'e' => true,\n            'i' => true,\n        \
    \    'o' => true,\n            'u' => true,\n            _ => false,\n       \
    \ }\n    ).count() as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpa9ql10rt.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels = \"aeiou\".to_string();\n    let mut count\
    \ = 0;\n    let mut pos = 0;\n    while pos < s.len() {\n        if s[pos].is_upper()\
    \ {\n            if pos == 0 {\n                pos = pos;\n            } else\
    \ {\n                pos = pos + 1;\n            }\n        } else {\n       \
    \     if pos == 0 {\n                pos = pos + 1;\n            }\n         \
    \   if s[pos] == vowels[0..] {\n                count += 1;\n            }\n \
    \           pos = pos + 1;\n        }\n    }\n    count\n}\n\nfn main() {\n  \
    \  let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmplt5t13x4.rs:15:12\n\
    \   |\n15 |         if s[pos].is_upper() {\n   |            ^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmplt5t13x4.rs:25:16\n   |\n25 |             if s[pos] == vowels[0..]\
    \ {\n   |                ^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // Initialize our count to 0 so that we can return it\n\
    \    let mut count = 0 as isize;\n\n    // Create a regex of all the vowels\n\
    \    let vowels = &[\"a\", \"e\", \"i\", \"o\", \"u\"];\n    for vowel in vowels\
    \ {\n        // Match the vowel at the beginning of the string, followed by anything\
    \ else\n        // until we hit the end of the string\n        let regex = format!(\"\
    (?<=^{}).\", vowel);\n        // Look for that match\n        let result = s.matches(regex).unwrap();\n\
    \        // Count the number of matches\n        count += result.len();\n    }\n\
    \n    // Return the count of vowels\n    count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpdd9x3thb.rs:21:32\n     |\n21   |         let result = s.matches(regex).unwrap();\n\
    \     |                        ------- ^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                        |\n     |                     \
    \   required by a bound introduced by this call\n     |\n     = note: the trait\
    \ bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::matches`\nhelp: consider borrowing here\n\
    \     |\n21   |         let result = s.matches(&regex).unwrap();\n     |     \
    \                           +\n\nerror[E0599]: no method named `unwrap` found\
    \ for struct `Matches` in the current scope\n  --> /tmp/tmpdd9x3thb.rs:21:39\n\
    \   |\n21 |         let result = s.matches(regex).unwrap();\n   |            \
    \                           ^^^^^^ method not found in `Matches<'_, String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| match c {\n        'a' | 'A' =>\
    \ true,\n        'e' | 'E' => true,\n        'i' | 'I' => true,\n        'o' |\
    \ 'O' => true,\n        'u' | 'U' => true,\n        _ => false,\n    }).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbm59els9.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ match c {\n12 | |         'a' | 'A' => true,\n13 | |         'e' | 'E' => true,\n\
    14 | |         'i' | 'I' => true,\n...  |\n17 | |         _ => false,\n18 | |\
    \     }).count()\n   | |______________^ expected `isize`, found `usize`\n   |\n\
    help: you can convert a `usize` to an `isize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     }).count().try_into().unwrap()\n   |           \
    \    ++++++++++++++++++++\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n        .count() + 1\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyx9hzfub.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpyx9hzfub.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpyx9hzfub.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpyx9hzfub.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpyx9hzfub.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyx9hzfub.rs:11:5\n\
    \   |\n10 |  "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.as_bytes())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzqbpj9y.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_bytes())\n   |                  ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c.is_alphanumeric())\n\
    \        .filter(|c| c.is_ascii_letter())\n        .filter(|c| c.is_ascii_lowercase())\n\
    \        .filter(|c| c != 'y')\n        .count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpor_ndjf0.rs:13:23\n   |\n13 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpor_ndjf0.rs:15:23\n   |\n15 |   \
    \      .filter(|c| c != 'y')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpor_ndjf0.rs:11:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` because of return type\n11 | /     s.chars()\n12 | |      \
    \   .filter(|c| c.is_alphanumeric())\n13 | |         .filter(|c| c.is_ascii_letter())\n\
    14 | |         .filter(|c| c.is_ascii_lowercase())\n15 | |         .filter(|c|\
    \ c != 'y')\n16 | |         .count()\n   | |________________^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n16 |         .count().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 1).unwrap()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp36oto_h8.rs:11:5\n   |\n11 |     vowels_count(s, 1).unwrap()\n\
    \   |     ^^^^^^^^^^^^ -  - supplied 2 arguments\n   |     |\n   |     expected\
    \ 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp36oto_h8.rs:10:4\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |    ^^^^^^^^^^^^ ---------\n\
    \nerror[E0599]: no method named `unwrap` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp36oto_h8.rs:11:24\n   |\n11 |     vowels_count(s, 1).unwrap()\n\
    \   |                        ^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if s.is_empty() {\n        return 0;\n    }\n\n    let\
    \ mut chars = s.chars();\n    let mut count = 0;\n    let mut has_y = 0;\n   \
    \ let mut vowels = vec![\n        'a',\n        'e',\n        'i',\n        'o',\n\
    \        'u',\n        'A', 'E', 'I', 'O', 'U',\n    ];\n\n    while let Some(char)\
    \ = chars.next() {\n        if char == b'y' {\n            has_y = 1;\n      \
    \  }\n\n        if let Some(vowel) = vowels.iter().find(|c| *c == char) {\n  \
    \          count += 1;\n        } else {\n            break;\n        }\n    }\n\
    \n    if has_y != 0 {\n        count += 1;\n    }\n\n    count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkm8jk403.rs:28:20\n   |\n\
    28 |         if char == b'y' {\n   |                    ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkm8jk403.rs:32:56\n\
    \   |\n32 |         if let Some(vowel) = vowels.iter().find(|c| *c == char) {\n\
    \   |                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c ==\
    \ 'i' || *c == 'o' || *c == 'u' || *c == 'y').count()\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwt8bvyqg.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u' || *c == 'y').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u' || *c == 'y').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels: Vec<&'static str> = vec![\"a\", \"e\"\
    , \"i\", \"o\", \"u\"];\n    let vowels_count = s.chars()\n        .filter(|c|\
    \ vowels.contains(c))\n        .count();\n    vowels_count\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ly7vp3x.rs:13:37\n   |\n\
    13 |         .filter(|c| vowels.contains(c))\n   |                           \
    \          ^ expected `&str`, found `char`\n   |\n   = note: expected reference\
    \ `&&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5ly7vp3x.rs:15:5\n   |\n10 | fn vowels_count(s: String) -> isize\
    \ {\n   |                               ----- expected `isize` because of return\
    \ type\n...\n15 |     vowels_count\n   |     ^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n15 |     vowels_count.try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if let Some(('a', _)) = (c, c + 1) {\n            vowel_count += 1;\n\
    \        } else if let Some(('e', _)) = (c, c + 1) {\n            vowel_count\
    \ += 1;\n        } else if let Some(('i', _)) = (c, c + 1) {\n            vowel_count\
    \ += 1;\n        } else if let Some(('o', _)) = (c, c + 1) {\n            vowel_count\
    \ += 1;\n        } else if let Some(('u', _)) = (c, c + 1) {\n            vowel_count\
    \ += 1;\n        }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpb3juuu2e.rs:13:39\n\
    \   |\n13 |         if let Some(('a', _)) = (c, c + 1) {\n   |               \
    \                      - ^ - {integer}\n   |                                 \
    \    |\n   |                                     char\n\nerror[E0369]: cannot\
    \ add `{integer}` to `char`\n  --> /tmp/tmpb3juuu2e.rs:15:46\n   |\n15 |     \
    \    } else if let Some(('e', _)) = (c, c + 1) {\n   |                       \
    \                     - ^ - {integer}\n   |                                  \
    \          |\n   |                                            char\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmpb3juuu2e.rs:17:46\n   |\n17\
    \ |         } else if let Some(('i', _)) = (c, c + 1) {\n   |                \
    \                            - ^ - {integer}\n   |                           \
    \                 |\n   |                                            char\n\n\
    error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpb3juuu2e.rs:19:46\n\
    \   |\n19 |         } else if let Some(('o', _)) = (c, c + 1) {\n   |        \
    \                                    - ^ - {integer}\n   |                   \
    \                         |\n   |                                            char\n\
    \nerror[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpb3juuu2e.rs:21:46\n\
    \   |\n21 |         } else if let Some(('u', _)) = (c, c + 1) {\n   |        \
    \                                    - ^ - {integer}\n   |                   \
    \                         |\n   |                                            char\n\
    \nerror: aborting due to 5 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n        .count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                       ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:35\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:47\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:59\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpwoag1yaf.rs:12:71\n   |\n12 |         .filter(|c| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n   |              \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]:"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u')\n        .count() + s.chars().filter(|c| c == 'y')\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp10skbumy.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp10skbumy.rs:11:40\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                        ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp10skbumy.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp10skbumy.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp10skbumy.rs:11:76\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't com"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = 0;\n\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if c.is_uppercase() {\n            if i == s.len() - 1 || s[i + 1]\
    \ != c.to_uppercase() {\n                vowels += 2;\n            }\n       \
    \ }\n        else if c.is_lowercase() {\n            if i == 0 || s[i] != c.to_lowercase()\
    \ {\n                vowels += 1;\n            }\n        }\n    }\n\n    vowels\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpiis_8xh3.rs:15:36\n\
    \   |\n15 |             if i == s.len() - 1 || s[i + 1] != c.to_uppercase() {\n\
    \   |                                    ^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpiis_8xh3.rs:20:26\n   |\n20 |             if i == 0 || s[i] !=\
    \ c.to_lowercase() {\n   |                          ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_impl(s, &'static)\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp_5etbx9g.rs:11:34\n\
    \   |\n11 |     vowels_count_impl(s, &'static)\n   |                         \
    \         ^ expected expression\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.length()\n        .map(|c| match c {\n           \
    \ 'a' => 1,\n            'e' => 1,\n            'i' => 1,\n            'o' =>\
    \ 1,\n            'u' => 1,\n            c => 0,\n        })\n        .sum()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu0l2hqd5.rs:11:7\n   |\n11 |     s.length()\n \
    \  |       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // Use a slice to iterate through the string one letter\
    \ at a time\n    // and count the number of occurrences of the vowels in the string.\n\
    \    // To do this, create a slice using the String::chars() method\n    // and\
    \ iterate through it using for loops\n    use std::slice::Iter;\n    let vowels:\
    \ Vec<_> = s.chars().filter_map(|c| match c {\n        'a' => Some(1),\n     \
    \   'e' => Some(1),\n        'i' => Some(1),\n        'o' => Some(1),\n      \
    \  'u' => Some(1),\n        _ => None,\n    })\n    .collect();\n\n    vowels.iter().filter(|count|\
    \ count.is_some()).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::slice::Iter`\n  --> /tmp/tmp4tke21j6.rs:15:9\n\
    \   |\n15 |     use std::slice::Iter;\n   |         ^^^^^^^^^^^^^^^^\n   |\n \
    \  = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_some` found for reference `&&{integer}` in the current scope\n  -->\
    \ /tmp/tmp4tke21j6.rs:26:40\n   |\n26 |     vowels.iter().filter(|count| count.is_some()).count()\n\
    \   |                                        ^^^^^^^ method not found in `&&{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4tke21j6.rs:26:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n...\n26 |     vowels.iter().filter(|count|\
    \ count.is_some()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n26 |     vowels.iter().filter(|count|\
    \ count.is_some()).count().try_into().unwrap()\n   |                         \
    \                                 ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors; 1 warning emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.length()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdd8mytyu.rs:11:7\n   |\n11 |     s.length()\n \
    \  |       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = HashSet::new();\n    let vowels_chars\
    \ = &['a', 'e', 'i', 'o', 'u'];\n    let vowels_char_indices: &'static [u8] =\
    \ &[\n        0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n        0x69,\
    \ 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71,\n        0x72, 0x73, 0x74, 0x75,\
    \ 0x76, 0x77, 0x78, 0x79, 0x7a, 0x5b,\n    ];\n\n    for c in s.chars() {\n  \
    \      match vowels_char_indices.iter().position(|x| *x == c) {\n            None\
    \ => continue,\n            Some(index) => {\n                if index > 0 {\n\
    \                    vowels.insert(vowels_chars[(index - 1) as usize]);\n    \
    \            }\n            }\n        }\n    }\n    vowels.len()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp387_e322.rs:11:22\n   |\n11 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp387_e322.rs:20:61\n   |\n20 |         match\
    \ vowels_char_indices.iter().position(|x| *x == c) {\n   |                   \
    \                                          ^ expected `u8`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8j98em2x.rs:11:53\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |                     \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8j98em2x.rs:11:65\n   |\n11 |   \
    \  s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count()\n   |                                 \
    \                                ^^ no implementation for `&char == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8j98em2x.rs:11:77\n   |\n11 |   \
    \  s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count()\n   |                                 \
    \                                            ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp8j98em2x.rs:11:89\n   |\n11 |   \
    \  s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count()\n   |                                 \
    \                                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8j98em2x.rs:11:101\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii()).filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |         "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: &[char] = &[\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    s.chars().filter(|c| vowels.contains(c)).count() + vowels.len()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbdrzn9_c.rs:11:29\n   |\n\
    11 |     let vowels: &[char] = &[\"a\", \"e\", \"i\", \"o\", \"u\"];\n   |   \
    \                          ^^^ expected `char`, found `&str`\n   |\nhelp: if you\
    \ meant to write a `char` literal, use single quotes\n   |\n11 |     let vowels:\
    \ &[char] = &['a', \"e\", \"i\", \"o\", \"u\"];\n   |                        \
    \     ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdrzn9_c.rs:12:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     let vowels:\
    \ &[char] = &[\"a\", \"e\", \"i\", \"o\", \"u\"];\n12 |     s.chars().filter(|c|\
    \ vowels.contains(c)).count() + vowels.len()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     (s.chars().filter(|c|\
    \ vowels.contains(c)).count() + vowels.len()).try_into().unwrap()\n   |     +\
    \                                                               +++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter_map(|c| {\n        if c.to_ascii_lowercase()\
    \ == 'a' || c.to_ascii_lowercase() == 'e' ||\n            c.to_ascii_lowercase()\
    \ == 'i' || c.to_ascii_lowercase() == 'o' ||\n            c.to_ascii_lowercase()\
    \ == 'u'\n        {\n            Some(c)\n        } else {\n            None\n\
    \        }\n    })\n        .count(|c| c.to_ascii_lowercase() == 'a')\n      \
    \  + s.chars().filter_map(|c| {\n            if c.to_ascii_lowercase() == 'e'\
    \ || c.to_ascii_lowercase() == 'i' ||\n                c.to_ascii_lowercase()\
    \ == 'o' || c.to_ascii_lowercase() == 'u'\n            {\n                Some(c)\n\
    \            } else {\n                None\n            }\n        })\n     \
    \   .count(|c| c.to_ascii_lowercase() == 'e')\n        + s.chars().filter_map(|c|\
    \ {\n            if c.to_ascii_lowercase() == 'i' || c.to_ascii_lowercase() ==\
    \ 'o' ||\n                c.to_ascii_lowercase() == 'u'\n            {\n     \
    \           Some(c)\n            } else {\n                None\n            }\n\
    \        })\n        .count(|c| c.to_ascii_lowercase() == 'i')\n        + s.chars().filter_map(|c|\
    \ {\n            if c.to_ascii_lowercase() == 'o' || c.to_ascii_lowercase() ==\
    \ 'u'\n            {\n                Some(c)\n            } else {\n        \
    \        None\n            }\n        })\n        .count(|c| c.to_ascii_lowercase()\
    \ == 'o')\n        + s.chars().filter_map(|c| {\n            if c.to_ascii_lowercase()\
    \ == 'u'\n            {\n                Some(c)\n            } else {\n     \
    \           None\n            }\n        })\n        .count(|c| c.to_ascii_lowercase()\
    \ == 'u')\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpu2czngwp.rs:21:17\n\
    \   |\n21 |         .count(|c| c.to_ascii_lowercase() == 'a')\n   |          \
    \       ^ consider giving this closure parameter a type\n   |\n   = note: type\
    \ must be known at this point\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpu2czngwp.rs:21:10\n    |\n21  |\
    \         .count(|c| c.to_ascii_lowercase() == 'a')\n    |          ^^^^^ ---------------------------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpu2czngwp.rs:31:10\n\
    \    |\n31  |         .count(|c| c.to_ascii_lowercase() == 'e')\n    |       \
    \   ^^^^^ --------------------------------- supplied 1 argument\n    |       \
    \   |\n    |          expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpu2czngwp.rs:41:10\n    |\n41  |         .count(|c| c.to_ascii_lowercase()\
    \ == 'i')\n    |          ^^^^^ --------------------------------- supplied 1 argument\n\
    \    |          |\n    |          expected 0 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 0 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpu2czngwp.rs:50:10\n    |\n50  |      \
    \   .count(|c| c.to_ascii_lowercase() == 'o')\n    |          ^^^^^ ---------------------------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpu2czngwp.rs:59:10\n\
    \    |\n59  |         .count(|c| c.to_ascii_lowercase() == 'u')\n    |       \
    \   ^^^^^ --------------------------------- supplied 1 argument\n    |       \
    \   |\n    |          expected 0 arguments\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu2czngwp.rs:11:5\n   |\n\
    10 |   fn vowels_"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_impl(s.chars().collect::<Vec<_>>(), 0)\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmp44as3esh.rs:11:5\n   |\n11 |     vowels_count_impl(s.chars().collect::<Vec<_>>(),\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut num_vowels = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' .. 'i' => num_vowels += 1,\n            'e'\
    \ .. 'o' => num_vowels += 1,\n            'u' .. 'y' => num_vowels += 1,\n   \
    \         _ => {}\n        }\n    }\n    num_vowels\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp51ppqcx5.rs:14:13\n\
    \   |\n14 |             'a' .. 'i' => num_vowels += 1,\n   |             ^^^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp51ppqcx5.rs:15:13\n   |\n15 |             'e' .. 'o' => num_vowels\
    \ += 1,\n   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp51ppqcx5.rs:16:13\n   |\n16 |             'u' .. 'y' => num_vowels\
    \ += 1,\n   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0658`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // Find the index of the first vowel in s, or the length\
    \ of the string if there\n    // isn't a vowel\n    let vowel_idx = s.find('a',\
    \ 0); // (0)\n    if vowel_idx == Some(s.len() - 1) {\n        return 0;\n   \
    \ }\n    // Find the index of the first vowel not immediately before 'a' in s\n\
    \    // This is not necessarily the first 'a' because 'a' could be part of the\n\
    \    // consonant-vowel-vowel combination\n    let non_vowel_start_idx = s.rfind('a',\
    \ vowel_idx + 1); // (6)\n    // Return the difference between the starting index\
    \ of the first vowel\n    // and the non-vowel start index\n    vowel_idx - non_vowel_start_idx\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmp2v_89h0e.rs:13:23\n     |\n13   |     let vowel_idx = s.find('a',\
    \ 0); // (0)\n     |                       ^^^^ ---  - supplied 2 arguments\n\
    \     |                       |\n     |                       expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0369]: cannot add `{integer}`\
    \ to `Option<usize>`\n  --> /tmp/tmp2v_89h0e.rs:20:54\n   |\n20 |     let non_vowel_start_idx\
    \ = s.rfind('a', vowel_idx + 1); // (6)\n   |                                \
    \            --------- ^ - {integer}\n   |                                   \
    \         |\n   |                                            Option<usize>\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \   --> /tmp/tmp2v_89h0e.rs:20:33\n     |\n20   |     let non_vowel_start_idx\
    \ = s.rfind('a', vowel_idx + 1); // (6)\n     |                              \
    \   ^^^^^ ---  ------------- supplied 2 arguments\n     |                    \
    \             |\n     |                                 expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror[E0369]: cannot subtract\
    \ `Option<usize>` from `Option<usize>`\n  --> /tmp/tmp2v_89h0e.rs:23:15\n   |\n\
    23 |     vowel_idx - non_vowel_start_idx\n   |     --------- ^ -------------------\
    \ Option<usize>\n   |     |\n   |     Option<usize>\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0061, E0369.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        (c.is_lowercase() || c.is_uppercase())\
    \ && c != 'y'\n    ).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprbisg18j.rs:12:53\n\
    \   |\n12 |         (c.is_lowercase() || c.is_uppercase()) && c != 'y'\n   | \
    \                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmprbisg18j.rs:11:5\n   |\n10 |   fn\
    \ vowels_count(s: String) -> isize {\n   |                                 -----\
    \ expected `isize` because of return type\n11 | /     s.chars().filter(|c|\n12\
    \ | |         (c.is_lowercase() || c.is_uppercase()) && c != 'y'\n13 | |     ).count()\n\
    \   | |_____________^ expected `isize`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n\
    13 |     ).count().try_into().unwrap()\n   |              ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not impleme"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s).iter().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' ||\n                                    c == 'o' || c == 'u' || c ==\
    \ 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmprnb33bvb.rs:11:5\n\
    \   |\n11 |     vowels(s).iter().filter(|c| c == 'a' || c == 'e' || c == 'i' ||\n\
    \   |     ^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_count(s.chars().filter(|&c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u').collect::<Vec<_>>())\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpsc6ldxoz.rs:11:5\n\
    \   |\n11 |     vowel_count(s.chars().filter(|&c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').collect::<Vec<_>>())\n   |     ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    match (s.chars().filter(|c| *c != 'a' && *c != 'e' &&\
    \ *c != 'i' && *c != 'o' && *c != 'u') {\n        None => 0,\n        Some(mut\
    \ c) => c != 'y',\n    }) {\n        Some(mut c) => c == 'y',\n        None =>\
    \ 0,\n    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmp4u71un1_.rs:12:14\n   |\n12 |         None => 0,\n\
    \   |              ^^ expected one of 8 possible tokens\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found `{`\n  --> /tmp/tmp4u71un1_.rs:11:96\n\
    \   |\n11 |     match (s.chars().filter(|c| *c != 'a' && *c != 'e' && *c != 'i'\
    \ && *c != 'o' && *c != 'u') {\n   |                                         \
    \                                                      -^ expected one of `)`,\
    \ `,`, `.`, `?`, or an operator\n   |                                        \
    \                                                       |\n   |              \
    \                                                                            \
    \     help: missing `,`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4u71un1_.rs:15:24\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n...\n15 |         Some(mut\
    \ c) => c == 'y',\n   |                        ^^^^^^^^ expected `isize`, found\
    \ `bool`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s)\n        .iter()\n        .filter(|&c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp_ouhs6rt.rs:11:5\n\
    \   |\n11 |     vowels(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_count(s).len()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpvqhslg2i.rs:11:5\n\
    \   |\n11 |     vowel_count(s).len()\n   |     ^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    fn count_vowel(mut s: &str, i: usize, state: &mut usize)\
    \ -> usize {\n        match s[i] {\n            'a' => state += 1,\n         \
    \   'e' => state += 1,\n            'i' => state += 1,\n            'o' => state\
    \ += 1,\n            'u' => state += 1,\n            _ => (),\n        }\n   \
    \     return state;\n    }\n    s.chars().filter(|c| c == 'a' || c == 'e' || c\
    \ == 'i' || c == 'o' || c == 'u').count() +\n        s.chars().filter(|c| c ==\
    \ 'y' && s[..i+1].to_ascii_lowercase().contains('y')).count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmp_2kdm_xp.rs:23:46\n\
    \   |\n23 |         s.chars().filter(|c| c == 'y' && s[..i+1].to_ascii_lowercase().contains('y')).count()\n\
    \   |                                              ^ help: a local variable with\
    \ a similar name exists: `c`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp_2kdm_xp.rs:22:28\n   |\n22 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() +\n   |           \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp_2kdm_xp.rs:22:40\n   |\n22 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() +\n   |  \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp_2kdm_xp.rs:22:52\n   |\n22 |   \
    \  s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\
    \ +\n   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_2kdm_xp.rs:22:64\n\
    \   |\n22 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() +\n   |                                           \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp_2kdm_xp.rs:22:76\n   |\n22 |     s.chars().filter(|c|\
    \ c ="
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.as_str()).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjxk_wm6o.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_str()).to_string()\n   |                  ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxk_wm6o.rs:11:5\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n11 |     vowels_count(s.as_str()).to_string()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_helper(s.as_slice()).unwrap()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmp9jhf506u.rs:11:5\n   |\n11 |     vowels_count_helper(s.as_slice()).unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `as_slice` found for struct `String` in the current scope\n  --> /tmp/tmp9jhf506u.rs:11:27\n\
    \   |\n11 |     vowels_count_helper(s.as_slice()).unwrap()\n   |             \
    \              ^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = vec!['a'..'u'];\n    let mut count\
    \ = 0;\n    let mut vowels_start = s.len() - 1;\n    while vowels_start > 0 {\n\
    \        if s[vowels_start] == 'a' {\n            vowels.insert('a', 0);\n   \
    \     }\n        if s[vowels_start] == 'e' {\n            vowels.insert('e', 0);\n\
    \        }\n        if s[vowels_start] == 'i' {\n            vowels.insert('i',\
    \ 0);\n        }\n        if s[vowels_start] == 'o' {\n            vowels.insert('o',\
    \ 0);\n        }\n        if s[vowels_start] == 'u' {\n            vowels.insert('u',\
    \ 0);\n        }\n        if s[vowels_start] == 'y' && vowels_start > 0 {\n  \
    \          vowels.insert('y', 0);\n            vowels_start -= 1;\n        }\n\
    \        count += vowels.len();\n        vowels_start -= 1;\n    }\n    count\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmps3aad_4v.rs:15:12\n\
    \   |\n15 |         if s[vowels_start] == 'a' {\n   |            ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps3aad_4v.rs:16:27\n\
    \   |\n16 |             vowels.insert('a', 0);\n   |                         \
    \  ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmps3aad_4v.rs:16:32\n   |\n16 |             vowels.insert('a', 0);\n \
    \  |                                ^ expected struct `std::ops::Range`, found\
    \ integer\n   |\n   = note: expected struct `std::ops::Range<char>`\n        \
    \        found type `{integer}`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmps3aad_4v.rs:18:12\n   |\n18 |         if s[vowels_start]\
    \ == 'e' {\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps3aad_4v.rs:19:27\n\
    \   |\n19 |             vowels.insert('e', 0);\n   |                         \
    \  ^^^ expected `usize`, found `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /t"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        match c {\n            'a' => vowel_count += 1,\n            'e'\
    \ => vowel_count += 1,\n            'i' => vowel_count += 1,\n            'o'\
    \ => vowel_count += 1,\n            'u' => vowel_count += 1,\n            c =>\
    \ {\n                if i != s.len() - 1 {\n                    vowel_count +=\
    \ 1;\n                }\n            }\n        }\n    }\n    vowel_count\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `5`,\n right: `2`', /tmp/tmpkd4aw206.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not impleme"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u')\n        .count() + s.chars().filter(|c|\
    \ c == 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n   \
    \ assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv6qd9jof.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpv6qd9jof.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpv6qd9jof.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpv6qd9jof.rs:12:59\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpv6qd9jof.rs:12:71\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpv6qd9jof.rs"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c == 'y').count()\n   |                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:64\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:76\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                 "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut i = 0;\n    while i < s.len() {\n        if\
    \ is_vowel(&s[i]) {\n            i += 1;\n        }\n    }\n    i + 1\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpkz3guz6y.rs:13:12\n\
    \   |\n13 |         if is_vowel(&s[i]) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkz3guz6y.rs:13:22\n   |\n13 |         if is_vowel(&s[i]) {\n  \
    \ |                      ^^^^ `String` cannot be indexed by `usize`\n   |\n  \
    \ = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkz3guz6y.rs:17:5\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n...\n17 |     i + 1\n   |     ^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     (i + 1).try_into().unwrap()\n\
    \   |     +     +++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmppjulyk1e.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjulyk1e.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.to_ascii_lowercase()\n      \
    \  .eq_ignore_ascii_case('a')\n        .or_else(c.to_ascii_lowercase()\n     \
    \       .eq_ignore_ascii_case('e')\n            .or_else(c.to_ascii_lowercase()\n\
    \                .eq_ignore_ascii_case('i')\n                .or_else(c.to_ascii_lowercase()\n\
    \                    .eq_ignore_ascii_case('o')\n                    .or_else(c.to_ascii_lowercase()\n\
    \                        .eq_ignore_ascii_case('u'))))))\n        .count()\n}\n\
    \nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb5mslhuu.rs:12:31\n   |\n\
    12 |         .eq_ignore_ascii_case('a')\n   |                               ^^^\n\
    \   |                               |\n   |                               expected\
    \ `&char`, found `char`\n   |                               help: consider borrowing\
    \ here: `&'a'`\n\nerror[E0599]: no method named `or_else` found for type `bool`\
    \ in the current scope\n  --> /tmp/tmpb5mslhuu.rs:13:10\n   |\n13 |         .or_else(c.to_ascii_lowercase()\n\
    \   |          ^^^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb5mslhuu.rs:14:35\n   |\n14 |             .eq_ignore_ascii_case('e')\n\
    \   |                                   ^^^\n   |                            \
    \       |\n   |                                   expected `&char`, found `char`\n\
    \   |                                   help: consider borrowing here: `&'e'`\n\
    \nerror[E0599]: no method named `or_else` found for type `bool` in the current\
    \ scope\n  --> /tmp/tmpb5mslhuu.rs:15:14\n   |\n15 |             .or_else(c.to_ascii_lowercase()\n\
    \   |              ^^^^^^^ method not found in `bool`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb5mslhuu.rs:16:39\n   |\n16 |                 .eq_ignore_ascii_case('i')\n\
    \   |                                       ^^^\n   |                        \
    \               |\n   |                                       expected `&char`,\
    \ found `char`\n   |                                       help: consider borrowing\
    \ here: `&'i'`\n\nerror[E0599]: no method named `or_else` found for type `bool`\
    \ in the current scope\n  --> /tmp/tmpb5mslhuu.rs:17:18\n   |\n17 |          \
    \       .or_else(c.to_ascii_lowercase()\n   |                  ^^^^^^^ method\
    \ not found in `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb5mslhuu.rs:18:43\n\
    \   |\n18 |                     .eq_ignore_ascii_case('o')\n   |             \
    \                              ^^^\n   |                                     \
    \      |\n   |                                           expected `&char`, found\
    \ `char`\n   |                                           he"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.as_bytes())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzqbpj9y.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_bytes())\n   |                  ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut n = 0;\n\n    for c in s.chars() {\n       \
    \ if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            n\
    \ += 1;\n        }\n    }\n\n    n\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp2uy_26mv.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp0tje42gm.rs:11:5\n   |\n11 |     vowels_count(s, 0)\n   |     ^^^^^^^^^^^^\
    \ -  - supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\n\
    note: function defined here\n  --> /tmp/tmp0tje42gm.rs:10:4\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |    ^^^^^^^^^^^^ ---------\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c ==\
    \ 'i' || *c == 'o' || *c == 'u')\n        .count() as isize\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmprar3a7lp.rs:18:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n\n    for &c in s.chars()\
    \ {\n        if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \           vowel_count += 1;\n        }\n    }\n\n    vowel_count\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4iqdzj14.rs:13:9\n   |\n\
    13 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s)\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmph0fci2e4.rs:11:5\n\
    \   |\n11 |     vowels(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = vec!['A'..'U'];\n    for (i, c) in\
    \ s.chars().enumerate() {\n        if c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' {\n            vowels[i] = c; \n        }\n    }\n    vowels.iter().filter(|x|\
    \ x.is_vowel()).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpox3losdu.rs:14:25\n   |\n\
    14 |             vowels[i] = c; \n   |             ---------   ^ expected struct\
    \ `std::ops::Range`, found `char`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0599]: no method named `is_vowel`\
    \ found for reference `&&std::ops::Range<char>` in the current scope\n  --> /tmp/tmpox3losdu.rs:17:32\n\
    \   |\n17 |     vowels.iter().filter(|x| x.is_vowel()).count()\n   |         \
    \                       ^^^^^^^^ method not found in `&&std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpox3losdu.rs:17:5\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n...\n17 |     vowels.iter().filter(|x|\
    \ x.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n17 |     vowels.iter().filter(|x|\
    \ x.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'Y').count() + 1\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpp5wum55m.rs:11:41\n\
    \   |\n11 |     s.chars().filter(|c| *c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'Y').count() + 1\n   |                             \
    \            ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpp5wum55m.rs:11:53\n   |\n11 |     s.chars().filter(|c| *c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'Y').count() + 1\n \
    \  |                                                     ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpp5wum55m.rs:11:65\n\
    \   |\n11 |     s.chars().filter(|c| *c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'Y').count() + 1\n   |                             \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpp5wum55m.rs:11:77\n   |\n11 |   \
    \  s.chars().filter(|c| *c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' || c == 'Y').count() + 1\n   |                                         \
    \                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpp5wum55m.rs:11:89\n   |\n11 |   \
    \  s.chars().filter(|c| *c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' || c == 'Y').count() + 1\n   |                                         \
    \                                                ^^ no imp"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_helper(s.as_bytes())?\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmpc8vqrqhp.rs:11:5\n   |\n11 |     vowels_count_helper(s.as_bytes())?\n\
    \   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the `?`\
    \ operator can only be used in a function that returns `Result` or `Option` (or\
    \ another type that implements `FromResidual`)\n  --> /tmp/tmpc8vqrqhp.rs:11:38\n\
    \   |\n10 | / fn vowels_count(s: String) -> isize {\n11 | |     vowels_count_helper(s.as_bytes())?\n\
    \   | |                                      ^ cannot use the `?` operator in\
    \ a function that returns `isize`\n12 | | }\n   | |_- this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>`\
    \ is not implemented for `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c ==\
    \ 'i' || *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjaq20yr.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ + s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv44ybzmr.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() + s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() + s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()).try_into().unwrap()\n\
    \   |     +                                                                  \
    \                                         +++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut count = 0; // Initialize count to 0.\n    for\
    \ i in s.chars() {\n        if i.is_uppercase() {\n            count += 1;\n \
    \       }\n        if i.is_lowercase() {\n            count += 1;\n        }\n\
    \        if i.is_ascii_letter() {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmp5j8uiuja.rs:19:14\n   |\n19 |         if i.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s).iter().filter(|&c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp4oebhjhs.rs:11:5\n\
    \   |\n11 |     vowels(s).iter().filter(|&c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.to_lowercase() == 'a' || c.to_lowercase()\
    \ == 'e' || c.to_lowercase() == 'i' || c.to_lowercase() == 'o' || c.to_lowercase()\
    \ == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpskz9e0bv.rs:11:43\n   |\n11 |     s.chars().filter(|c| c.to_lowercase()\
    \ == 'a' || c.to_lowercase() == 'e' || c.to_lowercase() == 'i' || c.to_lowercase()\
    \ == 'o' || c.to...\n   |                          ---------------- ^^ --- char\n\
    \   |                          |\n   |                          ToLowercase\n\n\
    error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpskz9e0bv.rs:11:70\n   |\n11 |     s.chars().filter(|c| c.to_lowercase()\
    \ == 'a' || c.to_lowercase() == 'e' || c.to_lowercase() == 'i' || c.to_lowercase()\
    \ == 'o' || c.to...\n   |                                                    \
    \ ---------------- ^^ --- char\n   |                                         \
    \            |\n   |                                                     ToLowercase\n\
    \nerror[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpskz9e0bv.rs:11:97\n   |\n11 |     s.chars().filter(|c| c.to_lowercase()\
    \ == 'a' || c.to_lowercase() == 'e' || c.to_lowercase() == 'i' || c.to_lowercase()\
    \ == 'o' || c.to...\n   |                                                    \
    \                            ---------------- ^^ --- char\n   |              \
    \                                                                  |\n   |   \
    \                                                                            \
    \ ToLowercase\n\nerror[E0369]: binary operation `==` cannot be applied to type\
    \ `ToLowercase`\n  --> /tmp/tmpskz9e0bv.rs:11:124\n   |\n11 |     s.chars().filter(|c|\
    \ c.to_lowercase() == 'a' || c.to_lowercase() == 'e' || c.to_lowercase() == 'i'\
    \ || c.to_lowercase() == 'o' || c.to...\n   |                                \
    \                                                                           ----------------\
    \ ^^ --- char\n   |                                                          \
    \                                                 |\n   |                    \
    \                                                                            \
    \           To"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.chars().count())\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_v2u351x.rs:11:18\n   |\n\
    11 |     vowels_count(s.chars().count())\n   |                  ^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(&s).len()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp26o2uzz8.rs:11:5\n\
    \   |\n11 |     vowels(&s).len()\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c == 'y').count()\n   |                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:64\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:76\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                 "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels: Vec<char> = vec!['A', 'E', 'I', 'O',\
    \ 'U'];\n    let mut counts: Vec<usize> = vec![0];\n\n    for ch in s {\n    \
    \    if vowels.contains(&ch) {\n            counts[vowels.iter().position(|&x|\
    \ x == ch)].unwrap()\n        } else {\n            counts.push(0);\n        }\n\
    \    }\n\n    counts.iter().fold(0, |acc, count| acc + count)\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpnsdxl0vz.rs:14:15\n\
    \   |\n14 |     for ch in s {\n   |               ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0277]: the type `[usize]`\
    \ cannot be indexed by `Option<usize>`\n  --> /tmp/tmpnsdxl0vz.rs:16:13\n   |\n\
    16 |             counts[vowels.iter().position(|&x| x == ch)].unwrap()\n   | \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[usize]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnsdxl0vz.rs:22:46\n   |\n22 |     counts.iter().fold(0,\
    \ |acc, count| acc + count)\n   |                                            \
    \  ^^^^^ expected `isize`, found `usize`\n\nerror[E0277]: cannot add `&usize`\
    \ to `isize`\n  --> /tmp/tmpnsdxl0vz.rs:22:44\n   |\n22 |     counts.iter().fold(0,\
    \ |acc, count| acc + count)\n   |                                            ^\
    \ no implementation for `isize + &usize`\n   |\n   = help: the trait `Add<&usize>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n             <&'a f64\
    \ as Add<f64>>\n             <&'a i128 as Add<i128>>\n             <&'a i16 as\
    \ Add<i16>>\n             <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n\
    \             <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n  \
    \         and 48 others\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplh7jk5rb.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count()\n   |                                 \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not impleme"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c != 'a' || c!='e' || c!='i' ||\
    \ c!='o' || c!='u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3_otpzdv.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' || c!='e' || c!='i' || c!='o' ||\
    \ c!='u').count()\n   |                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp3_otpzdv.rs:11:39\n   |\n11\
    \ |     s.chars().filter(|c| c != 'a' || c!='e' || c!='i' || c!='o' || c!='u').count()\n\
    \   |                                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp3_otpzdv.rs:11:49\n   |\n11 |   \
    \  s.chars().filter(|c| c != 'a' || c!='e' || c!='i' || c!='o' || c!='u').count()\n\
    \   |                                                 ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3_otpzdv.rs:11:59\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' || c!='e' || c!='i' || c!='o' ||\
    \ c!='u').count()\n   |                                                      \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3_otpzdv.rs:11:69\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' || c!='e' || c!='i' || c!='o' ||\
    \ c!='u').count()\n   |                                                      \
    \               ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /t"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: &str = \"aeiou\";\n    let vowels_length\
    \ = vowels.len();\n    if s.len() < vowels_length {\n        return 0;\n    }\n\
    \    for (i, c) in s.chars().enumerate() {\n        if c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' {\n            if i != (s.len() - 1) {\n  \
    \              continue;\n            }\n        } else {\n            return\
    \ 0;\n        }\n    }\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c\
    \ == 'i' || *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprktd7jcd.rs:25:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n25 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n25 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpar4_2que.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|&c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                                ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s)\n        .iter()\n        .filter(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpbkofnm_h.rs:11:5\n\
    \   |\n11 |     vowels(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_impl(s, 0)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmpmtmzi42x.rs:11:5\n   |\n11 |     vowels_count_impl(s, 0)\n   |\
    \     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut count = 0;\n    let len = s.len();\n\n    for\
    \ ch in s.chars() {\n        let (next_ch, _) = s.next_ch();\n\n        if next_ch\
    \ == Some('y') {\n            count += 1;\n        }\n    }\n\n    count\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next_ch` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9qxhdyay.rs:15:30\n   |\n15 |         let (next_ch,\
    \ _) = s.next_ch();\n   |                              ^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_count(s, false);\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpdze5baw6.rs:11:5\n\
    \   |\n11 |     vowel_count(s, false);\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdze5baw6.rs:10:31\n \
    \  |\n10 | fn vowels_count(s: String) -> isize {\n   |    ------------       \
    \        ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n        .count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                       ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:35\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:47\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpwoag1yaf.rs:12:59\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpwoag1yaf.rs:12:71\n   |\n12 |         .filter(|c| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n   |              \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]:"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        c.to_ascii_lowercase()\
    \ == c\n            && c != 'a'\n            && c != 'e'\n            && c !=\
    \ 'i'\n            && c != 'o'\n            && c != 'u'\n    ).count() as isize\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6h5f2fkq.rs:12:35\n   |\n\
    12 |         c.to_ascii_lowercase() == c\n   |                               \
    \    ^ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the\
    \ borrow\n   |\n12 |         c.to_ascii_lowercase() == *c\n   |              \
    \                     +\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmp6h5f2fkq.rs:13:18\n   |\n13 |             && c != 'a'\n   |    \
    \              ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp6h5f2fkq.rs:14:18\n   |\n14 |             && c !=\
    \ 'e'\n   |                  ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp6h5f2fkq.rs:15:18\n   |\n15 |           \
    \  && c != 'i'\n   |                  ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp6h5f2fkq.rs:16:18\n   |\n16 |   \
    \          && c != 'o'\n   |                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp6h5f2fkq.rs:17:18\n   |\n17\
    \ |             && c != 'u'\n   |                  ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if s.is_empty() {\n        return 0;\n    }\n\n    let\
    \ mut vowels = Vec::new();\n    let mut vowels_cnt = 0;\n    let mut i: usize\
    \ = 0;\n    vowels.resize(s.len(), false);\n    while i < s.len() {\n        vowels[i]\
    \ = match s.chars().next() {\n            None => false,\n            Some(ch)\
    \ => ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u',\n        };\n\
    \        if vowels[i] {\n            i += 1;\n        } else {\n            vowels_cnt\
    \ += 1;\n        }\n    }\n    vowels_cnt\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `0`,\n right: `2`', /tmp/tmpuy7uxcnw.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_ascii() && c.is_uppercase()).filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() + s.chars().filter(|c|\
    \ c.is_ascii()).filter(|c| c == 'Y').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphmx53a1w.rs:11:73\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii() && c.is_uppercase()).filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() +...\n   |\
    \                                                                         ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphmx53a1w.rs:11:85\n\
    \   |\n11 |     s.chars().filter(|c| c.is_ascii() && c.is_uppercase()).filter(|c|\
    \ c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() +...\n   |\
    \                                                                            \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmphmx53a1w.rs:11:97\n   |\n11 | ...ercase()).filter(|c| c == 'A'\
    \ || c == 'E' || c == 'I' || c == 'O' || c == 'U').count() + s.chars().filter(|c|\
    \ c.is_ascii()).filter(|c|...\n   |                                          \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmphmx53a1w.rs:11:109\n   |\n11 | ...lter(|c| c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U').count() + s.chars().filter(|c| c.is_ascii()).filter(|c|\
    \ c == 'Y').c...\n   |                                                   ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphmx53a1w.rs:11:121\n\
    \   |\n11 | ...= 'A' || c == 'E' || c == 'I' || c == 'O' || c =="
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ - s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c| *c >= 'A' && *c <=\
    \ 'Z').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkx8buu9u.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() - s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() - s.chars().filter(|c| *c >= 'a' && *c <= 'z').filter(|c|\
    \ *c >= 'A' && *c <= 'Z').count()).try_into().unwrap()\n   |     +           \
    \                                                                            \
    \                                                       +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpmwhczm8o.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n        .count() + 1\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2111bhc6.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                       ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp2111bhc6.rs:12:35\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2111bhc6.rs:12:47\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2111bhc6.rs:12:59\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp2111bhc6.rs:12:71\n   |\n12 |         .filter(|c| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n   |              \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]:"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if s.len() <= 1 {\n        return 0;\n    }\n\n    let\
    \ mut c = 0u8;\n\n    for c in s.chars() {\n        match c {\n            'a'\
    \ | 'e' | ... | 'o' => {\n                c += 1;\n            }\n           \
    \ 'u' | 'y' => {\n                c += 1;\n            }\n            _ => {\n\
    \                break;\n            }\n        }\n    }\n\n    c\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected `...`\n  --> /tmp/tmp_yz5eo6e.rs:19:25\n   |\n19 |  \
    \           'a' | 'e' | ... | 'o' => {\n   |                         ^^^\n   |\
    \                         |\n   |                         not a valid pattern\n\
    \   |                         help: for a rest pattern, use `..` instead of `...`\n\
    \nerror: `..` patterns are not allowed here\n  --> /tmp/tmp_yz5eo6e.rs:19:25\n\
    \   |\n19 |             'a' | 'e' | ... | 'o' => {\n   |                     \
    \    ^^^\n   |\n   = note: only allowed in tuple, tuple struct, and slice patterns\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `char`\n\
    \  --> /tmp/tmp_yz5eo6e.rs:20:17\n   |\n20 |                 c += 1;\n   |   \
    \              -^^^^^\n   |                 |\n   |                 cannot use\
    \ `+=` on type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmp_yz5eo6e.rs:23:17\n   |\n23 |     \
    \            c += 1;\n   |                 -^^^^^\n   |                 |\n  \
    \ |                 cannot use `+=` on type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_yz5eo6e.rs:31:5\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n31 |     c\n   |     ^ expected `isize`, found `u8`\n \
    \  |\nhelp: you can convert a `u8` to an `isize`\n   |\n31 |     c.into()\n  \
    \ |      +++++++\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0368.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut letters = s.chars();\n\
    \    if letters.next().unwrap() == 'a' {\n        count += 1;\n    }\n    if letters.next().unwrap()\
    \ == 'e' {\n        count += 1;\n    }\n    if letters.next().unwrap() == 'i'\
    \ {\n        count += 1;\n    }\n    if letters.next().unwrap() == 'o' {\n   \
    \     count += 1;\n    }\n    if letters.next().unwrap() == 'u' {\n        count\
    \ += 1;\n    }\n    if letters.next().unwrap() == 'y' {\n        count += 1;\n\
    \    }\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Option::unwrap()` on a `None` value'',
    /tmp/tmpt0o2e5fs.rs:28:23

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut count = 0;\n    let mut s = String::from(s);\n\
    \n    for i in s.chars() {\n        if let Ok(c) = (*i).to_ascii_lowercase() {\n\
    \            if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n \
    \               count += 1;\n            }\n        }\n    }\n    count\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpjqsfpdom.rs:15:24\n\
    \   |\n15 |         if let Ok(c) = (*i).to_ascii_lowercase() {\n   |         \
    \               ^^^^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|&c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpfwwgrb71.rs:17:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter_map(|c| {\n        match c {\n    \
    \        'a' | 'e' | 'i' | 'o' | 'u' => 1,\n            _ => 0,\n        }\n \
    \   }).sum()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpanbaw57g.rs:13:44\n   |\n\
    13 |             'a' | 'e' | 'i' | 'o' | 'u' => 1,\n   |                     \
    \                       ^ expected enum `Option`, found integer\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `{integer}`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n13 |             'a' | 'e' | 'i' | 'o' | 'u'\
    \ => Some(1),\n   |                                            +++++ +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c == 'y').count()\n   |                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:64\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:76\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                 "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        (c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u') &&\n        (c != 'y' || s.ends_with(\"\
    y\")))\n        .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpd9tfsx.rs:12:12\n\
    \   |\n12 |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ &&\n   |            ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpnpd9tfsx.rs:12:24\n   |\n12 |         (c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u') &&\n   |                     \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpd9tfsx.rs:12:36\n\
    \   |\n12 |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\
    \ &&\n   |                                    ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpnpd9tfsx.rs:12:48\n   |\n12\
    \ |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') &&\n  \
    \ |                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpnpd9tfsx.rs:12:60\n   |\n12\
    \ |         (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') &&\n  \
    \ |                                                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpnpd9tfsx.rs:13:12\n\
    \   |\n13 |         (c != 'y' || s.ends_with(\"y\")))\n   |            ^^ no implementation\
    \ f"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: &[&str] = &[\"a\", \"e\", \"i\", \"o\",\
    \ \"u\"];\n    let mut counter = 0;\n    for (i, char) in s.chars().enumerate()\
    \ {\n        if vowels.contains(char) {\n            counter += 1;\n        }\n\
    \        if i == s.len() - 1 {\n            counter += 1;\n        }\n    }\n\
    \    counter\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4unee29d.rs:14:28\n   |\n\
    14 |         if vowels.contains(char) {\n   |                            ^^^^\
    \ expected `&&str`, found `char`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_counts(s.chars()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_counts` in this scope\n  -->\
    \ /tmp/tmpd5_pfxsh.rs:11:5\n   |\n11 |     vowel_counts(s.chars()).count()\n \
    \  |     ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == b'a' || c == b'e' || c ==\
    \ b'i' || c == b'o' || c == b'u').count() + s.chars().filter(|c| c == b'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwj3nfaa_.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o'\
    \ || c == b'u').count() + s.chars().filter(|c| c == b'y').count()\n   |      \
    \                         ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't\
    \ compare `&char` with `u8`\n  --> /tmp/tmpwj3nfaa_.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count() + s.chars().filter(|c|\
    \ c == b'y').count()\n   |                            ^^ no implementation for\
    \ `&char == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwj3nfaa_.rs:11:44\n   |\n11 |  \
    \   s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o' || c\
    \ == b'u').count() + s.chars().filter(|c| c == b'y').count()\n   |           \
    \                                 ^^^^ expected `char`, found `u8`\n\nerror[E0277]:\
    \ can't compare `&char` with `u8`\n  --> /tmp/tmpwj3nfaa_.rs:11:41\n   |\n11 |\
    \     s.chars().filter(|c| c == b'a' || c == b'e' || c == b'i' || c == b'o' ||\
    \ c == b'u').count() + s.chars().filter(|c| c == b'y').count()\n   |         \
    \                                ^^ no implementation for `&char == u8`\n   |\n\
    \   = help: the trait `PartialEq<u8>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwj3nfaa_.rs:11:57\n   |\n11 |     s.chars().filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count() + s.chars().filter(|c|\
    \ c == b'y').count()\n   |                                                   \
    \      ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare `&char`\
    \ with `u8`\n  --> /tmp/tmpwj3nfaa_.rs:11:54\n   |\n11 |     s.chars().filter(|c|\
    \ c == b'a' || c == b'e' || c == b'i' || c == b'o' || c == b'u').count() + s.chars().filter(|c|\
    \ c == b'y').count()\n   |                                                   \
    \   ^^ no implem"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' | 'e' | .... 'o' => {\n                vowel_count\
    \ += 1;\n            }\n            'u' => (),\n            _ => (),\n       \
    \ }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `.`\n  --> /tmp/tmprsddsuxn.rs:14:28\n   |\n14\
    \ |             'a' | 'e' | .... 'o' => {\n   |             ---            ^\n\
    \   |             |\n   |             while parsing this or-pattern starting here\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmppjulyk1e.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjulyk1e.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c >= 'a' && *c <= 'z').count()\
    \ - s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe3xi5r6i.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() - s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     (s.chars().filter(|c|\
    \ *c >= 'a' && *c <= 'z').count() - s.chars().filter(|c| *c >= 'A' && *c <= 'Z').count()).try_into().unwrap()\n\
    \   |     +                                                                  \
    \                                         +++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = vec![];\n    for i in s.chars() {\n\
    \        match i {\n            'a' => vowels.push('a'),\n            'e' => vowels.push('e'),\n\
    \            'i' => vowels.push('i'),\n            'o' => vowels.push('o'),\n\
    \            'u' => vowels.push('u'),\n            _ => {}\n        }\n    }\n\
    \    vowels.iter().filter(|v| v == 'a' || v == 'e' || v == 'i' || v == 'o' ||\
    \ v == 'u').count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmp3mv4df4w.rs:22:32\n\
    \   |\n22 |     vowels.iter().filter(|v| v == 'a' || v == 'e' || v == 'i' || v\
    \ == 'o' || v == 'u').count() + 1\n   |                                ^^ no implementation\
    \ for `&&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmp3mv4df4w.rs:22:44\n\
    \   |\n22 |     vowels.iter().filter(|v| v == 'a' || v == 'e' || v == 'i' || v\
    \ == 'o' || v == 'u').count() + 1\n   |                                      \
    \      ^^ no implementation for `&&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmp3mv4df4w.rs:22:56\n\
    \   |\n22 |     vowels.iter().filter(|v| v == 'a' || v == 'e' || v == 'i' || v\
    \ == 'o' || v == 'u').count() + 1\n   |                                      \
    \                  ^^ no implementation for `&&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&char`\n   = help: the\
    \ trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&&char`\
    \ with `char`\n  --> /tmp/tmp3mv4df4w.rs:22:68\n   |\n22 |     vowels.iter().filter(|v|\
    \ v == 'a' || v == 'e' || v == 'i' || v == 'o' || v == 'u').count() + 1\n   |\
    \                                                                    ^^ no implementation\
    \ for `&&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&&char` with `char`\n  --> /tmp/tmp3mv4df4w.rs:22:80\n\
    \   |\n22 |     vowels.iter().filter(|v| v == 'a' || v == 'e' || v == 'i' || v\
    \ == 'o' || v == 'u').count() + 1\n   |                                      \
    \                                          ^^ no implementation for `&&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` "
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut cnt = 0;\n    for ch in s.chars() {\n      \
    \  cnt += if ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {1}\
    \ else {0};\n    }\n    cnt\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp1dcfnur3.rs:21:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in s.chars() {\n   \
    \     if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n        \
    \    counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpsupnk38a.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| *c == ' ' || c != 'y'\
    \ || 'A' <= c && c <= 'Z')\n        .filter(|c| *c != 'y' || 'a' <= c && c <=\
    \ 'z')\n        .count() + s.chars().filter(|c| *c != 'y').count() - s.chars().filter(|c|\
    \ *c != 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n  \
    \  assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmstm4kh2.rs:12:36\n\
    \   |\n12 |         .filter(|c| *c == ' ' || c != 'y' || 'A' <= c && c <= 'Z')\n\
    \   |                                    ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmstm4kh2.rs:12:53\n   |\n12 |         .filter(|c| *c ==\
    \ ' ' || c != 'y' || 'A' <= c && c <= 'Z')\n   |                             \
    \                        ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n12 |         .filter(|c| *c == ' ' || c != 'y'\
    \ || 'A' <= *c && c <= 'Z')\n   |                                            \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmstm4kh2.rs:12:63\n\
    \   |\n12 |         .filter(|c| *c == ' ' || c != 'y' || 'A' <= c && c <= 'Z')\n\
    \   |                                                               ^^^\n   |\
    \                                                               |\n   |      \
    \                                                         expected `&char`, found\
    \ `char`\n   |                                                               help:\
    \ consider borrowing here: `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmstm4kh2.rs:13:41\n\
    \   |\n13 |         .filter(|c| *c != 'y' || 'a' <= c && c <= 'z')\n   |     \
    \                                    ^ expected `char`, found `&char`\n   |\n\
    help: consider dereferencing the borrow\n   |\n13 |         .filter(|c| *c !=\
    \ 'y' || 'a' <= *c && c <= 'z')\n   |                                        \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmstm4kh2.rs:13:51\n   |\n\
    13 |         .filter(|c| *c != 'y' || 'a' <= c && c <= 'z')\n   |            \
    \                                       ^^^\n   |                            \
    \                       |\n   |                                              \
    \     expected `&char`, found `char`\n   |                                   \
    \                help: consider borrowing her"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter_map(|c| c.is_vowel()).count()\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp08z23rfw.rs:11:32\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count()\n   |                                ^^^^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp08z23rfw.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter_map(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                       ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_uppercase()).filter(|c| c\
    \ == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U').count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr2g0lvw8.rs:11:57\n\
    \   |\n11 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O' || c == 'U').count()\n   |                \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpr2g0lvw8.rs:11:69\n   |\n11 |   \
    \  s.chars().filter(|c| c.is_uppercase()).filter(|c| c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U').count()\n   |                              \
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpr2g0lvw8.rs:11:81\n   |\n11 |   \
    \  s.chars().filter(|c| c.is_uppercase()).filter(|c| c == 'A' || c == 'E' || c\
    \ == 'I' || c == 'O' || c == 'U').count()\n   |                              \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpr2g0lvw8.rs:11:93\n   |\n11\
    \ |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c == 'A' || c == 'E'\
    \ || c == 'I' || c == 'O' || c == 'U').count()\n   |                         \
    \                                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpr2g0lvw8.rs:11:105\n\
    \   |\n11 |     s.chars().filter(|c| c.is_uppercase()).filter(|c| c == 'A' ||\
    \ c == 'E' || c == 'I' || c == 'O"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels: Vec<&str> = vec!['a'..'u', 'a'..'o',\
    \ 'a'..'i', 'a'..'e'];\n    s.chars().for_each(|c| {\n        if vowels.contains(&c.to_string())\
    \ {\n            vowels.remove(&c.to_string());\n        }\n    });\n    vowels.len()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0cph1yzi.rs:11:38\n   |\n\
    11 |     let mut vowels: Vec<&str> = vec!['a'..'u', 'a'..'o', 'a'..'i', 'a'..'e'];\n\
    \   |                                      ^^^^^^^^ expected `&str`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected reference `&str`\n            \
    \     found struct `std::ops::Range<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0cph1yzi.rs:13:28\n   |\n13 |         if vowels.contains(&c.to_string())\
    \ {\n   |                            ^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `String`\n   |\n   = note: expected reference `&&str`\n              found reference\
    \ `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0cph1yzi.rs:14:27\n\
    \   |\n14 |             vowels.remove(&c.to_string());\n   |                 \
    \          ^^^^^^^^^^^^^^ expected `usize`, found `&String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp0cph1yzi.rs:17:5\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n17 |     vowels.len()\n   |     ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     vowels.len().try_into().unwrap()\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut counter = 0;\n    for c in s.chars() {\n   \
    \     if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n        \
    \    counter += 1;\n        }\n    }\n    counter\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpsupnk38a.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if s.is_empty() {\n        return 0;\n    }\n\n    let\
    \ mut counter = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if let\
    \ c == 'a' || let c == 'e' || let c == 'i' || let c == 'o' || let c == 'u'\n \
    \          || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || c ==\
    \ 'Y' {\n            counter += 1;\n        }\n\n        if i == s.len() - 1 {\n\
    \            if c == 'y' {\n                counter += 1;\n            }\n   \
    \     }\n    }\n\n    counter\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=`, `@`, or `|`, found `==`\n  --> /tmp/tmp01z1mwvq.rs:18:18\n\
    \   |\n18 |         if let c == 'a' || let c == 'e' || let c == 'i' || let c ==\
    \ 'o' || let c == 'u'\n   |                  ^^ expected one of `=`, `@`, or `|`\n\
    \nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y').count() + 1\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg09bbsz6.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() + 1\n   |                            ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg09bbsz6.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() + 1\n   |                             \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpg09bbsz6.rs:11:52\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y').count() + 1\n \
    \  |                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpg09bbsz6.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'y').count() + 1\n   |                             \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpg09bbsz6.rs:11:76\n   |\n11 |   \
    \  s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y').count() + 1\n   |                                             \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<c"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_impl(s.chars())\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmpj2cu7le7.rs:11:5\n   |\n11 |     vowels_count_impl(s.chars())\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().enumerate().filter(|&(_, c)| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().enumerate().filter(|&(_,\
    \ c)| c == 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbr4z1cme.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().enumerate().filter(|&(_,\
    \ c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().enumerate().filter(|&(_,\
    \ c)| c == 'y').count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     (s.chars().enumerate().filter(|&(_,\
    \ c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().enumerate().filter(|&(_,\
    \ c)| c == 'y').count()).try_into().unwrap()\n   |     +                     \
    \                                                                            \
    \                                                                  +++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels = vec!['a', 'e', 'i', 'o', 'u'];\n    let\
    \ mut num_vowels = 0;\n    let mut last_vowel = 0;\n    let mut last_vowel_found\
    \ = false;\n    for c in s.chars() {\n        if vowels.contains(&c.to_ascii_lowercase())\
    \ {\n            if last_vowel_found {\n                num_vowels += 1;\n   \
    \         } else {\n                last_vowel = c;\n                last_vowel_found\
    \ = true;\n            }\n        }\n        if last_vowel_found {\n         \
    \   num_vowels += 1;\n        }\n    }\n    num_vowels\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptu43gndr.rs:20:30\n   |\n\
    13 |     let mut last_vowel = 0;\n   |                          - expected due\
    \ to this value\n...\n20 |                 last_vowel = c;\n   |             \
    \                 ^ expected integer, found `char`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut i = 0;\n    for c in s.chars() {\n        if\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            i +=\
    \ 1;\n        }\n    }\n    i\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpz5re4buf.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.chars(), s.len())\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp_kje188c.rs:11:5\n   |\n11 |     vowels_count(s.chars(), s.len())\n\
    \   |     ^^^^^^^^^^^^ ---------  ------- supplied 2 arguments\n   |     |\n \
    \  |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp_kje188c.rs:10:4\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |    ^^^^^^^^^^^^ ---------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().enumerate().filter(|(_, c)| c == 'a' || c\
    \ == 'e' || c == 'i' ||\n                                        c == 'o' || c\
    \ == 'u' || c == 'y').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_uah_wy.rs:11:45\n\
    \   |\n11 |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' ||\
    \ c == 'i' ||\n   |                                             ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_uah_wy.rs:11:57\n\
    \   |\n11 |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' ||\
    \ c == 'i' ||\n   |                                                         ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_uah_wy.rs:11:69\n\
    \   |\n11 |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' ||\
    \ c == 'i' ||\n   |                                                          \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpa_uah_wy.rs:12:43\n   |\n12 | ...                   c == 'o' ||\
    \ c == 'u' || c == 'y').count()\n   |                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_uah_wy.rs:12:55\n\
    \   |\n12 | ...                   c == 'o' || c == 'u' || c == 'y').count()\n\
    \   |                                     ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpa_uah_wy.rs:12:67\n   |\n12 | ...\
    \          "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqn4hq5yo.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqn4hq5yo.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqn4hq5yo.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpqn4hq5yo.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpqn4hq5yo.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_count(s.chars())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmpb3_q_9kf.rs:11:5\n\
    \   |\n11 |     vowel_count(s.chars())\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.as_bytes())\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyzqbpj9y.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_bytes())\n   |                  ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c.is_vowel())\n     \
    \   .count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp874ycej9.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.is_vowel())\n   |                       ^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp874ycej9.rs:11:5\n   |\n10 | \
    \  fn vowels_count(s: String) -> isize {\n   |                               \
    \  ----- expected `isize` because of return type\n11 | /     s.chars()\n12 | |\
    \         .filter(|c| c.is_vowel())\n13 | |         .count() + 1\n   | |____________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 ~     (s.chars()\n\
    12 |         .filter(|c| c.is_vowel())\n13 ~         .count() + 1).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        if *c >= 'a' && *c <= 'z' {\n            if *c == c {\n             \
    \   vowel_count += 1;\n            }\n        }\n        if *c == 'y' && *c ==\
    \ c {\n            vowel_count += 1;\n        }\n    }\n    vowel_count\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmph3z6qxqf.rs:13:12\n\
    \   |\n13 |         if *c >= 'a' && *c <= 'z' {\n   |            ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmph3z6qxqf.rs:13:25\n   |\n\
    13 |         if *c >= 'a' && *c <= 'z' {\n   |                         ^^\n\n\
    error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmph3z6qxqf.rs:14:16\n\
    \   |\n14 |             if *c == c {\n   |                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmph3z6qxqf.rs:18:12\n   |\n\
    18 |         if *c == 'y' && *c == c {\n   |            ^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmph3z6qxqf.rs:18:25\n   |\n18 | \
    \        if *c == 'y' && *c == c {\n   |                         ^^\n\nerror:\
    \ aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // count the number of vowels in a word\n    s.chars()\n\
    \        .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \        .count();\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl7efwx4u.rs:13:23\n\
    \   |\n13 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpl7efwx4u.rs:13:35\n   |\n13 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpl7efwx4u.rs:13:47\n   |\n13 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpl7efwx4u.rs:13:59\n   |\n13\
    \ |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpl7efwx4u.rs:13:71\n\
    \   |\n13 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl7efwx4u.rs:10:31\n\
    \   |\n10 | "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s)\n        .iter()\n        .filter(|c| c.is_vowel())\n\
    \        .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp2_md_zxe.rs:11:5\n\
    \   |\n11 |     vowels(s)\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|&c| c.is_ascii_letter()\
    \ || c.is_ascii_digit())\n        .filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u' || c == 'y')\n        .count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpofzg5we3.rs:12:24\n   |\n12 |         .filter(|&c|\
    \ c.is_ascii_letter() || c.is_ascii_digit())\n   |                        ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpofzg5we3.rs:13:23\n   |\n13\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                       ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpofzg5we3.rs:13:35\n   |\n13 |   \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\
    \ c == 'y')\n   |                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpofzg5we3.rs:13:47\n   |\n13\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                                               ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpofzg5we3.rs:13:59\n\
    \   |\n13 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpofzg5we3.rs:13:71\n   |\n13 |         .filter(|c| c == 'a' || c\
    \ == 'e' |"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.as_str()).unwrap()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt29ob1ij.rs:11:18\n   |\n\
    11 |     vowels_count(s.as_str()).unwrap()\n   |                  ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  |\n\
    \   |                  expected struct `String`, found `&str`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `isize` in the current scope\n  -->\
    \ /tmp/tmpt29ob1ij.rs:11:30\n   |\n11 |     vowels_count(s.as_str()).unwrap()\n\
    \   |                              ^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut count = s.len();\n    for c in s.chars() {\n\
    \        if !c.is_ascii() {\n            return 0;\n        }\n        if c.to_ascii_lowercase()\
    \ == 'a' {\n            count -= 1;\n        }\n        if c.to_ascii_lowercase()\
    \ == 'e' {\n            count -= 1;\n        }\n        if c.to_ascii_lowercase()\
    \ == 'i' {\n            count -= 1;\n        }\n        if c.to_ascii_lowercase()\
    \ == 'o' {\n            count -= 1;\n        }\n        if c.to_ascii_lowercase()\
    \ == 'u' {\n            count -= 1;\n        }\n        if c == 'y' {\n      \
    \      count -= 1;\n        }\n    }\n    count\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1hb31dbh.rs:35:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n...\n35 |     count\n   |  \
    \   ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n35 |     count.try_into().unwrap()\n\
    \   |          ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowel_count::<_, ()>(s)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_count` in this scope\n  --> /tmp/tmp1rz5nzl_.rs:11:5\n\
    \   |\n11 |     vowel_count::<_, ()>(s)\n   |     ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_helper(s)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmp4m09jrag.rs:11:5\n   |\n11 |     vowels_count_helper(s)\n   | \
    \    ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpmwhczm8o.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = Vec::new();\n    let mut in_a_vowel\
    \ = false;\n\n    for c in s.chars() {\n        let v = if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            c\n        } else {\n   \
    \         false\n        };\n\n        if v {\n            vowels.push(v);\n \
    \       } else {\n            in_a_vowel = true;\n        }\n    }\n\n    if in_a_vowel\
    \ {\n        vowels.len()\n    } else {\n        s.chars().count(|c| c != 'y')\n\
    \    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmpldwl6ulj.rs:18:13\n\
    \   |\n15 |           let v = if c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u' {\n   |  _________________-\n16 | |             c\n   | |      \
    \       - expected because of this\n17 | |         } else {\n18 | |          \
    \   false\n   | |             ^^^^^ expected `char`, found `bool`\n19 | |    \
    \     };\n   | |_________- `if` and `else` have incompatible types\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpldwl6ulj.rs:29:9\n   |\n10 | fn vowels_count(s:\
    \ String) -> isize {\n   |                               ----- expected `isize`\
    \ because of return type\n...\n29 |         vowels.len()\n   |         ^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n29 |         vowels.len().try_into().unwrap()\n\
    \   |                     ++++++++++++++++++++\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpldwl6ulj.rs:31:19\n\
    \    |\n31  |         s.chars().count(|c| c != 'y')\n    |                   ^^^^^\
    \ ------------ supplied 1 argument\n    |                   |\n    |         \
    \          expected 0 arguments\n    |\nnote: associated function defined here\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpldwl6ulj.rs:31:9\n   |\n10 | fn\
    \ vowels_count(s: String) -> isize {\n   |                               -----\
    \ expected `isize` because of return type\n...\n31 |         s.chars().count(|c|\
    \ c != 'y')\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n31 |         s.chars().count(|c| c != 'y').try_into().unwrap()\n\
    \   |                                      ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0061, E0308.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        c.is_ascii_letter() ||\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'\n    ).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpxorjbij1.rs:12:11\n   |\n12 |         c.is_ascii_letter()\
    \ || c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'\n  \
    \ |           ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxorjbij1.rs:12:34\n\
    \   |\n12 |         c.is_ascii_letter() || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' || c == 'y'\n   |                                  ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxorjbij1.rs:12:46\n\
    \   |\n12 |         c.is_ascii_letter() || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' || c == 'y'\n   |                                     \
    \         ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpxorjbij1.rs:12:58\n   |\n12 |         c.is_ascii_letter() || c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'\n   |   \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxorjbij1.rs:12:70\n\
    \   |\n12 |         c.is_ascii_letter() || c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' || c == 'y'\n   |                                     \
    \                                 ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if !s.is_ascii() {\n        panic!(\"Not an ascii string!\"\
    );\n    }\n\n    let mut cnt = 0;\n\n    for c in s.chars() {\n        if c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            cnt += 1;\n\
    \        }\n    }\n\n    cnt\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmp02ifq0z2.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut n = 0;\n    let mut s = s.to_string();\n   \
    \ while s.len() > 0 {\n        if s.ends_with('y') {\n            n += 1;\n  \
    \      }\n        if s.ends_with('uy') {\n            n += 2;\n        }\n   \
    \     if s.ends_with('yy') {\n            n += 3;\n        }\n        if s.ends_with('ee')\
    \ {\n            n += 4;\n        }\n        if s.ends_with('ei') {\n        \
    \    n += 5;\n        }\n        if s.ends_with('iuy') {\n            n += 6;\n\
    \        }\n        if s.ends_with('oo') {\n            n += 7;\n        }\n \
    \       if s.ends_with('oy') {\n            n += 8;\n        }\n        if s.ends_with('ai')\
    \ {\n            n += 9;\n        }\n        if s.ends_with('yi') {\n        \
    \    n += 10;\n        }\n        if s.ends_with('uy') {\n            n += 11;\n\
    \        }\n        if s.ends_with('ou') {\n            n += 12;\n        }\n\
    \        if s.ends_with('ouy') {\n            n += 13;\n        }\n        if\
    \ s.ends_with('ay') {\n            n += 14;\n        }\n        if s.ends_with('eiu')\
    \ {\n            n += 15;\n        }\n        if s.ends_with('aiu') {\n      \
    \      n += 16;\n        }\n        if s.ends_with('ou') {\n            n += 17;\n\
    \        }\n        if s.ends_with('oui') {\n            n += 18;\n        }\n\
    \        s = &s[..];\n    }\n    n\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:17:24\n\
    \   |\n17 |         if s.ends_with('uy') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    17 |         if s.ends_with(\"uy\") {\n   |                        ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:20:24\n\
    \   |\n20 |         if s.ends_with('yy') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    20 |         if s.ends_with(\"yy\") {\n   |                        ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:23:24\n\
    \   |\n23 |         if s.ends_with('ee') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    23 |         if s.ends_with(\"ee\") {\n   |                        ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:26:24\n\
    \   |\n26 |         if s.ends_with('ei') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    26 |         if s.ends_with(\"ei\") {\n   |                        ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:29:24\n\
    \   |\n29 |         if s.ends_with('iuy') {\n   |                        ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    29 |         if s.ends_with(\"iuy\") {\n   |                        ~~~~~\n\n\
    error: character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:32:24\n\
    \   |\n32 |         if s.ends_with('oo') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    32 |         if s.ends_with(\"oo\") {\n   |                        ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp_uysh83w.rs:35:24\n\
    \   |\n35 |         if s.ends_with('oy') {\n   |                        ^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, us"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i'\
    \ &&\n                            c != 'o' && c != 'u').count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkzgn5fq3.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' &&\n   |\
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpkzgn5fq3.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' &&\n   |                                  \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkzgn5fq3.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' &&\n   |\
    \                                                    ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpkzgn5fq3.rs:12:31\n\
    \   |\n12 | ...                   c != 'o' && c != 'u').count()\n   |        \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpkzgn5fq3.rs:12:43\n   |\n12 | ...               \
    \    c != 'o' && c != 'u').count()\n   |                                     ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkzgn5fq3.rs:11:5\n\
    \   |\n10 |   fn vowels_count(s: String) -> isize {\n   |                    \
    \             ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ c "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                        ^^ no implementation for `&char == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:40\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + s.chars().filter(|c|\
    \ c == 'y').count()\n   |                                        ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |    \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:64\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp_l1e1hkk.rs:11:76\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u').count() + s.chars().filter(|c| c == 'y').count()\n   |             \
    \                 "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u').count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplctwhnq4.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplctwhnq4.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplctwhnq4.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmplctwhnq4.rs:11:64\n   |\n11 |     s.chars().filter(|c| c != 'a'\
    \ && c != 'e' && c != 'i' && c != 'o' && c != 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplctwhnq4.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels: Vec<&'static str> = vec![\"a\", \"e\"\
    , \"i\", \"o\", \"u\"];\n    if let Some(last) = s.rfind(\"y\") {\n        vowels.insert(last,\
    \ \"y\");\n    }\n    vowels.iter().filter(|&vowel| s.chars().any(|&c| vowel ==\
    \ c)).count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8etx7hgv.rs:15:50\n   |\n\
    15 |     vowels.iter().filter(|&vowel| s.chars().any(|&c| vowel == c)).count()\n\
    \   |                                                  ^--\n   |             \
    \                                     ||\n   |                               \
    \                   |expected due to this\n   |                              \
    \                    expected `char`, found reference\n   |                  \
    \                                help: did you mean `c`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8etx7hgv.rs:15:5\n   |\n10 | fn vowels_count(s: String)\
    \ -> isize {\n   |                               ----- expected `isize` because\
    \ of return type\n...\n15 |     vowels.iter().filter(|&vowel| s.chars().any(|&c|\
    \ vowel == c)).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n15 |     vowels.iter().filter(|&vowel|\
    \ s.chars().any(|&c| vowel == c)).count().try_into().unwrap()\n   |          \
    \                                                                ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u')\n        .count();\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfe5i7qfz.rs:12:23\n\
    \   |\n12 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpfe5i7qfz.rs:12:35\n   |\n12 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmpfe5i7qfz.rs:12:47\n   |\n12 |   \
    \      .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                               ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpfe5i7qfz.rs:12:59\n   |\n12\
    \ |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u')\n\
    \   |                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpfe5i7qfz.rs:12:71\n\
    \   |\n12 |         .filter(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u')\n   |                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfe5i7qfz.rs:10:31\n\
    \   |\n10 | "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    use std::ascii::AsciiExt;\n    vowels_count_helper(s.chars(),\
    \ s.len(), 0)\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_helper` in this scope\n\
    \  --> /tmp/tmpq2kfa1rr.rs:12:5\n   |\n12 |     vowels_count_helper(s.chars(),\
    \ s.len(), 0)\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nwarning:\
    \ unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmpq2kfa1rr.rs:11:9\n   |\n\
    11 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nwarning: use of deprecated\
    \ trait `std::ascii::AsciiExt`: use inherent methods instead\n  --> /tmp/tmpq2kfa1rr.rs:11:21\n\
    \   |\n11 |     use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s).len()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpdlzw1a_7.rs:11:5\n\
    \   |\n11 |     vowels(s).len()\n   |     ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_counter = 0;\n    let mut vowel_end =\
    \ false;\n    let mut s = s;\n    while let Some(letter) = s.as_str().next_char()\
    \ {\n        // If the letter is not a vowel, increment the vowel_counter.\n \
    \       if !vowel_end && (letter != 'a' && letter != 'e' && letter != 'i' &&\n\
    \            letter != 'o' && letter != 'u') {\n            vowel_counter += 1;\n\
    \        }\n        if letter == 'y' {\n            vowel_end = true;\n      \
    \  } else {\n            vowel_end = false;\n        }\n    }\n    vowel_counter\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next_char` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmp7tjfnrxg.rs:14:41\n   |\n14 |     while let\
    \ Some(letter) = s.as_str().next_char() {\n   |                              \
    \           ^^^^^^^^^ method not found in `&str`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: HashSet<char> = HashSet::new();\n\n    for\
    \ (i, c) in s.chars().enumerate() {\n        if !vowels.contains(&c) {\n     \
    \       vowels.insert(*c);\n        }\n    }\n    vowels.len()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmps67o06sa.rs:11:17\n\
    \   |\n11 |     let vowels: HashSet<char> = HashSet::new();\n   |            \
    \     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `HashSet`\n  --> /tmp/tmps67o06sa.rs:11:33\n   |\n11\
    \ |     let vowels: HashSet<char> = HashSet::new();\n   |                    \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmps67o06sa.rs:15:27\n   |\n\
    15 |             vowels.insert(*c);\n   |                           ^^\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n        .count() + s.chars()\n\
    \        .filter(|c| c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'\
    \ || c == 'Y')\n        .count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1qoxqx2d.rs:12:23\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                       ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp1qoxqx2d.rs:12:35\n   |\n12\
    \ |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'\
    \ || c == 'y')\n   |                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1qoxqx2d.rs:12:47\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                               ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp1qoxqx2d.rs:12:59\n\
    \   |\n12 |         .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y')\n   |                                                \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp1qoxqx2d.rs:12:71\n   |\n12 |         .filter(|c| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y')\n   |              \
    \                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]:"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpmwhczm8o.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpmwhczm8o.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 1\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009144
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut counter = 0;\n    for (i, c) in s.chars().enumerate()\
    \ {\n        counter += if c == 'a' || c == 'e' || c == 'i' || c == 'o' || c ==\
    \ 'u' {\n            1\n        } else if c == 'y' {\n            1\n        }\
    \ else if c == 'e' || c == 'i' || c == 'o' || c == 'u' {\n            0\n    \
    \    } else if c == 'y' {\n            0\n        } else {\n            0\n  \
    \      };\n    }\n    counter\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpmjjz4330.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c != 'a' && *c != 'e' && *c !=\
    \ 'i' &&\n                          *c != 'o' && *c != 'u'\n                 \
    \    ).count() + 1\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyy4djys.rs:11:5\n   |\n\
    10 |   fn vowels_count(s: String) -> isize {\n   |                           \
    \      ----- expected `isize` because of return type\n11 | /     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' &&\n12 | |                           *c\
    \ != 'o' && *c != 'u'\n13 | |                      ).count() + 1\n   | |__________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 ~     (s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' &&\n12 |                           *c !=\
    \ 'o' && *c != 'u'\n13 ~                      ).count() + 1).try_into().unwrap()\n\
    \   |\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| *c >= 'a' && *c <= 'z')\n\
    \        .filter(|c| *c >= 'A' && *c <= 'Z')\n        .count(|c| *c == 'a' ||\
    \ *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u')\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpkjfpyqtj.rs:14:17\n\
    \   |\n14 |         .count(|c| *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o'\
    \ || *c == 'u')\n   |                 ^ consider giving this closure parameter\
    \ a type\n   |\n   = note: type must be known at this point\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpkjfpyqtj.rs:14:10\n\
    \    |\n14  |         .count(|c| *c == 'a' || *c == 'e' || *c == 'i' || *c ==\
    \ 'o' || *c == 'u')\n    |          ^^^^^ -----------------------------------------------------------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpkjfpyqtj.rs:11:5\n   |\n10 |   fn vowels_count(s: String) -> isize\
    \ {\n   |                                 ----- expected `isize` because of return\
    \ type\n11 | /     s.chars()\n12 | |         .filter(|c| *c >= 'a' && *c <= 'z')\n\
    13 | |         .filter(|c| *c >= 'A' && *c <= 'Z')\n14 | |         .count(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u')\n   | |_________________________________________________________________________________^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |         .count(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').try_into().unwrap()\n\
    \   |                                                                        \
    \          ++++++++++++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0061, E0282, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count_impl(s)\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels_count_impl` in this scope\n\
    \  --> /tmp/tmp6wsvkao8.rs:11:5\n   |\n11 |     vowels_count_impl(s)\n   |   \
    \  ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_lowercase()).filter(|c| c.is_uppercase()).filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n}\n\n\
    fn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjs8m9cn7.rs:11:86\n\
    \   |\n11 |     s.chars().filter(|c| c.is_lowercase()).filter(|c| c.is_uppercase()).filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == '...\n   |            \
    \                                                                          ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjs8m9cn7.rs:11:98\n\
    \   |\n11 | ...|c| c.is_uppercase()).filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n   |                                 \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpjs8m9cn7.rs:11:110\n   |\n11 | ...ercase()).filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n   |\
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpjs8m9cn7.rs:11:122\n   |\n\
    11 | ...lter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\
    \ + 1\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpjs8m9cn7.rs:11:134\n\
    \   |\n11 | ...= 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\
    \ + 1\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is "
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut num = 0;\n    let mut i = 0;\n    while i <\
    \ s.len() {\n        if &s[i..].iter().filter(|c| c == 'a' || c == 'e' || c ==\
    \ 'i' || c == 'o' || c == 'u').count() > 0 {\n            num +=1;\n        }\n\
    \        i += 1;\n    }\n    num\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpoggrblu0.rs:14:20\n   |\n14 |         if &s[i..].iter().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() > 0 {\n  \
    \ |                    ^^^^ method not found in `str`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o' && c != 'u').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4kbwkz22.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4kbwkz22.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \    ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4kbwkz22.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp4kbwkz22.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').count() as isize\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4kbwkz22.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c != 'a' && c != 'e' && c != 'i' && c !=\
    \ 'o' && c != 'u').count() as isize\n   |                                    \
    \                                        ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels_count(s.chars())\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe3raiea_.rs:11:18\n   |\n\
    11 |     vowels_count(s.chars())\n   |                  ^^^^^^^^^ expected struct\
    \ `String`, found struct `Chars`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut s: String = s.to_string();\n    s.replace('a',\
    \ '');\n    s.replace('e', '');\n    s.replace('i', '');\n    s.replace('o', '');\n\
    \    s.replace('u', '');\n    s.replace('Y', '');\n    s.chars().filter(|c| c\
    \ == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'Y').count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmprdmsfead.rs:12:21\n   |\n\
    12 |     s.replace('a', '');\n   |                     ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmprdmsfead.rs:13:21\n   |\n13 |\
    \     s.replace('e', '');\n   |                     ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmprdmsfead.rs:14:21\n   |\n14 |\
    \     s.replace('i', '');\n   |                     ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmprdmsfead.rs:15:21\n   |\n15 |\
    \     s.replace('o', '');\n   |                     ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmprdmsfead.rs:16:21\n   |\n16 |\
    \     s.replace('u', '');\n   |                     ^ empty character literal\n\
    \nerror: empty character literal\n  --> /tmp/tmprdmsfead.rs:17:21\n   |\n17 |\
    \     s.replace('Y', '');\n   |                     ^ empty character literal\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprdmsfead.rs:18:28\n\
    \   |\n18 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'Y').count()\n   |                            ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprdmsfead.rs:18:40\n\
    \   |\n18 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'Y').count()\n   |                                 \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmprdmsfead.rs:18:52\n\
    \   |\n18 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u' || c == 'Y').count()\n   |                                 \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().enumerate().filter(|(_, c)| c == 'a' || c\
    \ == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpii0ynzem.rs:11:45\n\
    \   |\n11 |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count() + 1\n   |                        \
    \                     ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpii0ynzem.rs:11:57\n   |\n11 |     s.chars().enumerate().filter(|(_,\
    \ c)| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 1\n\
    \   |                                                         ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpii0ynzem.rs:11:69\n\
    \   |\n11 |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u').count() + 1\n   |                        \
    \                                             ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpii0ynzem.rs:11:81\n   |\n11\
    \ |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n   |                                 \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpii0ynzem.rs:11:93\n   |\n11\
    \ |     s.chars().enumerate().filter(|(_, c)| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 1\n   |                                 \
    \                             "
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    if s.is_empty() {\n        return 0;\n    }\n    let\
    \ mut vowels: Vec<&'static str> = vec!['a', 'e', 'i', 'o', 'u'];\n    vowels.clone_from(&s);\n\
    \n    let mut count = 0;\n    for i in 0..vowels.len() {\n        if vowels[i]\
    \ == 'y' && vowels[i + 1] == 'o' {\n            count += 1;\n        }\n    }\n\
    \    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeomesc4y.rs:14:46\n   |\n\
    14 |     let mut vowels: Vec<&'static str> = vec!['a', 'e', 'i', 'o', 'u'];\n\
    \   |                                              ^^^ expected `&str`, found\
    \ `char`\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n14 |     let mut vowels: Vec<&'static str> = vec![\"a\", 'e', 'i', 'o',\
    \ 'u'];\n   |                                              ~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpeomesc4y.rs:15:23\n   |\n15 |     vowels.clone_from(&s);\n\
    \   |                       ^^ expected struct `Vec`, found struct `String`\n\
    \   |\n   = note: expected reference `&Vec<&'static str>`\n              found\
    \ reference `&String`\n\nerror[E0277]: can't compare `&str` with `char`\n  -->\
    \ /tmp/tmpeomesc4y.rs:19:22\n   |\n19 |         if vowels[i] == 'y' && vowels[i\
    \ + 1] == 'o' {\n   |                      ^^ no implementation for `&str == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpeomesc4y.rs:19:46\n   |\n19 |         if vowels[i]\
    \ == 'y' && vowels[i + 1] == 'o' {\n   |                                     \
    \         ^^ no implementation for `&str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c.is_vowel())\n     \
    \   .count(|c| c)\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpw6bo3tbc.rs:12:23\n   |\n12 |         .filter(|c|\
    \ c.is_vowel())\n   |                       ^^^^^^^^ method not found in `&char`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpw6bo3tbc.rs:13:10\n    |\n13  |         .count(|c| c)\n    | \
    \         ^^^^^ ----- supplied 1 argument\n    |          |\n    |          expected\
    \ 0 arguments\n    |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw6bo3tbc.rs:11:5\n   |\n10 |   fn vowels_count(s:\
    \ String) -> isize {\n   |                                 ----- expected `isize`\
    \ because of return type\n11 | /     s.chars()\n12 | |         .filter(|c| c.is_vowel())\n\
    13 | |         .count(|c| c)\n   | |_____________________^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n13 |         .count(|c| c).try_into().unwrap()\n\
    \   |                      ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter_map(|c| match c {\n        'a' => Some(1),\n\
    \        'e' => Some(1),\n        'i' => Some(1),\n        'o' => Some(1),\n \
    \       'u' => Some(1),\n        _ => None,\n    }).sum()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `2`,\n right: `3`', /tmp/tmpst1k1lu_.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(&s).count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpk06wvala.rs:11:5\n\
    \   |\n11 |     vowels(&s).count()\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| *c == b'a' || *c == b'e'\
    \ || *c == b'i' || *c == b'o' || *c == b'u')\n        .count() + s.chars()\n \
    \       .filter(|c| *c == b'y' || *c == b'Y')\n        .count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4uhieus7.rs:12:27\n   |\n\
    12 |         .filter(|c| *c == b'a' || *c == b'e' || *c == b'i' || *c == b'o'\
    \ || *c == b'u')\n   |                           ^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4uhieus7.rs:12:41\n   |\n12 |\
    \         .filter(|c| *c == b'a' || *c == b'e' || *c == b'i' || *c == b'o' ||\
    \ *c == b'u')\n   |                                         ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4uhieus7.rs:12:55\n\
    \   |\n12 |         .filter(|c| *c == b'a' || *c == b'e' || *c == b'i' || *c ==\
    \ b'o' || *c == b'u')\n   |                                                  \
    \     ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4uhieus7.rs:12:69\n   |\n12 |         .filter(|c| *c == b'a' || *c ==\
    \ b'e' || *c == b'i' || *c == b'o' || *c == b'u')\n   |                      \
    \                                               ^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4uhieus7.rs:12:83\n   |\n12 |\
    \         .filter(|c| *c == b'a' || *c == b'e' || *c == b'i' || *c == b'o' ||\
    \ *c == b'u')\n   |                                                          \
    \                         ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4uhieus7.rs:14:27\n   |\n14 |         .filter(|c| *c ==\
    \ b'y' || *c == b'Y')\n   |                           ^^^^ expected `char`, found\
    \ `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4uhieus7.rs:14:41\n  \
    \ |\n14 |         .filter(|c| *c == b'y' || *c == b'Y')\n   |                \
    \                         ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4uhieus7.rs:11:5\n   |\n10 |   fn vowels_count(s: String)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n11 | /     s.chars()\n12 | |         .filter(|c| *c == b'a'\
    \ || *c == b'e' || *c == b'i' || *c == b'o' || *c == b'u')\n13 | |         .count()\
    \ + s.chars()\n14 | |         .filter(|c| *c == b'y' || *c == b'"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c == 'a' || *c == 'e' || *c ==\
    \ 'i' || *c == 'o' || *c == 'u').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqjaq20yr.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c == 'a' || *c == 'e' || *c == 'i' || *c == 'o' || *c == 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u')\n        .count() as isize\n}\n\nfn main() {\n    let\
    \ candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")),\
    \ 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn6o30y21.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                            ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpn6o30y21.rs:11:40\n   |\n11\
    \ |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                        ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn6o30y21.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpn6o30y21.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u')\n   |                                                     \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpn6o30y21.rs:11:76\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to "
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowels = \"aeiou\".to_string();\n    let mut\
    \ count = 0;\n    for ch in s.chars() {\n        if ch == 'a' || ch == 'e' ||\
    \ ch == 'i' || ch == 'o' || ch == 'u' {\n            count += 1;\n        } else\
    \ if ch == 'y' {\n            count += 1;\n            vowels = &vowels[1..];\n\
    \        }\n    }\n    count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp44b0gewi.rs:18:22\n   |\n\
    11 |     let mut vowels = \"aeiou\".to_string();\n   |                      -------------------\
    \ expected due to this value\n...\n18 |             vowels = &vowels[1..];\n \
    \  |                      ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n18 |             vowels = (&vowels[1..]).to_string();\n\
    \   |                      +            +++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let mut vowel_count = 0;\n    for c in s.chars() {\n\
    \        match c {\n            'a' | 0x11..=0x17 => vowel_count += 1,\n     \
    \       'e' | 0x11..=0x17 => vowel_count += 1,\n            'i' | 0x11..=0x17\
    \ => vowel_count += 1,\n            'o' | 0x11..=0x17 => vowel_count += 1,\n \
    \           'u' | 0x11..=0x17 => vowel_count += 1,\n            _ => ()\n    \
    \    }\n    }\n    vowel_count\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4az7ozn.rs:14:19\n   |\n\
    13 |         match c {\n   |               - this expression has type `char`\n\
    14 |             'a' | 0x11..=0x17 => vowel_count += 1,\n   |                \
    \   ^^^^   ---- this is of type `{integer}`\n   |                   |\n   |  \
    \                 expected `char`, found integer\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpo4az7ozn.rs:14:26\n   |\n13 |         match c {\n   |         \
    \      - this expression has type `char`\n14 |             'a' | 0x11..=0x17 =>\
    \ vowel_count += 1,\n   |                   ----   ^^^^ expected `char`, found\
    \ integer\n   |                   |\n   |                   this is of type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpo4az7ozn.rs:15:19\n   |\n13 |\
    \         match c {\n   |               - this expression has type `char`\n14\
    \ |             'a' | 0x11..=0x17 => vowel_count += 1,\n15 |             'e' |\
    \ 0x11..=0x17 => vowel_count += 1,\n   |                   ^^^^   ---- this is\
    \ of type `{integer}`\n   |                   |\n   |                   expected\
    \ `char`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4az7ozn.rs:15:26\n\
    \   |\n13 |         match c {\n   |               - this expression has type `char`\n\
    14 |             'a' | 0x11..=0x17 => vowel_count += 1,\n15 |             'e'\
    \ | 0x11..=0x17 => vowel_count += 1,\n   |                   ----   ^^^^ expected\
    \ `char`, found integer\n   |                   |\n   |                   this\
    \ is of type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4az7ozn.rs:16:19\n\
    \   |\n13 |         match c {\n   |               - this expression has type `char`\n\
    ...\n16 |             'i' | 0x11..=0x17 => vowel_count += 1,\n   |           \
    \        ^^^^   ---- this is of type `{integer}`\n   |                   |\n \
    \  |                   expected `char`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo4az7ozn.rs:16:26\n   |\n13 |         match c {\n   | \
    \              - this expression has type `char`\n...\n16 |             'i' |\
    \ 0x11..=0x17 => vowel_count += 1,\n   |         "
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count() + 2\n}\n\nfn main() {\n    let candidate =\
    \ vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpetemyg1z.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 2\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpetemyg1z.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 2\n   |                                        ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpetemyg1z.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 2\n   |                                         \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmpetemyg1z.rs:11:64\n   |\n11 |     s.chars().filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u').count() + 2\n   |         \
    \                                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpetemyg1z.rs:11:76\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count() + 2\n   |                                         \
    \                                   ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `P"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: Vec<&str> = vec![\"a\", \"e\", \"i\", \"\
    o\", \"u\"];\n    vowels.iter().cloned().filter(|&v| s.ends_with(v)).count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg_3ysc3i.rs:12:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     let vowels: Vec<&str>\
    \ = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n12 |     vowels.iter().cloned().filter(|&v|\
    \ s.ends_with(v)).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |     vowels.iter().cloned().filter(|&v|\
    \ s.ends_with(v)).count().try_into().unwrap()\n   |                          \
    \                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.length()\n        .filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u')\n        .count()\n}\n\nfn main() {\n \
    \   let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpp0_gihmk.rs:11:7\n   |\n11 |     s.length()\n \
    \  |       ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s).len()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpdlzw1a_7.rs:11:5\n\
    \   |\n11 |     vowels(s).len()\n   |     ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    let vowels: &str = &\"aeiou\";\n    let mut c = s.chars().filter_map(|c|\
    \ match c {\n        'a' | _  | 'e' | 'i' | _  | 'o' | 'u' | _ => false,\n   \
    \     _ => true,\n    });\n    c.filter(|c| vowels.contains(&c))\n        .count()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1qvt4rd.rs:13:54\n   |\n\
    13 |         'a' | _  | 'e' | 'i' | _  | 'o' | 'u' | _ => false,\n   |       \
    \                                               ^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n13 |       \
    \  'a' | _  | 'e' | 'i' | _  | 'o' | 'u' | _ => Some(false),\n   |           \
    \                                           +++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl1qvt4rd.rs:16:5\n   |\n10 |   fn vowels_count(s: String)\
    \ -> isize {\n   |                                 ----- expected `isize` because\
    \ of return type\n...\n16 | /     c.filter(|c| vowels.contains(&c))\n17 | |  \
    \       .count()\n   | |________________^ expected `isize`, found `usize`\n  \
    \ |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |         .count().try_into().unwrap()\n   |   \
    \              ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    vowels(s.to_lowercase()).count()\n}\n\nfn main() {\n\
    \    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmp80oag6vj.rs:11:5\n\
    \   |\n11 |     vowels(s.to_lowercase()).count()\n   |     ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // Write your solution here.\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppcsrdyaz.rs:10:31\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |    ------------             \
    \  ^^^^^ expected `isize`, found `()`\n   |    |\n   |    implicitly returns `()`\
    \ as its body has no tail or `return` expression\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmppjulyk1e.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjulyk1e.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    match s.chars() {\n        chars => chars\n        \
    \    .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n \
    \           .count() as isize,\n        _ => 0,\n    }\n}\n\nfn main() {\n   \
    \ let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\"\
    )), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplezpvhi9.rs:13:27\n\
    \   |\n13 |             .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                           ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmplezpvhi9.rs:13:39\n   |\n13\
    \ |             .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c\
    \ == 'u')\n   |                                       ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplezpvhi9.rs:13:51\n\
    \   |\n13 |             .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                   ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplezpvhi9.rs:13:63\n\
    \   |\n13 |             .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                         \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplezpvhi9.rs:13:75\n\
    \   |\n13 |             .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o'\
    \ || c == 'u')\n   |                                                         \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror: aborting due to 5 previous"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c|\n        c != 'a' &&\n        c\
    \ != 'e' &&\n        c != 'i' &&\n        c != 'o' &&\n        c != 'u'\n    ).count()\
    \ as isize\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp7x45bkz8.rs:12:11\n\
    \   |\n12 |         c != 'a' &&\n   |           ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp7x45bkz8.rs:13:11\n   |\n13\
    \ |         c != 'e' &&\n   |           ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp7x45bkz8.rs:14:11\n   |\n14 |   \
    \      c != 'i' &&\n   |           ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp7x45bkz8.rs:15:11\n   |\n15 |   \
    \      c != 'o' &&\n   |           ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp7x45bkz8.rs:16:11\n   |\n16 |   \
    \      c != 'u'\n   |           ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to 5\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| *c != 'a' && *c != 'e' && *c !=\
    \ 'i' && *c != 'o' && *c != 'u').count()\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6lpkx6kx.rs:11:5\n   |\n\
    10 | fn vowels_count(s: String) -> isize {\n   |                             \
    \  ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').count()\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u').count().try_into().unwrap()\n\
    \   |                                                                        \
    \                        ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter_map(|c| match c {\n     \
    \       'a' => 1,\n            'e' => 1,\n            'i' => 1,\n            'o'\
    \ => 1,\n            'u' => 1,\n            _ => 0,\n        })\n        .sum()\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxdjc59t5.rs:13:20\n   |\n\
    13 |             'a' => 1,\n   |                    ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n13 |  \
    \           'a' => Some(1),\n   |                    +++++ +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars()\n        .filter(|c| c.is_lowercase())\n \
    \       .filter(|c| c.is_ascii_letter())\n        .filter(|c| c.is_ascii_uppercase_letter())\n\
    \        .filter(|c| c.is_ascii_digit())\n        .filter(|c| c.is_ascii_symbol())\n\
    \        .filter(|c| c.is_ascii_whitespace())\n        .count(|c| c.is_ascii_vowel())\n\
    }\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpwp4s3pjm.rs:13:23\n   |\n13 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no\
    \ method named `is_ascii_uppercase_letter` found for reference `&char` in the\
    \ current scope\n  --> /tmp/tmpwp4s3pjm.rs:14:23\n   |\n14 |         .filter(|c|\
    \ c.is_ascii_uppercase_letter())\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii_uppercase`\n\
    \nerror[E0599]: no method named `is_ascii_symbol` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpwp4s3pjm.rs:16:23\n   |\n16 |         .filter(|c|\
    \ c.is_ascii_symbol())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmpwp4s3pjm.rs:18:10\n\
    \    |\n18  |         .count(|c| c.is_ascii_vowel())\n    |          ^^^^^ ----------------------\
    \ supplied 1 argument\n    |          |\n    |          expected 0 arguments\n\
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwp4s3pjm.rs:11:5\n   |\n10 |   fn vowels_count(s: String) -> isize\
    \ {\n   |                                 ----- expected `isize` because of return\
    \ type\n11 | /     s.chars()\n12 | |         .filter(|c| c.is_lowercase())\n13\
    \ | |         .filter(|c| c.is_ascii_letter())\n14 | |         .filter(|c| c.is_ascii_uppercase_letter())\n\
    ...  |\n17 | |         .filter(|c| c.is_ascii_whitespace())\n18 | |         .count(|c|\
    \ c.is_ascii_vowel())\n   | |______________________________________^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n18 |         .count(|c|\
    \ c.is_ascii_vowel()).try_into().unwrap()\n   |                              \
    \         ++++++++++++++++++++\n\nerror: aborting due to 5 "
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c.is_vowel()).count()\n}\n\nfn\
    \ main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_vowel` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmppjulyk1e.rs:11:28\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |                            ^^^^^^^^ method not found\
    \ in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppjulyk1e.rs:11:5\n\
    \   |\n10 | fn vowels_count(s: String) -> isize {\n   |                      \
    \         ----- expected `isize` because of return type\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |     s.chars().filter(|c|\
    \ c.is_vowel()).count().try_into().unwrap()\n   |                            \
    \                   ++++++++++++++++++++\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009144
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c|\
    \ c >= 'A' && c <= 'Z').count() as isize\n}\n\nfn main() {\n    let candidate\
    \ = vowels_count;\n    assert_eq!(candidate(String::from(\"abcde\")), 2);\n  \
    \  assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp97guek_8.rs:11:31\n   |\n\
    11 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c >= 'A' && c <=\
    \ 'Z').count() as isize\n   |                               ^^^\n   |        \
    \                       |\n   |                               expected `&char`,\
    \ found `char`\n   |                               help: consider borrowing here:\
    \ `&'a'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp97guek_8.rs:11:43\n\
    \   |\n11 |     s.chars().filter(|c| c >= 'a' && c <= 'z').filter(|c| c >= 'A'\
    \ && c <= 'Z').count() as isize\n   |                                        \
    \   ^^^\n   |                                           |\n   |              \
    \                             expected `&char`, found `char`\n   |           \
    \                                help: consider borrowing here: `&'z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp97guek_8.rs:11:64\n   |\n11 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').filter(|c| c >= 'A' && c <= 'Z').count() as isize\n  \
    \ |                                                                ^^^\n   | \
    \                                                               |\n   |      \
    \                                                          expected `&char`, found\
    \ `char`\n   |                                                               \
    \ help: consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp97guek_8.rs:11:76\n   |\n11 |     s.chars().filter(|c| c >= 'a' && c\
    \ <= 'z').filter(|c| c >= 'A' && c <= 'Z').count() as isize\n   |            \
    \                                                                ^^^\n   |   \
    \                                                                         |\n\
    \   |                                                                        \
    \    expected `&char`, found `char`\n   |                                    \
    \                                        help: consider borrowing here: `&'Z'`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 101
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    // This regex matches vowels at the end of the word.\n\
    \    match s.chars().nth(s.len() - 1).unwrap() {\n        'a' => 1,\n        'e'\
    \ => 1,\n        'i' => 1,\n        'o' => 1,\n        'u' => 1,\n        _ =>\
    \ 0,\n    }\n}\n\nfn main() {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `1`,\n right: `2`', /tmp/tmp_7zk3t7i.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| 'A' <= c && c <= 'Z' || 'a' <=\
    \ c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e' <= c && c <= 'z' || 'I' <= c &&\
    \ c <= 'Z' || 'i' <= c && c <= 'z' || 'O' <= c && c <= 'Z' || 'o' <= c && c <=\
    \ 'z' || 'U' <= c && c <= 'Z' || 'u' <= c && c <= 'z').count()\n}\n\nfn main()\
    \ {\n    let candidate = vowels_count;\n    assert_eq!(candidate(String::from(\"\
    abcde\")), 2);\n    assert_eq!(candidate(String::from(\"Alone\")), 3);\n    assert_eq!(candidate(String::from(\"\
    key\")), 2);\n    assert_eq!(candidate(String::from(\"bye\")), 1);\n    assert_eq!(candidate(String::from(\"\
    keY\")), 2);\n    assert_eq!(candidate(String::from(\"bYe\")), 1);\n    assert_eq!(candidate(String::from(\"\
    ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpycv0bja5.rs:11:33\n   |\n\
    11 |     s.chars().filter(|c| 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' ||\
    \ 'E' <= c && c <= 'Z' || 'e' <= c && c <= 'z' || 'I' <= c && c <=...\n   |  \
    \                               ^ expected `char`, found `&char`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n11 |     s.chars().filter(|c| 'A' <=\
    \ *c && c <= 'Z' || 'a' <= c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e' <= c &&\
    \ c <= 'z' || 'I' <= c && c <= 'Z' || 'i' <= c && c <= 'z' || 'O' <= c && c <=\
    \ 'Z' || 'o' <= c && c <= 'z' || 'U' <= c && c <= 'Z' || 'u' <= c && c <= 'z').count()\n\
    \   |                                 +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpycv0bja5.rs:11:43\n   |\n11 |     s.chars().filter(|c| 'A' <= c && c\
    \ <= 'Z' || 'a' <= c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e' <= c && c <= 'z'\
    \ || 'I' <= c && c <=...\n   |                                           ^^^\n\
    \   |                                           |\n   |                      \
    \                     expected `&char`, found `char`\n   |                   \
    \                        help: consider borrowing here: `&'Z'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpycv0bja5.rs:11:57\n   |\n11 |     s.chars().filter(|c|\
    \ 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e'\
    \ <= c && c <= 'z' || 'I' <= c && c <=...\n   |                              \
    \                           ^ expected `char`, found `&char`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n11 |     s.chars().filter(|c| 'A' <= c && c\
    \ <= 'Z' || 'a' <= *c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e' <= c && c <=\
    \ 'z' || 'I' <= c && c <= 'Z' || 'i' <= c && c <= 'z' || 'O' <= c && c <= 'Z'\
    \ || 'o' <= c && c <= 'z' || 'U' <= c && c <= 'Z' || 'u' <= c && c <= 'z').count()\n\
    \   |                                                         +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpycv0bja5.rs:11:67\n   |\n11 |     s.chars().filter(|c|\
    \ 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || 'E' <= c && c <= 'Z' || 'e'\
    \ <= c && c <= 'z' || 'I' <= c && c <=...\n   |  "
  stdout: ''
  timestamp: 1660009145
- exit_code: 1
  program: "/// Write a function vowels_count which takes a string representing\n\
    /// a word as input and returns the number of vowels in the string.\n/// Vowels\
    \ in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n/// vowel, but\
    \ only when it is at the end of the given word.\n/// Example:\n/// >>> vowels_count(String::from(\"\
    abcde\"))\n/// 2\n/// >>> vowels_count(String::from(\"ACEDY\"))\n/// 3\nfn vowels_count(s:\
    \ String) -> isize {\n    s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i'\
    \ || c == 'o' || c == 'u').count()\n}\n\nfn main() {\n    let candidate = vowels_count;\n\
    \    assert_eq!(candidate(String::from(\"abcde\")), 2);\n    assert_eq!(candidate(String::from(\"\
    Alone\")), 3);\n    assert_eq!(candidate(String::from(\"key\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bye\")), 1);\n    assert_eq!(candidate(String::from(\"keY\")), 2);\n    assert_eq!(candidate(String::from(\"\
    bYe\")), 1);\n    assert_eq!(candidate(String::from(\"ACEDY\")), 3);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:28\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                            ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:40\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:52\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \       ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:64\n\
    \   |\n11 |     s.chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c ==\
    \ 'o' || c == 'u').count()\n   |                                             \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp3hx3gq5f.rs:11:76\n   |\n11 |     s.chars().filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u').count()\n   |    \
    \                                                                        ^^ no\
    \ implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is impleme"
  stdout: ''
  timestamp: 1660009049
