language: rs
name: HumanEval_149_sorted_list_sum
results:
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut rev_lst = lst\n        .iter()\n        .map(|w|\
    \ w.to_lowercase())\n        .collect::<Vec<_>>();\n    let mut sum = 0;\n   \
    \ for &s in &mut rev_lst {\n        sum += s.len() as i32;\n    }\n    sorted_list_sum(sum,\
    \ &mut rev_lst)\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpah1onri9.rs:22:9\n   |\n\
    22 |     for &s in &mut rev_lst {\n   |         ^^    ------------ this expression\
    \ has type `Option<&mut String>`\n   |         |\n   |         types differ in\
    \ mutability\n   |         help: you can probably remove the explicit borrow:\
    \ `s`\n   |\n   = note: expected mutable reference `&mut String`\n           \
    \           found reference `&_`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmpah1onri9.rs:25:5\n   |\n25 |  \
    \   sorted_list_sum(sum, &mut rev_lst)\n   |     ^^^^^^^^^^^^^^^ ---  ------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpah1onri9.rs:16:4\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^ ----------------\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n\n    for word in lst {\n     \
    \   res.push(word);\n    }\n\n    let mut sorted_vec = vec![];\n    sorted_vec.sort();\n\
    \    let mut pos = 0;\n\n    for (i, word) in sorted_vec.iter().enumerate() {\n\
    \        if i % 2 == 0 {\n            continue;\n        }\n\n        sorted_vec.insert(pos,\
    \ word);\n        pos += 1;\n    }\n\n    sorted_vec\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu8l0n2p6.rs:32:32\n   |\n\
    32 |         sorted_vec.insert(pos, word);\n   |                             \
    \   ^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \                      |\n   |                                cyclic type of infinite\
    \ size\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec![\"aa\"]\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_oqvcx3c.rs:17:10\n   |\n\
    17 |     vec![\"aa\"]\n   |          ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |          |\n   |          expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec![lst[0].to_owned(), lst[1]].iter().fold(vec![], |mut\
    \ acc, elem| {\n        let mut new_acc = acc;\n        let new_elem = elem.to_owned();\n\
    \        let mut found_index = -1;\n        for i in 1..new_acc.len() {\n    \
    \        if new_acc[i] > new_elem {\n                new_acc[i] = new_acc[i];\n\
    \                found_index = i;\n            } else {\n                break;\n\
    \            }\n        }\n        if found_index != -1 {\n            new_acc.swap(found_index,\
    \ new_acc.len());\n        }\n        new_acc\n    })\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpeaobsc5o.rs:20:31\n\
    \   |\n20 |         let mut found_index = -1;\n   |                          \
    \     ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmpeaobsc5o.rs:29:27\n\
    \   |\n29 |         if found_index != -1 {\n   |                           ^^\n\
    \   |                           |\n   |                           cannot apply\
    \ unary operator `-`\n   |                           help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0600.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n\n    lst\n        .iter()\n\
    \        .filter(|x| x.len() % 2 != 0)\n        .for_each(|x| result.push(x));\n\
    \n    result.sort_by(|a, b| a.len() < b.len());\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp49comx6q.rs:24:27\n   |\n\
    24 |     result.sort_by(|a, b| a.len() < b.len());\n   |                     \
    \      ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp49comx6q.rs:26:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n26 |     result\n   |     ^^^^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().map(|x| x.to_string()).filter(|x| x.len() >\
    \ 2).cloned().collect();\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmp3blxrpy8.rs:17:20:\
    \ 17:37] as FnOnce<(&String,)>>::Output == &_`\n  --> /tmp/tmp3blxrpy8.rs:17:63\n\
    \   |\n17 |     lst.iter().map(|x| x.to_string()).filter(|x| x.len() > 2).cloned().collect();\n\
    \   |                                                               ^^^^^^ expected\
    \ reference, found struct `String`\n   |\n   = note: expected reference `&_`\n\
    \                 found struct `String`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Map<std::slice::Iter<'_, String>, [closure@/tmp/tmp3blxrpy8.rs:17:20:\
    \ 17:37]>`\n   = note: 1 redundant requirement hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmp3blxrpy8.rs:17:20: 17:37]>, [closure@/tmp/tmp3blxrpy8.rs:17:46:\
    \ 17:61]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmp3blxrpy8.rs:17:63\n\
    \   |\n17 |     lst.iter().map(|x| x.to_string()).filter(|x| x.len() > 2).cloned().collect();\n\
    \   |                                              ---------------  ^^^^^^ expected\
    \ signature of `for<'r> fn(&'r &_) -> _`\n   |                               \
    \               |\n   |                                              found signature\
    \ of `for<'r> fn(&'r String) -> _`\n   |\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_, String>, [closure@/tmp/tmp3blxrpy8.rs:17:20:\
    \ 17:37]>, [closure@/tmp/tmp3blxrpy8.rs:17:46: 17:61]>`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Filter<Map<std::slice::Iter<'_, String>,\
    \ [closure@/tmp/tmp3blxrpy8.rs:17:20: 17:37]>, [closure@/tmp/tmp3blxrpy8.rs:17:46:\
    \ 17:61]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp3blxrpy8.rs:17:72\n\
    \   |\n17 |        lst.iter().map(|x| x.to_string()).filter(|x| x.len() > 2).cloned().collect();\n\
    \   |                                                                        \
    \   ^^^^^^^ method cannot be called on `Cloned<Filter<Map<std::slice::Iter<'_,\
    \ String>, [closure@/t"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for elem in lst.iter() {\n\
    \        if elem.len() % 2 == 1 {\n            res.sort_by_key(|&x| x.to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpnqjgn1s6.rs:20:30\n\
    \   |\n20 |             res.sort_by_key(|&x| x.to_string());\n   |           \
    \                   ^^ consider giving this closure parameter the explicit type\
    \ `&T`, with the type parameters specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut total_sum\
    \ = 0;\n\n    for elem in lst {\n        if total_sum < elem.len() {\n       \
    \     sorted_list.push(elem);\n            total_sum += elem.len();\n        }\
    \ else {\n            total_sum -= elem.len();\n            sorted_list.sort_by(|a,\
    \ b| a.cmp(b).unwrap());\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmp706ffmw7.rs:26:49\n   |\n26 |          \
    \   sorted_list.sort_by(|a, b| a.cmp(b).unwrap());\n   |                     \
    \                            ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec![\n        lst\n            .iter()\n            .filter(|word|\
    \ {\n                word\n                    .chars()\n                    .filter(|c|\
    \ c.is_alphanumeric())\n                    .count() > 1\n            })\n   \
    \         .cloned()\n            .collect::<Vec<String>>()\n            .sort_by(|x,\
    \ y| x.len() < y.len())\n            .collect(),\n    ]\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvsr4zb1q.rs:28:29\n   |\n\
    28 |             .sort_by(|x, y| x.len() < y.len())\n   |                    \
    \         ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpvsr4zb1q.rs:29:14\n   |\n\
    29 |             .collect(),\n   |              ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst;\n    let mut counter = 0;\n\
    \    while let Some(elem) = sorted_list.iter().position(|x| x.len() != 0) {\n\
    \        sorted_list.swap(elem, counter);\n        counter += 1;\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp_70m9uhs.rs:20:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum(lst, lst.len())\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpofksss2c.rs:17:5\n   |\n17 |     sorted_list_sum(lst, lst.len())\n\
    \   |     ^^^^^^^^^^^^^^^ ---  --------- supplied 2 arguments\n   |     |\n  \
    \ |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpofksss2c.rs:16:4\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^\
    \ ----------------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().cloned().collect().into_iter().filter(|&word|\
    \ {\n        word.len() % 2 != 0\n    }).cloned().collect::<Vec<_>>().sort_by_key(|w|\
    \ w.to_lowercase()).collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmprzgsfup1.rs:17:25\n\
    \   |\n17 |     lst.iter().cloned().collect().into_iter().filter(|&word| {\n \
    \  |                         ^^^^^^^ cannot infer type for type parameter `B`\
    \ declared on the associated function `collect`\n   |\n   = note: type must be\
    \ known at this point\nhelp: consider specifying the type argument in the method\
    \ call\n   |\n17 |     lst.iter().cloned().collect::<B>().into_iter().filter(|&word|\
    \ {\n   |                                +++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    for el in lst {\n  \
    \      if el.length() > sorted_lst.len() {\n            sorted_lst.push(el);\n\
    \        } else {\n            if el == sorted_lst.iter().nth(sorted_lst.len()).unwrap()\
    \ {\n                sorted_lst.push(el);\n            }\n        }\n    }\n \
    \   sorted_lst.sort_by(|a, b| a.cmp(b));\n    sorted_lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp9r0cc9kt.rs:19:15\n   |\n19 |         if el.length()\
    \ > sorted_lst.len() {\n   |               ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0277]: can't compare `String`\
    \ with `&String`\n  --> /tmp/tmp9r0cc9kt.rs:22:19\n   |\n22 |             if el\
    \ == sorted_lst.iter().nth(sorted_lst.len()).unwrap() {\n   |                \
    \   ^^ no implementation for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    for el in lst\
    \ {\n        if el.length() % 2 == 1 {\n            result.push(el);\n       \
    \ }\n    }\n    result.sort();\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4r4oycwv.rs:19:15\n   |\n19 |         if el.length()\
    \ % 2 == 1 {\n   |               ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by_key(|w| w.len());\n    lst.into_iter().filter_map(|w|\
    \ {\n        if w.len() % 2 == 1 {\n            None\n        } else {\n     \
    \       Some(w)\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmph3d0ea0a.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort_by_key(|w| w.len());\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.is_empty() {\n        return vec![];\n    }\n\n\
    \    let mut sorted_lst = vec![];\n    let mut temp_lst = vec![];\n    let mut\
    \ current_lst = vec![];\n\n    for s in lst {\n        if s.len() % 2 == 1 {\n\
    \            current_lst.push(s);\n        } else {\n            temp_lst.push(current_lst);\n\
    \            current_lst.push(s);\n        }\n    }\n\n    for temp_list in temp_lst\
    \ {\n        let mut sorted_list = vec![];\n        for s in temp_list {\n   \
    \         if s.len() == 1 {\n                sorted_list.push(s);\n          \
    \  } else {\n                sorted_list.push(*s);\n            }\n        }\n\
    \        sorted_lst.push(sorted_list);\n    }\n\n    return sorted_lst;\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm2apogyp.rs:40:34\n   |\n\
    40 |                 sorted_list.push(*s);\n   |                             \
    \     ^^ expected struct `String`, found `str`\n   |\nhelp: try using a conversion\
    \ method\n   |\n40 |                 sorted_list.push((*s).to_string());\n   |\
    \                                  +  +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpm2apogyp.rs:46:12\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n46 |     return sorted_lst;\n   |\
    \            ^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n \
    \  = note: expected struct `Vec<String>`\n              found struct `Vec<Vec<String>>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut count = HashMap::new();\n\
    \    for s in lst.iter() {\n        if !count.contains_key(&s) {\n           \
    \ count.insert(s, 0);\n        }\n        count.entry(s).and_modify(|x| *x +=\
    \ 1);\n    }\n    for (key, value) in count.iter_mut() {\n        let mut it =\
    \ lst.iter();\n        while let Some(mut s) = it.next() {\n            if *s\
    \ == key {\n                if *value == *it.len() {\n                    res.push(s);\n\
    \                    break;\n                } else {\n                    *value\
    \ -= 1;\n                }\n            }\n        }\n    }\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpahbkcsdg.rs:18:21\n   |\n18 |     let mut count = HashMap::new();\n\
    \   |                     ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpahbkcsdg.rs:29:30\n   |\n\
    29 |                 if *value == *it.len() {\n   |                          \
    \    ^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpahbkcsdg.rs:38:5\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n38 |     res\n   |     ^^^ expected struct `String`, found\
    \ `&String`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0433, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut cur_len = std::collections::HashSet::new();\n\
    \    let mut cur_sum = 0;\n    for word in lst {\n        if cur_len.contains(&word)\
    \ {\n            cur_sum += word.len();\n        } else {\n            sorted_list.push(word);\n\
    \            cur_len.insert(word.clone());\n        }\n    }\n    if cur_sum <\
    \ 0 {\n        // if negative number sum, sort descending by length of words\n\
    \        sorted_list.sort_by(|a, b| b.len() - a.len());\n    } else {\n      \
    \  // if not negative number sum, sort ascending by length of words\n        sorted_list.sort_by(|a,\
    \ b| a.len() - b.len());\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz5sflt68.rs:30:36\n   |\n\
    30 |         sorted_list.sort_by(|a, b| b.len() - a.len());\n   |            \
    \                        ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz5sflt68.rs:33:36\n\
    \   |\n33 |         sorted_list.sort_by(|a, b| a.len() - b.len());\n   |     \
    \                               ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    sorted_list = lst.iter().cloned().collect();\n\
    \    sorted_list.sort_by_key(|x| x.len());\n    sorted_list.sort_by_key(|x| x.to_lowercase());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbav4jzwz.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_vec: Vec<String> = Vec::new();\n    for ele\
    \ in lst {\n        let mut new_ele = ele.to_string();\n        new_vec.push(new_ele);\n\
    \    }\n\n    new_vec.sort_by_key(|x| x.len() as usize).collect();\n    new_vec\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpht9alqez.rs:23:47\n\
    \   |\n23 |     new_vec.sort_by_key(|x| x.len() as usize).collect();\n   |   \
    \                                            ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.clone();\n    lst.sort_by(|a, b| b.cmp(&a));\n\
    \    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aaa\", \"aa\", \"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpd0m0mulb.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // get the length of each word\n    let mut lengths =\
    \ Vec::new();\n    for s in lst {\n        lengths.push(s.len());\n    }\n   \
    \ // sort by length\n    lengths.sort_by(|a, b| b.cmp(a));\n    // delete odd\
    \ lengths strings\n    for &length in lengths.iter() {\n        if length % 2\
    \ != 0 {\n            lst.delete_at(lst.iter().position(|s| s.len() == length).unwrap());\n\
    \        }\n    }\n    // sort by string\n    lst.sort_by(|a, b| a.cmp(b));\n\
    \    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `delete_at` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpdj995dmf.rs:27:17\n   |\n27 |          \
    \   lst.delete_at(lst.iter().position(|s| s.len() == length).unwrap());\n   |\
    \                 ^^^^^^^^^ method not found in `Vec<String>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    for word in lst\
    \ {\n        let len = word.chars().count();\n        if len % 2 == 1 {\n    \
    \        sorted_list.push(*word);\n        }\n    }\n    sorted_list.sort_unstable_by_key(|w|\
    \ w.chars().count());\n    sorted_list\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp17thwvn3.rs:21:30\n    |\n21  |             sorted_list.push(*word);\n\
    \    |                         ---- ^^^^^ doesn't have a size known at compile-time\n\
    \    |                         |\n    |                         required by a\
    \ bound introduced by this call\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp17thwvn3.rs:17:27\n    |\n17  |     let mut sorted_list = Vec::new();\n\
    \    |                           ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec::<T>::new`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n   --> /tmp/tmp17thwvn3.rs:17:27\n    |\n\
    17  |     let mut sorted_list = Vec::new();\n    |                           ^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec`\n\nerror[E0599]:\
    \ no method named `sort_unstable_by_key` found for struct `Vec` in the current\
    \ scope\n  --> /tmp/tmp17thwvn3.rs:24:17\n   |\n24 |     sorted_list.sort_unstable_by_key(|w|\
    \ w.chars().count());\n   |                 ^^^^^^^^^^^^^^^^^^^^ method not found\
    \ in `Vec<str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp17thwvn3.rs:25:5\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n25 |     sorted_list\n   |     ^^^^^^^^^^^ expected struct\
    \ `String`, found `str`\n   |\n   = note: expected struct `Vec<String>`\n    \
    \          found struct `Vec<str>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for elem in lst.iter()\
    \ {\n        let len: usize = elem.len();\n        if len % 2 != 0 {\n       \
    \     sorted_list.push(*elem);\n        }\n    }\n    sorted_list.sort();\n  \
    \  sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of `*elem` which is behind a shared reference\n\
    \  --> /tmp/tmpnuqby_m0.rs:21:30\n   |\n21 |             sorted_list.push(*elem);\n\
    \   |                              ^^^^^ move occurs because `*elem` has type\
    \ `String`, which does not implement the `Copy` trait\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut rev = lst.iter().rev();\n    rev.sort_unstable_by_key(|s|\
    \ s.len() as i32);\n    rev\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_unstable_by_key` found for struct `Rev`\
    \ in the current scope\n  --> /tmp/tmpaza2tw6s.rs:18:9\n   |\n18 |     rev.sort_unstable_by_key(|s|\
    \ s.len() as i32);\n   |         ^^^^^^^^^^^^^^^^^^^^ method not found in `Rev<std::slice::Iter<'_,\
    \ String>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpaza2tw6s.rs:19:5\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                   ----------- expected `Vec<String>` because\
    \ of return type\n...\n19 |     rev\n   |     ^^^ expected struct `Vec`, found\
    \ struct `Rev`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Rev<std::slice::Iter<'_, String>>`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_helper(lst, 0, lst.len())\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmpuo36azb5.rs:17:5\n   |\n17 |     sorted_list_sum_helper(lst, 0,\
    \ lst.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.into_iter().cloned().collect::<Vec<_>>();\n\
    \    let mut sorted_list = Vec::<String>::new();\n    let mut temp_sum = 0;\n\
    \    for e in lst {\n        temp_sum += e.len();\n        if temp_sum % 2 !=\
    \ 0 {\n            sorted_list.push(e);\n        }\n    }\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpinlc34e_.rs:17:35\n     |\n17   |     let mut lst =\
    \ lst.into_iter().cloned().collect::<Vec<_>>();\n     |                      \
    \             ^^^^^^ expected reference, found struct `String`\n     |\n     =\
    \ note: expected reference `&_`\n                   found struct `String`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `collect` exists\
    \ for struct `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpinlc34e_.rs:17:44\n   |\n17 |       let mut lst = lst.into_iter().cloned().collect::<Vec<_>>();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut last_index\
    \ = -1;\n    let mut current_index = -1;\n\n    for word in lst {\n        let\
    \ mut current_word = word;\n        while current_index < last_index {\n     \
    \       let mut current_word = String::from(current_word);\n            if current_word.len()\
    \ > last_index {\n                sorted_list.push(current_word);\n          \
    \      break;\n            }\n            if current_word.len() == last_index\
    \ {\n                sorted_list.sort_unstable();\n                return sorted_list;\n\
    \            }\n            match current_word.chars().zip(last_word.chars())\n\
    \                .map(|(x, y)| {\n                    if x[0].to_string().cmp(y[0].to_string())\
    \ > 0 {\n                        x.to_owned()\n                    } else {\n\
    \                        y.to_owned()\n                    }\n               \
    \ }).filter(|x| x == x).len() {\n                0 => current_word += String::from(\"\
    a\"),\n                1 => current_word += String::from(\"b\"),\n           \
    \     2 => current_word += String::from(\"c\"),\n                _ => current_word\n\
    \            }\n        }\n\n        last_index = current_word.len();\n      \
    \  current_index = -1;\n        sorted_list.push(current_word);\n    }\n\n   \
    \ sorted_list.sort_unstable();\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `last_word` in this scope\n  --> /tmp/tmpg4whplgv.rs:33:44\n\
    \   |\n33 |             match current_word.chars().zip(last_word.chars())\n  \
    \ |                                            ^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpg4whplgv.rs:18:26\n\
    \   |\n18 |     let mut last_index = -1;\n   |                          ^^ the\
    \ trait `Neg` is not implemented for `usize`\n   |\n   = help: the following other\
    \ types implement trait `Neg`:\n             &f32\n             &f64\n       \
    \      &i128\n             &i16\n             &i32\n             &i64\n      \
    \       &i8\n             &isize\n           and 8 others\n\nerror[E0277]: the\
    \ trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpg4whplgv.rs:19:29\n\
    \   |\n19 |     let mut current_index = -1;\n   |                            \
    \ ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmpg4whplgv.rs:35:24\n\
    \   |\n35 |                     if x[0].to_string().cmp(y[0].to_string()) > 0\
    \ {\n   |                        ^^^^\n\nerror[E0599]: no method named `len` found\
    \ for struct `Filter` in the current scope\n  --> /tmp/tmpg4whplgv.rs:40:39\n\
    \   |\n40 |                 }).filter(|x| x == x).len() {\n   |              \
    \                         ^^^ method not found in `Filter<Map<Zip<Chars<'_>, _>,\
    \ _>, [closure@/tmp/tmpg4whplgv.rs:40:27: 40:37]>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg4whplgv.rs:41:38\n   |\n41 |                 0 => current_word\
    \ += String::from(\"a\"),\n   |                                      ^^^^^^^^^^^^^^^^^\n\
    \   |                                      |\n   |                           \
    \           expected `&str`, found struct `String`\n   |                     \
    \                 help: consider borrowing here"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    let mut l = lst.len();\n\
    \    while l > 1 {\n        sorted_lst.push(&lst[l]);\n        l = (l - 1) / 2\n\
    \    }\n    sorted_lst.push(*lst);\n    sorted_lst.sort_by(|a, b| a.len() < b.len());\n\
    \    sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2cmow0qd.rs:23:21\n   |\n\
    23 |     sorted_lst.push(*lst);\n   |                     ^^^^ expected `&String`,\
    \ found slice\n   |\n   = note: expected reference `&String`\n               \
    \   found slice `[String]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cmow0qd.rs:24:31\n\
    \   |\n24 |     sorted_lst.sort_by(|a, b| a.len() < b.len());\n   |          \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cmow0qd.rs:25:5\n \
    \  |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |       \
    \                                  ----------- expected `Vec<String>` because\
    \ of return type\n...\n25 |     sorted_lst\n   |     ^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&String>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut s = String::new();\n\
    \    for v in lst {\n        if v.len() % 2 == 1 {\n            let n = v.len();\n\
    \            if n == 1 {\n                s.push_str(&v);\n            } else\
    \ {\n                s.push_str(&v[0..(n-1)]);\n            }\n        } else\
    \ {\n            s.push_str(&v);\n        }\n        res.push(s);\n        s =\
    \ String::new();\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aa\"]`,\n right: `[\"aa\"]`', /tmp/tmpgvf8ygoi.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = vec![];\n    for word in lst {\n       \
    \ if vec.len() == 0 {\n            vec.push(word);\n        } else if vec.len()\
    \ == 1 {\n            vec.push(vec[0]);\n        }\n        if vec.len() % 2 ==\
    \ 1 {\n            if word.len() > vec[vec.len() - 2].len() {\n              \
    \  vec.push(vec[vec.len() - 1]);\n            }\n            vec.push(word);\n\
    \        }\n    }\n    vec.sort_by(|a, b| a.len() < b.len());\n    vec\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoowcj_7k.rs:31:24\n   |\n\
    31 |     vec.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut s = String::new();\n\
    \    for ele in lst {\n        if ele == \"\" {\n            continue;\n     \
    \   }\n        let len = ele.len();\n        if len % 2 == 0 {\n            res.push(ele);\n\
    \        } else {\n            s.push(ele);\n        }\n    }\n    let mut len\
    \ = 0;\n    let mut i = 0;\n    for elem in res {\n        if elem == \"\" {\n\
    \            continue;\n        }\n        len = len + elem.len();\n        i\
    \ += 1;\n    }\n    let mut j = 0;\n    while i < len {\n        if j == i {\n\
    \            continue;\n        }\n        let mut x = s;\n        for mut i =\
    \ j + 1; i < len; i = i + 1 {\n            if i > j {\n                j += 1;\n\
    \            }\n            if i <= j {\n                x = x.clone();\n    \
    \        }\n            x = x.insert(i, \" \");\n        }\n        res.push(x);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpi8jnxc3z.rs:45:18\n  \
    \ |\n45 |         for mut i = j + 1; i < len; i = i + 1 {\n   |              \
    \    ^ help: try adding `in` here\n\nerror: expected expression, found `=`\n \
    \ --> /tmp/tmpi8jnxc3z.rs:45:19\n   |\n45 |         for mut i = j + 1; i < len;\
    \ i = i + 1 {\n   |                   ^ expected expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpi8jnxc3z.rs:27:20\n   |\n27 |             s.push(ele);\n\
    \   |                    ^^^ expected `char`, found struct `String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst.iter()\
    \ {\n        if let Ok(len) = word.length() {\n            if len % 2 != 0 {\n\
    \                sorted_list.push(*word);\n            }\n        }\n    }\n \
    \   sorted_list.sort_by_key(|a| a.to_owned());\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpjj712ioi.rs:19:31\n   |\n19 |         if let\
    \ Ok(len) = word.length() {\n   |                               ^^^^^^ help: there\
    \ is an associated function with a similar name: `len`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for v in lst.iter() {\n   \
    \     res.extend(v.iter().map(|c| c.to_owned()).filter(|c| c.len() % 2 != 0).collect());\n\
    \    }\n    res.sort();\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&String` in the\
    \ current scope\n  --> /tmp/tmpjhn_7ztf.rs:19:22\n   |\n19 |         res.extend(v.iter().map(|c|\
    \ c.to_owned()).filter(|c| c.len() % 2 != 0).collect());\n   |               \
    \       ^^^^ method not found in `&String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n19 |         res.extend(v.chars().map(|c| c.to_owned()).filter(|c|\
    \ c.len() % 2 != 0).collect());\n   |                      ~~~~~\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.into_iter().collect::<Vec<_>>();\n \
    \   lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbzcm3gp1.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for i in lst.iter() {\n   \
    \     let mut tmp_str = String::from(*i);\n        while !tmp_str.chars().all(|c|\
    \ c == b'a') {\n            tmp_str.delete_at(0);\n        }\n        res.push(tmp_str);\n\
    \    }\n    res.sort_by(|a, b| a.len().cmp(b.len()));\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6fpjicd.rs:20:45\n   |\n\
    20 |         while !tmp_str.chars().all(|c| c == b'a') {\n   |               \
    \                              ^^^^ expected `char`, found `u8`\n\nerror[E0599]:\
    \ no method named `delete_at` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpo6fpjicd.rs:21:21\n   |\n21 |             tmp_str.delete_at(0);\n\
    \   |                     ^^^^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo6fpjicd.rs:25:36\n   |\n25 |     res.sort_by(|a,\
    \ b| a.len().cmp(b.len()));\n   |                                    ^^^^^^^\n\
    \   |                                    |\n   |                             \
    \       expected `&usize`, found `usize`\n   |                               \
    \     help: consider borrowing here: `&b.len()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = vec![];\n    let mut i = 0;\n    for elem\
    \ in lst {\n        i += 1;\n        if i % 2 == 1 {\n            vec.push(elem);\n\
    \        }\n    }\n    let mut last_i = 0;\n    let mut last_val = 0;\n    for\
    \ elem in lst {\n        if elem != \"\" {\n            if last_val == 0 {\n \
    \               last_val = *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap();\n\
    \            }\n            if *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap()\
    \ > last_val {\n                vec.push(elem.to_string());\n                last_val\
    \ = *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap();\n         \
    \   }\n        }\n        last_i = i;\n    }\n    vec\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&[u8]` in the\
    \ current scope\n  --> /tmp/tmpwwfhiq_8.rs:30:57\n   |\n30 |                 last_val\
    \ = *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap();\n   |     \
    \                                                    ^^^^^^ help: there is an\
    \ associated function with a similar name: `swap`\n\nerror[E0599]: no method named\
    \ `unwrap` found for reference `&[u8]` in the current scope\n  --> /tmp/tmpwwfhiq_8.rs:32:45\n\
    \   |\n32 |             if *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap()\
    \ > last_val {\n   |                                             ^^^^^^ help:\
    \ there is an associated function with a similar name: `swap`\n\nerror[E0599]:\
    \ no method named `unwrap` found for reference `&[u8]` in the current scope\n\
    \  --> /tmp/tmpwwfhiq_8.rs:34:57\n   |\n34 |                 last_val = *elem.to_string().as_bytes().unwrap().parse::<u32>().unwrap();\n\
    \   |                                                         ^^^^^^ help: there\
    \ is an associated function with a similar name: `swap`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum = 0;\n    let mut s = String::new();\n   \
    \ for word in lst.into_iter().filter(|word| word.len() % 2 == 0) {\n        sum\
    \ += word.chars().filter(|c| c.is_ascii_alphanumeric()).sum();\n        s += word;\n\
    \    }\n    let mut result = vec![String::from(\"zz\")];\n    let mut i = 0;\n\
    \    while i < lst.len() {\n        if sum == lst.len() - 1 {\n            result.push((&lst.as_slice().swap_remove(i)).to_string());\n\
    \            i += 1;\n        } else {\n            while (sum > lst.len() - 1\
    \ && i < lst.len() && sum > 0) {\n                sum += lst.len() - 1;\n    \
    \            result.push((&lst.as_slice().swap_remove(i)).to_string());\n    \
    \            i += 1;\n            }\n            if sum < lst.len() - 1 {\n  \
    \              result.push((&lst.as_slice().swap_remove(i)).to_string());\n  \
    \          }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `while` condition\n  --> /tmp/tmpge_nku5r.rs:30:19\n\
    \   |\n30 |             while (sum > lst.len() - 1 && i < lst.len() && sum > 0)\
    \ {\n   |                   ^                                               ^\n\
    \   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n30 -             while (sum > lst.len() - 1 && i < lst.len() && sum > 0)\
    \ {\n30 +             while sum > lst.len() - 1 && i < lst.len() && sum > 0 {\n\
    \   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpge_nku5r.rs:21:14\n  \
    \ |\n21 |         s += word;\n   |              ^^^^\n   |              |\n  \
    \ |              expected `&str`, found struct `String`\n   |              help:\
    \ consider borrowing here: `&word`\n\nerror[E0599]: no method named `swap_remove`\
    \ found for reference `&[String]` in the current scope\n  --> /tmp/tmpge_nku5r.rs:27:42\n\
    \   |\n27 |             result.push((&lst.as_slice().swap_remove(i)).to_string());\n\
    \   |                                          ^^^^^^^^^^^ method not found in\
    \ `&[String]`\n\nerror[E0599]: no method named `swap_remove` found for reference\
    \ `&[String]` in the current scope\n  --> /tmp/tmpge_nku5r.rs:32:46\n   |\n32\
    \ |                 result.push((&lst.as_slice().swap_remove(i)).to_string());\n\
    \   |                                              ^^^^^^^^^^^ method not found\
    \ in `&[String]`\n\nerror[E0599]: no method named `swap_remove` found for reference\
    \ `&[String]` in the current scope\n  --> /tmp/tmpge_nku5r.rs:36:46\n   |\n36\
    \ |                 result.push((&lst.as_slice().swap_remove(i)).to_string());\n\
    \   |                                              ^^^^^^^^^^^ method not found\
    \ in `&[String]`\n\nerror: aborting due to 4 previous errors; 1 warning emitted\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = Vec::new();\n    for i in lst.iter() {\n \
    \       if i.len() % 2 != 0 {\n            s.push(i);\n        }\n    }\n    let\
    \ mut sort_keys = Vec::new();\n    for i in s.iter() {\n        if i.len() ==\
    \ 1 {\n            sort_keys.push(i);\n            continue;\n        }\n    \
    \    let mut j = 0;\n        let mut pos = 0;\n        while j < sort_keys.len()\
    \ {\n            if sort_keys[j].len() < i.len() {\n                break;\n \
    \           }\n            if sort_keys[j].len() == i.len() {\n              \
    \  sort_keys.insert(pos, sort_keys[j]);\n                j += 1;\n           \
    \     continue;\n            }\n            pos += 1;\n        }\n        if j\
    \ == sort_keys.len() {\n            sort_keys.push(i);\n        }\n    }\n   \
    \ sort_keys.sort_by(|a, b| a.len() < b.len());\n    sort_keys\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ccuvbap.rs:46:30\n   |\n\
    46 |     sort_keys.sort_by(|a, b| a.len() < b.len());\n   |                  \
    \            ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_ccuvbap.rs:47:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n47 |     sort_keys\n   |     ^^^^^^^^^ expected struct `String`, found `&&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for x in lst.iter() {\n   \
    \     res.push_back(x);\n    }\n    res\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_back` found for struct `Vec<_>` in\
    \ the current scope\n  --> /tmp/tmp328g2j93.rs:19:13\n   |\n19 |         res.push_back(x);\n\
    \   |             ^^^^^^^^^ method not found in `Vec<_>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = vec![];\n    let mut sorted_vec =\n    \
    \    vec![vec![], vec![0], vec![1], vec![2], vec![3], vec![4]];\n    for elem\
    \ in lst {\n        if vec.len() < elem.len() {\n            vec.push(elem);\n\
    \        } else {\n            for (i, w) in vec.iter().enumerate() {\n      \
    \          if *w > elem[i] {\n                    vec.swap(i, 4);\n          \
    \          sorted_vec.swap(i, 4);\n                    break;\n              \
    \  }\n                if *w < elem[i] {\n                    vec.swap(i, i);\n\
    \                    sorted_vec.swap(i, i);\n                    break;\n    \
    \            }\n            }\n        }\n    }\n    for w in sorted_vec {\n \
    \       vec.push(w);\n    }\n    return vec\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl2yz1zkp.rs:25:25\n\
    \   |\n25 |                 if *w > elem[i] {\n   |                         ^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl2yz1zkp.rs:30:25\n   |\n30 |                 if *w < elem[i] {\n\
    \   |                         ^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl2yz1zkp.rs:39:18\n\
    \   |\n39 |         vec.push(w);\n   |                  ^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    for word in lst\
    \ {\n        if sorted_list.iter().any(|s| s.to_vec()[0].len() < word.len()) {\n\
    \            sorted_list.push(word);\n        }\n    }\n    sorted_list.sort_by(|x,\
    \ y| x.len() < y.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpg25q_77x.rs:19:36\n\
    \   |\n19 |         if sorted_list.iter().any(|s| s.to_vec()[0].len() < word.len())\
    \ {\n   |                                    ^ consider giving this closure parameter\
    \ the explicit type `&T`, where the type parameter `T` is specified\n   |\n  \
    \ = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    for i in lst.into_iter()\
    \ {\n        sorted_lst.push(String::from(\"\"));\n    }\n    sorted_lst.sort_by_key(|&a|\
    \ a.len()).into_iter().for_each(|x| x.push_str(\" \"));\n    for i in lst.into_iter()\
    \ {\n        sorted_lst.push(i);\n    }\n    sorted_lst\n}\n\nfn main() {\n  \
    \  let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpf9z67j14.rs:21:42\n\
    \   |\n21 |     sorted_lst.sort_by_key(|&a| a.len()).into_iter().for_each(|x|\
    \ x.push_str(\" \"));\n   |                                          ^^^^^^^^^\
    \ `()` is not an iterator\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `(): Iterator`\n           which is required by `():\
    \ IntoIterator`\n           `&(): Iterator`\n           which is required by `&():\
    \ IntoIterator`\n           `&mut (): Iterator`\n           which is required\
    \ by `&mut (): IntoIterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Write your code here.\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpibq_bn1e.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().cloned().filter_map(|x| if x.len() % 2 == 0\
    \ { Some(x) } else { None })\n        .sorted().collect()\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `FilterMap` in\
    \ the current scope\n  --> /tmp/tmpy34r67k5.rs:18:10\n   |\n18 |         .sorted().collect()\n\
    \   |          ^^^^^^ method not found in `FilterMap<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmpy34r67k5.rs:17:36: 17:85]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    let mut cur = String::new();\n\
    \    for elem in lst.into_iter() {\n        if elem.len() % 2 != 0 {\n       \
    \     cur += elem;\n        } else {\n            res.push(cur);\n           \
    \ cur = elem;\n        }\n    }\n    res.push(cur);\n    res.sort();\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgok4ps34.rs:21:20\n   |\n\
    21 |             cur += elem;\n   |                    ^^^^\n   |            \
    \        |\n   |                    expected `&str`, found struct `String`\n \
    \  |                    help: consider borrowing here: `&elem`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for i in lst {\n      \
    \  if let Ok(s) = i.as_bytes() {\n            res.push(String::from_utf8(s)?);\n\
    \        }\n    }\n    if let Some(first_string) = res.first() {\n        let\
    \ mut cur_sum = 0;\n        for s in res {\n            if let Ok(bytes) = s.as_bytes()\
    \ {\n                let len = bytes.len() as u32;\n                cur_sum +=\
    \ len;\n            }\n        }\n        res.sort();\n        if cur_sum < first_string.len()\
    \ {\n            res.reverse();\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8hg2i68m.rs:19:16\n   |\n\
    19 |         if let Ok(s) = i.as_bytes() {\n   |                ^^^^^   ------------\
    \ this expression has type `&[u8]`\n   |                |\n   |              \
    \  expected slice `[u8]`, found enum `Result`\n   |\n   = note: expected slice\
    \ `[u8]`\n               found enum `Result<_, _>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8hg2i68m.rs:20:40\n   |\n20 |             res.push(String::from_utf8(s)?);\n\
    \   |                                        ^ expected struct `Vec`, found reference\n\
    \   |\n   = note: expected struct `Vec<u8>`\n           found reference `&_`\n\
    \nerror[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmp8hg2i68m.rs:20:42\n\
    \   |\n16 | / fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n17 | |  \
    \   let mut res = Vec::new();\n18 | |     for i in lst {\n19 | |         if let\
    \ Ok(s) = i.as_bytes() {\n20 | |             res.push(String::from_utf8(s)?);\n\
    \   | |                                          ^ cannot use the `?` operator\
    \ in a function that returns `Vec<String>`\n...  |\n36 | |     res\n37 | | }\n\
    \   | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<Result<Infallible, FromUtf8Error>>` is not\
    \ implemented for `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8hg2i68m.rs:26:20\n\
    \   |\n26 |             if let Ok(bytes) = s.as_bytes() {\n   |              \
    \      ^^^^^^^^^   ------------ this expression has type `&[u8]`\n   |       \
    \             |\n   |                    expected slice `[u8]`, found enum `Result`\n\
    \   |\n   = note: expected slice `[u8]`\n               found enum `Result<_,\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sort_impl(lst, |word| word.len())\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sort_impl` in this scope\n\
    \  --> /tmp/tmpk1h15jg5.rs:17:5\n   |\n17 |     sorted_list_sort_impl(lst, |word|\
    \ word.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut counter = 0;\n    let mut res = Vec::<String>::new();\n\
    \    for elem in lst.into_iter() {\n        let len = elem.len();\n        if\
    \ counter % 2 != 0 {\n            res.push(elem);\n        } else {\n        \
    \    let elem = elem.to_lowercase();\n            if res.iter().any(|x| x == elem)\
    \ {\n                continue;\n            }\n            res.push(elem);\n \
    \       }\n        counter += 1;\n    }\n    res.sort();\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpakd9lqbt.rs:25:37\n\
    \   |\n25 |             if res.iter().any(|x| x == elem) {\n   |             \
    \                        ^^ no implementation for `&String == String`\n   |\n\
    \   = help: the trait `PartialEq<String>` is not implemented for `&String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_nalo_1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![String::new(); lst.length()];\n\
    \    for word in lst {\n        if word.len() > sorted_lst.len() {\n         \
    \   for x in 0..sorted_lst.len() {\n                if sorted_lst[x] == String::new()\
    \ {\n                    sorted_lst[x] = word;\n                }\n          \
    \  }\n        }\n    }\n    sorted_lst.sort();\n    sorted_lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmp6dsw791k.rs:17:50\n   |\n17 |     let mut sorted_lst\
    \ = vec![String::new(); lst.length()];\n   |                                 \
    \                 ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()));\n    sorted_list.sort_by(|a, b| a.cmp(b));\n    sorted_list.clone()\
    \ + lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpmosv1fw7.rs:18:26\n\
    \   |\n18 |     sorted_list.sort_by(|a, b| a.len().cmp(&b.len()));\n   |     \
    \                     ^ consider giving this closure parameter the explicit type\
    \ `&T`, where the type parameter `T` is specified\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by(|a, b| a.len() < b.len());\n    lst.sort_by(|a,\
    \ b| a.len() == b.len() ? a.cmp(&b).unwrap() : a.len() < b.len());\n    lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmpwor8by2g.rs:18:45\n\
    \   |\n18 |     lst.sort_by(|a, b| a.len() == b.len() ? a.cmp(&b).unwrap() : a.len()\
    \ < b.len());\n   |                                             ^^^^^^^^^^^^^^^^^^----\n\
    \   |                                                               |\n   |  \
    \                                                             help: remove the\
    \ type ascription\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator,\
    \ found `a`\n  --> /tmp/tmpwor8by2g.rs:18:45\n   |\n18 |     lst.sort_by(|a, b|\
    \ a.len() == b.len() ? a.cmp(&b).unwrap() : a.len() < b.len());\n   |        \
    \                                    -^ expected one of `)`, `,`, `.`, `?`, or\
    \ an operator\n   |                                            |\n   |       \
    \                                     help: missing `,`\n\nerror[E0425]: cannot\
    \ find value `a` in this scope\n  --> /tmp/tmpwor8by2g.rs:18:45\n   |\n18 |  \
    \   lst.sort_by(|a, b| a.len() == b.len() ? a.cmp(&b).unwrap() : a.len() < b.len());\n\
    \   |                                             ^ expecting a type here because\
    \ of type ascription\n\nerror[E0425]: cannot find value `b` in this scope\n  -->\
    \ /tmp/tmpwor8by2g.rs:18:52\n   |\n18 |     lst.sort_by(|a, b| a.len() == b.len()\
    \ ? a.cmp(&b).unwrap() : a.len() < b.len());\n   |                           \
    \                         ^ expecting a type here because of type ascription\n\
    \nerror[E0412]: cannot find type `a` in this scope\n  --> /tmp/tmpwor8by2g.rs:18:66\n\
    \   |\n18 |     lst.sort_by(|a, b| a.len() == b.len() ? a.cmp(&b).unwrap() : a.len()\
    \ < b.len());\n   |                                                          \
    \        ^ expecting a type here because of type ascription\n\nerror[E0425]: cannot\
    \ find value `b` in this scope\n  --> /tmp/tmpwor8by2g.rs:18:76\n   |\n18 |  \
    \   lst.sort_by(|a, b| a.len() == b.len() ? a.cmp(&b).unwrap() : a.len() < b.len());\n\
    \   |                                                                        \
    \    ^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwor8by2g.rs:17:24\n\
    \   |\n17"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum(lst, SortBy::Length);\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `SortBy`\n  -->\
    \ /tmp/tmpexvwxcit.rs:17:26\n   |\n17 |     sorted_list_sum(lst, SortBy::Length);\n\
    \   |                          ^^^^^^ use of undeclared type `SortBy`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpexvwxcit.rs:17:5\n\
    \   |\n17 |     sorted_list_sum(lst, SortBy::Length);\n   |     ^^^^^^^^^^^^^^^\
    \ ---  -------------- supplied 2 arguments\n   |     |\n   |     expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpexvwxcit.rs:16:4\n   |\n16 |\
    \ fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^\
    \ ----------------\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpexvwxcit.rs:16:41\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    17 |     sorted_list_sum(lst, SortBy::Length);\n   |                         \
    \                - help: remove this semicolon\n   |\n   = note: expected struct\
    \ `Vec<String>`\n           found unit type `()`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.is_empty() {\n        return Vec::new();\n    }\n\
    \n    let mut result = Vec::new();\n    let mut sum = 0;\n    let mut last_index\
    \ = 0;\n    let mut last_word = None;\n\n    for word in lst {\n        if word.len()\
    \ % 2 == 1 {\n            sum += word.len();\n            last_index = result.len()\
    \ - 1;\n            last_word = Some(word);\n        }\n    }\n\n    for word\
    \ in lst {\n        if word == last_word {\n            sum += word.len();\n \
    \       } else {\n            result.push(word.to_owned());\n            sum +=\
    \ word.len();\n        }\n    }\n\n    if sum % 2 == 0 {\n        result.push(last_word.clone());\n\
    \    }\n\n    result.sort_by(|a, b| a.cmp(b));\n\n    result\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `Option<String>`\n  --> /tmp/tmpndzh56wf.rs:35:17\n\
    \   |\n35 |         if word == last_word {\n   |                 ^^ no implementation\
    \ for `String == Option<String>`\n   |\n   = help: the trait `PartialEq<Option<String>>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpndzh56wf.rs:44:21\n\
    \   |\n44 |         result.push(last_word.clone());\n   |                    \
    \ ^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   =\
    \ note: expected struct `String`\n                found enum `Option<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    sorted_list.extend(lst);\n\
    \    sorted_list.sort_by(|a, b| a.len().cmp(b.len()));\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoql2ohnz.rs:19:44\n   |\n\
    19 |     sorted_list.sort_by(|a, b| a.len().cmp(b.len()));\n   |             \
    \                               ^^^^^^^\n   |                                \
    \            |\n   |                                            expected `&usize`,\
    \ found `usize`\n   |                                            help: consider\
    \ borrowing here: `&b.len()`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut temp_string\
    \ = String::from(\"\");\n    let mut is_sorted = vec![false; lst.len()];\n\n \
    \   for word in lst {\n        // if sorted is false and word is less than temp_string\n\
    \        // then set it to word and mark it as sorted\n        if !is_sorted[lst.iter().position(|x|\
    \ *x == word).unwrap()] &&\n            (word.len() < temp_string.len()) && word.len()\
    \ > 0 {\n            temp_string = word;\n            is_sorted[lst.iter().position(|x|\
    \ *x == word).unwrap()] = true;\n        }\n\n        // if sorted is true and\
    \ word is less than temp_string\n        // then add it to sorted_list and reset\
    \ temp_string\n        else if is_sorted[lst.iter().position(|x| *x == word).unwrap()]\
    \ &&\n            (word.len() < temp_string.len()) && word.len() > 0 {\n     \
    \       sorted_list.push(word);\n            temp_string = word;\n        }\n\n\
    \        // if sorted is true and word is greater than temp_string\n        //\
    \ then add it to sorted_list and set temp_string to word\n        else if is_sorted[lst.iter().position(|x|\
    \ *x == word).unwrap()] &&\n            (word.len() > temp_string.len()) && word.len()\
    \ > 0 {\n            sorted_list.push(word);\n            temp_string = word;\n\
    \        }\n\n        // if sorted is false and word is greater than temp_string\n\
    \        // then add it to sorted_list and set temp_string to word\n        //\
    \ and mark it as sorted\n        else if !is_sorted[lst.iter().position(|x| *x\
    \ == word).unwrap()] &&\n            (word.len() > temp_string.len()) && word.len()\
    \ > 0 {\n            sorted_list.push(word);\n            temp_string = word;\n\
    \            is_sorted[lst.iter().position(|x| *x == word).unwrap()] = true;\n\
    \        }\n    }\n\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp8huz2lwd.rs:24:23\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n21  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |         if !is_sorted[lst.iter().position(|x| *x == word).unwrap()]\
    \ &&\n    |                       ^^^^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `lst`\n    = note: borrow occurs due to deref coercion to `[String]`\nhelp:\
    \ consider iterating over a slice of the `Vec<String>`'s content to avoid moving\
    \ into the `for` loop\n    |\n21  |     for word in &lst {\n    |            \
    \     +\n\nerror[E0382]: borrow of moved value: `word`\n  --> /tmp/tmp8huz2lwd.rs:27:43\n\
    \   |\n21 |     for word in lst {\n   |         ---- move occurs because `word`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n26 |    \
    \         temp_string = word;\n   |                           ---- value moved\
    \ here\n27 |             is_sorted[lst.iter().position(|x| *x == word).unwrap()]\
    \ = true;\n   |                                           ^^^       ---- borrow\
    \ occurs due to use in closure\n   |                                         \
    \  |\n   |                                           value borrowed here after\
    \ move\n\nerror[E0382]: use of moved value: `word`\n  --> /tmp/tmp8huz2lwd.rs:35:27\n\
    \   |\n21 |     for word in lst {\n   |         ---- move occurs because `word`\
    \ has type `String`, which does not implement the `Copy` trait\n...\n34 |    \
    \         sorted_list.push(word);\n   |                              ---- value\
    \ moved here\n35 |             temp_string = word;\n   |                     \
    \      ^^^^ value used here after move\n\nerror[E0382]: use of moved value: `word`\n\
    \  --> /tmp/tmp8huz2lwd.rs:43:27\n   |\n21 |     for word in lst {\n   |     \
    \    ---- move occurs because `word` has type `String`, which does n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for (index, item) in\
    \ lst.iter().enumerate() {\n        let item_string = item.to_string();\n    \
    \    if index % 2 != 0 {\n            sorted_list.push(item_string);\n       \
    \ }\n    }\n    sorted_list.sort();\n    sorted_list\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\"]`,\n right: `[\"aa\"]`', /tmp/tmpa1njqv18.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut word_counts\
    \ = vec![];\n    for s in lst {\n        if word_counts[s.len()].is_some() {\n\
    \            word_counts[s.len()] = Some(word_counts[s.len()].unwrap() + 1);\n\
    \        } else {\n            word_counts[s.len()] = Some(1);\n        }\n  \
    \  }\n\n    for n in word_counts {\n        if let Some(count) = n {\n       \
    \     sorted_list.push(String::from(n.unwrap()));\n            if count > 1 {\n\
    \                for _ in 0..(count - 1) {\n                    sorted_list.push(String::from(String::new()));\n\
    \                }\n            }\n        }\n    }\n    sorted_list.sort_by_key(|&x|\
    \ x.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp3kcmyyze.rs:20:12\n\
    \   |\n18 |     let mut word_counts = vec![];\n   |         --------------- consider\
    \ giving `word_counts` the explicit type `Vec<T>`, with the type parameters specified\n\
    19 |     for s in lst {\n20 |         if word_counts[s.len()].is_some() {\n  \
    \ |            ^^^^^^^^^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    sorted_list.push(String::from(\"\
    \"));\n    for word in lst {\n        if sorted_list.len() % 2 != 0 {\n      \
    \      sorted_list.push(word);\n        } else {\n            let mut new_word\
    \ = word;\n            sorted_list.sort_by(|a, b| a.cmp(b));\n            sorted_list.push(new_word);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprehq8v2j.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().map(|x| x.to_string()).filter(|x| x.is_empty()).map(|x|\
    \ x.to_string()).collect::<Vec<String>>().sort();\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbdluhbs5.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    sorted_list_sum_recursive(&mut\
    \ res, lst);\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_recursive` in this\
    \ scope\n  --> /tmp/tmphek5w6fm.rs:18:5\n   |\n18 |     sorted_list_sum_recursive(&mut\
    \ res, lst);\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by_key(|x| x.chars().count()).collect()\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpnttdn3f2.rs:17:44\n\
    \   |\n17 |     lst.sort_by_key(|x| x.chars().count()).collect()\n   |       \
    \                                     ^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut counter = 1;\n    for\
    \ str in lst {\n        if str.len() % 2 == 1 {\n            continue;\n     \
    \   }\n        res.push(str);\n        counter += 1;\n        if counter % 2 ==\
    \ 0 {\n            continue;\n        }\n        res.sort();\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"AI\", \"school\", \"asdf\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`',\
    \ /tmp/tmpwd44thfb.rs:36:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst_sum: Vec<String> = Vec::new();\n  \
    \  let mut prev_sum = 0;\n    for ele in lst {\n        let cur_sum = prev_sum\
    \ + elem.len();\n        if cur_sum % 2 == 1 {\n            sorted_lst_sum.push(ele);\n\
    \        } else {\n            prev_sum = cur_sum;\n        }\n    }\n    sorted_lst_sum.sort_by_key(|ele|\
    \ ele.len());\n    sorted_lst_sum\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `elem` in this scope\n  --> /tmp/tmp5g46l5ty.rs:20:34\n\
    \   |\n20 |         let cur_sum = prev_sum + elem.len();\n   |               \
    \                   ^^^^ help: a local variable with a similar name exists: `ele`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Your code here\n    let mut sorted_lst = Vec::new();\n\
    \    let mut sorted_count = Vec::new();\n    for ele in lst {\n        if sorted_count.len()\
    \ == 0 {\n            sorted_lst.push(ele);\n            sorted_count.push(1);\n\
    \        } else {\n            if sorted_count[sorted_count.len() - 1] < ele.len()\
    \ {\n                sorted_lst.push(ele);\n                sorted_count.push(1);\n\
    \            } else {\n                sorted_count[sorted_count.len() - 1] +=\
    \ 1;\n            }\n        }\n    }\n    return sorted_lst;\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `sorted_count` as immutable because it is also\
    \ borrowed as mutable\n  --> /tmp/tmpgekjd_en.rs:29:30\n   |\n29 |           \
    \      sorted_count[sorted_count.len() - 1] += 1;\n   |                 -------------^^^^^^^^^^^^^^^^^^-----\n\
    \   |                 |            |\n   |                 |            immutable\
    \ borrow occurs here\n   |                 mutable borrow occurs here\n   |  \
    \               mutable borrow later used here\n   |\nhelp: try adding a local\
    \ storing this...\n  --> /tmp/tmpgekjd_en.rs:29:30\n   |\n29 |               \
    \  sorted_count[sorted_count.len() - 1] += 1;\n   |                          \
    \    ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> /tmp/tmpgekjd_en.rs:29:17\n\
    \   |\n29 |                 sorted_count[sorted_count.len() - 1] += 1;\n   | \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for string in lst.iter()\
    \ {\n        if sorted_list.iter().all(|word|\n            word.len() > string.len())\n\
    \        {\n            sorted_list.sort_by(|a, b| a.len() < b.len());\n     \
    \   }\n        else {\n            sorted_list.push(string);\n        }\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmp55cbresz.rs:19:36\n\
    \   |\n19 |         if sorted_list.iter().all(|word|\n   |                   \
    \                 ^^^^ consider giving this closure parameter the explicit type\
    \ `&T`, where the type parameter `T` is specified\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![String::from(\"\")];\n    for elem\
    \ in lst {\n        if elem.len() % 2 != 0 {\n            let mut new_res = vec![String::from(\"\
    \")];\n            for elem in res {\n                new_res.push(elem);\n  \
    \          }\n            res = new_res;\n        }\n        res.push(elem);\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp2sol1zel.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sl = lst.clone();\n    sl.sort_by_key(|&s| s.len()\
    \ as i32);\n    sl\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n \
    \   assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpb2n2lws_.rs:18:21\n\
    \   |\n18 |     sl.sort_by_key(|&s| s.len() as i32);\n   |                   \
    \  ^-\n   |                     ||\n   |                     |data moved here\n\
    \   |                     |move occurs because `s` has type `String`, which does\
    \ not implement the `Copy` trait\n   |                     help: consider removing\
    \ the `&`: `s`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut word_count\
    \ = Vec::new();\n    for word in lst {\n        word_count.push(word.len());\n\
    \    }\n    word_count.sort_by_key(|w| w.len());\n    sorted_list.push(word_count.pop().unwrap());\n\
    \    sorted_list.extend_from_slice(word_count.iter().map(|&w| w.to_string()).collect::<Vec<_>>());\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for reference `&usize` in the\
    \ current scope\n  --> /tmp/tmpxuu_upcu.rs:22:34\n   |\n22 |     word_count.sort_by_key(|w|\
    \ w.len());\n   |                                  ^^^ method not found in `&usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxuu_upcu.rs:24:35\n   |\n24 |\
    \     sorted_list.extend_from_slice(word_count.iter().map(|&w| w.to_string()).collect::<Vec<_>>());\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&[usize]`, found struct `Vec`\n   |\n   = note: expected reference\
    \ `&[usize]`\n                 found struct `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxuu_upcu.rs:25:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                         ----------- expected\
    \ `Vec<String>` because of return type\n...\n25 |     sorted_list\n   |     ^^^^^^^^^^^\
    \ expected struct `String`, found `usize`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut odd_num\
    \ = 0;\n    for word in lst {\n        if word.len() % 2 == 1 {\n            odd_num\
    \ += 1;\n        }\n    }\n    for word in lst {\n        if word.len() % 2 ==\
    \ 1 {\n            if odd_num == 0 {\n                result.push(word);\n   \
    \         } else {\n                result.sort_by(|a, b| a.cmp(b));\n       \
    \         odd_num = 0;\n                result.push(result.remove(0));\n     \
    \       }\n        } else {\n            if odd_num > 0 {\n                result.push(word);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `lst`\n   --> /tmp/tmpf2ga18e_.rs:24:17\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n...\n19  |     for word in lst {\n    |\
    \                 --- `lst` moved due to this implicit call to `.into_iter()`\n\
    ...\n24  |     for word in lst {\n    |                 ^^^ value used here after\
    \ move\n    |\nnote: this function takes ownership of the receiver `self`, which\
    \ moves `lst`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n19  |     for word in &lst {\n \
    \   |                 +\n\nerror[E0499]: cannot borrow `result` as mutable more\
    \ than once at a time\n  --> /tmp/tmpf2ga18e_.rs:31:29\n   |\n31 |           \
    \      result.push(result.remove(0));\n   |                 ------------^^^^^^^^^^^^^^^^-\n\
    \   |                 |      |    |\n   |                 |      |    second mutable\
    \ borrow occurs here\n   |                 |      first borrow later used by call\n\
    \   |                 first mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmpf2ga18e_.rs:31:29\n   |\n31\
    \ |                 result.push(result.remove(0));\n   |                     \
    \        ^^^^^^^^^^^^^^^^\nhelp: ...and then using that local as the argument\
    \ to this call\n  --> /tmp/tmpf2ga18e_.rs:31:17\n   |\n31 |                 result.push(result.remove(0));\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0382, E0499.\n\
    For more information about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut a = vec![];\n    let mut b = vec![];\n    for\
    \ i in lst.iter() {\n        if a.len() == 0 {\n            a.push(i);\n     \
    \   } else {\n            if i.len() < b[b.len() - 1].len() {\n              \
    \  b.push(i);\n            } else {\n                let mut j = b.len() - 1;\n\
    \                while (j >= 0) && (b[j].len() < i.len()) {\n                \
    \    b.swap(j, j - 1);\n                    j -= 1;\n                }\n     \
    \           b.push(i);\n            }\n        }\n    }\n    for i in b.iter()\
    \ {\n        a.push(i);\n    }\n    a\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpuotph56y.rs:23:26\n\
    \   |\n18 |     let mut b = vec![];\n   |         ----- consider giving `b` the\
    \ explicit type `Vec<T>`, with the type parameters specified\n...\n23 |      \
    \       if i.len() < b[b.len() - 1].len() {\n   |                          ^^^^^^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuotph56y.rs:38:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n38 |     a\n\
    \   |     ^ expected struct `String`, found `&String`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<&String>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0308.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for word in lst {\n\
    \        sorted_list.push(word);\n    }\n    sorted_list\n        .sort_by(|x,\
    \ y| x.len() < y.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpaf_41hj5.rs:22:25\n   |\n\
    22 |         .sort_by(|x, y| x.len() < y.len());\n   |                       \
    \  ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for i in lst.iter().cloned().sort(|&a,\
    \ &b| b.len() - a.len()) {\n        if res.iter().any(|&x| x == i).unwrap_or(false)\
    \ {\n            res.push(i);\n        }\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpzv51hlwv.rs:18:34\n   |\n18 |     for i in lst.iter().cloned().sort(|&a,\
    \ &b| b.len() - a.len()) {\n   |                                  ^^^^ method\
    \ not found in `Cloned<std::slice::Iter<'_, String>>`\n\nerror[E0599]: no method\
    \ named `unwrap_or` found for type `bool` in the current scope\n  --> /tmp/tmpzv51hlwv.rs:19:40\n\
    \   |\n19 |         if res.iter().any(|&x| x == i).unwrap_or(false) {\n   |  \
    \                                      ^^^^^^^^^ method not found in `bool`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec!(lst.iter().filter_map(|s| {\n        let mut x =\
    \ String::new();\n        let len = s.len();\n        let mut y = String::new();\n\
    \        let mut i = 1;\n        while i <= len {\n            x.push_str(&s[i..i\
    \ + 1]);\n            i += 2;\n        }\n        y.push_str(&x);\n        Some(y)\n\
    \    }).collect())\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n \
    \   assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''byte index 2 is out of bounds of `a`'', library/core/src/str/mod.rs:107:9

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_nalo_1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut sum = 0;\n    let\
    \ mut i = 0;\n    while i < lst.len() {\n        if sum == 0 {\n            sum\
    \ = 1;\n            result.push(*lst[i..]);\n            i += 1;\n        } else\
    \ {\n            let mut j = i;\n            while j < lst.len() && sum != 0 {\n\
    \                sum += *lst[j].chars().filter(|c| c < 'A' || (c > 'Z' && c <\
    \ 'a' && c != 'z'))\n                    .count();\n                j += 1;\n\
    \            }\n            if sum == 0 {\n                result.push(*lst[i..]);\n\
    \                i += 1;\n            } else {\n                sum = sum - 1;\n\
    \                i += 1;\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `[String]` cannot be dereferenced\n  --> /tmp/tmp_af5bj47.rs:23:25\n\
    \   |\n23 |             result.push(*lst[i..]);\n   |                        \
    \ ^^^^^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_af5bj47.rs:28:55\n\
    \   |\n28 |                 sum += *lst[j].chars().filter(|c| c < 'A' || (c >\
    \ 'Z' && c < 'a' && c != 'z'))\n   |                                         \
    \              ^^^\n   |                                                     \
    \  |\n   |                                                       expected `&char`,\
    \ found `char`\n   |                                                       help:\
    \ consider borrowing here: `&'A'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_af5bj47.rs:28:67\n\
    \   |\n28 |                 sum += *lst[j].chars().filter(|c| c < 'A' || (c >\
    \ 'Z' && c < 'a' && c != 'z'))\n   |                                         \
    \                          ^^^\n   |                                         \
    \                          |\n   |                                           \
    \                        expected `&char`, found `char`\n   |                \
    \                                                   help: consider borrowing here:\
    \ `&'Z'`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_af5bj47.rs:28:78\n\
    \   |\n28 |                 sum += *lst[j].chars().filter(|c| c < 'A' || (c >\
    \ 'Z' && c < 'a' && c != 'z'))\n   |                                         \
    \                                     ^^^\n   |                              \
    \                                                |\n   |                     \
    \                                                         expected `&char`, found\
    \ `char`\n   |                                                               \
    \               help: consider borrowing here: `&'a'`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp_af5bj47.rs:28:87\n   |\n28 |           \
    \      sum += *lst[j].chars().filter(|c| c < 'A' || (c > 'Z' && c < 'a' && c !=\
    \ 'z'))\n   |                                                                \
    \                       ^^ no implementation "
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut counter: usize = 0;\n\n    let mut res = vec![];\n\
    \n    for e in lst.iter() {\n        if counter == 0 {\n            counter =\
    \ 1;\n            res.push(e);\n        } else {\n            if counter == e.len()\
    \ {\n                counter += 1;\n            } else {\n                counter\
    \ += 1;\n                res.push(e);\n            }\n        }\n    }\n\n   \
    \ return res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpthhxyppf.rs:35:12\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n35 |     return res\n   |            ^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `Vec<&String>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum = vec![];\n    sum.extend(lst.into_iter().filter(|&s|\
    \ s.len() % 2 != 0).collect::<Vec<String>>());\n    sum.sort_by(|a, b| a.cmp(b));\n\
    \    sum\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmp69m0oqz2.rs:18:40\n\
    \   |\n18 |     sum.extend(lst.into_iter().filter(|&s| s.len() % 2 != 0).collect::<Vec<String>>());\n\
    \   |                                        ^-\n   |                        \
    \                ||\n   |                                        |data moved here\n\
    \   |                                        |move occurs because `s` has type\
    \ `String`, which does not implement the `Copy` trait\n   |                  \
    \                      help: consider removing the `&`: `s`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n\n    sorted_list.sort_by(|a,\
    \ b| {\n        let a_len = a.len();\n        let b_len = b.len();\n        a_len.cmp(&b_len)\n\
    \    });\n\n    for i in 0..(sorted_list.len() - 1) {\n        if sorted_list[i].len()\
    \ == sorted_list[i +\n                                           1].len() {\n\
    \            sorted_list.swap(i, i + 1);\n        }\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmpxepxahwn.rs:19:26\n\
    \   |\n19 |     sorted_list.sort_by(|a, b| {\n   |                          ^\
    \ consider giving this closure parameter the explicit type `&T`, where the type\
    \ parameter `T` is specified\n   |\n   = note: type must be known at this point\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = vec![];\n    let mut i = 0;\n    while i <\
    \ lst.len() {\n        if i % 2 == 0 {\n            let mut j = 0;\n         \
    \   while j < lst.len() {\n                if j == i {\n                    s.push(*(&lst[j..i]));\n\
    \                    break;\n                }\n                if lst[j].len()\
    \ < lst[i].len() {\n                    s.push(*(&lst[j..i]));\n             \
    \       break;\n                }\n                if lst[j].len() > lst[i].len()\
    \ {\n                    s.push(*(&lst[i..j]));\n                    break;\n\
    \                }\n                s.push(*(&lst[i..j]));\n                i\
    \ += 1;\n                j += 1;\n            }\n        } else {\n          \
    \  let mut j = 0;\n            while j < lst.len() {\n                if j ==\
    \ i {\n                    s.push(*(&lst[j..i]));\n                    break;\n\
    \                }\n                if lst[j].len() < lst[i].len() {\n       \
    \             s.push(*(&lst[j..i]));\n                    break;\n           \
    \     }\n                if lst[j].len() > lst[i].len() {\n                  \
    \  s.push(*(&lst[i..j]));\n                    break;\n                }\n   \
    \             s.push(*(&lst[i..j]));\n                i += 1;\n              \
    \  j += 1;\n            }\n        }\n    }\n    vec![String::from(&*s)]\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[String]` cannot be known at\
    \ compilation time\n   --> /tmp/tmptfq84wl9.rs:24:28\n    |\n24  |           \
    \          s.push(*(&lst[j..i]));\n    |                       ---- ^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                       |\n \
    \   |                       required by a bound introduced by this call\n    |\n\
    \    = help: the trait `Sized` is not implemented for `[String]`\nnote: required\
    \ by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `[String]` cannot be known at compilation time\n   --> /tmp/tmptfq84wl9.rs:17:17\n\
    \    |\n17  |     let mut s = vec![];\n    |                 ^^^^^^ doesn't have\
    \ a size known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `[String]`\nnote: required by a bound in `Vec::<T>::new`\n    = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `[String]` cannot\
    \ be known at compilation time\n   --> /tmp/tmptfq84wl9.rs:17:17\n    |\n17  |\
    \     let mut s = vec![];\n    |                 ^^^^^^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `[String]`\nnote: required by a bound in `Vec`\n    = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror[E0599]: the method `push` exists for struct `Vec<[String]>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmptfq84wl9.rs:28:23\n \
    \  |\n28 |                     s.push(*(&lst[j..i]));\n   |                  \
    \     ^^^^ method cannot be called on `Vec<[String]>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `[String]: Sized`\n\nerror[E0599]: the method `push` exists for struct\
    \ `Vec<[String]>`, but its trait bounds were not satisfied\n  --> /tmp/tmptfq84wl9.rs:32:23\n\
    \   |\n32 |                     s.push(*(&lst[i..j]));\n   |                 \
    \      ^^^^ method cannot be called on `Vec<"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec!(\"aaa\") + vec!(\"ab\") + vec!(\"aa\") + vec!(\"\
    cd\") + vec!(\"ab\") + vec!(\"aaa\") + vec!(\"aaa\")\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `Vec<&str>` to `Vec<&str>`\n  --> /tmp/tmp3r_2u7y7.rs:17:17\n\
    \   |\n17 |     vec!(\"aaa\") + vec!(\"ab\") + vec!(\"aa\") + vec!(\"cd\") + vec!(\"\
    ab\") + vec!(\"aaa\") + vec!(\"aaa\")\n   |     ----------- ^ ---------- Vec<&str>\n\
    \   |     |\n   |     Vec<&str>\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum = 0;\n\n    for word in lst.into_iter() {\n\
    \        let len = word.len();\n        if len % 2 != 0 {\n            sum +=\
    \ len;\n        }\n    }\n\n    let mut result = Vec::new();\n    result.extend_from_slice(lst.iter().cloned().take(sum).collect::<Vec<_>>());\n\
    \    result.sort_by(|a, b| a.cmp(b));\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpautwc81f.rs:27:30\n   |\n\
    27 |     result.extend_from_slice(lst.iter().cloned().take(sum).collect::<Vec<_>>());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                              |\n   |                              expected\
    \ `&[_]`, found struct `Vec`\n   |                              help: consider\
    \ borrowing here: `&lst.iter().cloned().take(sum).collect::<Vec<_>>()`\n   |\n\
    \   = note: expected reference `&[_]`\n                 found struct `Vec<String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = Vec::with_capacity(lst.len());\n\
    \    let mut i = 0;\n    for word in lst {\n        sorted_lst.push(word);\n \
    \       i += 1;\n        if i % 2 == 0 {\n            continue;\n        }\n \
    \       sorted_lst.sort_unstable_by_key(|s| s.to_string());\n    }\n    sorted_lst\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprdl4gg_1.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = vec![];\n    for v in lst.iter() {\n     \
    \   if v.len() % 2 != 0 {\n            s.push(*v);\n        }\n    }\n    s.sort();\n\
    \    s\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of `*v` which is behind a shared reference\n\
    \  --> /tmp/tmp6iyzun3j.rs:20:20\n   |\n20 |             s.push(*v);\n   |   \
    \                 ^^ move occurs because `*v` has type `String`, which does not\
    \ implement the `Copy` trait\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_new = Vec::<String>::new();\n    lst.sort_unstable_by_key(|&word|\
    \ word.len());\n    for word in lst {\n        if lst_new.iter().all(|&s| s.len()\
    \ > word.len()) {\n            lst_new.push(word);\n        }\n    }\n    lst_new\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpklew7kst.rs:18:31\n\
    \   |\n18 |     lst.sort_unstable_by_key(|&word| word.len());\n   |          \
    \                     ^----\n   |                               ||\n   |     \
    \                          |data moved here\n   |                            \
    \   |move occurs because `word` has type `String`, which does not implement the\
    \ `Copy` trait\n   |                               help: consider removing the\
    \ `&`: `word`\n\nerror[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpklew7kst.rs:20:32\n\
    \   |\n20 |         if lst_new.iter().all(|&s| s.len() > word.len()) {\n   | \
    \                               ^-\n   |                                ||\n \
    \  |                                |data moved here\n   |                   \
    \             |move occurs because `s` has type `String`, which does not implement\
    \ the `Copy` trait\n   |                                help: consider removing\
    \ the `&`: `s`\n\nerror[E0596]: cannot borrow `lst` as mutable, as it is not declared\
    \ as mutable\n  --> /tmp/tmpklew7kst.rs:18:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     let mut lst_new = Vec::<String>::new();\n\
    18 |     lst.sort_unstable_by_key(|&word| word.len());\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0507, E0596.\nFor more information about\
    \ an error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sum: Vec<String> = Vec::new();\n    for s in lst\
    \ {\n        sum = sum.iter().filter_map(|s| {\n            s.len() as usize\n\
    \        }).fold(s, |a, b| {\n            if a > b {\n                a\n    \
    \        } else {\n                b\n            }\n        });\n    }\n    sum.iter().cloned().map(|s|\
    \ {\n        String::from(s)\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1p1z7ug7.rs:20:13\n   |\n\
    20 |             s.len() as usize\n   |             ^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n \
    \             found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |             Some(s.len() as usize)\n   |             +++++       \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1p1z7ug7.rs:21:17\n\
    \   |\n21 |         }).fold(s, |a, b| {\n   |                 ^ expected struct\
    \ `Vec`, found struct `String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `String`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by(|a, b| a.len_norm().cmp(b.len_norm()))\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len_norm` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmpzy3xg4z3.rs:17:26\n   |\n17 |     lst.sort_by(|a,\
    \ b| a.len_norm().cmp(b.len_norm()))\n   |                          ^^^^^^^^ method\
    \ not found in `&String`\n\nerror[E0599]: no method named `len_norm` found for\
    \ reference `&String` in the current scope\n  --> /tmp/tmpzy3xg4z3.rs:17:43\n\
    \   |\n17 |     lst.sort_by(|a, b| a.len_norm().cmp(b.len_norm()))\n   |     \
    \                                      ^^^^^^^^ method not found in `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzy3xg4z3.rs:17:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    17 |     lst.sort_by(|a, b| a.len_norm().cmp(b.len_norm()))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().cloned().filter(|item| item.len() % 2 != 0).cloned().collect().sort_by(|a,\
    \ b| a.cmp(b)).collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::slice::Iter<'_, String> as\
    \ Iterator>::Item == &&_`\n  --> /tmp/tmp6_jcelvp.rs:17:60\n   |\n17 |     lst.iter().cloned().filter(|item|\
    \ item.len() % 2 != 0).cloned().collect().sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                                            ^^^^^^ expected\
    \ reference, found struct `String`\n   |\n   = note: expected reference `&&_`\n\
    \              found reference `&String`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<std::slice::Iter<'_, String>>`\n   = note:\
    \ 1 redundant requirement hidden\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Filter<Cloned<std::slice::Iter<'_, String>>,\
    \ [closure@/tmp/tmp6_jcelvp.rs:17:32: 17:58]>`\n\nerror[E0631]: type mismatch\
    \ in closure arguments\n  --> /tmp/tmp6_jcelvp.rs:17:60\n   |\n17 |     lst.iter().cloned().filter(|item|\
    \ item.len() % 2 != 0).cloned().collect().sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                --------------------------  ^^^^^^ expected\
    \ signature of `for<'r> fn(&'r &_) -> _`\n   |                               \
    \ |\n   |                                found signature of `for<'r> fn(&'r String)\
    \ -> _`\n   |\n   = note: required because of the requirements on the impl of\
    \ `Iterator` for `Filter<Cloned<std::slice::Iter<'_, String>>, [closure@/tmp/tmp6_jcelvp.rs:17:32:\
    \ 17:58]>`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Filter<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmp6_jcelvp.rs:17:32: 17:58]>>`, but its trait bounds\
    \ were not satisfied\n  --> /tmp/tmp6_jcelvp.rs:17:69\n   |\n17 |        lst.iter().cloned().filter(|item|\
    \ item.len() % 2 != 0).cloned().collect().sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                                                        ^^^^^^^\
    \ method cannot be called on `Cloned<Filter<Cloned<std::slice::Iter<'_, String>>,\
    \ [closure@/tmp/tmp6_jcelvp.rs:17:32: 17:58]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfie"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut counters = Vec::new();\n    for s in lst {\n \
    \       if let Ok(n) = s.len() {\n            counters.push(n);\n        }\n \
    \   }\n\n    let mut sorter = Vec::<String>::new();\n    for (n, s) in counters.iter().enumerate()\
    \ {\n        sorter.push(s);\n        if n % 2 == 1 {\n            sorter.push(String::from(\"\
    \"));\n        }\n    }\n\n    sorter.sort_unstable();\n    sorter\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpe9svxr1z.rs:19:16\n   |\n\
    19 |         if let Ok(n) = s.len() {\n   |                ^^^^^   ------- this\
    \ expression has type `usize`\n   |                |\n   |                expected\
    \ `usize`, found enum `Result`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Result<_, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpe9svxr1z.rs:26:21\n\
    \   |\n26 |         sorter.push(s);\n   |                     ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                     |\n   |      \
    \               expected struct `String`, found reference\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().sort().collect()\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpzg2rlwoq.rs:17:16\n   |\n17 |     lst.iter().sort().collect()\n\
    \   |                ^^^^ method not found in `std::slice::Iter<'_, String>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    for i in lst.into_iter().rev()\
    \ {\n        if let Some(mut j) = sorted_list.iter().position(|&a| &a == &i) {\n\
    \            sorted_list[j] = i;\n        }\n    }\n    sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap_or(std::cmp::Ordering::Less))\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpp3z3hy1_.rs:23:54\n   |\n23 |     sorted_list.sort_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap_or(std::cmp::Ordering::Less))\n   |        \
    \                                              ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpp3z3hy1_.rs:23:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n23 |     sorted_list.sort_by(|a, b| a.len().cmp(&b.len()).unwrap_or(std::cmp::Ordering::Less))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![\"\".to_string(); *lst.iter().cloned()].sort();\n\
    \    let mut cnt = 0;\n    for i in &mut sorted_list {\n        if i.len() !=\
    \ sorted_list[cnt].len() {\n            sorted_list.swap(sorted_list.len() - cnt,\
    \ cnt);\n            cnt += 1;\n        }\n    }\n    sorted_list\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `Cloned<std::slice::Iter<'_, String>>` cannot be dereferenced\n\
    \  --> /tmp/tmpzh4q4t14.rs:17:48\n   |\n17 |     let mut sorted_list = vec![\"\
    \".to_string(); *lst.iter().cloned()].sort();\n   |                          \
    \                      ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]: `()` is not an iterator\n\
    \  --> /tmp/tmpzh4q4t14.rs:19:14\n   |\n19 |     for i in &mut sorted_list {\n\
    \   |              ^^^^^^^^^^^^^^^^ `()` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `()`\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `&mut ()`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&mut ()`\n\n\
    error[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmpzh4q4t14.rs:20:23\n\
    \   |\n20 |         if i.len() != sorted_list[cnt].len() {\n   |             \
    \          ^^^^^^^^^^^^^^^^\n   |\n   = help: to access tuple elements, use tuple\
    \ indexing syntax (e.g., `tuple.0`)\n\nerror[E0599]: no method named `swap` found\
    \ for unit type `()` in the current scope\n  --> /tmp/tmpzh4q4t14.rs:21:25\n \
    \  |\n21 |             sorted_list.swap(sorted_list.len() - cnt, cnt);\n   | \
    \                        ^^^^ method not found in `()`\n\nerror[E0599]: no method\
    \ named `len` found for unit type `()` in the current scope\n  --> /tmp/tmpzh4q4t14.rs:21:42\n\
    \   |\n21 |             sorted_list.swap(sorted_list.len() - cnt, cnt);\n   |\
    \                                          ^^^ method not found in `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzh4q4t14.rs:25:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n25 |     sorted_list\n\
    \   |     ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599, E0608, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_nalo_1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for i in lst.iter() {\n\
    \        res.extend(i);\n        res.sort();\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n   --> /tmp/tmpjyujy7w5.rs:19:20\n\
    \    |\n19  |         res.extend(i);\n    |             ------ ^ `&String` is\
    \ not an iterator\n    |             |\n    |             required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `&String`\n    = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `&String`\nnote: required by a bound in `extend`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = vec![];\n    sorted.push_str(&sorted_list_sum(&lst,\
    \ vec![]).unwrap());\n    sorted\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_str` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmp2s0igan3.rs:18:12\n   |\n18 |     sorted.push_str(&sorted_list_sum(&lst,\
    \ vec![]).unwrap());\n   |            ^^^^^^^^ help: there is an associated function\
    \ with a similar name: `push`\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmp2s0igan3.rs:18:22\n   |\n18 | \
    \    sorted.push_str(&sorted_list_sum(&lst, vec![]).unwrap());\n   |         \
    \             ^^^^^^^^^^^^^^^ ----  ------ supplied 2 arguments\n   |        \
    \              |\n   |                      expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmp2s0igan3.rs:16:4\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^ ----------------\n\n\
    error[E0599]: no method named `unwrap` found for struct `Vec<String>` in the current\
    \ scope\n  --> /tmp/tmp2s0igan3.rs:18:52\n   |\n18 |     sorted.push_str(&sorted_list_sum(&lst,\
    \ vec![]).unwrap());\n   |                                                   \
    \ ^^^^^^ help: there is an associated function with a similar name: `swap`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec = Vec::new();\n    for s in lst {\n      \
    \  if vec.len() == 0 {\n            vec.push(s);\n        } else if s.len() <\
    \ vec[0].len() {\n            vec.push(s);\n        } else {\n            let\
    \ mut i = 0;\n            while i < vec.len() && vec[i].len() < s.len() {\n  \
    \              i += 1;\n            }\n            vec.swap(i, 0);\n        }\n\
    \    }\n    vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 2 but the
    index is 2'', /tmp/tmphf6t5708.rs:28:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut iter = lst.iter();\n\
    \    while let Some(i) = iter.next() {\n        for j in 0..(i as usize).saturating_sub(1)\
    \ {\n            res.push(iter.get().clone());\n        }\n    }\n    res\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpkh5s23qw.rs:21:27\n   |\n21 |          \
    \   res.push(iter.get().clone());\n   |                           ^^^ method not\
    \ found in `std::slice::Iter<'_, String>`\n\nerror[E0606]: casting `&String` as\
    \ `usize` is invalid\n  --> /tmp/tmpkh5s23qw.rs:20:21\n   |\n20 |         for\
    \ j in 0..(i as usize).saturating_sub(1) {\n   |                     ^^^^^^^^^^^^\n\
    \   |\n   = help: cast through a raw pointer first\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // TODO: implement function here\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0gww19yb.rs:16:41\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ---------------\
    \                      ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |   \
    \ |\n   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \   |\n   = note: expected struct `Vec<String>`\n           found unit type `()`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    debug_assert_ne!(lst.len(), 0);\n    let mut res = vec![];\n\
    \    let mut current_word = String::from(\"\");\n    let mut current_sum = String::from(\"\
    \");\n    for word in lst {\n        let word_len = word.len();\n        if word_len\
    \ % 2 == 1 {\n            debug_assert_eq!(current_word, word);\n            debug_assert_ne!(current_sum,\
    \ \"\");\n            current_sum += word;\n        } else {\n            if current_word\
    \ != \"\" {\n                debug_assert_ne!(current_sum, \"\");\n          \
    \      debug_assert_ne!(current_word, \"\");\n                debug_assert_ne!(current_sum,\
    \ current_word);\n                res.push(current_sum);\n                current_sum\
    \ = String::from(\"\");\n            }\n            res.push(word);\n        }\n\
    \        current_word = word;\n    }\n    if current_word != \"\" {\n        debug_assert_ne!(current_sum,\
    \ \"\");\n        debug_assert_ne!(current_word, \"\");\n        debug_assert_ne!(current_sum,\
    \ current_word);\n        res.push(current_sum);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqdjvx6os.rs:26:28\n   |\n\
    26 |             current_sum += word;\n   |                            ^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&word`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut i = 0;\n  \
    \  for elem in lst {\n        if elem.len() > i {\n            sorted_list.push(elem);\n\
    \        }\n        i += 1;\n    }\n    sorted_list.sort_by_key(|elem| elem.len());\n\
    \    sorted_list.sort_by_key(|elem| elem);\n    sorted_list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: lifetime may not live long enough\n  --> /tmp/tmpofl01_7y.rs:26:36\n\
    \   |\n26 |     sorted_list.sort_by_key(|elem| elem);\n   |                  \
    \            ----- ^^^^ returning this value requires that `'1` must outlive `'2`\n\
    \   |                              |   |\n   |                              |\
    \   return type of closure is &'2 String\n   |                              has\
    \ type `&'1 String`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.len() % 2 != 0 {\n        sorted_list_sum(lst.iter().cloned().filter(|x|\
    \ x.len() % 2 != 0))\n    } else {\n        sorted_list_sum(lst.iter().cloned().filter(|x|\
    \ x.len() == 1))\n    }\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfea8dy3k.rs:18:25\n   |\n\
    18 |         sorted_list_sum(lst.iter().cloned().filter(|x| x.len() % 2 != 0))\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Filter`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Filter<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmpfea8dy3k.rs:18:52: 18:72]>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfea8dy3k.rs:20:25\n   |\n20 |         sorted_list_sum(lst.iter().cloned().filter(|x|\
    \ x.len() == 1))\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Filter`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Filter<Cloned<std::slice::Iter<'_,\
    \ String>>, [closure@/tmp/tmpfea8dy3k.rs:20:52: 20:68]>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n\n    for word in lst {\n     \
    \   if res.length() == 0 {\n            res.push(word);\n        } else {\n  \
    \          let (mut i, mut j) = (0, 0);\n\n            while i != res.length()\
    \ && j != word.length() {\n                if j >= word.length() || (res.get(i).len()\
    \ > word.length() && word[j] < res.get(i).chars().nth(j)) {\n                \
    \    j += 1;\n                } else {\n                    i += 1;\n        \
    \        }\n            }\n\n            if i != res.len() {\n               \
    \ res.swap(i, j);\n            }\n        }\n    }\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmpetyhnm25.rs:20:16\n   |\n20 |         if res.length()\
    \ == 0 {\n   |                ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `Vec<String>` in the current scope\n  --> /tmp/tmpetyhnm25.rs:25:28\n   |\n\
    25 |             while i != res.length() && j != word.length() {\n   |       \
    \                     ^^^^^^ help: there is an associated function with a similar\
    \ name: `len`\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpetyhnm25.rs:25:50\n   |\n25 |          \
    \   while i != res.length() && j != word.length() {\n   |                    \
    \                              ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpetyhnm25.rs:26:30\n   |\n26 | \
    \                if j >= word.length() || (res.get(i).len() > word.length() &&\
    \ word[j] < res.get(i).chars().nth(j)) {\n   |                              ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `len` found for enum `Option` in the current scope\n  --> /tmp/tmpetyhnm25.rs:26:54\n\
    \   |\n26 |                 if j >= word.length() || (res.get(i).len() > word.length()\
    \ && word[j] < res.get(i).chars().nth(j)) {\n   |                            \
    \                          ^^^ method not found in `Option<&String>`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpetyhnm25.rs:26:67\n   |\n26 |                 if j >= word.length()\
    \ || (res.get(i).len() > word.length() && word[j] < res.get(i).chars().nth(j))\
    \ {\n   |                                                                   ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpetyhnm25.rs:26:79\n\
    \   |"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut rev = lst.iter().rev();\n    let mut result: Vec<String>\
    \ = Vec::new();\n    for word in rev {\n        if word.len() % 2 != 0 {\n   \
    \         result.push(word);\n        }\n    }\n    result.sort_unstable_by_key(|word|\
    \ word.len());\n    result\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5n3b353v.rs:21:25\n   |\n\
    21 |             result.push(word);\n   |                         ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \ |\n   |                         expected struct `String`, found `&String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for ele in lst {\n        if\
    \ ele.len() % 2 == 1 {\n            let mut tmp = ele.clone();\n            tmp.sort();\n\
    \            res.push(tmp);\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp1lpc88a8.rs:21:17\n   |\n21 |             tmp.sort();\n\
    \   |                 ^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec![String::from(\"aa\")]\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\"]`,\n right: `[\"AI\", \"asdf\", \"school\"]`', /tmp/tmplxchc5g_.rs:23:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum(lst, String::new())\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpd6kwkm10.rs:17:5\n   |\n17 |     sorted_list_sum(lst, String::new())\n\
    \   |     ^^^^^^^^^^^^^^^ ---  ------------- supplied 2 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmpd6kwkm10.rs:16:4\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^\
    \ ----------------\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for word in lst {\n       \
    \ if res.iter().position(|&x| x == &word).is_some() {\n            continue;\n\
    \        }\n        if word.len() % 2 != 0 {\n            res.push(word);\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&String`\n  --> /tmp/tmp4lll9w0t.rs:19:39\n\
    \   |\n19 |         if res.iter().position(|&x| x == &word).is_some() {\n   |\
    \                                       ^^ no implementation for `String == &String`\n\
    \   |\n   = help: the trait `PartialEq<&String>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut i = 0;\n    for word\
    \ in lst {\n        if i % 2 != 0 {\n            res.push(word);\n        }\n\
    \        i += 1;\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\"]`,\n right: `[\"aa\"]`', /tmp/tmp1tbiu0wl.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = vec![];\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    let mut length: usize = 0;\n    while j < lst.len() {\n    \
    \    if length > 0 {\n            sorted.push(vec![lst[j].clone(), lst[j + 1].clone()]);\n\
    \            i += 2;\n            j += 2;\n            length -= 2;\n        }\
    \ else {\n            sorted.push(vec![lst[j].clone()]);\n            i += 1;\n\
    \            j += 1;\n            length += 1;\n        }\n    }\n    sorted\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp528tgssi.rs:34:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n34 |     sorted\n   |     ^^^^^^ expected struct `String`, found\
    \ struct `Vec`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<Vec<String>>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = Vec::new();\n    for word in lst\
    \ {\n        let mut first_word = word;\n        sorted_lst.push(first_word);\n\
    \        if word.len() > 1 {\n            for w in &sorted_lst {\n           \
    \     if w.len() > 1 && w[0].len().cmp(&first_word[0]) == -1 {\n             \
    \       first_word = w;\n                }\n            }\n        }\n    }\n\
    \    sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpiyireh9e.rs:23:35\n   |\n23 |                 if w.len() > 1 && w[0].len().cmp(&first_word[0])\
    \ == -1 {\n   |                                   ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpiyireh9e.rs:23:51\n   |\n23 |                 if w.len() > 1 &&\
    \ w[0].len().cmp(&first_word[0]) == -1 {\n   |                               \
    \                    ^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiyireh9e.rs:24:34\n\
    \   |\n19 |         let mut first_word = word;\n   |                         \
    \     ---- expected due to this value\n...\n24 |                     first_word\
    \ = w;\n   |                                  ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                  |\n   |      \
    \                            expected struct `String`, found `&String`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor "
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum(lst.iter().cloned())\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpswb8x85y.rs:17:21\n   |\n\
    17 |     sorted_list_sum(lst.iter().cloned())\n   |                     ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Cloned`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Cloned<std::slice::Iter<'_, String>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    let mut seen = vec![];\n  \
    \  for str in lst {\n        if seen.contains(&str) {\n            continue;\n\
    \        }\n        seen.push(str);\n        if res.len() == 0 {\n           \
    \ seen.sort_unstable_by_key(|x| x.len() as f32);\n            res.sort_unstable_by_key(|x|\
    \ x.chars().collect::<Vec<char>>());\n        }\n        res.push(str);\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `f32: Ord` is not satisfied\n    --> /tmp/tmpmqrpfxh_.rs:25:39\n\
    \     |\n25   |             seen.sort_unstable_by_key(|x| x.len() as f32);\n \
    \    |                  -------------------- ^^^^^^^^^^^^^^^^^^ the trait `Ord`\
    \ is not implemented for `f32`\n     |                  |\n     |            \
    \      required by a bound introduced by this call\n     |\n     = help: the following\
    \ other types implement trait `Ord`:\n               i128\n               i16\n\
    \               i32\n               i64\n               i8\n               isize\n\
    \               u128\n               u16\n             and 4 others\nnote: required\
    \ by a bound in `core::slice::<impl [T]>::sort_unstable_by_key`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    for word in lst\
    \ {\n        let len: usize = word.chars().count();\n        if len % 2 == 1 {\n\
    \            sorted_list.push(word);\n        }\n    }\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpustxb7vo.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut slst = vec![];\n    for ele in lst {\n       \
    \ let mut sord = true;\n        for ele2 in slst {\n            if ele < ele2\
    \ {\n                sord = false;\n                break;\n            }\n  \
    \      }\n        if sord {\n            slst.push(ele);\n        }\n    }\n \
    \   slst.sort_by(|a, b| a.len() < b.len());\n    slst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyvwsdbcm.rs:30:25\n   |\n\
    30 |     slst.sort_by(|a, b| a.len() < b.len());\n   |                       \
    \  ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found `bool`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by(|a, b| a.len().cmp(&b.len()).unwrap_or(String::cmp(&a,\
    \ &b)))\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpjuwg0bxv.rs:17:46\n   |\n17 |     lst.sort_by(|a,\
    \ b| a.len().cmp(&b.len()).unwrap_or(String::cmp(&a, &b)))\n   |             \
    \                                 ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpjuwg0bxv.rs:17:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    17 |     lst.sort_by(|a, b| a.len().cmp(&b.len()).unwrap_or(String::cmp(&a, &b)))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst_sorted = Vec::with_capacity(lst.len());\n\
    \    for (i, word) in lst.iter().enumerate() {\n        if lst.len() <= i {\n\
    \            lst_sorted.push(word);\n        } else {\n            if lst.len()\
    \ > i {\n                let mut lst_i = lst.iter().filter(|&x| x != word).collect::<Vec<String>>();\n\
    \                let mut lst_i_count = lst_i.len();\n                let mut lst_j_count\
    \ = lst_sorted.iter().filter(|&x| x != word).collect::<Vec<String>>().len();\n\
    \                while lst_i_count != lst_j_count {\n                    if lst_i_count\
    \ > lst_j_count {\n                        lst_i.sort();\n                   \
    \     lst_sorted.push(word);\n                        break;\n               \
    \     } else {\n                        lst_i.sort();\n                      \
    \  lst_sorted.push(lst_i.pop().unwrap());\n                        lst_i_count\
    \ -= 1;\n                    }\n                }\n            }\n        }\n\
    \    }\n    lst_sorted\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpn674xkby.rs:23:67\n     |\n\
    23   |                 let mut lst_i = lst.iter().filter(|&x| x != word).collect::<Vec<String>>();\n\
    \     |                                                                   ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&String>`\n\
    \     |\n     = help: the trait `FromIterator<&String>` is not implemented for\
    \ `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0277]: can't compare `&String`\
    \ with `String`\n  --> /tmp/tmpn674xkby.rs:25:71\n   |\n25 |                 let\
    \ mut lst_j_count = lst_sorted.iter().filter(|&x| x != word).collect::<Vec<String>>().len();\n\
    \   |                                                                       ^^\
    \ no implementation for `&String == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&String>` for `&&String`\n\nerror[E0277]: a value of type\
    \ `Vec<String>` cannot be built from an iterator over elements of type `&&String`\n\
    \    --> /tmp/tmpn674xkby.rs:25:80\n     |\n25   |                 let mut lst_j_count\
    \ = lst_sorted.iter().filter(|&x| x != word).collect::<Vec<String>>().len();\n\
    \     |                                                                      \
    \          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&&String>`\n\
    \     |\n     = help: the trait `"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().sorted_by_key(|x| x.len() as i32).collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted_by_key` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpox11a9vt.rs:17:16\n   |\n17 |     lst.iter().sorted_by_key(|x|\
    \ x.len() as i32).collect()\n   |                ^^^^^^^^^^^^^ method not found\
    \ in `std::slice::Iter<'_, String>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by_key(|x| x.len());\n    lst.iter().map(|x|\
    \ x.clone()).collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_elxqnok.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort_by_key(|x| x.len());\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst\n        .iter()\n        .map(|word| word.len() as\
    \ i32)\n        .collect::<Vec<_>>()\n        .sort_unstable_by(|a, b| a.cmp(b).unwrap_or(b.cmp(a).unwrap_or(0)))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpjlsx9von.rs:21:43\n   |\n21 |         .sort_unstable_by(|a,\
    \ b| a.cmp(b).unwrap_or(b.cmp(a).unwrap_or(0)))\n   |                        \
    \                   ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\nerror[E0599]:\
    \ no method named `unwrap_or` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpjlsx9von.rs:21:62\n   |\n21 |         .sort_unstable_by(|a,\
    \ b| a.cmp(b).unwrap_or(b.cmp(a).unwrap_or(0)))\n   |                        \
    \                                      ^^^^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpjlsx9von.rs:22:10\n   |\n\
    22 |         .collect()\n   |          ^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut sorted_list_mut_ptr\
    \ = sorted_list.as_mut_ptr();\n    let mut current_index = lst.len() - 1;\n  \
    \  let mut current_word = String::new();\n    while current_index >= 0 {\n   \
    \     let mut current_word = current_word.to_string();\n        let mut current_string_pointer\
    \ = current_word.as_mut_ptr();\n        let current_string_pointer = &mut *current_string_pointer;\n\
    \        let current_word = current_string_pointer.offset(1);\n        let mut\
    \ current_index = 0;\n        for element in lst {\n            if element.len()\
    \ != current_word.len() {\n                sorted_list_mut_ptr = sorted_list.as_mut_ptr();\n\
    \                current_index = 0;\n                break;\n            }\n \
    \           if element.to_string_lossy() == current_word {\n                current_index\
    \ += 1;\n            }\n        }\n        if current_index != 0 {\n         \
    \   sorted_list_mut_ptr = sorted_list.as_mut_ptr();\n            current_index\
    \ = 0;\n        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `offset` found for mutable reference `&mut\
    \ u8` in the current scope\n  --> /tmp/tmp0yy3195z.rs:25:51\n   |\n25 |      \
    \   let current_word = current_string_pointer.offset(1);\n   |               \
    \                                    ^^^^^^ method not found in `&mut u8`\n\n\
    error[E0599]: no method named `to_string_lossy` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp0yy3195z.rs:33:24\n   |\n33 |             if element.to_string_lossy()\
    \ == current_word {\n   |                        ^^^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_list = Vec::new();\n    let mut sorted_list\
    \ = Vec::new();\n    for i in lst.iter() {\n        let mut is_in = false;\n \
    \       for j in sorted_list.iter() {\n            if j.len() > i.len() {\n  \
    \              break;\n            } else if j == i {\n                is_in =\
    \ true;\n                break;\n            }\n        }\n        if !is_in {\n\
    \            new_list.push(i);\n        }\n    }\n    for i in new_list.iter()\
    \ {\n        let mut is_in = false;\n        for j in sorted_list.iter() {\n \
    \           if j.len() > i.len() {\n                break;\n            } else\
    \ if j == i {\n                is_in = true;\n                break;\n       \
    \     }\n        }\n        if !is_in {\n            sorted_list.push(i);\n  \
    \      }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&T`\n  --> /tmp/tmptnwrbaxk.rs:21:18\n\
    \   |\n18 |     let mut sorted_list = Vec::new();\n   |         ---------------\
    \ consider giving `sorted_list` the explicit type `&T`, where the type parameter\
    \ `T` is specified\n...\n21 |         for j in sorted_list.iter() {\n   |    \
    \              ^^^^^^^^^^^^^^^^^^ cannot infer type for type parameter `T`\n \
    \  |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    let mut counter = 1;\n\
    \    for string in lst {\n        if counter % 2 == 1 {\n            sorted_lst.push(string);\n\
    \        }\n        counter += 1;\n    }\n    sorted_lst\n}\n\nfn main() {\n \
    \   let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmphyy2p3ms.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut count = 0;\n\
    \    let mut length = lst.len();\n    while count != 0 {\n        sorted_list.push(&lst[count\
    \ % length]);\n        count /= length;\n    }\n    sorted_list.sort_by_key(|x|\
    \ x.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzfz0zxmp.rs:25:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n25 |     sorted_list\n   |     ^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\n   = note: expected struct `Vec<String>`\n          \
    \    found struct `Vec<&String>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec_to_sort = vec![];\n    for word in lst {\n\
    \        if vec_to_sort.len() > 0 {\n            if word.length() < vec_to_sort.last().unwrap().length()\
    \ {\n                vec_to_sort.push(word);\n            } else {\n         \
    \       let mut first = vec_to_sort.last().unwrap();\n                let mut\
    \ second = word;\n                if first.length() < second.length() {\n    \
    \                second = word;\n                }\n                if vec_to_sort.len()\
    \ > 1 {\n                    if first.len() < vec_to_sort.last().unwrap().len()\
    \ {\n                        first = vec_to_sort.last().unwrap();\n          \
    \          }\n                }\n                vec_to_sort.push(first);\n  \
    \              vec_to_sort.push(second);\n            }\n        } else {\n  \
    \          vec_to_sort.push(word);\n        }\n    }\n    vec_to_sort.sort_by_key(|x|\
    \ x.len());\n    vec_to_sort\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu63dljm6.rs:20:21\n   |\n20 |             if word.length()\
    \ < vec_to_sort.last().unwrap().length() {\n   |                     ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpu63dljm6.rs:25:44\n   |\n25 |                 if first.length() < second.length()\
    \ {\n   |                                            ^^^^^^ help: there is an\
    \ associated function with a similar name: `len`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    let mut sorted_vec =\
    \ vec![];\n    let mut seen = HashSet::new();\n\n    for word in lst.iter() {\n\
    \        let mut new_word = word;\n        if seen.contains(&new_word) {\n   \
    \         new_word = String::from(\"\");\n        }\n\n        if new_word !=\
    \ \"\" {\n            sorted_lst.push(new_word);\n            sorted_vec.push(new_word);\n\
    \            seen.insert(new_word);\n        }\n    }\n    sorted_lst.sort_by(|x,\
    \ y| x.len() < y.len());\n    sorted_vec.sort_by(|x, y| x.len() < y.len());\n\
    \    sorted_vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpd27_4muc.rs:19:20\n   |\n19 |     let mut seen = HashSet::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd27_4muc.rs:24:24\n   |\n22 |         let mut\
    \ new_word = word;\n   |                            ---- expected due to this\
    \ value\n23 |         if seen.contains(&new_word) {\n24 |             new_word\
    \ = String::from(\"\");\n   |                        ^^^^^^^^^^^^^^^^\n   |  \
    \                      |\n   |                        expected `&String`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&String::from(\"\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd27_4muc.rs:33:31\n\
    \   |\n33 |     sorted_lst.sort_by(|x, y| x.len() < y.len());\n   |          \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd27_4muc.rs:34:31\n\
    \   |\n34 |     sorted_vec.sort_by(|x, y| x.len() < y.len());\n   |          \
    \                     ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd27_4muc.rs:35:5\n \
    \  |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |       \
    \                                  ----------- expected `Vec<String>` because\
    \ of return type\n...\n35 |     sorted_vec\n   |     ^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&String>`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Your code here\n    let mut sorted_list = vec![];\n\
    \    for i in lst.iter().rev() {\n        let mut j = i;\n        if j % 2 ==\
    \ 1 {\n            sorted_list = vec![j];\n            break;\n        }\n   \
    \ }\n    for i in lst.iter().rev() {\n        let mut j = i;\n        if j % 2\
    \ == 0 {\n            sorted_list.push(*i);\n        }\n    }\n    for i in sorted_list.iter().rev()\
    \ {\n        let mut j = i;\n        while j > 0 {\n            let mut k = j;\n\
    \            while k > 0 {\n                if k < j {\n                    let\
    \ mut c = *j;\n                    *j = k;\n                    k = c;\n     \
    \           }\n                j -= 1;\n            }\n            j -= 1;\n \
    \       }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&String` by `{integer}`\n  --> /tmp/tmpbdvii7rq.rs:21:14\n\
    \   |\n21 |         if j % 2 == 1 {\n   |            - ^ - {integer}\n   |   \
    \         |\n   |            &String\n\nerror[E0369]: cannot mod `&String` by\
    \ `{integer}`\n  --> /tmp/tmpbdvii7rq.rs:28:14\n   |\n28 |         if j % 2 ==\
    \ 0 {\n   |            - ^ - {integer}\n   |            |\n   |            &String\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbdvii7rq.rs:29:30\n   |\n29 |\
    \             sorted_list.push(*i);\n   |                              ^^\n  \
    \ |                              |\n   |                              expected\
    \ `&String`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `&*i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdvii7rq.rs:34:19\n\
    \   |\n34 |         while j > 0 {\n   |                   ^ expected `&&String`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdvii7rq.rs:36:23\n\
    \   |\n36 |             while k > 0 {\n   |                       ^ expected `&&String`,\
    \ found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdvii7rq.rs:40:25\n\
    \   |\n35 |             let mut k = j;\n   |                         - expected\
    \ due to this value\n...\n40 |                     k = c;\n   |              \
    \           ^ expected `&String`, found struct `String`\n   |\n   = note: expected\
    \ reference `&&String`\n              found reference `&String`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `&&String`\n  -->\
    \ /tmp/tmpbdvii7rq.rs:42:17\n   |\n42 |                 j -= 1;\n   |        \
    \         -^^^^^\n   |                 |\n   |                 cannot use `-=`\
    \ on type `&&String`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `&&String`\n  --> /tmp/tmpbdvii7rq.rs:44:13\n   |\n44 | \
    \            j -= 1;\n   |             -^^^^^\n   |             |\n   |      \
    \       cannot use `-=` on type `&&String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpbdvii7rq.rs:47:5\n   |\n16 | fn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n   |                                  "
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_helper(lst, |a, b| a.cmp(b))\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmpeuufnx3v.rs:17:5\n   |\n17 |     sorted_list_sum_helper(lst, |a,\
    \ b| a.cmp(b))\n   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.into_iter().cloned().collect();\n  \
    \  let mut result = Vec::<String>::new();\n\n    for elem in lst.into_iter() {\n\
    \        let mut len = elem.len();\n        let mut cnt = 0;\n\n        for (i,\
    \ elem) in lst.into_iter().enumerate() {\n            if len != elem.len() {\n\
    \                cnt += 1;\n                continue;\n            }\n\n     \
    \       if cnt == 0 {\n                result.push(elem);\n                break;\n\
    \            }\n\n            if cnt > 0 && elem[i] < elem[i - 1] {\n        \
    \        cnt -= 1;\n                result.push(elem);\n                break;\n\
    \            }\n        }\n    }\n\n    let mut it = result.into_iter();\n   \
    \ it.sort_by_key(|&elem| elem.len());\n    it\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpb69jt3lb.rs:17:35\n     |\n17   |     let mut lst =\
    \ lst.into_iter().cloned().collect();\n     |                                \
    \   ^^^^^^ expected reference, found struct `String`\n     |\n     = note: expected\
    \ reference `&_`\n                   found struct `String`\nnote: required by\
    \ a bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct\
    \ `Cloned<std::vec::IntoIter<String>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpb69jt3lb.rs:17:44\n   |\n17 |       let mut lst = lst.into_iter().cloned().collect();\n\
    \   |                                              ^^^^^^^ method cannot be called\
    \ on `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n  \
    \ |\n   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror[E0599]: no method named `sort_by_key` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpb69jt3lb.rs:44:8\n   |\n44 |     it.sort_by_key(|&elem|\
    \ elem.len());\n   |        ^^^^^^^^^^^ method not found in `std::vec::IntoIter<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpb69jt3lb.rs:45:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n45 |     it\n   |     ^^ expected struct `Vec`, found struct `std::vec::IntoIter`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `std::vec::IntoIter<String>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.into_iter().cloned();\n    let mut sorted_lst\
    \ = lst.cloned();\n    sorted_lst.sort();\n    for val in sorted_lst {\n     \
    \   if !lst.contains(&val).unwrap() {\n            sorted_lst.remove(&val);\n\
    \        }\n    }\n    sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<std::vec::IntoIter<String> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpqu3abr9z.rs:17:35\n     |\n17   |     let mut lst =\
    \ lst.into_iter().cloned();\n     |                                   ^^^^^^ expected\
    \ reference, found struct `String`\n     |\n     = note: expected reference `&_`\n\
    \                   found struct `String`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `cloned` exists for struct `Cloned<std::vec::IntoIter<String>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpqu3abr9z.rs:18:30\n \
    \  |\n18 |       let mut sorted_lst = lst.cloned();\n   |                    \
    \            ^^^^^^ method cannot be called on `Cloned<std::vec::IntoIter<String>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<std::vec::IntoIter<String> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror[E0599]: no method named `contains` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpqu3abr9z.rs:21:17\n   |\n21 |         if !lst.contains(&val).unwrap()\
    \ {\n   |                 ^^^^^^^^ method not found in `Cloned<std::vec::IntoIter<String>>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_nalo_1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.is_empty() {\n        vec![]\n    }\n    let mut\
    \ res = vec![];\n    let mut i = 1;\n    for str in lst {\n        if i & 1 ==\
    \ 0 {\n            res.push(str);\n        }\n        i += 1;\n    }\n    res.sort_by(|a,\
    \ b| a.len_without_odd() > b.len_without_odd());\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptvxjoxof.rs:18:9\n   |\n\
    17 | /     if lst.is_empty() {\n18 | |         vec![]\n   | |         ^^^^^^ expected\
    \ `()`, found struct `Vec`\n19 | |     }\n   | |_____- expected this to be `()`\n\
    \   |\n   = note: expected unit type `()`\n                 found struct `Vec<_>`\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\nhelp: consider using a semicolon here\n \
    \  |\n19 |     };\n   |      +\n\nerror[E0599]: no method named `len_without_odd`\
    \ found for reference `&String` in the current scope\n  --> /tmp/tmptvxjoxof.rs:28:26\n\
    \   |\n28 |     res.sort_by(|a, b| a.len_without_odd() > b.len_without_odd());\n\
    \   |                          ^^^^^^^^^^^^^^^ method not found in `&String`\n\
    \nerror[E0599]: no method named `len_without_odd` found for reference `&String`\
    \ in the current scope\n  --> /tmp/tmptvxjoxof.rs:28:48\n   |\n28 |     res.sort_by(|a,\
    \ b| a.len_without_odd() > b.len_without_odd());\n   |                       \
    \                         ^^^^^^^^^^^^^^^ method not found in `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptvxjoxof.rs:28:24\n   |\n28 |     res.sort_by(|a,\
    \ b| a.len_without_odd() > b.len_without_odd());\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut list = vec![String::from(\"a\")];\n    for string\
    \ in lst {\n        list.push(string.to_lowercase());\n    }\n\n    list.sort_by_key(|x|\
    \ x.len() as i32).unwrap();\n\n    let mut list_final = vec![String::from(\"a\"\
    )];\n\n    for string in list {\n        if let Ok(count) = list_final.iter().filter(|&i|\
    \ i == string).count() {\n            list_final.push(string);\n        } else\
    \ {\n            list_final.push(string);\n        }\n    }\n\n    list_final.sort_by_key(|x|\
    \ x.to_lowercase()).unwrap();\n    list_final\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpo4nnv_tv.rs:22:42\n   |\n22 |     list.sort_by_key(|x|\
    \ x.len() as i32).unwrap();\n   |                                          ^^^^^^\
    \ method not found in `()`\n\nerror[E0277]: can't compare `&String` with `String`\n\
    \  --> /tmp/tmpo4nnv_tv.rs:27:60\n   |\n27 |         if let Ok(count) = list_final.iter().filter(|&i|\
    \ i == string).count() {\n   |                                               \
    \             ^^ no implementation for `&String == String`\n   |\n   = help: the\
    \ trait `PartialEq<String>` is not implemented for `&String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo4nnv_tv.rs:27:16\n\
    \   |\n27 |         if let Ok(count) = list_final.iter().filter(|&i| i == string).count()\
    \ {\n   |                ^^^^^^^^^   --------------------------------------------------\
    \ this expression has type `usize`\n   |                |\n   |              \
    \  expected `usize`, found enum `Result`\n   |\n   = note: expected type `usize`\n\
    \              found enum `Result<_, _>`\n\nerror[E0599]: no method named `unwrap`\
    \ found for unit type `()` in the current scope\n  --> /tmp/tmpo4nnv_tv.rs:34:50\n\
    \   |\n34 |     list_final.sort_by_key(|x| x.to_lowercase()).unwrap();\n   | \
    \                                                 ^^^^^^ method not found in `()`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_vec: Vec<String> = vec![];\n\n    for str\
    \ in lst {\n        let len = str.len();\n\n        if len % 2 != 0 {\n      \
    \      sorted_vec.push(str);\n        }\n    }\n\n    sorted_vec.sort();\n\n \
    \   sorted_vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpllvsrycf.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst.dedup();\n    lst.into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpnlxa0q1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `lst` as mutable, as it is\
    \ not declared as mutable\n  --> /tmp/tmpnlxa0q1r.rs:18:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n18 |     lst.dedup();\n\
    \   |     ^^^^^^^^^^^ cannot borrow as mutable\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_helper(lst, vec![String::new(), String::new(),\
    \ String::new()].into())\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmp0w45j6vl.rs:17:5\n   |\n17 |     sorted_list_sum_helper(lst, vec![String::new(),\
    \ String::new(), String::new()].into())\n   |     ^^^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_vec: Vec<String> = Vec::new();\n    for el\
    \ in lst {\n        let mut new_string = String::from(el);\n        let len =\
    \ new_string.chars().filter(|c| !c.is_whitespace()).count() as i32; // count whitespace\n\
    \        if len % 2 != 0 {\n            new_vec.push(new_string);\n        } else\
    \ {\n            let mut new_slice = new_string.chars().filter(|c| c.is_whitespace()).collect::<Vec<char>>();\n\
    \            new_slice.remove(0);\n            new_vec.push(new_slice.to_string());\n\
    \        }\n    }\n    new_vec.sort_by(|a, b| a.len().cmp(&b.len()));\n    new_vec\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<char>` doesn't implement `std::fmt::Display`\n   -->\
    \ /tmp/tmpjj3d0fx9.rs:26:36\n    |\n26  |               new_vec.push(new_slice.to_string());\n\
    \    |                                      ^^^^^^^^^ `Vec<char>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Vec<char>: std::fmt::Display`\n            which\
    \ is required by `Vec<char>: ToString`\n            `[char]: std::fmt::Display`\n\
    \            which is required by `[char]: ToString`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = String::new();\n    for e in lst {\n     \
    \   s += e;\n    }\n    s.into_lowercase();\n    let mut t = s.split_whitespace();\n\
    \    for e in t {\n        if e % 2 != 0 {\n            s.clear();\n         \
    \   break;\n        }\n    }\n    t.sort_by(|x, y| x.cmp(y));\n    t.collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp4ue2nyg.rs:19:14\n   |\n\
    19 |         s += e;\n   |              ^\n   |              |\n   |         \
    \     expected `&str`, found struct `String`\n   |              help: consider\
    \ borrowing here: `&e`\n\nerror[E0599]: no method named `into_lowercase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpp4ue2nyg.rs:21:7\n \
    \  |\n21 |     s.into_lowercase();\n   |       ^^^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `to_lowercase`\n\nerror[E0369]: cannot\
    \ mod `&str` by `{integer}`\n  --> /tmp/tmpp4ue2nyg.rs:24:14\n   |\n24 |     \
    \    if e % 2 != 0 {\n   |            - ^ - {integer}\n   |            |\n   |\
    \            &str\n\nerror[E0599]: no method named `sort_by` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpp4ue2nyg.rs:29:7\n   |\n\
    29 |     t.sort_by(|x, y| x.cmp(y));\n   |       ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpp4ue2nyg.rs:30:7\n     |\n30 \
    \  |     t.collect::<Vec<String>>()\n     |       ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut counter = String::from(\"\
    \");\n    for x in lst {\n        counter += x;\n    }\n\n    for y in lst {\n\
    \        if counter.chars().filter(|&x| x.to_string().len() > 1).count() > 1 {\n\
    \            sorted_list.push(y);\n        }\n    }\n\n    for y in lst {\n  \
    \      if !sorted_list.contains(&y) {\n            sorted_list.push(y);\n    \
    \    }\n    }\n\n    for y in lst {\n        if !sorted_list.contains(&y.to_string())\
    \ {\n            sorted_list.push(y);\n        }\n    }\n\n    sorted_list.sort_by_key(|&x|\
    \ x.to_string().len());\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoggs2jpg.rs:20:20\n   |\n\
    20 |         counter += x;\n   |                    ^\n   |                  \
    \  |\n   |                    expected `&str`, found struct `String`\n   |   \
    \                 help: consider borrowing here: `&x`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list: Vec<String> = Vec::new();\n    for\
    \ word in lst {\n        if sorted_list.len() == 0 {\n            sorted_list.push(word);\n\
    \        } else {\n            let length = word.len();\n            let mut is_sorted\
    \ = true;\n            for val in sorted_list {\n                if val.length()\
    \ == length {\n                    if val < word {\n                        is_sorted\
    \ = false;\n                    }\n                }\n            }\n        \
    \    if is_sorted {\n                sorted_list.push(word);\n            }\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpd09flhmw.rs:25:24\n   |\n25 |                 if\
    \ val.length() == length {\n   |                        ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list: Vec<String> = vec![];\n    for elem\
    \ in lst {\n        let len = elem.len();\n        if len % 2 != 0 {\n       \
    \     sorted_list.push(elem);\n        }\n    }\n    sorted_list.sort_by_key(|x|\
    \ x.len());\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpx_n4jzp3.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_list = vec![];\n    for s in lst.iter() {\n\
    \        if new_list.len() % 2 == 1 {\n            new_list.push(s);\n       \
    \ } else {\n            let mut s1 = s.chars().map(|c| c as i32).sum::<i32>();\n\
    \            let mut s2 = new_list[new_list.len() - 1].chars().map(|c| c as i32).sum::<i32>();\n\
    \            if s1 < s2 {\n                new_list.push(s);\n            } else\
    \ {\n                new_list.pop();\n                new_list.push(s);\n    \
    \        }\n        }\n    }\n    new_list.sort_by_key(|s| s.len() as u8);\n \
    \   new_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo99osyjv.rs:33:5\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n33 |     new_list\n   |     ^^^^^^^^ expected struct `String`, found\
    \ `&String`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `Vec<&String>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_helper(\n        &mut lst,\n        |s|\
    \ s.len() as u32,\n        |a, b| cmp::Ordering::Less { a: a, b: b },\n    )\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp7nm39c39.rs:20:16\n   |\n20 |         |a, b| cmp::Ordering::Less\
    \ { a: a, b: b },\n   |                ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmp7nm39c39.rs:17:5\n   |\n17 |     sorted_list_sum_helper(\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for ele in lst.iter().rev()\
    \ {\n        if ele.chars().count() % 2 != 0 {\n            ele += ele.chars().last().unwrap();\n\
    \        } else {\n            res.push_back(ele);\n        }\n    }\n    res.sort_by_key(|x|\
    \ x.chars().count()).reverse();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&String`\n  --> /tmp/tmpam6j0zcy.rs:20:13\n   |\n20 |             ele += ele.chars().last().unwrap();\n\
    \   |             ---^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&String`\n\nerror[E0599]: no method named\
    \ `push_back` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpam6j0zcy.rs:22:17\n\
    \   |\n22 |             res.push_back(ele);\n   |                 ^^^^^^^^^ method\
    \ not found in `Vec<_>`\n\nerror[E0599]: no method named `reverse` found for unit\
    \ type `()` in the current scope\n  --> /tmp/tmpam6j0zcy.rs:25:44\n   |\n25 |\
    \     res.sort_by_key(|x| x.chars().count()).reverse();\n   |                \
    \                            ^^^^^^^ method not found in `()`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0368, E0599.\n\
    For more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_vec: Vec<String> = Vec::new();\n    let\
    \ mut strings = vec![];\n    for elem in lst {\n        let str: String = elem.to_owned();\n\
    \        if strings.len() == 0 || strings.last().unwrap().len() < str.len() {\n\
    \            strings.push(str);\n        } else {\n            if strings.last().unwrap().len()\
    \ == str.len() {\n                sorted_vec.push(*strings);\n               \
    \ strings = Vec::new();\n            } else {\n                strings.push(str);\n\
    \            }\n        }\n    }\n    sorted_vec.push(*strings);\n    sorted_vec\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmp2x0rdk1j.rs:21:42\n\
    \   |\n18 |     let mut strings = vec![];\n   |         ----------- consider giving\
    \ `strings` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    ...\n21 |         if strings.len() == 0 || strings.last().unwrap().len() < str.len()\
    \ {\n   |                                          ^^^^ cannot infer type for\
    \ type parameter `T`\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut copy = vec![String::new(); lst.len()];\n    for\
    \ x in lst {\n        copy[lst.iter().position(|y| x.len() > y.len()).unwrap()]\
    \ = x;\n    }\n    copy\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `lst`\n   --> /tmp/tmp76xl8qth.rs:19:14\n\
    \    |\n16  | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n    |   \
    \                 --- move occurs because `lst` has type `Vec<String>`, which\
    \ does not implement the `Copy` trait\n17  |     let mut copy = vec![String::new();\
    \ lst.len()];\n18  |     for x in lst {\n    |              --- `lst` moved due\
    \ to this implicit call to `.into_iter()`\n19  |         copy[lst.iter().position(|y|\
    \ x.len() > y.len()).unwrap()] = x;\n    |              ^^^^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `lst`\n    = note: borrow occurs due to deref coercion to\
    \ `[String]`\nhelp: consider iterating over a slice of the `Vec<String>`'s content\
    \ to avoid moving into the `for` loop\n    |\n18  |     for x in &lst {\n    |\
    \              +\n\nerror[E0382]: borrow of moved value: `x`\n  --> /tmp/tmp76xl8qth.rs:19:34\n\
    \   |\n18 |     for x in lst {\n   |         - move occurs because `x` has type\
    \ `String`, which does not implement the `Copy` trait\n19 |         copy[lst.iter().position(|y|\
    \ x.len() > y.len()).unwrap()] = x;\n   |                                  ^^^\
    \ -                              - value moved here\n   |                    \
    \              |   |\n   |                                  |   borrow occurs\
    \ due to use in closure\n   |                                  value borrowed\
    \ here after move\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut last_idx =\
    \ -1;\n\n    for e in lst {\n        let idx = e.len();\n        if idx > last_idx\
    \ {\n            sorted_list.push(e);\n            last_idx = idx;\n        }\
    \ else {\n            let idx = e.len();\n            if idx > last_idx {\n  \
    \              sorted_list.push(e);\n                last_idx = idx;\n       \
    \     }\n        }\n    }\n\n    return sorted_list;\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpd1l50jeq.rs:18:24\n\
    \   |\n18 |     let mut last_idx = -1;\n   |                        ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort().by_ref().collect()\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `by_ref` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmp6fhz7mnc.rs:17:16\n   |\n17 |     lst.sort().by_ref().collect()\n\
    \   |                ^^^^^^ method not found in `()`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    fn is_odd(i: u32) -> bool {\n        i % 2 == 1\n    }\n\
    \    fn swap(mut a1: &mut String, _i: u32, mut a2: &mut String) {\n        let\
    \ tmp_val1 = a1.as_str();\n        a1.as_str() = a2.as_str();\n        a2.as_str()\
    \ = tmp_val1;\n    }\n    fn is_sorted(mut lst: Vec<String>) -> bool {\n     \
    \   for j in 0..lst.len() - 1 {\n            for i in 0..(j + 1) {\n         \
    \       if is_odd(i) && is_odd(j + 1) {\n                    swap(&mut lst[j],\
    \ i, &mut lst[j + 1]);\n                }\n            }\n        }\n        true\n\
    \    }\n    if is_sorted(lst) == false {\n        false\n    } else {\n      \
    \  sorted_list_sum(lst)\n    }\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1vs0nywr.rs:36:9\n   |\n\
    16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |             \
    \                            ----------- expected `Vec<String>` because of return\
    \ type\n...\n36 |         false\n   |         ^^^^^ expected struct `Vec`, found\
    \ `bool`\n   |\n   = note: expected struct `Vec<String>`\n                found\
    \ type `bool`\n\nerror[E0070]: invalid left-hand side of assignment\n  --> /tmp/tmp1vs0nywr.rs:22:21\n\
    \   |\n22 |         a1.as_str() = a2.as_str();\n   |         ----------- ^\n \
    \  |         |\n   |         cannot assign to this expression\n\nerror[E0070]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmp1vs0nywr.rs:23:21\n   |\n\
    23 |         a2.as_str() = tmp_val1;\n   |         ----------- ^\n   |       \
    \  |\n   |         cannot assign to this expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1vs0nywr.rs:28:27\n   |\n28 |                 if is_odd(i)\
    \ && is_odd(j + 1) {\n   |                           ^ expected `u32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to a `u32` and panic if the converted value\
    \ doesn't fit\n   |\n28 |                 if is_odd(i.try_into().unwrap()) &&\
    \ is_odd(j + 1) {\n   |                            ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1vs0nywr.rs:28:40\n   |\n28 |              \
    \   if is_odd(i) && is_odd(j + 1) {\n   |                                    \
    \    ^^^^^ expected `u32`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to a `u32` and panic if the converted value doesn't fit\n   |\n28 |        \
    \         if is_odd(i) && is_odd((j + 1).try_into().unwrap()) {\n   |        \
    \                                +     +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1vs0nywr.rs:29:39\n   |\n29 |              \
    \       swap(&mut lst[j], i, &mut lst[j + 1]);\n   |                         \
    \              ^ expected `u32`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to a `u32` and panic if the converted value doesn't fit\n   |\n29 |\
    \                     swap(&mut lst[j], i.try_into().unwrap(), &m"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.iter().map(|s| s.len()).filter(|&len| len % 2 == 0).cloned().collect().sort().collect()\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpfjeq69dr.rs:17:20:\
    \ 17:31] as FnOnce<(&String,)>>::Output == &_`\n  --> /tmp/tmpfjeq69dr.rs:17:61\n\
    \   |\n17 |     lst.iter().map(|s| s.len()).filter(|&len| len % 2 == 0).cloned().collect().sort().collect()\n\
    \   |                                                             ^^^^^^ expected\
    \ reference, found `usize`\n   |\n   = note: expected reference `&_`\n       \
    \            found type `usize`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Map<std::slice::Iter<'_, String>, [closure@/tmp/tmpfjeq69dr.rs:17:20:\
    \ 17:31]>`\n   = note: 1 redundant requirement hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_,\
    \ String>, [closure@/tmp/tmpfjeq69dr.rs:17:20: 17:31]>, [closure@/tmp/tmpfjeq69dr.rs:17:40:\
    \ 17:59]>`\n\nerror[E0631]: type mismatch in closure arguments\n  --> /tmp/tmpfjeq69dr.rs:17:61\n\
    \   |\n17 |     lst.iter().map(|s| s.len()).filter(|&len| len % 2 == 0).cloned().collect().sort().collect()\n\
    \   |                                        -------------------  ^^^^^^ expected\
    \ signature of `for<'r> fn(&'r &_) -> _`\n   |                               \
    \         |\n   |                                        found signature of `for<'r>\
    \ fn(&'r usize) -> _`\n   |\n   = note: required because of the requirements on\
    \ the impl of `Iterator` for `Filter<Map<std::slice::Iter<'_, String>, [closure@/tmp/tmpfjeq69dr.rs:17:20:\
    \ 17:31]>, [closure@/tmp/tmpfjeq69dr.rs:17:40: 17:59]>`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Filter<Map<std::slice::Iter<'_, String>,\
    \ [closure@/tmp/tmpfjeq69dr.rs:17:20: 17:31]>, [closure@/tmp/tmpfjeq69dr.rs:17:40:\
    \ 17:59]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpfjeq69dr.rs:17:70\n\
    \   |\n17 |        lst.iter().map(|s| s.len()).filter(|&len| len % 2 == 0).cloned().collect().sort().collect()\n\
    \   |                                                                        \
    \ ^^^^^^^ method cannot be called on `Cloned<Filter<Map<std::slice::Iter<'_, String"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = lst;\n    res.sort();\n    res.dedup();\n\
    \    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp2hbaq43q.rs:25:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = vec![];\n    let mut counter = 1;\n \
    \   for word in lst {\n        sorted.push((word, &counter));\n        counter\
    \ += 1;\n    }\n\n    let mut i = 0;\n    while i < sorted.len() {\n        let\
    \ (word, count) = (sorted[i], counter);\n        let mut j = i;\n        while\
    \ j < sorted.len() && count == sorted[j][1].0 {\n            j += 1;\n       \
    \ }\n        if j > i + 1 {\n            sorted.swap(i, j);\n        }\n     \
    \   i += 1;\n    }\n    sorted.sort_by(|a, b| a[0].cmp(&b[0]));\n    sorted\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(String, &{integer})`\n\
    \  --> /tmp/tmpazpvu1dr.rs:28:44\n   |\n28 |         while j < sorted.len() &&\
    \ count == sorted[j][1].0 {\n   |                                            ^^^^^^^^^^^^\
    \ help: to access tuple elements, use: `sorted[j].1`\n\nerror[E0608]: cannot index\
    \ into a value of type `&(String, &{integer})`\n  --> /tmp/tmpazpvu1dr.rs:36:27\n\
    \   |\n36 |     sorted.sort_by(|a, b| a[0].cmp(&b[0]));\n   |                \
    \           ^^^^\n\nerror[E0608]: cannot index into a value of type `&(String,\
    \ &{integer})`\n  --> /tmp/tmpazpvu1dr.rs:36:37\n   |\n36 |     sorted.sort_by(|a,\
    \ b| a[0].cmp(&b[0]));\n   |                                     ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpazpvu1dr.rs:37:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                                        \
    \ ----------- expected `Vec<String>` because of return type\n...\n37 |     sorted\n\
    \   |     ^^^^^^ expected struct `String`, found tuple\n   |\n   = note: expected\
    \ struct `Vec<String>`\n              found struct `Vec<(String, &{integer})>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut lst = lst.iter().cloned().collect::<Vec<_>>();\n\
    \    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmppuen9err.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    debug_assert!(lst.len() > 0);\n    let mut sorted_vec\
    \ = Vec::new();\n    let mut prev_word = String::new();\n    let mut curr_word\
    \ = String::new();\n\n    for curr_word in lst {\n        sorted_vec.clear();\n\
    \        sorted_vec.push(curr_word);\n\n        while sorted_vec.len() > 0 {\n\
    \            if sorted_vec[0].len() > sorted_vec[0].len() as usize {\n       \
    \         sorted_vec.remove(0);\n                sorted_vec.push(String::from(\"\
    \"));\n            } else {\n                break;\n            }\n        }\n\
    \n        if prev_word != curr_word {\n            sorted_vec.sort_by(|a, b| b.len()\
    \ - a.len());\n            sorted_vec.sort_by(|a, b| a.cmp(b));\n        }\n\n\
    \        prev_word = curr_word;\n        sorted_vec.push(curr_word);\n    }\n\n\
    \    sorted_vec\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyk01o7hm.rs:36:39\n   |\n\
    36 |             sorted_vec.sort_by(|a, b| b.len() - a.len());\n   |         \
    \                              ^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst_iter = lst.iter().cloned().collect::<Vec<_>>();\n\
    \n    sorted_lst_iter.sort_by_key(|s| s.len() as u8);\n\n    sorted_lst_iter\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp4sr_7x6r.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst;\n    sorted_list.sort();\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmp52ks9yrc.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_helper(vec![], lst)\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_helper` in this scope\n\
    \  --> /tmp/tmp9vpiag0f.rs:17:5\n   |\n17 |     sorted_list_sum_helper(vec![],\
    \ lst)\n   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    let mut res = vec![];\n    for el in\
    \ lst {\n        if res.len() == 0 {\n            res.push(el);\n        } else\
    \ if el.len() < res[0].len() {\n            res.push(el);\n        } else {\n\
    \            while res.len() > 0 && res[0].len() < el.len() {\n              \
    \  res.pop();\n            }\n            res.push(el);\n        }\n    }\n  \
    \  res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmpi252_84l.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_impl(lst, String::new())\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_impl` in this scope\n\
    \  --> /tmp/tmpe408x7gr.rs:17:5\n   |\n17 |     sorted_list_sum_impl(lst, String::new())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_list = vec![];\n    for (i, v) in lst.iter().enumerate()\
    \ {\n        let new_v = if i % 2 == 0 {\n            String::from(v.clone())\n\
    \        } else {\n            String::from(v.clone())\n        };\n        new_list.push(new_v);\n\
    \    }\n    new_list.sort();\n    new_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpbqpwvrfr.rs:32:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    for e in lst {\n   \
    \     if !sorted_lst.contains(&e) {\n            sorted_lst.push(e);\n       \
    \ }\n    }\n    sorted_lst.sort();\n    sorted_lst\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpwkziuiez.rs:29:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for str in lst {\n        let\
    \ len = str.len();\n        if len % 2 == 1 {\n            str += String::from(\"\
    \ \");\n        }\n        match res {\n            [] => (),\n            _ =>\
    \ {\n                let new_str = (&str).to_string();\n                let lower\
    \ = new_str.chars().nth(len / 2).unwrap();\n                let upper = new_str.chars().nth(len\
    \ / 2).unwrap();\n                res.push(String::from(upper));\n           \
    \     res.push(String::from(lower));\n            }\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0af85tl.rs:21:20\n   |\n\
    21 |             str += String::from(\" \");\n   |                    ^^^^^^^^^^^^^^^^^\n\
    \   |                    |\n   |                    expected `&str`, found struct\
    \ `String`\n   |                    help: consider borrowing here: `&String::from(\"\
    \ \")`\n\nerror[E0529]: expected an array or slice, found `Vec<_>`\n  --> /tmp/tmpb0af85tl.rs:24:13\n\
    \   |\n23 |         match res {\n   |               --- help: consider slicing\
    \ here: `res[..]`\n24 |             [] => (),\n   |             ^^ pattern cannot\
    \ match with input type `Vec<_>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0529.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by_key(|x| x.len());\n    let mut sorted_list\
    \ = vec![];\n    for string in lst {\n        if sorted_list.len() < sorted_list.iter().filter(|x|\
    \ x.len() == string.len()).count() {\n            sorted_list.push(string);\n\
    \        }\n    }\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `&&T`\n  --> /tmp/tmp2qrp_di7.rs:20:59\n\
    \   |\n20 |         if sorted_list.len() < sorted_list.iter().filter(|x| x.len()\
    \ == string.len()).count() {\n   |                                           \
    \                ^ consider giving this closure parameter the explicit type `&&T`,\
    \ where the type parameter `T` is specified\n   |\n   = note: type must be known\
    \ at this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut result = vec![];\n    let mut iter = lst.into_iter().collect::<Vec<_>>();\n\
    \    for word in iter {\n        if word.is_empty() {\n            continue;\n\
    \        }\n        result.push(word);\n    }\n    result.sort_by(|a, b| {\n \
    \       let len_a = a.len();\n        let len_b = b.len();\n        len_a < len_b\
    \ ? len_a : len_b\n    });\n    result\n}\n\nfn main() {\n    let candidate =\
    \ sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `len_a`\n\
    \  --> /tmp/tmpflfssddv.rs:28:25\n   |\n28 |         len_a < len_b ? len_a : len_b\n\
    \   |                         ^^^^^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut vec:\
    \ Vec<String> = vec![];\n    for (word, _) in lst.into_iter().zip(vec) {\n   \
    \     if vec.len() == 0 {\n            vec.push(word);\n        } else {\n   \
    \         vec.sort_by(|a, b| b.len() as i32 - a.len() as i32);\n            if\
    \ vec.len() == 1 {\n                res.push(vec[0]);\n            } else {\n\
    \                res.push(vec[0]);\n            }\n            vec.clear();\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8_emyzw2.rs:23:32\n   |\n\
    23 |             vec.sort_by(|a, b| b.len() as i32 - a.len() as i32);\n   |  \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `std::cmp::Ordering`,\
    \ found `i32`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_vec = vec![];\n    for elem in lst {\n\
    \        if elem.len() % 2 == 0 {\n            sorted_vec.push(elem);\n      \
    \  }\n    }\n\n    if let Some(mut v) = sorted_vec.iter_mut().find(|&x| x.len()\
    \ < sorted_vec.len() as i32) {\n        v.sort_by_key(|x| x.len() as i32);\n \
    \       v.swap(0, v.len() - 1);\n    }\n    sorted_vec\n}\n\nfn main() {\n   \
    \ let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjnosh5z0.rs:24:68\n   |\n\
    24 |     if let Some(mut v) = sorted_vec.iter_mut().find(|&x| x.len() < sorted_vec.len()\
    \ as i32) {\n   |                                                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`, found `i32`\n   |\nhelp: you\
    \ can convert an `i32` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n24 |     if let Some(mut v) = sorted_vec.iter_mut().find(|&x| x.len() <\
    \ (sorted_vec.len() as i32).try_into().unwrap()) {\n   |                     \
    \                                               +                       +++++++++++++++++++++\n\
    \nerror[E0599]: no method named `sort_by_key` found for mutable reference `&mut\
    \ String` in the current scope\n  --> /tmp/tmpjnosh5z0.rs:25:11\n   |\n25 |  \
    \       v.sort_by_key(|x| x.len() as i32);\n   |           ^^^^^^^^^^^ method\
    \ not found in `&mut String`\n\nerror[E0599]: no method named `swap` found for\
    \ mutable reference `&mut String` in the current scope\n  --> /tmp/tmpjnosh5z0.rs:26:11\n\
    \   |\n26 |         v.swap(0, v.len() - 1);\n   |           ^^^^ method not found\
    \ in `&mut String`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for el in lst {\n     \
    \   let len = el.chars().filter(|&c| c.is_ascii_alphanumeric()).count();\n   \
    \     if len % 2 != 0 {\n            res.push(el);\n        }\n    }\n    res.sort_by_key(|&s|\
    \ s.chars().filter(|&c| c.is_ascii_alphanumeric()).count());\n    return res;\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of a shared reference\n  --> /tmp/tmpb56jmbcz.rs:24:22\n\
    \   |\n24 |     res.sort_by_key(|&s| s.chars().filter(|&c| c.is_ascii_alphanumeric()).count());\n\
    \   |                      ^-\n   |                      ||\n   |            \
    \          |data moved here\n   |                      |move occurs because `s`\
    \ has type `String`, which does not implement the `Copy` trait\n   |         \
    \             help: consider removing the `&`: `s`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = vec![];\n    for s in lst {\n        if s.len()\
    \ % 2 != 0 {\n            s.push(s);\n        }\n    }\n    sort_vec(s)\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sort_vec` in this scope\n  --> /tmp/tmpspvcgbf6.rs:23:5\n\
    \   |\n23 |     sort_vec(s)\n   |     ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpspvcgbf6.rs:20:20\n   |\n20 |             s.push(s);\n\
    \   |                    ^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![String::new(); lst.len()];\n    let\
    \ mut j = 0;\n    for i in lst.into_iter().skip(1).cloned() {\n        while j\
    \ < lst.len() && i.len() < lst[j].len() {\n            res[j] = i;\n         \
    \   j += 1\n        }\n        res[j..].push(i);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Skip<std::vec::IntoIter<String>>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmprbheawib.rs:19:38\n     |\n19   |\
    \     for i in lst.into_iter().skip(1).cloned() {\n     |                    \
    \                  ^^^^^^ expected reference, found struct `String`\n     |\n\
    \     = note: expected reference `&_`\n                   found struct `String`\n\
    note: required by a bound in `cloned`\n\nerror[E0271]: type mismatch resolving\
    \ `<Skip<std::vec::IntoIter<String>> as Iterator>::Item == &_`\n  --> /tmp/tmprbheawib.rs:19:14\n\
    \   |\n19 |     for i in lst.into_iter().skip(1).cloned() {\n   |            \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found reference\n\
    \   |\n   = note: expected struct `String`\n           found reference `&_`\n\
    \   = note: required because of the requirements on the impl of `Iterator` for\
    \ `Cloned<Skip<std::vec::IntoIter<String>>>`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `Cloned<Skip<std::vec::IntoIter<String>>>`\n\
    \nerror[E0271]: type mismatch resolving `<Skip<std::vec::IntoIter<String>> as\
    \ Iterator>::Item == &_`\n  --> /tmp/tmprbheawib.rs:19:14\n   |\n19 |     for\
    \ i in lst.into_iter().skip(1).cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found reference\n   |\n   = note: expected struct\
    \ `String`\n           found reference `&_`\n   = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<Skip<std::vec::IntoIter<String>>>`\n\
    \nerror[E0599]: no method named `push` found for slice `[String]` in the current\
    \ scope\n  --> /tmp/tmprbheawib.rs:24:18\n   |\n24 |         res[j..].push(i);\n\
    \   |                  ^^^^ method not found in `[String]`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut list = vec![];\n    for str in lst {\n       \
    \ list.push(str);\n    }\n    list.sort_by_key(|x| x.len().unwrap());\n    list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp9r67lwf6.rs:21:34\n   |\n21 |     list.sort_by_key(|x|\
    \ x.len().unwrap());\n   |                                  ^^^^^^ method not\
    \ found in `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut new_list = vec![];\n    for word in lst {\n  \
    \      let len = word.chars().count() as u32;\n        if len % 2 != 0 {\n   \
    \         new_list.push(word);\n        }\n    }\n    new_list.sort_by_key(|x|\
    \ x.chars().count() as i32);\n    new_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprdkqj1sy.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = Vec::new();\n    for word in lst.iter()\
    \ {\n        if res.iter().position(|x| x == word) != res.iter().position(|x|\
    \ x == word.to_lowercase()) {\n            res.push(word);\n        }\n    }\n\
    \    res.sort_by_key(|x| x.len());\n    res\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpqnjijc3w.rs:19:54\n    |\n19  |         if res.iter().position(|x|\
    \ x == word) != res.iter().position(|x| x == word.to_lowercase()) {\n    |   \
    \                                                   ^^^^ doesn't have a size known\
    \ at compile-time\n    |\n    = help: the trait `Sized` is not implemented for\
    \ `str`\nnote: required by a bound in `core::slice::<impl [T]>::iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpqnjijc3w.rs:19:61\n   |\n19 |         if res.iter().position(|x| x ==\
    \ word) != res.iter().position(|x| x == word.to_lowercase()) {\n   |         \
    \                                                    ^^^^^^^^ doesn't have a size\
    \ known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `str`\n   = help: the trait `Iterator` is implemented for `std::slice::Iter<'a,\
    \ T>`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `std::slice::Iter<'_, str>`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmpqnjijc3w.rs:19:16\n\
    \   |\n19 |         if res.iter().position(|x| x == word) != res.iter().position(|x|\
    \ x == word.to_lowercase()) {\n   |                ^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: required because of the requirements on the impl of `Deref` for `Vec<str>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpqnjijc3w.rs:19:23\n   |\n19 |         if res.iter().position(|x|\
    \ x == word) != res.iter().position(|x| x == word.to_lowercase()) {\n   |    \
    \                   ^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `str`\n   = help: the trait\
    \ `Iterator` is implemented for `std::slice::Iter<'a, T>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n    let mut num_duplicates\
    \ = 0;\n    for s in lst {\n        if s.len() > sorted_lst.len() {\n        \
    \    sorted_lst.push(s);\n            num_duplicates += 1;\n        } else if\
    \ s.len() == sorted_lst.len() {\n            num_duplicates += 1;\n          \
    \  if num_duplicates > 1 {\n                sorted_lst.push(s);\n            \
    \    num_duplicates = 1;\n            } else {\n                sorted_lst.sort();\n\
    \            }\n        }\n    }\n    sorted_lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpxep34s35.rs:38:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = vec![];\n\n    let mut cnt = 0;\n\
    \    let mut i = 1;\n    while i < lst.len() {\n        if lst[i] != lst[cnt]\
    \ {\n            sorted_lst.push(lst[i]);\n        }\n        i += 1;\n      \
    \  cnt += 1;\n    }\n\n    sorted_lst.push(lst[cnt]);\n\n    sorted_lst\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of index of `Vec<String>`\n  --> /tmp/tmpfd32usvz.rs:23:29\n\
    \   |\n23 |             sorted_lst.push(lst[i]);\n   |                       \
    \      ^^^^^^ move occurs because value has type `String`, which does not implement\
    \ the `Copy` trait\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n\
    \  --> /tmp/tmpfd32usvz.rs:29:21\n   |\n29 |     sorted_lst.push(lst[cnt]);\n\
    \   |                     ^^^^^^^^ move occurs because value has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::new();\n    let mut sorted_list\
    \ = lst.into_iter().enumerate().filter(|&(i, _)| i % 2 == 1).collect();\n    sorted_list.sort_by(|a,\
    \ b| a.1.len().cmp(&b.1.len()));\n    sorted_list\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmplr2o3hi4.rs:19:5\n\
    \   |\n18 |     let mut sorted_list = lst.into_iter().enumerate().filter(|&(i,\
    \ _)| i % 2 == 1).collect();\n   |         --------------- consider giving `sorted_list`\
    \ a type\n19 |     sorted_list.sort_by(|a, b| a.1.len().cmp(&b.1.len()));\n  \
    \ |     ^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must be known at\
    \ this point\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut l = lst.clone();\n    l.sort_by(|a, b| a.len().cmp(&b.len()));\n\
    \    l\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpsn8ar969.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort();\n    lst\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `lst` as mutable, as it is not declared as\
    \ mutable\n  --> /tmp/tmp_nalo_1r.rs:17:5\n   |\n16 | fn sorted_list_sum(lst:\
    \ Vec<String>) -> Vec<String> {\n   |                    --- help: consider changing\
    \ this to be mutable: `mut lst`\n17 |     lst.sort();\n   |     ^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut vec: Vec<String> = vec![String::new(); lst.len()];\n\
    \n    for i in 0..lst.len() {\n        vec[i] = String::from(&lst[i]);\n    }\n\
    \n    vec.iter_mut().sort_by(|a, b| a.len() < b.len()).collect();\n    vec\n}\n\
    \nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::slice::IterMut`\
    \ in the current scope\n  --> /tmp/tmpo5usxi1u.rs:23:20\n   |\n23 |     vec.iter_mut().sort_by(|a,\
    \ b| a.len() < b.len()).collect();\n   |                    ^^^^^^^ method not\
    \ found in `std::slice::IterMut<'_, String>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for str in lst {\n        if\
    \ res.iter().any(|&s| str == s) {\n            continue;\n        }\n        res.push(str);\n\
    \    }\n    res.sort_by(|a, b| a.len() < b.len());\n    res\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjkxzcuc1.rs:24:24\n   |\n\
    24 |     res.sort_by(|a, b| a.len() < b.len());\n   |                        ^^^^^^^^^^^^^^^^^\
    \ expected enum `std::cmp::Ordering`, found `bool`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut list = vec![];\n    let mut counter = Vec::new();\n\
    \    for word in lst.iter() {\n        if !counter.contains(&word.len()) {\n \
    \           list.push(word);\n            counter.push(word.len());\n        }\
    \ else {\n            list.remove_by_index(counter.iter().position(|x| *x == word.len()).unwrap());\n\
    \            list.push(word);\n        }\n    }\n    list\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_by_index` found for struct `Vec<&String>`\
    \ in the current scope\n  --> /tmp/tmp7dkwemho.rs:24:18\n   |\n24 |          \
    \   list.remove_by_index(counter.iter().position(|x| *x == word.len()).unwrap());\n\
    \   |                  ^^^^^^^^^^^^^^^ method not found in `Vec<&String>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7dkwemho.rs:28:5\n   |\n16 | fn\
    \ sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |                   \
    \                      ----------- expected `Vec<String>` because of return type\n\
    ...\n28 |     list\n   |     ^^^^ expected struct `String`, found `&String`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = Vec::new();\n    let mut len = 0.;\n\
    \    for s in lst {\n        len += s.len();\n    }\n    let mut i = 0;\n    while\
    \ i < lst.len() {\n        if len % 2 == 1 {\n            sorted_lst.push(lst.remove(i));\n\
    \        } else {\n            sorted_lst.push(lst.remove(i));\n            i\
    \ += 1;\n        }\n    }\n    sorted_lst.sort();\n    sorted_lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `usize` to `{float}`\n  --> /tmp/tmpu4wj6os8.rs:20:13\n\
    \   |\n20 |         len += s.len();\n   |             ^^ no implementation for\
    \ `{float} += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `{float}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: cannot mod `{float}` by `{integer}`\n  --> /tmp/tmpu4wj6os8.rs:24:16\n\
    \   |\n24 |         if len % 2 == 1 {\n   |                ^ no implementation\
    \ for `{float} % {integer}`\n   |\n   = help: the trait `Rem<{integer}>` is not\
    \ implemented for `{float}`\n   = help: the following other types implement trait\
    \ `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n\
    \             <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n  \
    \           <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n      \
    \       <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n        \
    \   and 54 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst;\n    sorted_list.sort_by(|a,\
    \ b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpz7bzwqib.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    vec!lst.sort_by(|a, b| a.len()\
    \ < b.len());\n    vec!lst.iter().for_each(|x| res.push(x));\n    res\n}\n\nfn\
    \ main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `lst`\n  --> /tmp/tmpewhwv3j1.rs:18:9\n\
    \   |\n18 |     vec!lst.sort_by(|a, b| a.len() < b.len());\n   |         ^^^ expected\
    \ one of `(`, `[`, or `{`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    vec!(\"aa\".to_string(), \"ab\".to_string(), \"ac\".to_string(),\
    \ \"ad\".to_string(), \"ae\".to_string(), \"af\".to_string(), \"ag\".to_string(),\
    \ \"ah\".to_string(), \"ai\".to_string(), \"aj\".to_string(), \"ak\".to_string(),\
    \ \"am\".to_string(), \"an\".to_string(), \"ao\".to_string(), \"aq\".to_string(),\
    \ \"ar\".to_string(), \"as\".to_string(), \"at\".to_string(), \"au\".to_string(),\
    \ \"av\".to_string(), \"aw\".to_string(), \"ax\".to_string(), \"ay\".to_string(),\
    \ \"az\".to_string(), \"ba\".to_string(), \"bb\".to_string(), \"bc\".to_string(),\
    \ \"bd\".to_string(), \"be\".to_string(), \"bf\".to_string(), \"bg\".to_string(),\
    \ \"bh\".to_string(), \"bi\".to_string(), \"bj\".to_string(), \"bk\".to_string(),\
    \ \"bl\".to_string(), \"bm\".to_string(), \"bn\".to_string(), \"bo\".to_string(),\
    \ \"bp\".to_string(), \"bq\".to_string(), \"br\".to_string(), \"bs\".to_string(),\
    \ \"bt\".to_string(), \"bu\".to_string(), \"bx\".to_string(), \"by\".to_string(),\
    \ \"bz\".to_string(), \"ca\".to_string(), \"cb\".to_string(), \"cc\".to_string(),\
    \ \"cd\".to_string(), \"ce\".to_string(), \"cf\".to_string(), \"cg\".to_string(),\
    \ \"ch\".to_string(), \"ci\".to_string(), \"cj\".to_string(), \"ck\".to_string(),\
    \ \"cl\".to_string(), \"cm\".to_string(), \"cn\".to_string(), \"co\".to_string(),\
    \ \"cp\".to_string(), \"cq\".to_string(), \"cr\".to_string(), \"cs\".to_string(),\
    \ \"ct\".to_string(), \"cu\".to_string(), \"cv\".to_string(), \"cw\".to_string(),\
    \ \"cx\".to_string(), \"cy\".to_string(), \"cz\".to_string(), \"da\".to_string(),\
    \ \"db\".to_string(), \"dc\".to_string(), \"dd\".to_string(), \"de\".to_string(),\
    \ \"df\".to_string(), \"dg\".to_string(), \"dh\".to_string(), \"di\".to_string(),\
    \ \"dj\".to_string(), \"dk\".to_string(), \"dl\".to_string(), \"dm\".to_string(),\
    \ \"dn\".to_string(), \"do\".to_string(), \"dp\".to_string(), \"dq\".to_string(),\
    \ \"dr\".to_string(), \"ds\".to_string(), \"dt\".to_string(), \"du\".to_string(),\
    \ \"dv\".to_string(), \"dw\".to_string(), \"dx\".to_string(), \"dy\".to_string(),\
    \ \"dz\".to_string(), \"ea\".to_string(), \"eb\".to_string(), \"ec\".to_string(),\
    \ \"ed\".to_string(), \"ee\".to_string(), \"ef\".to_string(), \"eg\".to_string(),\
    \ \"eh\".to_string(), \"ei\".to_string(), \"ej\".to_string(), \"ek\".to_string(),\
    \ \"el\".to_string(), \"em\".to_string(), \"en\".to_string(), \"eo\".to_string(),\
    \ \"ep\".to_string(), \"eq\".to_string(), \"er\".to_string(), \"es\".to_string(),\
    \ \"et\".to_string(), \"eu\".to_string(), \"ev\".to_string(), \"ew\".to_string(),\
    \ \"ex\".to_string(), \"ey\".to_string(), \"e\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp0sg_kjr_.rs:28:202\n\
    \   |\n28 |       assert_eq!(candidate(vec![String::from(\"aaaa\"), String::from(\"\
    bbbb\"), String::from(\"dd\"), String::from(\"cc\")]), vec![String::from(\"cc\"\
    ), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"bbbb\")...\n \
    \  |  __________________________________________________________________________________________________________________________________________________________________________________________________________^\n\
    29 | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    let mut total_sum =\
    \ 0;\n\n    for word in lst {\n        if total_sum % 2 != 0 {\n            sorted_list.push(word);\n\
    \        }\n        total_sum += word.len();\n    }\n\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `word`\n  --> /tmp/tmpff7qcksg.rs:24:22\n\
    \   |\n20 |     for word in lst {\n   |         ----\n   |         |\n   |   \
    \      this reinitialization might get skipped\n   |         move occurs because\
    \ `word` has type `String`, which does not implement the `Copy` trait\n21 |  \
    \       if total_sum % 2 != 0 {\n22 |             sorted_list.push(word);\n  \
    \ |                              ---- value moved here\n23 |         }\n24 | \
    \        total_sum += word.len();\n   |                      ^^^^^^^^^^ value\
    \ borrowed here after move\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut counter = 0;\n    let mut sorted_lst = Vec::new();\n\
    \n    for elem in lst.iter() {\n        if counter % 2 != 0 {\n            sorted_lst.push(*elem);\n\
    \        }\n        counter += 1;\n    }\n\n    sorted_lst\n}\n\nfn main() {\n\
    \    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0507]: cannot move out of `*elem` which is behind a shared reference\n\
    \  --> /tmp/tmpb34vt3j8.rs:22:29\n   |\n22 |             sorted_lst.push(*elem);\n\
    \   |                             ^^^^^ move occurs because `*elem` has type `String`,\
    \ which does not implement the `Copy` trait\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_lst = Vec::new();\n    sorted_lst.push(\"\
    a\".to_owned());\n    for s in lst {\n        if s.len() % 2 != 0 {\n        \
    \    sorted_lst.push(s);\n        }\n    }\n    sorted_lst.sort_by(|a, b| a.cmp(&b));\n\
    \    sorted_lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmptc_7k35x.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = Vec::<String>::new();\n    let mut\
    \ sorted_len = Vec::<i32>::new();\n    let mut i = 0;\n    loop {\n        sorted_len.clear();\n\
    \        // find the smallest string\n        sorted_len.push(sorted_list.len());\n\
    \        for val in sorted_list {\n            if val.length() < sorted_len[0]\
    \ {\n                sorted_len = val.chars().map(|c| c.len_utf8()).collect();\n\
    \                sorted_list.clear();\n            }\n            if val.length()\
    \ == sorted_len[0] {\n                sorted_list.push(val);\n            }\n\
    \        }\n        // found the smallest string, move all strings after it by\
    \ one\n        if sorted_list.len() < sorted_len[0] {\n            break;\n  \
    \      }\n        // if next string is not smaller, move it\n        for val in\
    \ sorted_list {\n            if val.length() != sorted_len[0] {\n            \
    \    sorted_list.push(val);\n            }\n        }\n        i += 1;\n    }\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzavop4nx.rs:23:25\n   |\n\
    23 |         sorted_len.push(sorted_list.len());\n   |                       \
    \  ^^^^^^^^^^^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `i32` and panic if the converted value doesn't fit\n   |\n23\
    \ |         sorted_len.push(sorted_list.len().try_into().unwrap());\n   |    \
    \                                      ++++++++++++++++++++\n\nerror[E0599]: no\
    \ method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpzavop4nx.rs:25:20\n   |\n25 |             if val.length() < sorted_len[0]\
    \ {\n   |                    ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: a value of type `Vec<i32>` cannot be\
    \ built from an iterator over elements of type `usize`\n    --> /tmp/tmpzavop4nx.rs:26:64\n\
    \     |\n26   |                 sorted_len = val.chars().map(|c| c.len_utf8()).collect();\n\
    \     |                                                                ^^^^^^^\
    \ value of type `Vec<i32>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<i32>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `length` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpzavop4nx.rs:29:20\n   |\n\
    29 |             if val.length() == sorted_len[0] {\n   |                    ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzavop4nx.rs:34:32\n   |\n34 |         if sorted_list.len()\
    \ < sorted_len[0] {\n   |                                ^^^^^^^^^^^^^ expected\
    \ `usize`, found `i32`\n   |\nhelp: you can convert an `i32` to a `usize` and\
    \ panic if the converted value doesn't fit\n   |\n34 |         if sorted_list.len()\
    \ < sorted_len[0].try_into().unwrap() {\n   |                                \
    \             ++++++++++++++++++++\n\nerror[E0599]: no method named `length` found\
    \ for struc"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut temp:\
    \ Vec<String> = Vec::new();\n    for word in lst {\n        if !temp.iter().any(|&x|\
    \ x == &word) {\n            res.push(word);\n            temp.push(word);\n \
    \       } else {\n            if temp.iter().any(|&x| x == &word) {\n        \
    \        let mut cur_word: Vec<String> = temp.iter().cloned().collect();\n   \
    \             cur_word.sort_unstable();\n                res.push(cur_word);\n\
    \            }\n            temp.clear();\n            temp.push(word);\n    \
    \    }\n    }\n    if temp.iter().any(|&x| x == &word) {\n        let mut cur_word:\
    \ Vec<String> = temp.iter().cloned().collect();\n        cur_word.sort_unstable();\n\
    \        res.push(cur_word);\n    }\n    return res;\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `word` in this scope\n  --> /tmp/tmpo1awt9an.rs:33:35\n\
    \   |\n33 |     if temp.iter().any(|&x| x == &word) {\n   |                  \
    \                 ^^^^ not found in this scope\n\nerror[E0277]: can't compare\
    \ `String` with `&String`\n  --> /tmp/tmpo1awt9an.rs:20:36\n   |\n20 |       \
    \  if !temp.iter().any(|&x| x == &word) {\n   |                              \
    \      ^^ no implementation for `String == &String`\n   |\n   = help: the trait\
    \ `PartialEq<&String>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `&String`\n\
    \  --> /tmp/tmpo1awt9an.rs:24:39\n   |\n24 |             if temp.iter().any(|&x|\
    \ x == &word) {\n   |                                       ^^ no implementation\
    \ for `String == &String`\n   |\n   = help: the trait `PartialEq<&String>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo1awt9an.rs:27:26\n\
    \   |\n27 |                 res.push(cur_word);\n   |                        \
    \  ^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `String`\n              found struct `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo1awt"
  stdout: ''
  timestamp: 1659980023
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = vec![];\n    sorted_list.sort();\n\
    \    let mut list_without_odd = vec![];\n    for string in lst {\n        if string.len()\
    \ % 2 != 0 {\n            list_without_odd.push(string);\n        } else {\n \
    \           sorted_list.push(string);\n        }\n    }\n    sorted_list.extend(list_without_odd);\n\
    \    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpsoyb5eox.rs:33:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst\n        .into_iter()\n    \
    \    .filter(|s| s.len() % 2 != 0)\n        .collect::<Vec<String>>();\n    sorted_list.sort_unstable_by(|a,\
    \ b| a.cmp(b));\n    sorted_list\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"a\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmprlxwmsb8.rs:27:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_impl(lst, Ordering::Ascending, Ordering::Ascending)\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpdhv_cb2k.rs:17:31\n   |\n17 |     sorted_list_sum_impl(lst, Ordering::Ascending,\
    \ Ordering::Ascending)\n   |                               ^^^^^^^^ use of undeclared\
    \ type `Ordering`\n\nerror[E0433]: failed to resolve: use of undeclared type `Ordering`\n\
    \  --> /tmp/tmpdhv_cb2k.rs:17:52\n   |\n17 |     sorted_list_sum_impl(lst, Ordering::Ascending,\
    \ Ordering::Ascending)\n   |                                                 \
    \   ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0425]: cannot find function\
    \ `sorted_list_sum_impl` in this scope\n  --> /tmp/tmpdhv_cb2k.rs:17:5\n   |\n\
    17 |     sorted_list_sum_impl(lst, Ordering::Ascending, Ordering::Ascending)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980022
- exit_code: 101
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    if lst.len() <= 1 {\n        return lst\n    }\n    let\
    \ mut new_lst = Vec::new();\n    let mut cnt = 0;\n    for v in lst {\n      \
    \  if cnt % 2 == 0 {\n            new_lst.push(v);\n        }\n        cnt +=\
    \ 1;\n    }\n    new_lst.sort_by_key(|s| s.len());\n    new_lst\n}\n\nfn main()\
    \ {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"aa\", \"aaa\"]`,\n right: `[\"aa\"]`', /tmp/tmpol9e_359.rs:34:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut s = Vec::<String>::new();\n\n    for ele in lst\
    \ {\n        if ele != ele {\n            s.push(ele);\n        } else {\n   \
    \         s.push(*ele);\n        }\n    }\n\n    s\n}\n\nfn main() {\n    let\
    \ candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpj3gkc_q_.rs:23:20\n   |\n\
    23 |             s.push(*ele);\n   |                    ^^^^ expected struct `String`,\
    \ found `str`\n   |\nhelp: try using a conversion method\n   |\n23 |         \
    \    s.push((*ele).to_string());\n   |                    +    +++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    lst.sort_by(|a, b| b.len() as usize <\n        a.len()\
    \ as usize\n        || (a.len() as usize).cmp(&b.len() as usize)\n        || a.cmp(b)\n\
    \    );\n    lst\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n   \
    \ assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: `<` is interpreted as a start of generic arguments for `usize`,\
    \ not a comparison\n  --> /tmp/tmpn52rnjr7.rs:17:41\n   |\n17 |     lst.sort_by(|a,\
    \ b| b.len() as usize <\n   |                                         ^ not interpreted\
    \ as comparison\n18 |         a.len() as usize\n   |         -- interpreted as\
    \ generic arguments\n   |\nhelp: try comparing the cast value\n   |\n17 |    \
    \ lst.sort_by(|a, b| (b.len() as usize) <\n   |                        +     \
    \           +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn52rnjr7.rs:19:35\n\
    \   |\n19 |         || (a.len() as usize).cmp(&b.len() as usize)\n   |       \
    \                            ^^^^^^^^^^^^^^^^^\n   |                         \
    \          |\n   |                                   expected `&usize`, found\
    \ `usize`\n   |                                   help: consider borrowing here:\
    \ `&(&b.len() as usize)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn52rnjr7.rs:19:12\n\
    \   |\n19 |         || (a.len() as usize).cmp(&b.len() as usize)\n   |       \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found enum `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn52rnjr7.rs:20:12\n   |\n20 |\
    \         || a.cmp(b)\n   |            ^^^^^^^^ expected `bool`, found enum `std::cmp::Ordering`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpn52rnjr7.rs:17:24\n   |\n17 |\
    \       lst.sort_by(|a, b| b.len() as usize <\n   |  ________________________^\n\
    18 | |         a.len() as usize\n19 | |         || (a.len() as usize).cmp(&b.len()\
    \ as usize)\n20 | |         || a.cmp(b)\n   | |___________________^ expected enum\
    \ `std::cmp::Ordering`, found `bool`\n\nerror[E0606]: casting `&usize` as `usize`\
    \ is invalid\n  --> /tmp/tmpn52rnjr7.rs:19:35\n   |\n19 |         || (a.len()\
    \ as usize).cmp(&b.len() as usize)\n   |                                   --------^^^^^^^^^\n\
    \   |                                   |\n   |                              \
    \     cannot cast `&usize` as `usize`\n   |                                  \
    \ help: dereference the expression: `*&b.len()`\n\nerror: aborting due to 6 previous\
    \ erro"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    // Write your code here\n    let mut sorted_list = vec![];\n\
    \n    for word in lst {\n        if sorted_list.len() != 0 {\n            if word.len()\
    \ > sorted_list.last().len() {\n                sorted_list.push(word);\n    \
    \        }\n        } else {\n            sorted_list.push(word);\n        }\n\
    \    }\n\n    sorted_list.sort_by(|a, b| a.cmp(b));\n\n    sorted_list\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmp9yf50td9.rs:22:48\n   |\n22 |             if word.len()\
    \ > sorted_list.last().len() {\n   |                                         \
    \       ^^^ method not found in `Option<&_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_impl(\n        lst,\n        String::from_iter(vec![]),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n        |a, b| a.cmp(b),\n\
    \        |a, b| a.cmp(b),\n        |a, b| a.\n}\n\nfn main() {\n    let candidate\
    \ = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `)`\n  --> /tmp/tmpj8oj_dfa.rs:82:1\n   |\n82\
    \ | }\n   | ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpj8oj_dfa.rs:17:25\n\
    \   |\n16 | fn sorted_list_sum(lst: Vec<String>) -> Vec<String> {\n   |      \
    \                                               - closing delimiter possibly meant\
    \ for this\n17 |     sorted_list_sum_impl(\n   |                         ^ unclosed\
    \ delimiter\n...\n82 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]:\
    \ cannot find function `sorted_list_sum_impl` in this scope\n  --> /tmp/tmpj8oj_dfa.rs:17:5\n\
    \   |\n17 |     sorted_list_sum_impl(\n   |     ^^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no function or associated item named `from_iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpj8oj_dfa.rs:19:17\n\
    \   |\n19 |         String::from_iter(vec![]),\n   |                 ^^^^^^^^^\
    \ function or associated item not found in `String`\n   |\n   = help: items from\
    \ traits can only be used if the trait is in scope\nhelp: the following trait\
    \ is implemented but not in scope; perhaps add a `use` for it:\n   |\n1  | use\
    \ std::iter::FromIterator;\n   |\nhelp: there is an associated function with a\
    \ similar name\n   |\n19 |         String::from_utf8(vec![]),\n   |          \
    \       ~~~~~~~~~\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    sorted_list_sum_impl(lst, String::from(\"A\"))\n}\n\n\
    fn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sorted_list_sum_impl` in this scope\n\
    \  --> /tmp/tmpnzg1x27a.rs:17:5\n   |\n17 |     sorted_list_sum_impl(lst, String::from(\"\
    A\"))\n   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted = vec![String::from(\"0\");\n         \
    \               String::from(\"1\");\n                        String::from(\"\
    2\");\n                        String::from(\"3\");\n                        String::from(\"\
    4\");\n                        String::from(\"5\");\n                        String::from(\"\
    6\");\n                        String::from(\"7\");\n                        String::from(\"\
    8\");\n                        String::from(\"9\")];\n    let mut sum = 0;\n \
    \   let mut counter = 0;\n    for word in lst.iter() {\n        if counter % 2\
    \ == 0 {\n            sorted.push(word);\n            sum += word.length();\n\
    \            counter += 1;\n        } else {\n            sorted.sort();\n   \
    \     }\n    }\n    sorted\n}\n\nfn main() {\n    let candidate = sorted_list_sum;\n\
    \    assert_eq!(candidate(vec![String::from(\"aa\"), String::from(\"a\"), String::from(\"\
    aaa\")]), vec![String::from(\"aa\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    school\"), String::from(\"AI\"), String::from(\"asdf\"), String::from(\"b\")]),\
    \ vec![String::from(\"AI\"), String::from(\"asdf\"), String::from(\"school\")]);\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"b\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"dcba\"), String::from(\"abcd\"), String::from(\"a\")]), vec![String::from(\"\
    abcd\"), String::from(\"dcba\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    AI\"), String::from(\"ai\"), String::from(\"au\")]), vec![String::from(\"AI\"\
    ), String::from(\"ai\"), String::from(\"au\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    a\"), String::from(\"b\"), String::from(\"b\"), String::from(\"c\"), String::from(\"\
    c\"), String::from(\"a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error: no rules expected the token `;`\n  --> /tmp/tmpruwu0dul.rs:18:42\n\
    \   |\n18 |                         String::from(\"1\");\n   |               \
    \                           ^ no rules expected this token in macro call\n\nerror[E0599]:\
    \ no method named `length` found for reference `&String` in the current scope\n\
    \  --> /tmp/tmpruwu0dul.rs:32:25\n   |\n32 |             sum += word.length();\n\
    \   |                         ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980023
- exit_code: 1
  program: "/// Write a function that accepts a vector of strings as a parameter,\n\
    /// deletes the strings that have odd lengths from it,\n/// and returns the resulted\
    \ vector with a sorted order,\n/// The vector is always a vector of strings and\
    \ never a vector of numbers,\n/// and it may contain duplicates.\n/// The order\
    \ of the vector should be ascending by length of each word, and you\n/// should\
    \ return the vector sorted by that rule.\n/// If two words have the same length,\
    \ sort the vector alphabetically.\n/// The function should return a vector of\
    \ strings in sorted order.\n/// You may assume that all words will have the same\
    \ length.\n/// For example:\n/// >>> list_sort(vec![String::from(\"aa\"), String::from(\"\
    a\"), String::from(\"aaa\")])\n/// vec![String::from(\"aa\")]\n/// >>> list_sort(vec![String::from(\"\
    ab\"), String::from(\"a\"), String::from(\"aaa\"), String::from(\"cd\")])\n///\
    \ vec![String::from(\"ab\"), String::from(\"cd\")]\nfn sorted_list_sum(lst: Vec<String>)\
    \ -> Vec<String> {\n    let mut sorted_list = lst;\n    let mut sum_lst = vec![];\n\
    \    for word in sorted_list {\n        let mut sum_word = vec![];\n        for\
    \ char in word.chars() {\n            let len = char.len();\n            if len\
    \ % 2 != 0 {\n                sum_word.push(char);\n            } else {\n   \
    \             sum_word.push(char.clone());\n            }\n        }\n       \
    \ sum_lst.push(String::from(sum_word.iter().map(|x| x.to_string()).collect()));\n\
    \    }\n    sum_lst = sum_lst.into_iter().map(|x| x.sort()).collect();\n    for\
    \ word in sum_lst {\n        sorted_list.push(word);\n    }\n    sorted_list\n\
    }\n\nfn main() {\n    let candidate = sorted_list_sum;\n    assert_eq!(candidate(vec![String::from(\"\
    aa\"), String::from(\"a\"), String::from(\"aaa\")]), vec![String::from(\"aa\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"school\"), String::from(\"\
    AI\"), String::from(\"asdf\"), String::from(\"b\")]), vec![String::from(\"AI\"\
    ), String::from(\"asdf\"), String::from(\"school\")]);\n    assert_eq!(candidate(vec![String::from(\"\
    d\"), String::from(\"b\"), String::from(\"c\"), String::from(\"a\")]), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![String::from(\"d\"), String::from(\"dcba\"), String::from(\"\
    abcd\"), String::from(\"a\")]), vec![String::from(\"abcd\"), String::from(\"dcba\"\
    )]);\n    assert_eq!(candidate(vec![String::from(\"AI\"), String::from(\"ai\"\
    ), String::from(\"au\")]), vec![String::from(\"AI\"), String::from(\"ai\"), String::from(\"\
    au\")]);\n    assert_eq!(candidate(vec![String::from(\"a\"), String::from(\"b\"\
    ), String::from(\"b\"), String::from(\"c\"), String::from(\"c\"), String::from(\"\
    a\")]), Vec::<String>::new());\n    assert_eq!(candidate(vec![String::from(\"\
    aaaa\"), String::from(\"bbbb\"), String::from(\"dd\"), String::from(\"cc\")]),\
    \ vec![String::from(\"cc\"), String::from(\"dd\"), String::from(\"aaaa\"), String::from(\"\
    bbbb\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmppl37fq3y.rs:22:28\n   |\n22 |             let len = char.len();\n\
    \   |                            ^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `sort` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmppl37fq3y.rs:31:45\n   |\n31 |     sum_lst = sum_lst.into_iter().map(|x|\
    \ x.sort()).collect();\n   |                                             ^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659980023
