name: HumanEval_11_string_xor
language: rs
prompt: "/// Input are two strings a and b consisting only of 1s and 0s.\n/// Perform\
  \ binary XOR on these inputs and return result also as a string.\n/// >>> string_xor(String::from(\"\
  010\"), String::from(\"110\"))\n/// String::from(\"100\")\nfn string_xor(a: String,\
  \ b: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = string_xor;\n    assert_eq!(candidate(String::from(\"\
  111000\"), String::from(\"101010\")), String::from(\"010010\"));\n    assert_eq!(candidate(String::from(\"\
  1\"), String::from(\"1\")), String::from(\"0\"));\n    assert_eq!(candidate(String::from(\"\
  0101\"), String::from(\"0000\")), String::from(\"0101\"));\n}\n"
completions: ['    format!("{}{}", a, b)', "    a.to_vec() ^ b.to_vec()\n        .iter()\n\
    \        .cloned()\n        .fold(String::new(), |mut acc: String, chr: &Char|\
    \ {\n            acc.push_str(&chr);\n            acc.push_str(&chr);\n      \
    \      acc\n        })", '    String::from(a.to_owned() & b.to_owned())', "  \
    \  assert!(a.is_ascii());\n    assert!(a.is_binary());\n    assert!(a.is_mut());\n\
    \    assert!(a.is_utf8());\n\n    assert!(b is String);\n    assert!(b.is_ascii());\n\
    \    assert!(b.is_binary());\n    assert!(b.is_mut());\n    assert!(b.is_utf8());\n\
    \n    let mut res = String::new();\n    res.extend_from_slice(a);\n    res.extend_from_slice(b);\n\
    \n    let mut result = String::new();\n    for i in res.bytes() {\n        if\
    \ *i != 0 {\n            result.push(i);\n        }\n    }\n\n    result", '    format!("{}",
    a.to_vec() ^ b.to_vec())', '    bin2str(bin2str(bin2str(bin2str(a, a), a), b),
    b)', "    if a.len() != b.len() {\n        panic!(\"Input strings must have the\
    \ same length!\");\n    }\n    let mut result = String::new();\n    for i in 0..a.len()\
    \ {\n        let char = a.as_bytes()[i] ^ b.as_bytes()[i];\n        result.push_str(char.to_string());\n\
    \    }\n    result", "    let mut a_len = a.len();\n    let mut b_len = b.len();\n\
    \    while a_len > 0 || b_len > 0 {\n        let left = a_len > 0 ? (a_len - 1)\
    \ % 8 + 1 : 0;\n        let right = b_len > 0 ? (b_len - 1) % 8 + 1 : 0;\n   \
    \     a_len = left - right;\n        b_len = left - right;\n        let a_char\
    \ = a.chars().nth(left);\n        let b_char = b.chars().nth(right);\n       \
    \ match a_char.cmp(&b_char) {\n            Some(0) => {}\n            Some(1)\
    \ => a.push('0'),\n            Some(-1) => a.push('1'),\n            None => a.push(b_char.to_string()),\n\
    \        }\n    }\n    a", "    assert!(!a.is_empty(), \"String must not be empty\"\
    );\n    assert!(!b.is_empty(), \"String must not be empty\");\n    assert!(a.is_bytes(),\
    \ format!(\"String must be bytes, but it is {:?}\", a));\n    assert!(b.is_bytes(),\
    \ format!(\"String must be bytes, but it is {:?}\", b));\n\n    let mut res =\
    \ String::with_capacity(a.len());\n    let mut a_buf = a.as_bytes();\n    let\
    \ mut b_buf = b.as_bytes();\n    while a_buf.len() > 0 && b_buf.len() > 0 {\n\
    \        if a_buf[0] != b_buf[0] {\n            res.push_str(&format!(\"{:?}\"\
    , b_buf[0]));\n            b_buf.pop();\n        } else {\n            res.push((a_buf.pop()\
    \ as char) ^ b_buf.pop() as char);\n        }\n    }\n    res.push_str(&format!(\"\
    {:?}\", b_buf[0]));\n    res.into_bytes()", "    let a_vec = a.encode_utf8().into_vec();\n\
    \    let b_vec = b.encode_utf8().into_vec();\n    let mut result = a_vec.clone();\n\
    \    for &x in b_vec {\n        result ^= x;\n    }\n    String::from_utf8(result)",
  "    debug_assert!(a != \"0\" && b != \"0\");\n    if a.len() != b.len() {\n   \
    \     panic!(\"a and b have different length\");\n    }\n    String::from(String::from_utf8(a).xor(String::from_utf8(b))).into()",
  "    format!(\"{}{}\", a, b).into_bytes()\n        .iter()\n        .filter(|x|\
    \ *x != 0)\n        .map(|x| *x ^ 1)\n        .collect()\n        .to_vec()\n\
    \        .iter()\n        .map(|x| *x.to_string())\n        .collect()\n     \
    \   .to_owned()", '    string_binaryxor_a::<[u8; 2]>(a, b).0', '    String::from(a.chars().zip(b.chars()).map(|(a,
    b)| a ^ b).collect())', '    bin2hex_or_null!(a ^ b)', "    String::from(a.chars().filter(|c|\
    \ c == '0').count() as u32).to_string()\n        .pad_by(a.len(), b'0')\n    \
    \    .chain(b.chars().filter(|c| c == '0').count() as u32).to_string()\n     \
    \   .pad_by(b.len(), b'0')\n        .to_string()", "    let mut result = String::new();\n\
    \    for n in a.chars().zip(b.chars()) {\n        if *n.0 == *n.1 {\n        \
    \    result.replace_range(n.0, n.0..1, *n.0 ^ *n.1);\n        } else {\n     \
    \       result.replace_range(n.0, n.0..1, *n.0);\n        }\n    }\n    result",
  "    let mut result = String::new();\n    for i in a.chars() {\n        result.push((i\
    \ ^ b.chars().nth(i % b.chars().len())));\n    }\n    result", "    let mut res\
    \ = String::from(\"0\");\n    for i in 0..a.len() {\n        if a[i] != b[i] {\n\
    \            res.push_str(&*b);\n        } else {\n            res.push(a[i]);\n\
    \        }\n    }\n    res", "    let mut result = String::new();\n    for i in\
    \ 0..a.len() {\n        if a[i] != \"1\" || b[i] != \"1\" {\n            result.push(\"\
    1\");\n        } else {\n            result.push(\"0\");\n        }\n    }\n \
    \   result", '    bin2str(bin2bin(a) ^ bin2bin(b))', "    if a.len() != b.len()\
    \ {\n        String::from(\"\")\n    } else {\n        let mut result = String::from(\"\
    \");\n        for (i, elt) in a.chars().zip(b.chars()) {\n            let res\
    \ = *elt ^ *i;\n            *result = if res == 0 { \"0\" } else { \"1\" };\n\
    \        }\n        result\n    }", "    let mut xor = String::new();\n    xor.extend_from_slice(a.as_bytes());\n\
    \    xor.extend_from_slice(b.as_bytes());\n    xor", "    if a.len() != b.len()\
    \ {\n        panic!(\"StringXor: Length of strings not equal.\");\n    }\n   \
    \ let mut result = String::new();\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()',
  "    if a == b {\n        a\n    } else {\n        let mut ret = String::new();\n\
    \        for x in a.chars() {\n            if b == x {\n                ret +=\
    \ x;\n            }\n        }\n        ret\n    }", "    String::from(b.to_ascii_lowercase().chars().zip(\n\
    \        a.to_ascii_lowercase().chars()\n            .enumerate()\n          \
    \  .map(|(idx, c)| {\n                if c == '1' {\n                    let mut\
    \ c = '0';\n                    c = '0' ^ c;\n                    c.to_string()\n\
    \                } else {\n                    c\n                }\n        \
    \    })\n            .collect::<Vec<String>>(),\n    )\n    .iter()\n    .map(|s|\
    \ s.to_string())\n    .collect::<Vec<String>>()\n    .join();", "    let mut result\
    \ = String::with_capacity(a.len());\n    for i in 0..a.len() {\n        result.push(a[i]\
    \ ^ b[i]);\n    }\n    result", "    let mut result = String::new();\n    bincode::bytes::xor_mut(&mut\
    \ result, a.as_bytes(), b.as_bytes()).unwrap();\n    result", '    String::from(a.to_owned()
    + b.to_owned())', '    a.bytes().iter().map(|&b| b ^ b.to_digit(10)).fold(String::new(),
    |s, b| s + b.to_digit(10))', "    let mut res = String::with_capacity(a.len());\n\
    \    for i in a.chars().zip(b.chars()).map(|(a, b)| {\n        a ^ b\n    }) {\n\
    \        res.push(*i);\n    }\n    res", "    assert!(a.len() >= b.len());\n \
    \   let mut result = String::new();\n    for pos in 0..a.len() {\n        result.push(a[pos]\
    \ ^ b[pos]);\n    }\n    result", "    let mut res = String::from(a);\n    let\
    \ mut carry = 0;\n    for (i, c) in res.chars().enumerate() {\n        if carry\
    \ != 0 {\n            res.insert(i, Char::from_u32(carry as u32) + Char::from_u32(1));\n\
    \            carry = 0;\n        } else {\n            carry = *c & 1;\n     \
    \       *c &= 1;\n        }\n    }\n    res += &b[..].to_string();\n    res +=\
    \ &a[..].to_string();\n    res.into()", "    match a & b {\n        &b\"011\"\
    [..] => String::from(\"101\"),\n        &b\"110\"[..] => String::from(\"011\"\
    ),\n        _ => String::from(\"001\"),\n    }", "    let mut res = String::new();\n\
    \    for &ch in a.chars() {\n        res.push_str(&ch.to_string() ^ &b.chars().nth(ch\
    \ as usize).to_string());\n    }\n    res", "    BinaryOperation::xor(a, b)\n\
    \        .to_string()\n        .unwrap()", "    vec![i32::from(a.chars()) ^ i32::from(b.chars())].iter()\n\
    \        .map(|x| x.to_string()).collect::<String>()", "    debug_assert!(a.len()\
    \ == b.len());\n    let mut res = String::from(a);\n    res.chars().rev().zip(b.chars().rev()).filter(|(a,b)|\
    \ *a != *b).for_each(|(a,b)| *a = *a ^ *b);\n    res", "    if a.len() != b.len()\
    \ {\n        \"\".to_string()\n    } else {\n        let mut a: Vec<u8> = a.as_bytes().to_vec();\n\
    \        let mut b: Vec<u8> = b.as_bytes().to_vec();\n        for i in 0..a.len()\
    \ {\n            a[i] ^= b[i];\n        }\n        String::from_utf8(a).into_owned()\n\
    \    }", "    debug_assert!(a != b);\n    let mut result = String::new();\n  \
    \  a.chars().for_each(|c| {\n        let mut x = b.chars().skip_while(|&b| *b\
    \ != c).next();\n        if let Some(&mut b) = &mut x {\n            *b = 0x01;\n\
    \        }\n        result.push(*x);\n    });\n    result", '    b.iter().chain(a.iter()).filter(|x|
    x != 0).collect()', "    match (a.len(), b.len()) {\n        (2, 2) => String::from(a.to_owned()\
    \ & b.to_owned()),\n        (2, 3) => String::from(a.to_owned() ^ (b.to_owned()[..])),\n\
    \        (3, 2) => String::from(a.to_owned() ^ b.to_owned()),\n        _ => String::from(a.to_owned()\
    \ ^ b.to_owned()),\n    }", "    vec![(a ^ b).chars().filter_map(|c| {\n     \
    \   if *c != 0 {\n            Some(c)\n        } else {\n            None\n  \
    \      }\n    })].collect()", '    format!("{}{}", a, b).into()', '    a.to_string()
    + b.to_string().binary_xor_prefix()', "    let mut res = String::with_capacity(a.len());\n\
    \    for a_char, b_char in a.chars().zip(b.chars()) {\n        *res += *a_char\
    \ ^ *b_char;\n    }\n    res", '    String::from(bincode::encode(bincode::XOR,
    a.as_bytes(), b.as_bytes()))', "    a.to_vec().iter().map(|x| {\n        if x\
    \ != b.to_vec().iter().next(){\n            Some(x ^ b.to_vec().iter().next())\n\
    \        } else {\n            None\n        }\n    }).collect().map(|x| x.unwrap()).collect()",
  '    a.to_string().chars().zip(b.to_string().chars()).filter(|(a, b)| a != b).map(|(a,
    b)| a ^ b).collect::<String>()', "    if a == b {\n        return a;\n    }\n\
    \    let mut x = a.as_bytes().to_vec();\n    let mut y = b.as_bytes().to_vec();\n\
    \    x.reverse();\n    y.reverse();\n    match x.len() {\n        0 => String::from(\"\
    \"),\n        1 => String::from(b.clone()),\n        _ => {\n            let mut\
    \ result = String::from(b.clone());\n            x.iter().for_each(|&x| *x = 0);\n\
    \            y.iter().for_each(|&y| *y = 0);\n            let mut carry = 0;\n\
    \            for (a, b) in x.iter_mut().zip(y.iter_mut()) {\n                *a\
    \ ^= *b;\n                *b |= carry;\n                carry = *b >> 8;\n   \
    \         }\n            *a = (*a << 8) + carry;\n            result.push((*a\
    \ >> 24) as u8);\n        }\n    }\n    result", "    let mut res = String::new();\n\
    \    for (x, y) in a.as_bytes_mut().iter().zip(b.as_bytes_mut()) {\n        *res\
    \ += *x ^ *y;\n    }\n    res", "    let mut result = String::new();\n    for\
    \ &c in a.chars().filter_map(|c| match c {\n        0 => Some(b'0'),\n       \
    \ 1 => Some(b'1'),\n        _ => None,\n    }) {\n        match b.chars().filter_map(|c|\
    \ match c {\n            0 => Some(b'0'),\n            1 => Some(b'1'),\n    \
    \        _ => None,\n        }) {\n            None => return result.push_str(&c.to_string()),\n\
    \            Some(&mut b) => {\n                match c {\n                  \
    \  b'0' if *b ==  b'1' => result.push_str(&c.to_string()),\n                 \
    \   b'1' if *b ==  b'0' => result.push_str(&c.to_string()),\n                }\n\
    \            },\n        }\n    }\n    result", "    let mut carry = 0;\n    let\
    \ mut result = [0u8; a.len()];\n    for i in 0..a.len() {\n        result[i] =\
    \ ((a.as_bytes()[i] ^ b.as_bytes()[i]) as u8)\n            as usize;\n       \
    \ carry += result[i] as usize;\n    }\n    if carry > 0 {\n        result.push(carry\
    \ as u8);\n    }\n    String::from_utf8_unchecked(result).unwrap()", '    String::from_ascii(a
    ^ b)', "    let mut result = String::new();\n    let a_len = a.len();\n    let\
    \ b_len = b.len();\n    if a_len != b_len {\n        return String::new();\n \
    \   }\n\n    for i in 0..a_len {\n        if a[i] != b[i] {\n            result.push('a');\n\
    \        } else {\n            result.push('0');\n        }\n    }\n    result",
  "    a.iter().chain(b.iter()).filter(|&c| c == b'0' || c == b'1').collect::<String>()",
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        res.push_str(&if a[i] != b[i] { \"1\".to_string()\
    \ } else { \"0\".to_string() });\n    }\n    res", "    if a.len() != b.len()\
    \ {\n        assert!(false);\n    }\n    let mut res = String::new();\n    for\
    \ i in 0..a.len() {\n        res.push(a[i] ^ b[i]);\n    }\n    res", "    let\
    \ mut res = String::with_capacity(a.len());\n    let mut carry = 0;\n    let mut\
    \ a = a.chars().collect::<Vec<_>>();\n    let mut b = b.chars().collect::<Vec<_>>();\n\
    \    let mut a_len = a.len();\n    let mut b_len = b.len();\n\n    while carry\
    \ != 0 {\n        let mut next_carry = 0;\n        // Find the carry in `a`\n\
    \        a_len.cmp(&mut b_len).unwrap();\n        loop {\n            let mut\
    \ a_index = 0;\n            // Find the carry in `b`\n            b_len.cmp(&mut\
    \ a_len).unwrap();\n            loop {\n                // Check if a character\
    \ in `a` could be XOR'ed with one in `b`\n                a_index += 1;\n    \
    \            if a_index >= a_len {\n                    break;\n             \
    \   }\n                let mut a_byte = a.get_mut(a_index);\n                let\
    \ b_byte = b.get_mut(b_index);\n                let mut carry = 0;\n         \
    \       while a_byte != 0 {\n                    let mut temp_byte = a_byte ^\
    \ b_byte + carry;\n                    if temp_byte > 0 {\n                  \
    \      carry = 1;\n                    } else {\n                        carry\
    \ = 0;\n                    }\n                    next_carry += 1;\n        \
    \            a_byte >>= 1;\n                    b_byte >>= 1;\n              \
    \  }\n                if next_carry == 1 {\n                    break;\n     \
    \           }\n            }\n            // Exit the loop if carry is 0 and `a`\
    \ becomes empty\n            if next_carry == 0 {\n                break;\n  \
    \          }\n        }\n        // If carry is 0 then both `a` and `b` have zero\
    \ carry. Add the least\n        // significant zero of `a` to `b`. Add all the\
    \ remaining `b` to the result\n        // string.\n        if carry == 0 {\n \
    \           b_len -= 1;\n            b_len.cmp(&mut a_len).unwrap();\n       \
    \     loop {\n                let mut a_byte = a.get_mut(0);\n               \
    \ let b_byte = b.get_mut(0);\n                let mut carry = 0;\n           \
    \     while a_byte != 0 {\n                    let mut temp_byte = a_byte ^ b_byte\
    \ + carry;\n                    if temp_byte > 0 {\n                        carry\
    \ = 1;\n                    } else {\n                        carry = 0;\n   \
    \                 }\n                    a_byte >>= 1;\n                    b_byte\
    \ >>= 1;\n                }\n                if carry == 0 {\n               \
    \     break;\n                }\n                res.push(b'0');\n           \
    \ }\n            res.push(b'1');\n        } else {\n", '    bincode::binary_xor_bytes(a.as_bytes(),
    b.as_bytes()).to_string()', "    let mut res = String::new();\n    let mut a_val\
    \ = a.chars().collect::<Vec<_>>();\n    let mut b_val = b.chars().collect::<Vec<_>>();\n\
    \    let mut carry = 0;\n    for i in a_val.iter() {\n        let mut val = *i;\n\
    \        if val == '1' {\n            *val = *b_val[a_val.iter().position(|x|\
    \ x == &val).unwrap()];\n            res.push(carry);\n        }\n        *val\
    \ = '0';\n        carry = 1;\n    }\n    res.push(carry);\n    res", "    let\
    \ mut result = String::from(a);\n    for ch in a.chars() {\n        let index\
    \ = (result as usize) & (b.len() as usize);\n        result += b[index];\n   \
    \ }\n    result", "    let mut result = String::with_capacity(a.len());\n    for\
    \ (a, b) in a.chars().zip(b.chars()) {\n        *result += a.to_ascii_lowercase().unwrap()\
    \ ^ b.to_ascii_lowercase().unwrap();\n    }\n    result", '    string_from_bytes(a.as_bytes()
    ^ b.as_bytes()).to_string()', '    BinaryXor::new().xor_str(a, b).to_string()',
  "    if a.len() != b.len() {\n        panic!(\"inputs must be of equal length\"\
    );\n    }\n\n    let mut result = String::new();\n    for char in a.chars().zip(b.chars()).filter(|&(a,\
    \ b)| a == b) {\n        result.push('a');\n    }\n    result", "    let mut out\
    \ = String::new();\n    for i in 0..a.len() {\n        out.push_str(&a[i..].chars().map(|x|\
    \ *x ^ *b[i..]).collect());\n    }\n    out", "    let mut result = String::from(a);\n\
    \    for i in 0..a.len() {\n        result[i] = a[i] ^ b[i];\n    }\n    result",
  '    String::from_utf8(a.to_utf16().iter().zip(b.to_utf16().iter()).map(|(a, b)|
    a ^ b).collect())', "    a.to_owned() + b.to_owned().rev().iter().fold(String::new(),\
    \ |mut acc, &c| {\n        acc += c;\n        acc\n    })", "    a.to_string_ascii_checked()\n\
    \        ^ b.to_string_ascii_checked()\n        .to_owned()", "    if a.len()\
    \ != b.len() {\n        return String::from(\"\");\n    }\n\n    if a.is_empty()\
    \ {\n        return b;\n    }\n\n    if b.is_empty() {\n        return a;\n  \
    \  }\n\n    let mut a: Vec<u8> = a.as_bytes().iter().map(|&x| *x).collect();\n\
    \    let mut b: Vec<u8> = b.as_bytes().iter().map(|&x| *x).collect();\n\n    for\
    \ (i, &a) in a.iter_mut().zip(b.iter_mut()) {\n        *a ^= *b;\n        a[i]\
    \ = *a;\n    }\n\n    String::from_utf8_lossy(&a)", "    if a.len() != b.len()\
    \ {\n        bail!(\"String::xor error: length of input is not equal\");\n   \
    \ }\n\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()", '    String::from(a)
    ^ b', "    assert_eq!(a.len(), b.len());\n    let mut s = String::new();\n   \
    \ for i in 0..a.len() {\n        s.push_str(&a[i] ^ b[i]);\n    }\n    s", " \
    \   string::String::from_str(format!(\"{:b}\", bincode::xor_utf8(a.0).unwrap())\n\
    \        .join(\"\")\n        + format!(\"{:b}\", bincode::xor_utf8(b.0).unwrap())\n\
    \        .join(\"\")\n    )", "    let a_vec = a.as_bytes().to_vec();\n    let\
    \ b_vec = b.as_bytes().to_vec();\n    let mut c_vec = Vec::new();\n    for i in\
    \ 0..a_vec.len() {\n        c_vec.push(a_vec[i] ^ b_vec[i]);\n    }\n    String::from_utf8(c_vec).unwrap()",
  '    hex_xor(a.as_bytes(), b.as_bytes())', '    a.binary_xor_mut(b).to_string()',
  "    b.chars().fold(\"\".to_string(), |mut s, c| {\n        debug_assert!(c.is_ascii());\n\
    \        if !a.contains(&c) {\n            return s;\n        }\n        if !b.contains(&c)\
    \ {\n            return s;\n        }\n        s ^= c;\n        debug_assert!(s.len()\
    \ > 0);\n        s + &s[..1]\n    })", "    // Calculate the number of bits in\
    \ the strings.\n    const NUM_BITS: usize = a.len() * b.len() + 1;\n    // Allocate\
    \ space for result\n    let mut result = String::new();\n    // Calculate xor\
    \ of each bit\n    for i in 0..NUM_BITS {\n        let mut carry = false;\n  \
    \      let x = a.chars().nth(i).unwrap();\n        let y = b.chars().nth(i).unwrap();\n\
    \        for j in 0..b.len() {\n            if x != y {\n                carry\
    \ = true;\n            }\n            x >>= 1;\n            y >>= 1;\n       \
    \ }\n        if carry {\n            result.push('a');\n        } else {\n   \
    \         result.push('0');\n        }\n    }\n    result", "    // Iterate over\
    \ the shorter string (length of a or b)\n    // O(n)\n    let mut res = String::new();\n\
    \    for (_i, ch) in a.chars().enumerate() {\n        if b.chars().any(|ch| ch\
    \ != ch) {\n            res.push_str(&a[_i].to_string());\n        }\n    }\n\
    \    for (_i, ch) in b.chars().enumerate() {\n        if a.chars().any(|ch| ch\
    \ != ch) {\n            res.push_str(&b[_i].to_string());\n        }\n    }\n\
    \    res", "    let mut res = String::new();\n    res.extend_from_slice(a.as_bytes());\n\
    \    res.extend_from_slice(b.as_bytes());\n    res.iter().for_each(|byte| {\n\
    \        if *byte != *byte.wrapping_add(1) {\n            *byte.wrapping_add(1,\
    \ 'u8);\n        }\n    });\n    res", '    a.to_string_radix(2) ^ b.to_string_radix(2).to_string()',
  '    a + &b ^ (&a + &b).to_ascii()', "    let mut res = String::new();\n    for\
    \ i in 0..a.len() {\n        if a[i] ^ b[i] == 0 {\n            res.push('a');\n\
    \        } else {\n            res.push('0');\n        }\n    }\n    res", " \
    \   let mut result = String::new();\n    let mut carry = 0;\n    for &c in &a.as_bytes()[..]\
    \ {\n        let current = *c as i8;\n        let next = (current ^ b.as_bytes()[0])\
    \ as i8;\n        let next_str = format!(\"{}\", next);\n        if carry != 0\
    \ {\n            result.push(carry as char);\n        }\n        result.push_str(&next_str[..]);\n\
    \        carry = next as i8;\n    }\n    if carry != 0 {\n        result.push(carry\
    \ as char);\n    }\n    result", "    let a = a.to_owned();\n    let b = b.to_owned();\n\
    \    let mut c = String::new();\n\n    let a_len = a.len();\n    let b_len = b.len();\n\
    \n    let mut xor_table = [0u8; 256];\n\n    for &(idx, _) in a.chars().zip(b.chars())\
    \ {\n        xor_table[*idx] ^= *idx;\n    }\n\n    for &(idx, _) in xor_table.iter_mut()\
    \ {\n        *idx = (*idx & !idx).wrapping_add(1);\n    }\n\n    for &(_, idx)\
    \ in xor_table.iter().enumerate() {\n        c.push((*idx & !idx).to_string());\n\
    \    }\n\n    c", "    use std::cmp::Ordering;\n    use std::str::FromStr;\n \
    \   a.len().cmp(&b.len()).unwrap().cmp(&a.len()).unwrap().cmp(&b.len()).unwrap()\n\
    \        .cmp(&a.len()).unwrap().cmp(&b.len()).unwrap()", "    let mut a = a.to_owned();\n\
    \    let mut b = b.to_owned();\n    let mut res = String::new();\n    loop {\n\
    \        res.push_str(&mut a.chars().filter(|c| c.is_digit(10)).collect::<Vec<_>>()\
    \ &\n            b.chars().filter(|c| c.is_digit(10)).collect::<Vec<_>>() &\n\
    \            &[0; a.len() - b.len()]);\n        if a.len() == 0 && b.len() ==\
    \ 0 {\n            return res;\n        }\n        a.rotate_left(1);\n       \
    \ b.rotate_left(1);\n    }", "    let mut res = String::with_capacity(a.len());\n\
    \    for i in 0..a.len() {\n        if a[i] != b[i] {\n            res.push_str(&format!(\"\
    0{:X}\", a[i] ^ b[i]));\n        } else {\n            res.push(a[i]);\n     \
    \   }\n    }\n    res", "    let mut c = String::new();\n    c.copy_from_slice(&a.as_bytes().iter().map(|x|\
    \ x ^ b.as_bytes().iter().map(|y| y as u8).collect()).collect());\n    c", '    String::from(bitxor_x(&a,
    &b).to_string())', "    let mut a = a.chars();\n    let mut b = b.chars();\n \
    \   loop {\n        if a.next().unwrap() != b.next().unwrap() {\n            a.next();\n\
    \            b.next();\n            break;\n        }\n    }\n    String::from(a.collect::<Vec<_>>().iter().cloned().collect())",
  "    // Compute xor of all characters from each input string.\n    let mut xor =\
    \ a.chars().map(|c| c ^ b.chars().nth(c.0)).collect();\n\n    // Reverse the character\
    \ order and append the remainder.\n    xor.extend(b);\n\n    // The result is\
    \ now in the reverse order as we wanted.\n    xor.reverse();\n\n    // Convert\
    \ to string\n    xor.to_string()", '    binary_xor_string(a, b)', "    debug_assert!(b.len()\
    \ == a.len());\n    let mut res = String::new();\n    for a_char, b_char in a.chars().zip(b.chars())\
    \ {\n        res.push_char(b_char.xor(a_char));\n    }\n    res", '    hex_string(&binstring::XOR(a[0],
    b[0]))', '    format!("{}{}", a, b).into()', "    let mut s = String::new();\n\
    \n    for i in 0..a.len() {\n        s += if a[i] ^ b[i] == 1 {\n            '1'\n\
    \        } else {\n            '0'\n        };\n    }\n\n    s", "    let mut\
    \ c = String::new();\n    for (i, c1) in a.chars().enumerate() {\n        let\
    \ c2 = b.chars().nth(i);\n        c.push(c1 ^ c2);\n    }\n    c", '    String::from(a.to_owned())
    ^ String::from(b.to_owned())', '    to_hex_str(string::xor(to_hex_str(&a), to_hex_str(&b)))',
  "    let mut a = a.into_bytes();\n    let mut b = b.into_bytes();\n    a.truncate(0);\n\
    \    b.truncate(0);\n    for i in 0..(a.len() + b.len()) {\n        let c1 = a.get(i\
    \ as usize) ^ b.get(i as usize);\n        a[i as usize] = c1;\n        b[i as\
    \ usize] = c1;\n    }\n    String::from_utf8_lossy(&a)", "    let mut res = String::from(a);\n\
    \    for &b in b.bytes() {\n        res.swap_bit(&mut res, b.0, b.1);\n    }\n\
    \    res.into()", "    let mut res = String::from(a);\n    for i in 0..a.len()\
    \ {\n        res.swap(a[i], b[i]);\n    }\n    res", '    a.binary_xor_of(b).to_string()',
  "    let mut res = String::new();\n    a.chars().for_each(|x| {\n        if *x !=\
    \ b[x.checked_sub(1).unwrap()] {\n            *res += *x;\n        }\n    });\n\
    \    res", "    let mut result = String::new();\n    for i in 0..a.len() {\n \
    \       if a[i] != b[i] {\n            result.push('a');\n        } else {\n \
    \           result.push('0');\n        }\n    }\n    result", '    a + &b', '    a.to_string().iter().chain(b.to_string().iter()).map(|c|
    c ^ 1).collect()', '    String::from(&a.to_vec() ^ b.to_vec())', "    a.to_string().as_bytes().iter()\n\
    \        .zip(b.to_string().as_bytes().iter())\n        .map(|(a, b)| a ^ b)\n\
    \        .map(|b| String::from_utf8(b.to_vec()))\n        .collect::<Vec<_>>()\n\
    \        .to_owned()\n        .to_owned()\n        .to_string()", "    let mut\
    \ result = String::new();\n    let mut carry = 0;\n    for (i, achar) in a.chars().enumerate()\
    \ {\n        if i < b.len() {\n            let bchar = b.chars().nth(i);\n   \
    \         match carry {\n                0 => result.push(achar),\n          \
    \      1 => result.push(bchar),\n                2 => result.push(achar | bchar),\n\
    \                _ => result.push(carry | achar | bchar),\n            }\n   \
    \         carry += 1;\n        } else {\n            result.push(achar);\n   \
    \     }\n    }\n    result", "    match a.len() {\n        0 => String::from(b),\n\
    \        _ => string_xor(a[..], b[..]),\n    }", "    let mut result = String::from(b);\n\
    \    for i in a.chars() {\n        result.push(if b[i] == a[i] { 0 else 1 });\n\
    \    }\n    result", "    let mut result = String::from(a);\n    for ch in a.chars().take(b.len())\
    \ {\n        result ^= &b[ch as usize];\n    }\n    result", "    let mut a =\
    \ a.chars();\n    let mut b = b.chars();\n    let mut res = String::new();\n\n\
    \    while !a.next().is_none() || !b.next().is_none() {\n        let a = a.next()?;\n\
    \        let b = b.next()?;\n\n        if a == '1' && b == '0' {\n           \
    \ res.push('0');\n        } else {\n            res.push('1');\n        }\n  \
    \  }\n\n    res", "    if a.len() != b.len() {\n        Err(format!(\n       \
    \     \"Length of string a {} != length of string b {}\",\n            a.len(),\n\
    \            b.len()\n        ))\n    } else {\n        let mut result = String::new();\n\
    \        let mut carry = 0;\n        let mut a_iter = a.chars().enumerate();\n\
    \        let mut b_iter = b.chars().enumerate();\n        for (a, b) in a_iter.zip((a_iter.next(),\
    \ b_iter.next())) {\n            let res = if *a > *b {\n                *a ^\
    \ *b + carry\n            } else {\n                *a ^ *b - carry\n        \
    \    };\n            result.push((res % 2));\n            carry = res / 2;\n \
    \       }\n        if carry > 0 {\n            result.push(carry);\n        }\n\
    \        result\n    }", "    format!(\"{}{}\", a, b)\n        .into_string()\n\
    \        .ok()\n        .into_owned()\n        .into()", "    let mut result =\
    \ String::new();\n    for i in a.chars().filter_map(|c| match c {\n        '1'\
    \ => Some('0'),\n        '0' => Some('1'),\n        _ => None,\n    }) {\n   \
    \     result.push(*i);\n    }\n    for i in b.chars().filter_map(|c| match c {\n\
    \        '1' => Some('0'),\n        '0' => Some('1'),\n        _ => None,\n  \
    \  }) {\n        result.push(*i);\n    }\n    result", "    let mut result = String::new();\n\
    \    result.push('a' as u8);\n    for i in a.chars().filter(|c| b == c).rev()\
    \ {\n        result.push('0' as u8);\n    }\n    result", '    string_xor(&a,
    &b)', "    if a.len() != b.len() {\n        assert!(\n            a.len() < b.len(),\n\
    \            \"a length must less than b length\"\n        );\n    }\n    String::from_utf8(binary_xor_str(a))",
  "    assert!(!a.is_empty() && !b.is_empty());\n    if a.len() < b.len() {\n    \
    \    String::from(a) ^ String::from(b)\n    } else if a.len() > b.len() {\n  \
    \      String::from(b) ^ String::from(a)\n    } else {\n        String::from(a)\
    \ ^ String::from(b)\n    }", "    let a = a.chars().filter(|x| x.is_ascii()).collect::<Vec<_>>();\n\
    \    let b = b.chars().filter(|x| x.is_ascii()).collect::<Vec<_>>();\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&a[i\
    \ ^ b[i..].iter().map(|x| match x {\n            0 => \"0\",\n            1 =>\
    \ \"1\",\n            _ => panic!(),\n        }).collect::<String>());\n    }\n\
    \    res", "    let a = a.to_vec();\n    let b = b.to_vec();\n    let mut result\
    \ = String::with_capacity(a.len() + b.len());\n    for i in 0..a.len() {\n   \
    \     result.set_str(i, a[i] ^ b[i]);\n    }\n    result", "    if a.len() !=\
    \ b.len() {\n        panic!(\"Length of input must be equal!\");\n    }\n    let\
    \ mut res = String::new();\n    for i in 0..a.len() {\n        res.push_str(&(a[i]\
    \ - b[i]).to_string());\n    }\n    res", "    assert_eq!(\n        String::from(std::mem::transmute(\n\
    \            a ^ b\n        )),\n        string_xor(a, b)\n    );\n    assert_eq!(a,\
    \ String::from(a));\n    assert_eq!(b, String::from(b));\n    assert_eq!(a, String::from(&a));\n\
    \    assert_eq!(b, String::from(&b));\n    assert_eq!(String::from(&a ^ &b), String::from(&a\
    \ ^ &b));\n    assert_eq!(String::from(&a ^ &b), string_xor(a, b));\n    assert_eq!(\n\
    \        String::from(\n            &a ^ &b\n        ),\n        string_xor(&a,\
    \ &b)\n    );\n    assert_eq!(\n        String::from(\n            &a ^ &b\n \
    \       ),\n        string_xor(String::from(&a), String::from(&b))\n    );\n \
    \   assert_eq!(\n        String::from(\n            &a ^ &b\n        ),\n    \
    \    string_xor(String::from(&a), &b)\n    );\n    assert_eq!(\n        String::from(\n\
    \            &a ^ &b\n        ),\n        string_xor(&a, String::from(&b))\n \
    \   );\n    assert_eq!(\n        String::from(\n            &a ^ &b\n        ),\n\
    \        string_xor(String::from(&a), String::from(&b))\n    );\n    assert_eq!(\n\
    \        String::from(\n            &a ^ &b\n        ),\n        string_xor(&a,\
    \ String::from(&b))\n    );\n    assert_eq!(\n        String::from(\n        \
    \    &a ^ &b\n        ),\n        string_xor(String::from(&a), &b)\n    );\n \
    \   assert_eq!(\n        String::from(\n            &a ^ &b\n        ),\n    \
    \    string_xor(String::from(&a), String::from(&b))\n    );\n    assert_eq!(\n\
    \        String::from(\n            &a ^ &b\n        ),\n        string_xor(&a,\
    \ String::from(&b))\n    );\n    assert_eq!(\n        String::from(\n        \
    \    &a ^ &b\n        ),\n        string_xor(String::from(&a), &b)\n    );\n \
    \   assert_eq!(\n        String::from(\n            &a ^ &b\n        ),\n    \
    \    string_xor(String::from(&a), String::from(&b))\n    );\n    assert_eq!(\n\
    \        String::from(\n            &a ^ &b\n        ),\n        string_xor(&a,\
    \ String::from(&b))\n    );\n    assert_eq!(\n        String", "    // convert\
    \ a and b to binary, then perform xor on them\n    let mut a = a.to_string();\n\
    \    let mut b = b.to_string();\n    let mut carry = false;\n    let mut a_len\
    \ = a.len();\n    let mut b_len = b.len();\n    while a_len > 0 || b_len > 0 {\n\
    \        if a_len > 0 {\n            let a_element = a.as_str()[0];\n        \
    \    a += \"1\".to_string();\n            a_len -= 1;\n            if a_len ==\
    \ 0 {\n                carry = false;\n                a_len = 0;\n          \
    \  }\n        } else {\n            let b_element = b.as_str()[0];\n         \
    \   b += \"1\".to_string();\n            b_len -= 1;\n            if b_len ==\
    \ 0 {\n                carry = false;\n                b_len = 0;\n          \
    \  }\n        }\n        if carry {\n            a = (&a[..a_len].to_string()\
    \ + (a_element + \"0\").to_string()[..]).to_owned();\n        } else {\n     \
    \       b = (&b[..b_len].to_string() + (b_element + \"0\").to_string()[..]).to_owned();\n\
    \        }\n        carry = a_element != b_element;\n    }\n    return a;", " \
    \   if a.len() == 0 || b.len() == 0 {\n        String::new()\n    } else {\n \
    \       binary_xor_helper(&a, &b).to_string()\n    }", '    String::from_utf8(a
    ^ b).expect("Binary xor on invalid input")', "    if a == b {\n        return\
    \ a.to_string();\n    }\n    let mut a_rev = a[..].chars().collect::<Vec<_>>();\n\
    \    let mut b_rev = b[..].chars().collect::<Vec<_>>();\n    let mut xor_rev =\
    \ [0u8; 8];\n    let mut i = 0;\n    while i < 8 {\n        xor_rev[i] ^= a_rev[i]\
    \ ^ b_rev[i];\n        i += 1;\n    }\n    xor_rev.rev().iter().cloned().collect::<String>()",
  "    a.cmp(b)\n        .map(|c| !c)\n        .unwrap_or(true)\n        .to_string()",
  "    let mut result = String::new();\n    let mut a_iter = a.char_indices().copied().collect::<Vec<_>>();\n\
    \    let mut b_iter = b.char_indices().copied().collect::<Vec<_>>();\n    a_iter.sort();\n\
    \    b_iter.sort();\n    for i in a_iter {\n        if b_iter.contains(&(i[0]))\
    \ {\n            result.push((*i[0]) ^ (*i[1]));\n        }\n    }\n    result",
  "    assert!(!a.is_empty());\n    assert!(!b.is_empty());\n    let len = a.len();\n\
    \    assert!(len > 0 && len <= 256);\n\n    let mut xor = 0;\n    for i in 0..len\
    \ {\n        xor = xor | a.bytes().nth(i) ^ b.bytes().nth(i);\n    }\n    let\
    \ mut result = String::with_capacity(len);\n    for i in 0..len {\n        result.push(xor\
    \ & 1);\n        xor = xor >> 1;\n    }\n    result", "    let mut xor_str = \"\
    \".to_string();\n    for c in &a | &b {\n        xor_str += (*c as u8)\n     \
    \       ^ xor_str.len() as u8\n            + (*xor_str.len() as u8) as u8;\n \
    \       xor_str += c as char;\n    }\n    xor_str", "    let mut ret = vec![];\n\
    \    let a = a.chars().collect::<Vec<_>>();\n    let b = b.chars().collect::<Vec<_>>();\n\
    \    for i in 0..a.len() {\n        if a[i] ^ b[i] != 0 {\n            ret.push('a');\n\
    \        } else {\n            ret.push('0');\n        }\n    }\n    ret.join(\"\
    \").to_string()", "    if a.len() != b.len() {\n        panic!(\"Strings are of\
    \ different lengths\")\n    }\n\n    let mut c = String::from(\"\");\n    for\
    \ i in 0..a.len() {\n        c.push_str(&if a.chars().nth(i).unwrap() != b.chars().nth(i).unwrap()\
    \ {\n            '0'\n        } else {\n            '1'\n        });\n    }\n\
    \    c", "    assert!(a != b);\n    let mut a = a.chars().collect::<String>();\n\
    \    let mut b = b.chars().collect::<String>();\n    b.copy_from_slice(&mut a);\n\
    \    b.to_owned()", '    bincode_str!("(~{:0>b} ^ {:0>a})", a, b)', "    if a.len()\
    \ != b.len() {\n        panic!(\"Inconsistent lengths for string xor\");\n   \
    \ }\n\n    let mut result = String::new();\n    let mut carry = 0;\n\n    for\
    \ (a, b) in zip(a.chars(), b.chars()) {\n        let result = result + (*a ^ *b)\
    \ + (carry << 1);\n        carry = (*a & 0b1) + (*b & 0b1);\n    }\n\n    if carry\
    \ != 0 {\n        result = result + &format!(\"{:?}\", carry);\n    }\n\n    result",
  "    let mut c = String::with_capacity(a.len());\n    for i in 0..a.len() {\n  \
    \      c.push(a[i] - b[i]);\n    }\n    c", "    let mut res = String::new();\n\
    \    for x in a.as_bytes().iter() {\n        res.push_str(&format!(\"{:?}\", x));\n\
    \    }\n    for y in b.as_bytes().iter() {\n        res.push_str(&format!(\"{:?}\"\
    , y));\n    }\n    res", '    a + &b[..]', "    let mut result: Vec<u8> = vec![0;\
    \ a.len()];\n\n    result.iter_mut().for_each(|&c| {\n        if c == b'0' {\n\
    \            *c = b'1';\n        } else {\n            *c = b'0';\n        }\n\
    \    });\n    String::from_utf8_lossy(&result).unwrap()", "    let mut c = a.clone();\n\
    \    c.rev();\n    let mut d = b.clone();\n    d.rev();\n    for (a, b) in c.chars().zip(d.chars())\
    \ {\n        if *a != *b {\n            return c.clone();\n        }\n    }\n\
    \    c", '    format!("{}{}", a, b).to_string()', "    String::from(\n       \
    \ (a as &str) ^ b\n            .char_indices()\n            .filter_map(|i| i.map(|idx|\
    \ match idx {\n                0 => 1,\n                _ => 0,\n            }))\n\
    \            .collect::<String>()\n    )", "    let mut result = String::new();\n\
    \    let len = cmp::min(a.length(), b.length());\n    for i in 0..len {\n    \
    \    let c = a.get(i) ^ b.get(i);\n        if c != 0 {\n            result.push((c\
    \ % 2).to_string());\n        }\n    }\n    result", '    String::from_utf8(a.as_bytes()).xor_utf8(b.as_bytes()).to_string()',
  "    if a.len() != b.len() {\n        String::from(\"0\")\n    } else {\n      \
    \  a.to_string().chars().fold(String::from(\"0\"), |acc, x| acc ^ x.to_string().chars().fold(String::from('0'),\
    \ |acc, y| acc ^ y.to_string().chars().fold(String::from('0'), |acc, z| acc ^\
    \ z)));\n    }", "    let mut res = String::new();\n    for x in a.chars() {\n\
    \        match b.chars().next() {\n            None => res.push(x),\n        \
    \    Some(y)\n                if x == y => res.push(x),\n            Some(y) =>\
    \ res.push(y),\n        }\n    }\n    res", "    let mut res = String::from(b);\n\
    \    for i in 0..a.len() {\n        if a[i] == '1' {\n            *res += '0';\n\
    \        } else {\n            *res += '1';\n        }\n    }\n    res", "   \
    \ let mut result = String::new();\n    for i in 0..a.len() {\n        let mut\
    \ curr = a.chars();\n        curr.next() && curr.next().unwrap();\n        let\
    \ mut curr = b.chars();\n        curr.next() && curr.next().unwrap();\n      \
    \  result.push((curr.get(0) ^ curr.get(1)));\n    }\n    result", "    let mut\
    \ result = String::new();\n    for &bchar in b.chars().iter() {\n        result.push(bchar.xor(a[bchar.index()].unwrap()).to_string());\n\
    \    }\n    result", '    a.to_owned() ^ b.to_owned()', "    String::from(a.chars().zip(b.chars())\n\
    \        .filter(|(a, _)| a == 0)\n        .map(|(a, _)| a.clone())\n        .collect::<Vec<_>>())",
  "    binary_xor_iter(a.as_bytes(), b.as_bytes())\n        .fold(String::new(), |mut\
    \ acc, i| acc.push_str(&*i));", "    let mut a = [0u8; a.len()];\n    a.copy_from_slice(&a.as_bytes());\n\
    \    let mut b = [0u8; b.len()];\n    b.copy_from_slice(&b.as_bytes());\n    for\
    \ i in 0..a.len() {\n        a[i] ^= b[i];\n    }\n    String::from_utf8(a).unwrap()",
  "    let mut result = String::new();\n    for i in a.chars() {\n        result.push_str(b[i\
    \ ^ 1].to_string());\n    }\n    result", "    assert!(a.len() == b.len());\n\
    \    let mut a = a.to_string();\n    let mut b = b.to_string();\n    while a.len()\
    \ > 0 && b.len() > 0 {\n        let a_char = a.chars().next().unwrap();\n    \
    \    let b_char = b.chars().next().unwrap();\n        *a ^= *b;\n        *b ^=\
    \ a_char;\n        *a ^= b_char;\n        a.remove(0);\n        b.remove(0);\n\
    \    }\n    String::from(a)", "    let mut result = String::from(\"0\");\n   \
    \ for &c in &a { result ^= b[c.index(0)] };\n    result", '    binary_xor_iter(a.as_ref(),
    b.as_ref())', '    String::from_utf8(a.as_bytes()).xor_prefix(b.as_bytes()).to_string()',
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()', "    a + &b\n      \
    \  .chars()\n        .filter(|&c| c == '0' || c == '1')\n        .collect::<String>()",
  "    let mut res = String::from(a);\n    res.chars().for_each(|c| {\n        if\
    \ *c != *b {\n            *c = '0';\n        }\n    });\n    res", '    String::from_utf8(a.to_utf8()).unwrap()
    ^ String::from_utf8(b.to_utf8()).unwrap()', "    let mut res = String::new();\n\
    \    for i in 0..a.len() {\n        if a[i] == b[i] {\n            res.push('a');\n\
    \        } else {\n            res.push('0');\n        }\n    }\n    res", '    a.iter().zip(b.iter()).map(|(a,
    b)| a ^ b).collect()', '    a.iter().chain(b.iter()).cloned().map(|b| b ^ 1).collect()',
  '    format!("{}{}", a.chars().zip(b).fold(String::new(), |res, (_, _b)| res + &_b).to_owned(),
    a)', "    a.to_owned().iter().zip(b.to_owned().iter()).map(|(x, y)| {\n      \
    \  match x ^ y {\n            0 => \"0\",\n            1 => \"1\",\n         \
    \   -1 => \"-1\",\n            _ => \"\",\n        }\n    }).collect::<String>().to_string()",
  '    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect::<String>()', "    assert_eq!(a.len(),\
    \ b.len());\n    let mut out = String::new();\n    for i in 0..a.len() {\n   \
    \     if a[i] != b[i] {\n            if a[i] < b[i] {\n                out.push(a[i]);\n\
    \            } else {\n                out.push(b[i]);\n            }\n      \
    \  }\n    }\n    out", "    let mut res = String::from(\"0\");\n    for (a, b)\
    \ in zip(a.split(''), b.split('')) {\n        if a != b {\n            res.push((a\
    \ ^ b) as char);\n        }\n    }\n    res", '    binary_xor_chars(a.as_bytes(),
    b).unwrap()', "    // Calculate the string lengths\n    let lena = a.len();\n\
    \    let lenb = b.len();\n\n    let mut c = String::new();\n    if lena > lenb\
    \ {\n        c.resize(lena, 0);\n        let mut cb = c.as_bytes();\n        for\
    \ (i, x) in a.chars().enumerate() {\n            cb[i..] = x.to_le_bytes();\n\
    \        }\n    } else {\n        c.resize(lenb, 0);\n        let mut ca = c.as_bytes();\n\
    \        for (i, x) in b.chars().enumerate() {\n            ca[i..] = x.to_le_bytes();\n\
    \        }\n    }\n\n    // XOR them together\n    let mut cb = c.as_bytes();\n\
    \    for (i, x) in ca.iter_mut().zip(b.iter_mut()) {\n        *x = *x ^ *x;\n\
    \    }\n    c", '    binary_xor_impl(a.data(), b.data()).to_string()', '    a.iter().zip(b.iter()).map(|(a,
    b)| a^b).collect()', '    String::from(a.to_owned() ^ b.to_owned())', "    if\
    \ a.len() != b.len() {\n        String::from(\"false\")\n    } else {\n      \
    \  let mut res = String::new();\n        for &i in a.bytes() {\n            res.push_str(&i.to_string().unwrap_or(\"\
    0\"));\n            res.push(' ');\n        }\n        for &i in b.bytes() {\n\
    \            res.push_str(&i.to_string().unwrap_or(\"0\"));\n            res.push('\
    \ ');\n        }\n        res.push_str(&res.last().to_string().unwrap_or(\"0\"\
    ))\n    }", '    a.iter().zip(b.iter()).map(|(a, b)| format!("{:02x}", a ^ b)).collect()',
  "    // return if both strings are equal\n    if a == b {\n        return a;\n \
    \   }\n    // return if both strings are empty\n    if a.is_empty() || b.is_empty()\
    \ {\n        return a;\n    }\n    // return if length of both strings are different\n\
    \    if a.len() != b.len() {\n        return b;\n    }\n    // return if length\
    \ of both strings are same\n    for i in 0..a.len() {\n        if a[i] != b[i]\
    \ {\n            return b;\n        }\n    }\n    // both strings have a common\
    \ substring\n    let mut res = String::from(\"0\");\n    for i in 0..a.len() {\n\
    \        res.push_str(&format!(\"{}{}\", a[i], b[i]));\n    }\n    return res;",
  "    assert_eq!(\n        a_len_eq(b),\n        true,\n        \"Length of strings\
    \ must be equal for string_xor to work\"\n    );\n    let mut a: Vec<u8> = vec![0u8;\
    \ a.len()];\n    let mut b: Vec<u8> = vec![0u8; b.len()];\n    for (i, a) in a.iter_mut().enumerate()\
    \ {\n        a[i] = a.chars().next().unwrap();\n    }\n    for (i, b) in b.iter_mut().enumerate()\
    \ {\n        b[i] = b.chars().next().unwrap();\n    }\n    String::from_utf8(\n\
    \        (&a).iter().map(|&c| c ^ &b[i as usize]).collect::<Vec<_>>(),\n    )",
  "    let mut a_len = (a as &str).len();\n    let mut b_len = (b as &str).len();\n\
    \    loop {\n        match a_len < b_len {\n            true => break a_len,\n\
    \            false => a_len,\n        }\n        match b_len < a_len {\n     \
    \       true => break b_len,\n            false => b_len,\n        }\n    }\n\
    \    let mut res = String::with_capacity(a_len);\n    res\n        .append(&a[a_len..a_len\
    \ + b_len])\n        .append(&b[b_len..b_len + a_len])\n        .to_string();\n\
    \    res", "    let mut result = String::new();\n    for &bv in b.bytes() {\n\
    \        if a.is_empty() {\n            result.push(bv);\n        } else {\n \
    \           result.push(a[0] as u8 ^ bv);\n        }\n        a.shift();\n   \
    \ }\n    result", "    a.iter().chain(b.iter()).map(|b| if b == '0' then '1' else\
    \ '0').collect()", '    a.to_owned() & b.to_owned()', "    assert!(\n        a.len()\
    \ == b.len(),\n        \"Both strings must have same length.\".to_string(),\n\
    \    );\n\n    a.iter().zip(b.iter()).map(|(a, b)| a ^ b).collect()", '    format!("{:b}",
    bincode::Xor(&a.as_bytes(), &b.as_bytes()))', "    let mut result = String::from(a);\n\
    \    for i in 0..a.len() {\n        result.insert(i, b.chars().nth(i).unwrap());\n\
    \    }\n    result", "    let mut out = String::new();\n    for &i in a & b {\n\
    \        out.push(i);\n    }\n    out", "    let mut result = String::from(\"\"\
    );\n\n    for (i_a, i_b) in a.chars().zip(b.chars()) {\n        if i_a == i_b\
    \ {\n            result.push(i_a);\n        } else {\n            result.push(b'1');\n\
    \        }\n    }\n\n    result", "    debug_assert!(\n        a.len() == b.len(),\n\
    \        \"a and b have different lengths {} and {}\",\n        a.len(),\n   \
    \     b.len()\n    );\n\n    let mut result = String::from(\"\");\n    for i in\
    \ 0..a.len() {\n        result.append(&a[i >> 1][i & 1]);\n    }\n    for i in\
    \ 0..b.len() {\n        result.append(&b[i >> 1][i & 1]);\n    }\n    result",
  '    a.to_owned() & b.to_owned()', "    assert_eq!(binary_string_length(a), binary_string_length(b));\n\
    \    let mut output = String::new();\n    for i in 0..binary_string_length(a)\
    \ {\n        output.push_str(&(a.chars()[i as usize] ^ b.chars()[i as usize]));\n\
    \    }\n    output"]
stop_tokens:
- "\n}"
