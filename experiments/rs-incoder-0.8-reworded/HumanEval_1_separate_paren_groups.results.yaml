language: rs
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    paren_string.chars().for_each(|c|\
    \ {\n        // If open\n        if c.is_whitespace() {\n            output.push(String::from(\"\
    \"));\n        } else if c == ')' || c == '(' {\n            // If open\n    \
    \        output.push(String::from(\"\"));\n        } else {\n            // Not\
    \ open and not close\n            if output.is_empty() {\n                // If\
    \ close, close all open parens\n                if c == '(' {\n              \
    \      output.push(String::from(\"\"));\n                } else {\n          \
    \          output.push(String::from(\"\"));\n                }\n            }\n\
    \n            output.push(c.to_string());\n        }\n    });\n\n    output\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\
    \", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpohbbvirx.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut paren_groups = vec![];\n\
    \    while !paren_string.is_empty() {\n        let start_index = paren_string.rfind('(');\n\
    \        if start_index == -1 {\n            paren_groups.push(paren_string);\n\
    \            break;\n        }\n        let end_index = paren_string.find(')',\
    \ start_index);\n        let group = paren_string[start_index..end_index].to_string();\n\
    \        paren_groups.push(group);\n        paren_string = paren_string.trim_right_matches(')');\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn5seuxir.rs:12:27\n   |\n\
    12 |         if start_index == -1 {\n   |                           ^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |         if start_index == Some(-1) {\n   |                       \
    \    +++++  +\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmpn5seuxir.rs:16:38\n     |\n16   |         let\
    \ end_index = paren_string.find(')', start_index);\n     |                   \
    \                   ^^^^ ---  ----------- supplied 2 arguments\n     |       \
    \                               |\n     |                                    \
    \  expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `std::ops::Range<Option<usize>>`\n  -->\
    \ /tmp/tmpn5seuxir.rs:17:21\n   |\n17 |         let group = paren_string[start_index..end_index].to_string();\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `std::ops::Range<Option<usize>>`\n   = help: the following other types implement\
    \ trait `SliceIndex<T>`:\n             <std::ops::Range<usize> as SliceIndex<[T]>>\n\
    \             <std::ops::Range<usize> as SliceIndex<str>>\n   = note: required\
    \ because of the requirements on the impl of `Index<std::ops::Range<Option<usize>>>`\
    \ for `str`\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right_matches`: superseded by `trim_end_matches`\n  --> /tmp/tmpn5seuxir.rs:19:37\n\
    \   |\n19 |         paren_string = paren_string.trim_right_matches(')');\n   |\
    \                                     ^^^^^^^^^^^^^^^^^^ help: replace the use\
    \ of the deprecated associated function: `trim_end_matches`\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpn5seuxir.rs:21:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ Strin"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack: Vec<String> = vec![];\n\n    let mut paren_strings =\
    \ paren_string.char_indices()\n        .filter_map(|b| {\n            if b[0]\
    \ < b[1] {\n                None\n            } else {\n                Some(paren_stack.push(b[1]))\n\
    \            }\n        })\n        .collect::<Vec<_>>();\n\n    if paren_strings.len()\
    \ != 0 {\n        paren_stack.push(paren_strings.last().unwrap());\n    }\n\n\
    \    paren_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `(usize, char)`\n  -->\
    \ /tmp/tmprurw3kd7.rs:12:16\n   |\n12 |             if b[0] < b[1] {\n   |   \
    \             ^^^^ help: to access tuple elements, use: `b.0`\n\nerror[E0608]:\
    \ cannot index into a value of type `(usize, char)`\n  --> /tmp/tmprurw3kd7.rs:12:23\n\
    \   |\n12 |             if b[0] < b[1] {\n   |                       ^^^^ help:\
    \ to access tuple elements, use: `b.1`\n\nerror[E0608]: cannot index into a value\
    \ of type `(usize, char)`\n  --> /tmp/tmprurw3kd7.rs:15:39\n   |\n15 |       \
    \          Some(paren_stack.push(b[1]))\n   |                                \
    \       ^^^^ help: to access tuple elements, use: `b.1`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprurw3kd7.rs:21:26\n   |\n21 |         paren_stack.push(paren_strings.last().unwrap());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprurw3kd7.rs:24:5\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                   ----------- expected `Vec<String>`\
    \ because of return type\n...\n24 |     paren_strings\n   |     ^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<()>`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n\n    for paren in paren_string.chars()\
    \ {\n        if paren == char::NL || paren == char::CR {\n            // Ignore\
    \ carriage returns and new line\n            continue;\n        }\n        if\
    \ paren == char::LBRACE || paren == char::RBRACE {\n            paren_groups.push((paren_groups.pop().unwrap()));\n\
    \        } else {\n            paren_groups.push(paren);\n        }\n    }\n\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpywup2mhm.rs:16:31\n\
    \   |\n16 |             paren_groups.push((paren_groups.pop().unwrap()));\n  \
    \ |                               ^                           ^\n   |\n   = note:\
    \ `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n   |\n\
    16 -             paren_groups.push((paren_groups.pop().unwrap()));\n16 +     \
    \        paren_groups.push(paren_groups.pop().unwrap());\n   | \n\nerror[E0599]:\
    \ no associated item named `NL` found for type `char` in the current scope\n \
    \ --> /tmp/tmpywup2mhm.rs:11:27\n   |\n11 |         if paren == char::NL || paren\
    \ == char::CR {\n   |                           ^^ associated item not found in\
    \ `char`\n\nerror[E0599]: no associated item named `CR` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpywup2mhm.rs:11:48\n   |\n11 |         if\
    \ paren == char::NL || paren == char::CR {\n   |                             \
    \                   ^^ associated item not found in `char`\n\nerror[E0599]: no\
    \ associated item named `LBRACE` found for type `char` in the current scope\n\
    \  --> /tmp/tmpywup2mhm.rs:15:27\n   |\n15 |         if paren == char::LBRACE\
    \ || paren == char::RBRACE {\n   |                           ^^^^^^ associated\
    \ item not found in `char`\n\nerror[E0599]: no associated item named `RBRACE`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpywup2mhm.rs:15:52\n\
    \   |\n15 |         if paren == char::LBRACE || paren == char::RBRACE {\n   |\
    \                                                    ^^^^^^ associated item not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpywup2mhm.rs:22:5\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                   ----------- expected `Vec<String>`\
    \ because of return type\n...\n22 |     paren_groups\n   |     ^^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 5 previous errors;\
    \ 1 warning emitted\n\nSome errors have detaile"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_groups = paren_string.split(\"((?=\\\\()|(?=\\\\))\"));\n    let\
    \ mut paren_strings = Vec::new();\n\n    for group in paren_groups {\n       \
    \ let mut paren_string = String::from(\"(\");\n        let mut open_brace_counter\
    \ = 0;\n\n        for char in group.chars() {\n            match char {\n    \
    \            '(' as u8 => open_brace_counter = open_brace_counter + 1,\n     \
    \           ')' as u8 => open_brace_counter = open_brace_counter - 1,\n      \
    \          _ => (),\n            };\n\n            match open_brace_counter {\n\
    \                0 => paren_string.push_str(&char),\n                1 => paren_string.push_str(\"\
    ()\"),\n                _ => (),\n            };\n        }\n\n        paren_strings.push(paren_string);\n\
    \    }\n\n    paren_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmp_leacjwg.rs:33:1\n\
    \   |\n11 |     for group in paren_groups {\n   |                            \
    \   - this opening brace...\n...\n30 |     }\n   |     - ...matches this closing\
    \ brace\n...\n33 | }\n   | ^ unexpected closing delimiter\n\nerror: mismatched\
    \ closing delimiter: `)`\n --> /tmp/tmp_leacjwg.rs:7:63\n  |\n7 | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n  |                                              \
    \                 ^ unclosed delimiter\n8 |     let paren_groups = paren_string.split(\"\
    ((?=\\\\()|(?=\\\\))\"));\n  |                                               \
    \               ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut iter = paren_string.char_indices();\n    let mut parens = Vec::new();\n\
    \    let mut open_parens = Vec::new();\n    let mut closed_parens = Vec::new();\n\
    \    while let Some(mut index) = iter.next() {\n        match index {\n      \
    \      None => (),\n            Some(index) => {\n                let char = paren_string[index\
    \ as usize];\n                if char == '(' { parens.push(char); }\n        \
    \        if char == ')' { closed_parens.push(char); }\n            }\n       \
    \ }\n    }\n    while !closed_parens.is_empty() {\n        parens.push(closed_parens.pop());\n\
    \    }\n    while !open_parens.is_empty() {\n        parens.push(open_parens.pop());\n\
    \    }\n    parens\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpubi5yg48.rs:14:13\n   |\n\
    13 |         match index {\n   |               ----- this expression has type\
    \ `(usize, char)`\n14 |             None => (),\n   |             ^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpubi5yg48.rs:15:13\n   |\n13 |         match index {\n   |          \
    \     ----- this expression has type `(usize, char)`\n14 |             None =>\
    \ (),\n15 |             Some(index) => {\n   |             ^^^^^^^^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found enum `Option<_>`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpubi5yg48.rs:16:28\n   |\n16 |         \
    \        let char = paren_string[index as usize];\n   |                      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpubi5yg48.rs:23:21\n\
    \   |\n23 |         parens.push(closed_parens.pop());\n   |                  \
    \   ^^^^^^^^^^^^^^^^^^^ cyclic type of infinite size\n\nerror[E0277]: can't compare\
    \ `Option<_>` with `char`\n  --> /tmp/tmpubi5yg48.rs:18:25\n   |\n18 |       \
    \          if char == ')' { closed_parens.push(char); }\n   |                \
    \         ^^ no implementation for `Option<_> == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `Option<_>`\n   = help: the trait `PartialEq`\
    \ is implemented for `Option<T>`\n\nerror[E0277]: can't compare `Option<_>` wi"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string_stack = paren_string.chars().collect::<Vec<Char>>();\n\
    \    let mut result_vec: Vec<String> = vec![];\n    let mut cur_pos = 0;\n   \
    \ let mut open_braces = 0;\n    let mut closed_braces = 0;\n\n    while cur_pos\
    \ < paren_string.len() {\n        // Go until we reach a closing brace, or we\
    \ reach the end of the string.\n        while cur_pos < paren_string.len() &&\
    \ paren_string_stack[cur_pos] == ')' {\n            cur_pos += 1;\n        }\n\
    \n        if cur_pos == paren_string.len() {\n            break;\n        }\n\n\
    \        // If the current position is open, we count the number of closed braces\
    \ until we reach the current\n        // open brace, or we reach the end of the\
    \ string.\n        while cur_pos < paren_string.len() && paren_string_stack[cur_pos]\
    \ == '(' {\n            if open_braces > closed_braces {\n                closed_braces\
    \ += 1;\n            } else {\n                open_braces += 1;\n           \
    \ }\n\n            cur_pos += 1;\n        }\n\n        // Push a group if the\
    \ stack is empty or if the current position is not open\n        if paren_string_stack.len()\
    \ == 0 || paren_string_stack[paren_string_stack.len() - 1] != ')' {\n        \
    \    result_vec.push(paren_string.chars().take(cur_pos).collect::<String>());\n\
    \        }\n    }\n\n    paren_string_stack\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmpe4jem5oh.rs:8:69\n\
    \  |\n8 |     let mut paren_string_stack = paren_string.chars().collect::<Vec<Char>>();\n\
    \  |                                                                     ^^^^\n\
    \  |\nhelp: a builtin type with a similar name exists\n  |\n8 |     let mut paren_string_stack\
    \ = paren_string.chars().collect::<Vec<char>>();\n  |                        \
    \                                             ~~~~\nhelp: you might be missing\
    \ a type parameter\n  |\n7 | fn separate_paren_groups<Char>(paren_string: String)\
    \ -> Vec<String> {\n  |                         ++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack: Vec<String> = Vec::new();\n    paren_string.chars().for_each(|c|{\n\
    \        if c == '(' {\n            stack.push(String::from(\"(\"));\n       \
    \ } else if c == ')' {\n            match stack.pop() {\n                Some(String::from(\"\
    (\")) => {}\n                Some(String::from(\"))\")) => {\n               \
    \ }\n                None => return None,\n            }\n        } else if stack.is_empty()\
    \ {\n            return None;\n        }\n    });\n    stack\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpkta18bke.rs:14:22\n   |\n14 |       \
    \          Some(String::from(\"(\")) => {}\n   |                      ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpkta18bke.rs:15:22\n   |\n15 |                 Some(String::from(\"\
    ))\")) => {\n   |                      ^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed\
    \ in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkta18bke.rs:17:32\n   |\n17 |\
    \                 None => return None,\n   |                                ^^^^\
    \ expected `()`, found enum `Option`\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<_>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0164, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = vec![];\n    let mut open_parens: usize = 0;\n\
    \    let mut closed_parens: usize = 0;\n    let mut last_string: Option<String>\
    \ = None;\n    let mut inside_group = false;\n    for char in paren_string.chars()\
    \ {\n        if inside_group {\n            // We hit a closed paren inside a\
    \ group\n            open_parens--;\n        }\n        if char == ')' {\n   \
    \         // We hit a closing paren\n            if open_parens > closed_parens\
    \ {\n                // Close the group if we haven't closed it already\n    \
    \            open_parens++;\n            }\n            closed_parens++;\n   \
    \     } else if char == '(' {\n            // We hit an opening paren\n      \
    \      open_parens++;\n        }\n        if char == ' ' {\n            // We\
    \ hit a space in the group\n            if last_string == None {\n           \
    \     // We haven't hit any spaces yet\n                inside_group = true;\n\
    \            }\n        } else {\n            // We haven't hit a space yet\n\
    \            if last_string != None {\n                // We have a space between\
    \ groups\n                groups.push(last_string.unwrap());\n            }\n\
    \            last_string = Some(String::from(&char));\n        }\n    }\n    if\
    \ last_string != None {\n        // We have a space at the end\n        groups.push(last_string.unwrap());\n\
    \    }\n    if open_parens == 0 {\n        // We have zero open parens, no grouping\
    \ required\n        return groups;\n    }\n    // We have some parens open, need\
    \ to close them\n    let mut open_paren_groups: Vec<String> = vec![];\n    for\
    \ group in groups {\n        let open = open_parens - 1;\n        let closed =\
    \ open_parens - group.length;\n        let mut opening_paren = open_parens;\n\
    \        let mut closing_paren = 0;\n        while opening_paren > 0 {\n     \
    \       opening_paren--;\n            if opening_paren > closed { // need to close\
    \ this group\n                closing_paren++;\n                opening_paren--;\n\
    \            }\n        }\n        open_paren_groups.push(group.clone());\n  \
    \      for _ in 0..(closing_paren - open) {\n            open_paren_groups.push(\"\
    \");\n        }\n    }\n    open_paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp90o88i3t.rs:16:26\n\
    \   |\n16 |             open_parens--;\n   |                          ^ expected\
    \ expression\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp90o88i3t.rs:22:28\n\
    \   |\n22 |                 open_parens++;\n   |                            ^^\
    \ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |   \
    \              { let tmp = open_parens; open_parens += 1; tmp };\n   |       \
    \          +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n22 -            \
    \     open_parens++;\n22 +                 open_parens += 1;\n   | \n\nerror:\
    \ Rust has no postfix increment operator\n  --> /tmp/tmp90o88i3t.rs:24:26\n  \
    \ |\n24 |             closed_parens++;\n   |                          ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |         \
    \    { let tmp = closed_parens; closed_parens += 1; tmp };\n   |             +++++++++++\
    \              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n24 -             closed_parens++;\n\
    24 +             closed_parens += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmp90o88i3t.rs:27:24\n   |\n27 |             open_parens++;\n\
    \   |                        ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n27 |             { let tmp = open_parens; open_parens\
    \ += 1; tmp };\n   |             +++++++++++            ~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    27 -             open_parens++;\n27 +             open_parens += 1;\n   | \n\n\
    error: expected expression, found `;`\n  --> /tmp/tmp90o88i3t.rs:60:28\n   |\n\
    60 |             opening_paren--;\n   |                            ^ expected\
    \ expression\n\nerror[E0277]: the trait bound `String: From<&char>` is not satisfied\n\
    \  --> /tmp/tmp90o88i3t.rs:41:32\n   |\n41 |             last_string = Some(String::from(&char));\n\
    \   |                                ^^^^^^^^^^^^ the trait `From<&char>` is not\
    \ implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `From<T>`:\n             <String as From<&String>>\n             <String\
    \ as From<&mut str>>\n             <St"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_braces: Vec<bool> = Vec::new();\n    paren_string.chars().for_each(|c|\
    \ {\n        if c == ')' {\n            if !open_braces.is_empty() {\n       \
    \         open_braces.pop();\n            }\n        } else {\n            open_braces.push(c\
    \ == '(');\n        }\n    });\n    open_braces.iter().filter_map(|b| !b).collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpor5qlra6.rs:18:39\n   |\n\
    18 |     open_braces.iter().filter_map(|b| !b).collect()\n   |               \
    \                        ^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n18 |     open_braces.iter().filter_map(|b| Some(!b)).collect()\n\
    \   |                                       +++++  +\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter_map(|c|\n            if c\
    \ == '(' {\n                Some(c as char)\n            } else {\n          \
    \      None\n            })\n        .filter(|c| !c.is_whitespace())\n       \
    \ .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9kok7y4a.rs:8:5\n   |\n7\
    \  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   | \
    \                                                    ----------- expected `Vec<String>`\
    \ because of return type\n8  | /     paren_string\n9  | |         .chars()\n10\
    \ | |         .filter_map(|c|\n11 | |             if c == '(' {\n...  |\n16 |\
    \ |         .filter(|c| !c.is_whitespace())\n17 | |         .collect::<Vec<_>>()\n\
    \   | |____________________________^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .lines()\n        .filter_map(|line| {\n          \
    \  if line.contains(\"{\") {\n                Some(line)\n            } else {\n\
    \                None\n            }\n        })\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpv7x2p0a7.rs:17:10\n     |\n17\
    \   |         .collect::<Vec<String>>()\n     |          ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().filter_map(|c| {\n        if c == '(' || c == ')' ||\
    \ c == '{' || c == '}' {\n            Some(true)\n        } else {\n         \
    \   Some(false)\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `bool`\n    --> /tmp/tmpnj796eeg.rs:14:8\n     |\n14 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=bool>`\n     |\n     = help: the trait\
    \ `FromIterator<bool>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .split_whitespace()\n        .collect::<Vec<_>>()\n\
    \        .filter_map(|x| x.chars().any(|x| x == '(' || x == '{'))\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<&str>` is not an iterator\n   --> /tmp/tmphalv85m9.rs:11:10\n\
    \    |\n11  |           .filter_map(|x| x.chars().any(|x| x == '(' || x == '{'))\n\
    \    |            ^^^^^^^^^^ `Vec<&str>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<&str>: Iterator`\n\
    \            which is required by `&mut Vec<&str>: Iterator`\n            `[&str]:\
    \ Iterator`\n            which is required by `&mut [&str]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_count = 0;\n    let mut paren_groups: Vec<Vec<String>> = vec![];\n\
    \    for (i, c) in paren_string.chars().enumerate() {\n        match c {\n   \
    \         '(' | ')' | ' ' => {\n                if paren_count == 0 {\n      \
    \              paren_groups.push(vec![String::from(\"(\".to_string())]);\n   \
    \             }\n                paren_groups[paren_groups.len() - 1].push(c)\n\
    \                paren_count = paren_count + 1;\n            }\n            '['\
    \ | ']' | ' ' => {\n                if paren_count == 0 {\n                  \
    \  paren_groups.push(vec![String::from(\"[\").to_string()]);\n               \
    \ }\n                paren_groups[paren_groups.len() - 1].push(c)\n          \
    \      paren_count = paren_count + 1;\n            }\n            _ => continue\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `paren_count`\n  --> /tmp/tmp9jnvgcm0.rs:16:61\n\
    \   |\n16 |                 paren_groups[paren_groups.len() - 1].push(c)\n   |\
    \                                                             ^ help: add `;`\
    \ here\n17 |                 paren_count = paren_count + 1;\n   |            \
    \     ----------- unexpected token\n\nerror: expected `;`, found `paren_count`\n\
    \  --> /tmp/tmp9jnvgcm0.rs:23:61\n   |\n23 |                 paren_groups[paren_groups.len()\
    \ - 1].push(c)\n   |                                                         \
    \    ^ help: add `;` here\n24 |                 paren_count = paren_count + 1;\n\
    \   |                 ----------- unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9jnvgcm0.rs:16:59\n   |\n16 |                 paren_groups[paren_groups.len()\
    \ - 1].push(c)\n   |                                                         \
    \  ^- help: try using a conversion method: `.to_string()`\n   |              \
    \                                             |\n   |                        \
    \                                   expected struct `String`, found `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp9jnvgcm0.rs:23:59\n   |\n23 |  \
    \               paren_groups[paren_groups.len() - 1].push(c)\n   |           \
    \                                                ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                               \
    \            |\n   |                                                         \
    \  expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9jnvgcm0.rs:29:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n29 |  \
    \   paren_groups\n   |     ^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `Vec<String>`\n              found struct\
    \ `Vec<Vec<String>>`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack: Vec<String> = vec![];\n    let mut in_group = false;\n   \
    \ let mut paren_count = 0;\n\n    for ch in paren_string.chars() {\n        if\
    \ ch == ')' || ch == '(' {\n            if in_group {\n                stack.push(String::from(char.to_string()));\n\
    \                in_group = false;\n            } else {\n                if paren_count\
    \ == 0 {\n                    stack.push(String::from(char.to_string()));\n  \
    \                  paren_count = 1;\n                } else {\n              \
    \      paren_count += 1;\n                }\n            }\n        } else if\
    \ ch == '{' {\n            stack.push(String::from(char.to_string()));\n     \
    \       in_group = true;\n        } else if ch == '}' {\n            if stack.len()\
    \ == 0 {\n                continue;\n            }\n            paren_count -=\
    \ 1;\n            stack.pop();\n            in_group = true;\n        }\n    }\n\
    \n    stack\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected value, found builtin type `char`\n  --> /tmp/tmplxd6uhcl.rs:15:41\n\
    \   |\n15 |                 stack.push(String::from(char.to_string()));\n   |\
    \                                         ^^^^ not a value\n\nerror[E0423]: expected\
    \ value, found builtin type `char`\n  --> /tmp/tmplxd6uhcl.rs:19:45\n   |\n19\
    \ |                     stack.push(String::from(char.to_string()));\n   |    \
    \                                         ^^^^ not a value\n\nerror[E0423]: expected\
    \ value, found builtin type `char`\n  --> /tmp/tmplxd6uhcl.rs:26:37\n   |\n26\
    \ |             stack.push(String::from(char.to_string()));\n   |            \
    \                         ^^^^ not a value\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0423`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_string: Vec<_> = paren_string.chars()\n        .filter_map(|c|\
    \ match c {\n            '(' | ')' => Some('('),\n            _ => None,\n   \
    \     })\n        .collect();\n    let mut return_vec = Vec::new();\n    for i\
    \ in 0..paren_string.len() {\n        if paren_string[i] == Some('(') {\n    \
    \        paren_string[i] = None;\n            separate_paren_groups(paren_string,\
    \ return_vec)\n        } else {\n            return_vec.push(paren_string[i]);\n\
    \        }\n    }\n    return_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjkxb9jhu.rs:16:31\n   |\n\
    16 |         if paren_string[i] == Some('(') {\n   |                         \
    \      ^^^^^^^^^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjkxb9jhu.rs:17:31\n   |\n17 |             paren_string[i]\
    \ = None;\n   |             ---------------   ^^^^ expected `char`, found enum\
    \ `Option`\n   |             |\n   |             expected due to the type of this\
    \ binding\n   |\n   = note: expected type `char`\n              found enum `Option<_>`\n\
    \nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmpjkxb9jhu.rs:18:13\n   |\n18 |             separate_paren_groups(paren_string,\
    \ return_vec)\n   |             ^^^^^^^^^^^^^^^^^^^^^ ------------  ----------\
    \ supplied 2 arguments\n   |             |\n   |             expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpjkxb9jhu.rs:7:4\n   |\n7  |\
    \ fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |    ^^^^^^^^^^^^^^^^^^^^^\
    \ --------------------\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjkxb9jhu.rs:18:13\n\
    \   |\n16 | /         if paren_string[i] == Some('(') {\n17 | |             paren_string[i]\
    \ = None;\n18 | |             separate_paren_groups(paren_string, return_vec)\n\
    \   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`,\
    \ found struct `Vec`\n19 | |         } else {\n20 | |             return_vec.push(paren_string[i]);\n\
    21 | |         }\n   | |_________- expected this to be `()`\n   |\n   = note:\
    \ expected unit type `()`\n                 found struct `Vec<String>`\nhelp:\
    \ consider using a semicolon here\n   |\n18 |             separate_paren_groups(paren_string,\
    \ return_vec);\n   |                                                         \
    \   +\nhelp: consider using a semicolon here\n   |\n21 |         };\n   |    \
    \      +\nhelp: you might have meant to return this value\n   |\n18 |        \
    \     return separate_paren_groups(paren_string, return_vec);\n   |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // use regex_iterator::Captures;\n    // use std::regex::Regex;\n    let\
    \ paren_str = paren_string.as_str();\n    let paren_iter = paren_str.chars().filter_map(|c|\
    \ if c == '(' { return Some(c) } else { None }).collect();\n    let mut paren_paren_pairs\
    \ = paren_iter\n        .into_iter()\n        .zip(paren_iter)\n        .filter(|(a,\
    \ b)| a == b)\n        .map(|(a, b)| (a, b.into_iter().collect::<Vec<_>>()))\n\
    \        .collect::<Vec<_>>();\n\n    paren_paren_pairs\n        .into_iter()\n\
    \        .flat_map(|paren_group| paren_group.into_iter().collect::<Vec<_>>())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpwitb7y2m.rs:12:33\n\
    \   |\n11 |     let paren_iter = paren_str.chars().filter_map(|c| if c == '('\
    \ { return Some(c) } else { None }).collect();\n   |         ---------- consider\
    \ giving `paren_iter` a type\n12 |     let mut paren_paren_pairs = paren_iter\n\
    \   |                                 ^^^^^^^^^^ cannot infer type\n   |\n   =\
    \ note: type must be known at this point\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut split_string = paren_string.split_whitespace().collect::<Vec<String>>();\n\
    \    let mut stack: Vec<String> = Vec::new();\n    let mut open_braces = 0;\n\
    \    for brace in split_string.iter() {\n        if brace == \"(\" || brace ==\
    \ \"{\" {\n            open_braces += 1;\n        } else if brace == \")\" ||\
    \ brace == \"}\" {\n            open_braces -= 1;\n        }\n        if open_braces\
    \ == 0 {\n            stack.push(brace);\n        }\n    }\n    stack\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp8b6id1as.rs:8:60\n     |\n8  \
    \  |     let mut split_string = paren_string.split_whitespace().collect::<Vec<String>>();\n\
    \     |                                                            ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8b6id1as.rs:18:24\n\
    \   |\n18 |             stack.push(brace);\n   |                        ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \      |\n   |                        expected struct `String`, found `&String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .split_whitespace()\n        .filter(|x| *x != ')')\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmpx7olgqxw.rs:10:24\n\
    \   |\n10 |         .filter(|x| *x != ')')\n   |                        ^^ no\
    \ implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: a value of type `Vec<String>` cannot\
    \ be built from an iterator over elements of type `&str`\n    --> /tmp/tmpx7olgqxw.rs:11:10\n\
    \     |\n11   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_string().to_string();\n\n    // Keep\
    \ track of all the characters we have seen. Whenever a character is seen that\
    \ isn't a closing brace, we\n    // keep track of the position of the character\
    \ and put it into a map along with it's value. Whenever a closing\n    // brace\
    \ is seen, that closing brace is removed and the map values are re-ordered\n \
    \   let mut seen_char_map: HashMap<usize, usize> = HashMap::new();\n    let mut\
    \ current_position = 0;\n    let mut paren_position = 0;\n    let mut paren_char\
    \ = String::new();\n    paren_string.chars().for_each(|c| {\n        if *c !=\
    \ ')' {\n            paren_char.push(*c);\n        } else {\n            paren_position\
    \ = current_position;\n            seen_char_map.insert(paren_position, paren_char.len());\n\
    \            paren_char = String::new();\n        }\n\n        current_position\
    \ += 1;\n    });\n\n    // If the last character we saw wasn't a closing bracket,\
    \ put it into the map\n    if !seen_char_map.contains_key(current_position) {\n\
    \        seen_char_map.insert(current_position, 0);\n    }\n\n    // Create vector\
    \ of strings containing only those groups of nested parentheses\n    let mut paren_group_vec:\
    \ Vec<String> = vec![];\n    seen_char_map.iter().for_each(|(_, char_len)| {\n\
    \        paren_group_vec.push(paren_string.split_last_mut().collect());\n    });\n\
    \    paren_group_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpeia3oa6i.rs:13:28\n\
    \   |\n13 |     let mut seen_char_map: HashMap<usize, usize> = HashMap::new();\n\
    \   |                            ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmpeia3oa6i.rs:13:52\n   |\n13 |     let mut seen_char_map: HashMap<usize,\
    \ usize> = HashMap::new();\n   |                                             \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpeia3oa6i.rs:18:12\n   |\n18 |        \
    \ if *c != ')' {\n   |            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpeia3oa6i.rs:19:29\n   |\n19 |             paren_char.push(*c);\n\
    \   |                             ^^\n\nerror[E0599]: no method named `split_last_mut`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpeia3oa6i.rs:37:43\n\
    \   |\n37 |         paren_group_vec.push(paren_string.split_last_mut().collect());\n\
    \   |                                           ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_at`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0412, E0433,\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack = Vec::<String>::new();\n    let mut cur_paren_group\
    \ = false;\n    let mut paren_group_start = String::from(\"\");\n    let mut paren_group_end\
    \ = String::from(\"\");\n    let mut paren_group_contents = String::from(\"\"\
    );\n    let mut paren_group_closed = false;\n    let mut cur_paren_group_braces\
    \ = String::from(\"\");\n    let mut inside_brace_count = 0;\n    let mut inside_brace_closed\
    \ = false;\n    for ch in paren_string.chars() {\n        if ch == '(' {\n   \
    \         paren_stack.push(paren_group_start.clone());\n            paren_group_start\
    \ = String::from(\"\");\n            cur_paren_group = true;\n            paren_group_contents\
    \ = String::from(\"\");\n            paren_group_closed = false;\n           \
    \ inside_brace_count = 0;\n            inside_brace_closed = false;\n        }\
    \ else if ch == ')' {\n            let paren_group_end = paren_stack.pop().unwrap();\n\
    \            paren_group_contents.push_str(\")\");\n            if !paren_group_closed\
    \ && paren_stack.len() == 0 {\n                paren_group_contents.push_str(&paren_group_end[..]);\n\
    \            }\n            paren_group_closed = true;\n            inside_brace_closed\n\
    \                = paren_group_contents.len() >= 2 && paren_group_contents.chars().any(|c|\
    \ c == '}');\n            if inside_brace_closed {\n                inside_brace_count\n\
    \            }\n            if !inside_brace_closed && paren_stack.len() == 0\
    \ {\n                paren_group_contents.push_str(&paren_group_end[..]);\n  \
    \          }\n            cur_paren_group = false;\n        } else if ch == ')'\
    \ && inside_brace_count != 0 {\n            inside_brace_count -= 1;\n       \
    \ } else {\n            paren_group_contents.push_str(&ch);\n        }\n     \
    \   if inside_brace_count != 0 && cur_paren_group {\n            cur_paren_group\
    \ = false;\n        }\n    }\n    if !inside_brace_closed {\n        paren_group_contents.push_str(&paren_group_end[..]);\n\
    \    }\n    paren_stack.push(paren_group_start.clone());\n    paren_stack\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjucjk29w.rs:36:17\n   |\n\
    35 | /             if inside_brace_closed {\n36 | |                 inside_brace_count\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^ expected `()`, found integer\n37 |\
    \ |             }\n   | |_____________- expected this to be `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjucjk29w.rs:45:43\n   |\n45 |             paren_group_contents.push_str(&ch);\n\
    \   |                                           ^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Create a string builder to store a substring\n    let mut builder = StringBuilder::new();\n\
    \n    // For each substring in the input string\n    for i in paren_string.char_indices()\
    \ {\n        // If the character is one of the opening/closing parens characters\n\
    \        if paren_string[i..i + 1].is_empty() {\n            // Add the substring\
    \ to the string builder\n            builder.push('a');\n        } else {\n  \
    \          // Otherwise, replace the character with the corresponding character\n\
    \            builder.push(paren_string[i]);\n        }\n    }\n\n    // Return\
    \ the vector of substrings\n    builder.collect()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `StringBuilder`\n\
    \ --> /tmp/tmposk8qcaf.rs:9:23\n  |\n9 |     let mut builder = StringBuilder::new();\n\
    \  |                       ^^^^^^^^^^^^^ use of undeclared type `StringBuilder`\n\
    \nerror[E0369]: cannot add `{integer}` to `(usize, char)`\n  --> /tmp/tmposk8qcaf.rs:14:30\n\
    \   |\n14 |         if paren_string[i..i + 1].is_empty() {\n   |             \
    \               - ^ - {integer}\n   |                            |\n   |     \
    \                       (usize, char)\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `std::ops::Range<(usize, char)>`\n  --> /tmp/tmposk8qcaf.rs:14:12\n\
    \   |\n14 |         if paren_string[i..i + 1].is_empty() {\n   |            ^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `std::ops::Range<(usize, char)>`\n   |\n   = help:\
    \ the trait `Index<std::ops::Range<(usize, char)>>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `(usize, char)`\n\
    \  --> /tmp/tmposk8qcaf.rs:19:26\n   |\n19 |             builder.push(paren_string[i]);\n\
    \   |                          ^^^^^^^^^^^^^^^ `String` cannot be indexed by `(usize,\
    \ char)`\n   |\n   = help: the trait `Index<(usize, char)>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = vec![];\n    let mut current_string: String\
    \ = \"\";\n    let mut bracket_stack: Vec<bool> = vec![];\n    for c in paren_string.chars()\
    \ {\n        match c {\n            '(' | ')' => {\n                bracket_stack.push(c\
    \ != '(');\n            }\n            _ => {\n                if bracket_stack.len()\
    \ == 0 {\n                    current_string += &c.to_string();\n            \
    \    } else {\n                    if c == ')' {\n                        bracket_stack.pop();\n\
    \                    }\n                    if c == '(' {\n                  \
    \      result.push(current_string);\n                        current_string =\
    \ \"\";\n                        bracket_stack.push(true);\n                 \
    \   }\n                }\n            }\n        }\n    }\n    if current_string\
    \ != \"\" {\n        result.push(current_string);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp933q62hw.rs:9:38\n  |\n9 |\
    \     let mut current_string: String = \"\";\n  |                            \
    \ ------   ^^- help: try using a conversion method: `.to_string()`\n  |      \
    \                       |        |\n  |                             |        expected\
    \ struct `String`, found `&str`\n  |                             expected due\
    \ to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp933q62hw.rs:25:42\n\
    \   |\n9  |     let mut current_string: String = \"\";\n   |                 \
    \            ------ expected due to this type\n...\n25 |                     \
    \    current_string = \"\";\n   |                                          ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                        |\n   |                                          expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(\"()\")\n        .map(|s| s.trim_end())\n        .filter(|s|\
    \ !s.is_empty())\n        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpgo_kzg6v.rs:11:10\n     |\n11\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut paren_groups_stack = Vec::new();\n\
    \n    let mut char_count = 0;\n    let mut paren_count = 0;\n\n    for c in paren_string.chars()\
    \ {\n        // Skip whitespace and non-paren character\n        if char_count++\
    \ > 0 && c != '(' && c != ')' {\n            continue;\n        }\n\n        if\
    \ char_count++ == 0 {\n            if c == '(' {\n                paren_groups_stack.push(c);\n\
    \                paren_count++;\n            } else {\n                paren_groups_stack.clear();\n\
    \                paren_groups.push(String::from(String::new()));\n           \
    \     paren_count = 0;\n                paren_groups_stack.push(c);\n        \
    \    }\n        } else if c == ')' {\n            if paren_count == 0 {\n    \
    \            paren_groups_stack.pop();\n            } else {\n               \
    \ paren_groups.push(String::from(String::new()));\n            }\n           \
    \ paren_count--;\n        } else if c == '(' {\n            paren_groups_stack.push(c);\n\
    \            paren_count++;\n        }\n    }\n\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfwyy4f18.rs:16:22\n\
    \   |\n16 |         if char_count++ > 0 && c != '(' && c != ')' {\n   |      \
    \                ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n16 |         if { let tmp = char_count; char_count += 1; tmp } > 0 && c\
    \ != '(' && c != ')' {\n   |            +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n\
    16 -         if char_count++ > 0 && c != '(' && c != ')' {\n16 +         if char_count\
    \ += 1 > 0 && c != '(' && c != ')' {\n   | \n\nerror: aborting due to previous\
    \ error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut tokens = paren_string.trim().split_whitespace();\n    let mut groups\
    \ = vec![];\n    let mut open_brace_token = false;\n    let mut current_token:\
    \ Option<String> = tokens.next().ok_or(\"Invalid input string.\")?;\n    while\
    \ let Some(token) = tokens.next() {\n        if let Some(is_open) = current_token.as_ref().starts_with(\"\
    (\") {\n            if !is_open {\n                return vec![];\n          \
    \  }\n            open_brace_token = true;\n        }\n        if let Some(is_open)\
    \ = current_token.as_ref().starts_with(\")\") {\n            if open_brace_token\
    \ {\n                open_brace_token = false;\n            }\n        } else\
    \ {\n            groups.push(current_token.as_ref().to_string());\n          \
    \  current_token = Some(token);\n        }\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `?` operator has incompatible types\n  --> /tmp/tmpf2j7ev3z.rs:11:45\n\
    \   |\n11 |     let mut current_token: Option<String> = tokens.next().ok_or(\"\
    Invalid input string.\")?;\n   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `&str`\n   |\n   = note: `?` operator cannot convert\
    \ from `&str` to `Option<String>`\n   = note:   expected enum `Option<String>`\n\
    \           found reference `&str`\n\nerror[E0277]: the `?` operator can only\
    \ be used in a function that returns `Result` or `Option` (or another type that\
    \ implements `FromResidual`)\n  --> /tmp/tmpf2j7ev3z.rs:11:89\n   |\n7  | / fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n8  | |     let\
    \ mut tokens = paren_string.trim().split_whitespace();\n9  | |     let mut groups\
    \ = vec![];\n10 | |     let mut open_brace_token = false;\n11 | |     let mut\
    \ current_token: Option<String> = tokens.next().ok_or(\"Invalid input string.\"\
    )?;\n   | |                                                                  \
    \                       ^ cannot use the `?` operator in a function that returns\
    \ `Vec<String>`\n...  |\n28 | |     groups\n29 | | }\n   | |_- this function should\
    \ return `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Result<Infallible,\
    \ &str>>` is not implemented for `Vec<String>`\n\nerror[E0599]: no method named\
    \ `starts_with` found for enum `Option` in the current scope\n  --> /tmp/tmpf2j7ev3z.rs:13:55\n\
    \   |\n13 |         if let Some(is_open) = current_token.as_ref().starts_with(\"\
    (\") {\n   |                                                       ^^^^^^^^^^^\
    \ method not found in `Option<&String>`\n\nerror[E0599]: no method named `starts_with`\
    \ found for enum `Option` in the current scope\n  --> /tmp/tmpf2j7ev3z.rs:19:55\n\
    \   |\n19 |         if let Some(is_open) = current_token.as_ref().starts_with(\"\
    )\") {\n   |                                                       ^^^^^^^^^^^\
    \ method not found in `Option<&String>`\n\nerror[E0599]: the method `to_string`\
    \ exists for enum `Option<&String>`, b"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output_vec: Vec<String> = vec![];\n    let mut open_paren_count =\
    \ paren_string.chars().filter(|c| c == b'(').count();\n    let mut close_paren_count\
    \ = paren_string.chars().filter(|c| c == b')').count();\n    output_vec.push(paren_string.clone());\n\
    \    while open_paren_count != 0 || close_paren_count != 0 {\n        if open_paren_count\
    \ == 0 && close_paren_count == 0 {\n            break;\n        }\n        let\
    \ open_paren_count = open_paren_count.min(close_paren_count);\n        let close_paren_count\
    \ = close_paren_count.min(open_paren_count);\n        if open_paren_count > close_paren_count\
    \ {\n            output_vec.push(String::from(\"\"));\n            output_vec.push(paren_string.clone());\n\
    \        } else {\n            open_paren_count -= 1;\n            close_paren_count\
    \ -= 1;\n            output_vec.push(paren_string.clone());\n        }\n    }\n\
    \    output_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpxdj5hu3r.rs:9:69\n  |\n9 |\
    \     let mut open_paren_count = paren_string.chars().filter(|c| c == b'(').count();\n\
    \  |                                                                     ^^^^\
    \ expected `char`, found `u8`\n\nerror[E0277]: can't compare `&char` with `u8`\n\
    \ --> /tmp/tmpxdj5hu3r.rs:9:66\n  |\n9 |     let mut open_paren_count = paren_string.chars().filter(|c|\
    \ c == b'(').count();\n  |                                                   \
    \               ^^ no implementation for `&char == u8`\n  |\n  = help: the trait\
    \ `PartialEq<u8>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxdj5hu3r.rs:10:70\n\
    \   |\n10 |     let mut close_paren_count = paren_string.chars().filter(|c| c\
    \ == b')').count();\n   |                                                    \
    \                  ^^^^ expected `char`, found `u8`\n\nerror[E0277]: can't compare\
    \ `&char` with `u8`\n  --> /tmp/tmpxdj5hu3r.rs:10:67\n   |\n10 |     let mut close_paren_count\
    \ = paren_string.chars().filter(|c| c == b')').count();\n   |                \
    \                                                   ^^ no implementation for `&char\
    \ == u8`\n   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_regex = Regex::new(r\"\\([^\\(\\)]*\\)\").unwrap();\n    let mut\
    \ paren_string = paren_string.as_bytes();\n    let mut out: Vec<String> = vec![];\n\
    \    let mut last = 0;\n    let mut stack = Stack::new();\n    let mut in_open_brace\
    \ = false;\n    while last < paren_string.len() {\n        let index = paren_string.iter().position(|&b|\
    \ *b == paren_regex[last]);\n        if index > last {\n            out.push(paren_string.clone());\n\
    \            last = index + 1;\n        }\n        if in_open_brace {\n      \
    \      stack.push(paren_string[last..]);\n            if paren_string[last..].is_empty()\
    \ {\n                last = paren_string.len();\n            } else {\n      \
    \          last++;\n            }\n            in_open_brace = false;\n      \
    \  } else {\n            match (stack.pop(), paren_string[last..]) {\n       \
    \         (Some(b), b) => if paren_string[b..].is_empty() {\n                \
    \    last = paren_string.len();\n                } else {\n                  \
    \  last = b + 1;\n                },\n                _ => {}\n            }\n\
    \        }\n    }\n    out.push(paren_string);\n    out\n}\n\nfn main() {\n  \
    \  let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpfq89hum6.rs:25:21\n\
    \   |\n25 |                 last++;\n   |                     ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n25 |                 { let tmp\
    \ = last; last += 1; tmp };\n   |                 +++++++++++     ~~~~~~~~~~~~~~~~~~\n\
    25 -                 last++;\n25 +                 last += 1;\n   | \n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpfq89hum6.rs:8:23\n\
    \  |\n8 |     let paren_regex = Regex::new(r\"\\([^\\(\\)]*\\)\").unwrap();\n\
    \  |                       ^^^^^ use of undeclared type `Regex`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmpfq89hum6.rs:12:21\n\
    \   |\n12 |     let mut stack = Stack::new();\n   |                     ^^^^^\
    \ use of undeclared type `Stack`\n\nerror[E0416]: identifier `b` is bound more\
    \ than once in the same pattern\n  --> /tmp/tmpfq89hum6.rs:30:27\n   |\n30 | \
    \                (Some(b), b) => if paren_string[b..].is_empty() {\n   |     \
    \                      ^ used in a pattern more than once\n\nerror[E0614]: type\
    \ `u8` cannot be dereferenced\n  --> /tmp/tmpfq89hum6.rs:15:55\n   |\n15 |   \
    \      let index = paren_string.iter().position(|&b| *b == paren_regex[last]);\n\
    \   |                                                       ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfq89hum6.rs:16:20\n   |\n16 |         if index\
    \ > last {\n   |                    ^^^^ expected enum `Option`, found `usize`\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `usize`\n\
    help: try wrapping the expression in `Some`\n   |\n16 |         if index > Some(last)\
    \ {\n   |                    +++++    +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpfq89hum6.rs:17:22\n   |\n17 |             out.push(paren_string.clone());\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&[u8]`\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpfq89hum6.rs:18:26\n\
    \   |\n18 |             last = index + 1;\n   |                    ----- ^ - {integer}\n\
    \   |      "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // 1. Find all of the nested open parens\n    // 2. Create and array containing\
    \ each set of nested parens\n    // 3. Return vector of result\n    let mut nested_paren_strings\
    \ = Vec::new();\n    let mut open_paren_count = Vec::new();\n    for paren in\
    \ paren_string.chars() {\n        // Add open paren to our vector\n        if\
    \ paren == '(' {\n            open_paren_count.push(0);\n        } else if paren\
    \ == ')' {\n            // If the count of open parens matches the total count\
    \ of the string - we are at a closed paren\n            let open = open_paren_count.iter().cloned().collect::<Vec<_>>();\n\
    \            if open.len() == 0 {\n                return vec![\"(())\".to_string()];\n\
    \            }\n            // We found one open paren, so decrement the count\
    \ by 1\n            open_paren_count = open_paren_count.iter().map(|x| x - 1).collect();\n\
    \        } else {\n            // Increment the count\n            open_paren_count.iter().cloned().for_each(|x|\
    \ *x += 1);\n        }\n    }\n    // Check if we have opened all the parens -\
    \ If not, we have missed an op\n    if open_paren_count.len() != paren_string.len()\
    \ {\n        return vec![\"(())\".to_string()];\n    }\n    let mut opened_paren_count\
    \ = open_paren_count.iter().cloned().collect::<Vec<_>>();\n    // Go through the\
    \ string backwards, adding the closing paren only if we are at or before a matching\
    \ open\n    // paren\n    let mut open_parens = vec![];\n    for paren in paren_string.chars().rev()\
    \ {\n        // Add closed paren to our vector\n        if paren == ')' {\n  \
    \          // If the count of open parens matches the total count of the string\
    \ - we are at a closed paren\n            let open = opened_paren_count.iter().cloned().collect::<Vec<_>>();\n\
    \            if open.len() == 0 {\n                return vec![\"(())\".to_string()];\n\
    \            }\n            // We found one open paren, so decrement the count\
    \ by 1\n            opened_paren_count = opened_paren_count.iter().map(|x| x -\
    \ 1).collect();\n        }\n        // Add opening paren to our vector\n     \
    \   if paren == '(' {\n            opened_paren_count.push(0);\n        } else\
    \ {\n            // Increment the count\n            opened_paren_count.iter().cloned().for_each(|x|\
    \ *x += 1);\n        }\n        // Check to see if we found the matching open\
    \ paren\n        if opened_paren_count.len() == 0 {\n            // We haven't\
    \ found the matching open \n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp9786_edu.rs:67:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n38 |     for paren in paren_string.chars().rev() {\n   |   \
    \                                          - unclosed delimiter\n...\n57 |   \
    \      if opened_paren_count.len() == 0 {\n   |                              \
    \            - this delimiter might not be properly closed...\n58 |          \
    \   // We haven't found the matching open \n59 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n67 | }\n   |   ^\n\nerror[E0614]: type\
    \ `{integer}` cannot be dereferenced\n  --> /tmp/tmp9786_edu.rs:27:59\n   |\n\
    27 |             open_paren_count.iter().cloned().for_each(|x| *x += 1);\n   |\
    \                                                           ^^\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmp9786_edu.rs:54:61\n \
    \  |\n54 |             opened_paren_count.iter().cloned().for_each(|x| *x += 1);\n\
    \   |                                                             ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9786_edu.rs:38:5\n   |\n7  |   fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \        ----------- expected `Vec<String>` because of return type\n...\n38 |\
    \ /     for paren in paren_string.chars().rev() {\n39 | |         // Add closed\
    \ paren to our vector\n40 | |         if paren == ')' {\n41 | |             //\
    \ If the count of open parens matches the total count of the string - we are at\
    \ a closed paren\n...  |\n66 | |     assert_eq!(candidate(String::from(\"( ) ((\
    \ )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n67 | | }\n   | |__^ expected struct `Vec`, found `()`\n   |\n  \
    \ = note: expected struct `Vec<String>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, tr"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = vec![];\n    let mut current_string: String\
    \ = \"\";\n    for character in paren_string.chars() {\n        match character\
    \ {\n            '(' | ')' => {\n                // Add string to output\n   \
    \             if current_string.len() != 0 {\n                    output\n   \
    \                     .push(current_string.clone());\n                    current_string\
    \ = \"\";\n                }\n            }\n            '(' | '[' => {\n    \
    \            // Start a new string\n                current_string = &String::from(\"\
    [\");\n            }\n            '[' | ']' => {\n                // End current\
    \ string\n                current_string = &String::from(\"]\");\n           \
    \ }\n            _ => {\n                // Add character to current string\n\
    \                current_string = current_string.to_string() + &format!(\"{:?}\"\
    , character);\n            }\n        }\n    }\n    // Add string to output\n\
    \    if current_string.len() != 0 {\n        output\n            .push(current_string.clone());\n\
    \    }\n    // Return output\n    output\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp99xblg9n.rs:9:38\n  |\n9 |\
    \     let mut current_string: String = \"\";\n  |                            \
    \ ------   ^^- help: try using a conversion method: `.to_string()`\n  |      \
    \                       |        |\n  |                             |        expected\
    \ struct `String`, found `&str`\n  |                             expected due\
    \ to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp99xblg9n.rs:17:38\n\
    \   |\n9  |     let mut current_string: String = \"\";\n   |                 \
    \            ------ expected due to this type\n...\n17 |                     current_string\
    \ = \"\";\n   |                                      ^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                      |\n   |  \
    \                                    expected struct `String`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp99xblg9n.rs:22:34\n   |\n9  |  \
    \   let mut current_string: String = \"\";\n   |                             ------\
    \ expected due to this type\n...\n22 |                 current_string = &String::from(\"\
    [\");\n   |                                  ^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `&String`\n   |\nhelp: consider removing the borrow\n   |\n\
    22 -                 current_string = &String::from(\"[\");\n22 +            \
    \     current_string = String::from(\"[\");\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp99xblg9n.rs:26:34\n   |\n9  |     let mut current_string:\
    \ String = \"\";\n   |                             ------ expected due to this\
    \ type\n...\n26 |                 current_string = &String::from(\"]\");\n   |\
    \                                  ^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&String`\n   |\nhelp: consider removing the borrow\n   |\n26 -      \
    \           current_string = &String::from(\"]\");\n26 +                 current_string\
    \ = String::from(\"]\");\n   | \n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack: Vec<String> = Vec::new();\n\n    paren_string.split_whitespace().filter(|char|\
    \ char != ')').filter(|char| char != ')()').filter(|char| char != '(()')\n   \
    \     .filter(|char| char != \")\").filter(|char| char != \")()\").filter(|char|\
    \ char != \"()()\").filter(|char| char != \"(()\")\n        .into_iter().for_each(|c|\
    \ {\n        if c == '(' {\n            paren_stack.push(c);\n        } else {\n\
    \            paren_stack.pop();\n        }\n    });\n    paren_stack\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp4hypot8p.rs:10:86\n\
    \   |\n10 |     paren_string.split_whitespace().filter(|char| char != ')').filter(|char|\
    \ char != ')()').filter(|char| char != '(()')\n   |                          \
    \                                                            ^^^^^\n   |\nhelp:\
    \ if you meant to write a `str` literal, use double quotes\n   |\n10 |     paren_string.split_whitespace().filter(|char|\
    \ char != ')').filter(|char| char != \")()\").filter(|char| char != '(()')\n \
    \  |                                                                         \
    \             ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmp4hypot8p.rs:10:115\n   |\n10 |     paren_string.split_whitespace().filter(|char|\
    \ char != ')').filter(|char| char != ')()').filter(|char| char != '(()')\n   |\
    \                                                                            \
    \                                       ^^^^^\n   |\nhelp: if you meant to write\
    \ a `str` literal, use double quotes\n   |\n10 |     paren_string.split_whitespace().filter(|char|\
    \ char != ')').filter(|char| char != ')()').filter(|char| char != \"(()\")\n \
    \  |                                                                         \
    \                                          ~~~~~\n\nerror[E0277]: can't compare\
    \ `&&str` with `char`\n  --> /tmp/tmp4hypot8p.rs:10:56\n   |\n10 |     paren_string.split_whitespace().filter(|char|\
    \ char != ')').filter(|char| char != ')()').filter(|char| char != '(()')\n   |\
    \                                                        ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .trim()\n        .split_whitespace()\n        .filter(|e|\
    \ !e.is_empty())\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph2p3c3xz.rs:8:5\n   |\n7\
    \  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   | \
    \                                                    ----------- expected `Vec<String>`\
    \ because of return type\n8  | /     paren_string\n9  | |         .trim()\n10\
    \ | |         .split_whitespace()\n11 | |         .filter(|e| !e.is_empty())\n\
    12 | |         .collect::<Vec<_>>()\n   | |____________________________^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut bracket_string: Vec<String> = vec![];\n    let mut last_open_bracket\
    \ = String::from(\"\");\n    for c in paren_string.chars() {\n        if c ==\
    \ ' ' {\n            if last_open_bracket.is_empty() {\n                continue;\n\
    \            }\n            bracket_string.push(last_open_bracket);\n        \
    \    last_open_bracket = String::from(\"\");\n        } else {\n            last_open_bracket\
    \ = last_open_bracket.push_str(&c);\n        }\n    }\n    if last_open_bracket.is_empty()\
    \ {\n        bracket_string.push(String::from(\"\"));\n    }\n    bracket_string\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn69jzhqu.rs:18:60\n   |\n\
    18 |             last_open_bracket = last_open_bracket.push_str(&c);\n   |   \
    \                                                         ^^ expected `str`, found\
    \ `char`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpn69jzhqu.rs:18:33\n\
    \   |\n9  |     let mut last_open_bracket = String::from(\"\");\n   |        \
    \                         ---------------- expected due to this value\n...\n18\
    \ |             last_open_bracket = last_open_bracket.push_str(&c);\n   |    \
    \                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n \
    \ --> /tmp/tmpn69jzhqu.rs:18:51\n   |\n18 |             last_open_bracket = last_open_bracket.push_str(&c);\n\
    \   |                                 ----------------- ^^^^^^^^ this call modifies\
    \ `last_open_bracket` in-place\n   |                                 |\n   | \
    \                                you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut bracket_stack = Vec::new();\n    let mut non_paren_characters = paren_string.chars();\n\
    \    let mut paren_characters = non_paren_characters.skip_while(|c|\n        c.is_ascii_digit(0)\
    \ || c == '_' || c == '.'\n    );\n\n    loop {\n        // Pop out the matching\
    \ opening and closing parentheses until there are none left to pop\n        if\
    \ paren_characters.next() != Some(')') {\n            let current_character =\
    \ non_paren_characters.next();\n            non_paren_characters.next_back();\n\
    \            bracket_stack.push(current_character.unwrap());\n        }\n    \
    \    // Pop out the matching opening parenthesis until there are none left to\
    \ pop\n        if bracket_stack.len() != 0 && paren_characters.next() != Some('(')\
    \ {\n            let current_character = paren_characters.next();\n          \
    \  paren_characters.next_back();\n            non_paren_characters.next_back();\n\
    \            bracket_stack.pop();\n            bracket_stack.push(current_character.unwrap());\n\
    \        }\n        // Stop when there are no more opening and closing parentheses\
    \ left\n        if bracket_stack.len() == 0 {\n            break;\n        }\n\
    \    }\n\n    bracket_stack\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpypszp7m9.rs:11:11\n     |\n11   |         c.is_ascii_digit(0)\
    \ || c == '_' || c == '.'\n     |           ^^^^^^^^^^^^^^ - supplied 1 argument\n\
    \     |           |\n     |           expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmpypszp7m9.rs:11:34\n   |\n11 |         c.is_ascii_digit(0) || c ==\
    \ '_' || c == '.'\n   |                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpypszp7m9.rs:11:46\n\
    \   |\n11 |         c.is_ascii_digit(0) || c == '_' || c == '.'\n   |        \
    \                                      ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: no\
    \ method named `next_back` found for struct `SkipWhile` in the current scope\n\
    \  --> /tmp/tmpypszp7m9.rs:24:30\n   |\n24 |             paren_characters.next_back();\n\
    \   |                              ^^^^^^^^^ method not found in `SkipWhile<Chars<'_>,\
    \ [closure@/tmp/tmpypszp7m9.rs:10:64: 11:52]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpypszp7m9.rs:35:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n35 |  \
    \   bracket_stack\n   |     ^^^^^^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0277, E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = vec![];\n    let mut group_offset = 0;\n    let mut last_group_brace\
    \ = paren_string.chars().next().unwrap();\n    let mut cur = paren_string.chars();\n\
    \    while let Some(chr) = cur {\n        if chr == last_group_brace {\n     \
    \       groups.push_back(paren_string.chars().skip(group_offset).take());\n  \
    \          group_offset = 0;\n            last_group_brace = paren_string.chars().next().unwrap();\n\
    \        } else {\n            group_offset += 1;\n        }\n        cur = paren_string.chars();\n\
    \    }\n    groups.push_back(paren_string.chars().skip(group_offset).take());\n\
    \    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwtw2chec.rs:12:15\n   |\n\
    12 |     while let Some(chr) = cur {\n   |               ^^^^^^^^^   --- this\
    \ expression has type `Chars<'_>`\n   |               |\n   |               expected\
    \ struct `Chars`, found enum `Option`\n   |\n   = note: expected struct `Chars<'_>`\n\
    \                found enum `Option<_>`\n\nerror[E0599]: no method named `push_back`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmpwtw2chec.rs:14:20\n\
    \   |\n14 |             groups.push_back(paren_string.chars().skip(group_offset).take());\n\
    \   |                    ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpwtw2chec.rs:14:70\n\
    \     |\n14   |             groups.push_back(paren_string.chars().skip(group_offset).take());\n\
    \     |                                                                      ^^^^-\
    \ supplied 0 arguments\n     |                                               \
    \                       |\n     |                                            \
    \                          expected 1 argument\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `push_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmpwtw2chec.rs:22:12\n   |\n22 |     groups.push_back(paren_string.chars().skip(group_offset).take());\n\
    \   |            ^^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpwtw2chec.rs:22:62\n\
    \     |\n22   |     groups.push_back(paren_string.chars().skip(group_offset).take());\n\
    \     |                                                              ^^^^- supplied\
    \ 0 arguments\n     |                                                        \
    \      |\n     |                                                             \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308, E0599.\nFor more information about an error, try `rustc --e"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut parts = paren_string.split(\"(\");\n    let mut results = Vec::new();\n\
    \    for part in parts.into_iter() {\n        if !part.contains(')') {\n     \
    \       results.push(\"(\");\n        } else {\n            results.push(\"(\"\
    );\n            let mut current = part;\n            while !current.contains(')')\
    \ {\n                current = current.replace(\")\", \"\");\n               \
    \ results.push(current.to_string());\n            }\n            results.push(\"\
    )\");\n        }\n    }\n    results\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqcudbze3.rs:17:27\n   |\n\
    15 |             let mut current = part;\n   |                               ----\
    \ expected due to this value\n16 |             while !current.contains(')') {\n\
    17 |                 current = current.replace(\")\", \"\");\n   |           \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^\n   |                           |\n\
    \   |                           expected `&str`, found struct `String`\n   | \
    \                          help: consider borrowing here: `&current.replace(\"\
    )\", \"\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqcudbze3.rs:18:30\n\
    \   |\n18 |                 results.push(current.to_string());\n   |         \
    \                     ^^^^^^^^^^^^^^^^^^^\n   |                              |\n\
    \   |                              expected `&str`, found struct `String`\n  \
    \ |                              help: consider borrowing here: `&current.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpqcudbze3.rs:23:5\n   |\n7  | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                          ----------- expected `Vec<String>`\
    \ because of return type\n...\n23 |     results\n   |     ^^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| c.is_ascii())\n     \
    \   .filter(|c| c != '(')\n        .filter(|c| c != ')')\n        .filter(|c|\
    \ !c.is_ascii())\n        .filter(|c| !c.is_whitespace())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvuol5orm.rs:11:23\n\
    \   |\n11 |         .filter(|c| c != '(')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpvuol5orm.rs:12:23\n\
    \   |\n12 |         .filter(|c| c != ')')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: a value of type `Vec<String>` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmpvuol5orm.rs:15:10\n     |\n15   | \
    \        .collect()\n     |          ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(r\")(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\")\n  \
    \      .filter_map(|x| x.into_string().unwrap().to_owned())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: unknown start of token: \\\n --> /tmp/tmpkdukpj3l.rs:8:39\n  |\n\
    8 |     paren_string.split(r\")(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\")\n\
    \  |                                       ^\n\nerror: unexpected closing delimiter:\
    \ `}`\n  --> /tmp/tmpkdukpj3l.rs:11:1\n   |\n11 | }\n   | ^ unexpected closing\
    \ delimiter\n\nerror: mismatched closing delimiter: `]`\n --> /tmp/tmpkdukpj3l.rs:8:23\n\
    \  |\n8 |     paren_string.split(r\")(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\"\
    )\n  |                       ^             ^ mismatched closing delimiter\n  |\
    \                       |\n  |                       unclosed delimiter\n\nerror:\
    \ mismatched closing delimiter: `)`\n --> /tmp/tmpkdukpj3l.rs:7:63\n  |\n7 | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n  |          \
    \                                                     ^ unclosed delimiter\n8\
    \ |     paren_string.split(r\")(?=(?:[^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)\")\n\
    \  |                                                            ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string\n        .bytes()\n        .into_iter()\n \
    \       .filter_map(|c| if c == '(' { true } else { false })\n        .collect::<Vec<_>>();\n\
    \    let mut curr = groups.len();\n    while curr.is_positive() {\n        if\
    \ curr == 1 {\n            return groups;\n        }\n        // Remove any space\
    \ and count how many brackets are left\n        let mut removed = 1;\n       \
    \ while groups.len() > 0 && groups.last().unwrap() == ' ' {\n            groups.pop();\n\
    \            removed += 1;\n        }\n        // Remove trailing brackets if\
    \ there is any\n        if groups.len() == 1 {\n            groups.pop();\n  \
    \      }\n        // Remove any whitespace from the group\n        if groups.len()\
    \ > 0 && groups.last().unwrap() == '(' {\n            let mut iter = groups.iter().cloned();\n\
    \            iter.next();\n            if !iter.next().unwrap().is_whitespace()\
    \ {\n                iter = groups.iter().cloned();\n                iter.next();\n\
    \                groups.pop();\n            }\n        }\n        // Remove any\
    \ whitespace from each of the group and push it to new vector\n        groups.retain(|g|\
    \ !g.is_whitespace());\n        let new_curr = groups.len();\n        if new_curr\
    \ == 0 {\n            break;\n        }\n        groups = groups.drain(..new_curr);\n\
    \        curr = new_curr;\n    }\n    Vec::new()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgsdzqhxs.rs:11:33\n   |\n\
    11 |         .filter_map(|c| if c == '(' { true } else { false })\n   |      \
    \                           ^^^ expected `u8`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgsdzqhxs.rs:11:39\n   |\n11 |         .filter_map(|c| if\
    \ c == '(' { true } else { false })\n   |                                    \
    \   ^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected enum\
    \ `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n11 |         .filter_map(|c| if c == '(' { Some(true) } else\
    \ { false })\n   |                                       +++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgsdzqhxs.rs:11:53\n   |\n11 |         .filter_map(|c|\
    \ if c == '(' { true } else { false })\n   |                                 \
    \                    ^^^^^ expected enum `Option`, found `bool`\n   |\n   = note:\
    \ expected enum `Option<_>`\n              found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n11 |         .filter_map(|c| if c == '(' { true\
    \ } else { Some(false) })\n   |                                              \
    \       +++++     +\n\nerror[E0599]: no method named `is_positive` found for type\
    \ `usize` in the current scope\n  --> /tmp/tmpgsdzqhxs.rs:14:16\n   |\n14 |  \
    \   while curr.is_positive() {\n   |                ^^^^^^^^^^^ method not found\
    \ in `usize`\n\nerror[E0277]: can't compare `&String` with `char`\n  --> /tmp/tmpgsdzqhxs.rs:20:58\n\
    \   |\n20 |         while groups.len() > 0 && groups.last().unwrap() == ' ' {\n\
    \   |                                                          ^^ no implementation\
    \ for `&String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n          "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(|x| x.is_whitespace()).collect()\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpq7s76ych.rs:8:25\n\
    \  |\n8 |     paren_string.split(|x| x.is_whitespace()).collect()\n  |       \
    \                  ^ consider giving this closure parameter a type\n  |\n  = note:\
    \ type must be known at this point\n\nerror[E0277]: a value of type `Vec<String>`\
    \ cannot be built from an iterator over elements of type `&str`\n    --> /tmp/tmpq7s76ych.rs:8:47\n\
    \     |\n8    |     paren_string.split(|x| x.is_whitespace()).collect()\n    \
    \ |                                               ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0282.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_owned();\n    paren_string.clear();\n\
    \    let mut paren_string = paren_string.split_whitespace();\n    let mut paren_string\
    \ = paren_string.collect();\n    while !paren_string.is_empty() {\n        let\
    \ mut first_index = paren_string.iter().position(|x| *x != '(');\n        let\
    \ mut last_index = paren_string.rposition(|x| *x != '(');\n        if last_index\
    \ == paren_string.len() - 1 {\n            last_index = 0;\n        }\n      \
    \  if first_index == 0 {\n            continue;\n        }\n        let paren_string\
    \ = paren_string[first_index..last_index + 1];\n        paren_string.clear();\n\
    \        paren_string = paren_string.split_whitespace();\n        paren_string\
    \ = paren_string.collect();\n    }\n    paren_string.iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpulpnwcls.rs:12:12\n\
    \   |\n11 |     let mut paren_string = paren_string.collect();\n   |         ----------------\
    \ consider giving `paren_string` a type\n12 |     while !paren_string.is_empty()\
    \ {\n   |            ^^^^^^^^^^^^ cannot infer type\n   |\n   = note: type must\
    \ be known at this point\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = Vec::new();\n\n    for paren in paren_string.split('(')\
    \ {\n        let paren_group: Vec<String> = paren\n            .replace(\")\"\
    , \"\")\n            .trim()\n            .split_whitespace()\n            .collect();\n\
    \        if paren_group.len() == 1 {\n            paren_groups.push(paren_group[0]);\n\
    \        } else {\n            paren_groups.push(paren_group);\n        }\n  \
    \  }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpl_zaf15f.rs:15:14\n     |\n15\
    \   |             .collect();\n     |              ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl_zaf15f.rs:19:31\n\
    \   |\n19 |             paren_groups.push(paren_group);\n   |                \
    \               ^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n\
    \   = note: expected struct `String`\n              found struct `Vec<String>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Initialize stack with empty paren groups\n    let mut stack = Vec::new();\n\
    \    // Initialize vector of paren groups with empty string\n    let mut groups\
    \ = vec![];\n\n    for paren in paren_string.chars() {\n        match paren {\n\
    \            ' ' | ')' | ']' | '](' | ')[' => {\n                stack.push(paren);\n\
    \            }\n            '(' => {\n                if stack.len() > 0 {\n \
    \                   groups.push(stack.pop().to_string());\n                } else\
    \ {\n                    groups.push(String::from(\"()\"));\n                }\n\
    \            }\n            _ => {\n                groups.push(paren);\n    \
    \        }\n        }\n    }\n\n    // Push everything remaining in the stack\
    \ to groups\n    while stack.len() > 0 {\n        groups.push(stack.pop().to_string());\n\
    \    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpjglyvg9q.rs:15:31\n\
    \   |\n15 |             ' ' | ')' | ']' | '](' | ')[' => {\n   |             \
    \                  ^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n15 |             ' ' | ')' | ']' | \"](\" | ')[' => {\n\
    \   |                               ~~~~\n\nerror: character literal may only\
    \ contain one codepoint\n  --> /tmp/tmpjglyvg9q.rs:15:38\n   |\n15 |         \
    \    ' ' | ')' | ']' | '](' | ')[' => {\n   |                                \
    \      ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n15 |             ' ' | ')' | ']' | '](' | \")[\" => {\n   |           \
    \                           ~~~~\n\nerror[E0599]: `Option<char>` doesn't implement\
    \ `std::fmt::Display`\n   --> /tmp/tmpjglyvg9q.rs:20:45\n    |\n20  |        \
    \               groups.push(stack.pop().to_string());\n    |                 \
    \                              ^^^^^^^^^ `Option<char>` cannot be formatted with\
    \ the default formatter\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `Option<char>: std::fmt::Display`\n            which\
    \ is required by `Option<char>: ToString`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjglyvg9q.rs:26:29\n   |\n26 |                 groups.push(paren);\n\
    \   |                             ^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                             |\n   |                   \
    \          expected struct `String`, found `char`\n\nerror[E0599]: `Option<char>`\
    \ doesn't implement `std::fmt::Display`\n   --> /tmp/tmpjglyvg9q.rs:33:33\n  \
    \  |\n33  |           groups.push(stack.pop().to_string());\n    |           \
    \                        ^^^^^^^^^ `Option<char>` cannot be formatted with the\
    \ default formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Option<char>: std::fmt::Display`\n            which is required\
    \ by `Option<char>: ToString`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more informatio"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_string = paren_string.trim();\n    let mut paren_string = paren_string.chars();\n\
    \    let mut paren_string = paren_string.collect::<Vec<_>>();\n    let mut open_paren\
    \ = String::from(\"\");\n    let mut closed_paren = String::from(\"\");\n\n  \
    \  while let Some(item) = paren_string.pop() {\n        if item == '{' {\n   \
    \         open_paren.push_str(&item.to_ascii_lowercase());\n        } else if\
    \ item == '}' {\n            let index = open_paren.len();\n            if open_paren[..index]\
    \ == closed_paren[..] {\n                paren_string.extend(open_paren.clone());\n\
    \                paren_string.extend(closed_paren.clone());\n            } else\
    \ {\n                paren_string.extend(open_paren.clone());\n            }\n\
    \            open_paren.clear();\n            closed_paren.clear();\n        }\
    \ else {\n            closed_paren.push_str(&item.to_ascii_lowercase());\n   \
    \     }\n    }\n\n    paren_string\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgz3ia6gm.rs:16:33\n   |\n\
    16 |             open_paren.push_str(&item.to_ascii_lowercase());\n   |      \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpgz3ia6gm.rs:20:37\n\
    \    |\n20  |                 paren_string.extend(open_paren.clone());\n    |\
    \                              ------ ^^^^^^^^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |                              |\n\
    \    |                              required by a bound introduced by this call\n\
    \    |\n    = help: the trait `Iterator` is not implemented for `String`\n   \
    \ = note: required because of the requirements on the impl of `IntoIterator` for\
    \ `String`\nnote: required by a bound in `extend`\n\nerror[E0277]: `String` is\
    \ not an iterator\n   --> /tmp/tmpgz3ia6gm.rs:21:37\n    |\n21  |            \
    \     paren_string.extend(closed_paren.clone());\n    |                      \
    \        ------ ^^^^^^^^^^^^^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |                              |\n    |      \
    \                        required by a bound introduced by this call\n    |\n\
    \    = help: the trait `Iterator` is not implemented for `String`\n    = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    note: required by a bound in `extend`\n\nerror[E0277]: `String` is not an iterator\n\
    \   --> /tmp/tmpgz3ia6gm.rs:20:30\n    |\n20  |                 paren_string.extend(open_paren.clone());\n\
    \    |                              ^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = help: the trait `Iterator` is not implemented\
    \ for `String`\nnote: required by a bound in `extend`\n\nerror[E0277]: `String`\
    \ is not an iterator\n   --> /tmp/tmpgz3ia6gm.rs:23:37\n    |\n23  |         \
    \        paren_string.extend(open_paren.clone());\n    |                     \
    \         ------ ^^^^^^^^^^"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = vec![];\n    let mut paren_count = paren_string.len();\n\
    \n    // Track when we see a left paren open\n    struct State {\n        paren_level:\
    \ usize,\n        paren_open: usize,\n    }\n\n    // Helper function to check\
    \ whether we see a paren open\n    fn check_for_open_paren(level: usize, paren_count:\
    \ usize) -> bool {\n        if paren_count == 0 {\n            true\n        }\
    \ else if level > 0 && paren_count >= level {\n            true\n        } else\
    \ {\n            false\n        }\n    }\n\n    // Go through the string one character\
    \ at a time\n    for c in paren_string.chars() {\n        // Check our state for\
    \ the current character\n        let mut state = State {\n            paren_level:\
    \ 0,\n            paren_open: 0,\n        };\n\n        // We only care about\
    \ opening parens\n        if c == '(' {\n            state.paren_open = 1;\n \
    \           state.paren_level += 1;\n        }\n\n        // Close the left paren\
    \ when we see an opening paren\n        if state.paren_open > 0 && c == '(' {\n\
    \            state.paren_level -= 1;\n            state.paren_open -= 1;\n   \
    \     }\n\n        // Handle the rest of parens\n        if check_for_open_paren(state.paren_level,\
    \ state.paren_open) {\n            // Close this paren if we're on level 0\n \
    \           if state.paren_level == 0 {\n                output.push(c).unwrap();\n\
    \            }\n\n            // Increment the level\n            state.paren_level\
    \ += 1;\n            state.paren_open += 1;\n        } else {\n            //\
    \ Do nothing\n        }\n    }\n\n    // Return our output\n    output\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa159jqf8.rs:52:29\n   |\n\
    52 |                 output.push(c).unwrap();\n   |                          \
    \   ^- help: try using a conversion method: `.to_string()`\n   |             \
    \                |\n   |                             expected struct `String`,\
    \ found `char`\n\nerror[E0599]: no method named `unwrap` found for unit type `()`\
    \ in the current scope\n  --> /tmp/tmpa159jqf8.rs:52:32\n   |\n52 |          \
    \       output.push(c).unwrap();\n   |                                ^^^^^^ method\
    \ not found in `()`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_lowercase().to_string();\n    paren_string.replace(\"\
    ( )\", \" \").replace(\"( )\", \" \").replace(\"( )\", \" \").trim()\n       \
    \ .split(\",\")\n        .filter_map(|c| c.trim().to_owned())\n        .collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpje3o5xeh.rs:11:25\n   |\n\
    11 |         .filter_map(|c| c.trim().to_owned())\n   |                      \
    \   ^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `String`\n   |\n\
    \   = note: expected enum `Option<_>`\n            found struct `String`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n11 |         .filter_map(|c| Some(c.trim().to_owned()))\n\
    \   |                         +++++                   +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.clone();\n    let mut paren_string =\
    \ paren_string.chars();\n\n    // To handle escaped parens, we keep track of a\
    \ state that determines whether we should be escaping or not\n    // This state\
    \ will be updated based on the last character processed. If we see a character\
    \ that we\n    // want to escape we do so and advance the state to the next character\
    \ that we want to escape. If we see\n    // a character that we don't want to\
    \ escape we do nothing and advance the state to the next character.\n    // If\
    \ at any point we see a closing character that is not the start of a group, we\
    \ simply return an empty string.\n    let mut state = paren_string.next().unwrap();\n\
    \n    let mut result: Vec<String> = vec![];\n    while let Some(next) = paren_string.next()\
    \ {\n        // If we see a paren, check if its state has changed and escape it\
    \ if necessary\n        if next == \"(\" {\n            if state != \"(\" {\n\
    \                result.push(\"(\");\n            }\n        } else {\n      \
    \      if state != \")\" {\n                result.push(\")\");\n            }\n\
    \        }\n\n        // Keep track of the next character state and advance to\
    \ the next character\n        state = next;\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa4vz_l6s.rs:21:20\n   |\n\
    21 |         if next == \"(\" {\n   |                    ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n21 |         if next == '(' {\n   |                    ~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa4vz_l6s.rs:22:25\n   |\n22 |  \
    \           if state != \"(\" {\n   |                         ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n22 |             if state != '(' {\n   |                     \
    \    ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4vz_l6s.rs:23:29\n\
    \   |\n23 |                 result.push(\"(\");\n   |                        \
    \     ^^^- help: try using a conversion method: `.to_string()`\n   |         \
    \                    |\n   |                             expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4vz_l6s.rs:26:25\n\
    \   |\n26 |             if state != \")\" {\n   |                         ^^^\
    \ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal,\
    \ use single quotes\n   |\n26 |             if state != ')' {\n   |          \
    \               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa4vz_l6s.rs:27:29\n\
    \   |\n27 |                 result.push(\")\");\n   |                        \
    \     ^^^- help: try using a conversion method: `.to_string()`\n   |         \
    \                    |\n   |                             expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 5 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_owned();\n    let mut paren_groups:\
    \ Vec<String> = vec![];\n    let mut in_paren = false;\n    while let Some(next_char)\
    \ = paren_string.chars().next() {\n        if !in_paren {\n            if next_char\
    \ == '(' {\n                paren_groups.push(paren_string);\n               \
    \ in_paren = true;\n            } else if next_char == ')' {\n               \
    \ paren_groups.push(String::from(\"\"));\n                in_paren = false;\n\
    \            }\n        } else {\n            if next_char == ')' {\n        \
    \        paren_groups.push(String::from(\"\"));\n                in_paren = false;\n\
    \            } else {\n                paren_groups.push(paren_string);\n    \
    \            paren_string = String::from(\"\");\n                in_paren = false;\n\
    \            }\n        }\n    }\n    if paren_string.is_empty() {\n        paren_groups.push(paren_string);\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `paren_string`\n  --> /tmp/tmpuixateei.rs:11:33\n\
    \   |\n8  |     let mut paren_string = paren_string.to_owned();\n   |        \
    \ ---------------- move occurs because `paren_string` has type `String`, which\
    \ does not implement the `Copy` trait\n...\n11 |     while let Some(next_char)\
    \ = paren_string.chars().next() {\n   |                                 ^^^^^^^^^^^^^^^^^^^^\
    \ value borrowed here after move\n...\n14 |                 paren_groups.push(paren_string);\n\
    \   |                                   ------------ value moved here, in previous\
    \ iteration of loop\n...\n26 |                 paren_string = String::from(\"\"\
    );\n   |                 ------------ this reinitialization might get skipped\n\
    \   |\n   = note: borrow occurs due to deref coercion to `str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: Your code here\n    Vec::new()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpx6xk15hs.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: use regex\n    // TODO: fix performance of regex on large strings\n\
    \    paren_string.splitn(2, |c| c != \" \").map(|c| c.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `char` with `&str`\n  --> /tmp/tmpe7fi7s_q.rs:10:34\n\
    \   |\n10 |     paren_string.splitn(2, |c| c != \" \").map(|c| c.to_string()).collect()\n\
    \   |                                  ^^ no implementation for `char == &str`\n\
    \   |\n   = help: the trait `PartialEq<&str>` is not implemented for `char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n\n    let mut paren_string =\
    \ paren_string.strip_spaces();\n    paren_string.trim_end();\n\n    let mut paren_string\
    \ = paren_string.split(\"(\");\n    let mut paren_string = paren_string.collect::<Vec<String>>();\n\
    \    let mut paren_string = paren_string.split_back();\n\n    paren_string\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `strip_spaces` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpr7roxb98.rs:10:41\n   |\n10 |     let mut\
    \ paren_string = paren_string.strip_spaces();\n   |                          \
    \               ^^^^^^^^^^^^ method not found in `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    paren_string.split(\"(\").collect::<Vec<_>>()\n\
    \        .iter()\n        .map(|mut string| string.trim())\n        .filter(|string|\
    \ !string.is_empty())\n        .filter_map(|string| match string.as_str() {\n\
    \            \"()\" => Some(()),\n            _ => None,\n        })\n       \
    \ .filter(|string| !string.is_empty())\n        .for_each(|string| {\n       \
    \     let mut split_string = string.split_ascii_whitespace();\n            split_string.truncate(split_string.len()\
    \ - 1);\n            for split in split_string {\n                if split.starts_with(split.as_str().trim_start())\
    \ {\n                    result.push(split);\n                    break;\n   \
    \             }\n            }\n        });\n    result\n}\n\nfn main() {\n  \
    \  let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpo38985lb.rs:13:43\n   |\n13 |         .filter_map(|string|\
    \ match string.as_str() {\n   |                                          -^^^^^^--\
    \ help: remove this method call\n\nerror[E0599]: no method named `is_empty` found\
    \ for reference `&()` in the current scope\n  --> /tmp/tmpo38985lb.rs:17:34\n\
    \   |\n17 |         .filter(|string| !string.is_empty())\n   |               \
    \                   ^^^^^^^^ method not found in `&()`\n\nerror[E0599]: no method\
    \ named `split_ascii_whitespace` found for unit type `()` in the current scope\n\
    \  --> /tmp/tmpo38985lb.rs:19:43\n   |\n19 |             let mut split_string\
    \ = string.split_ascii_whitespace();\n   |                                   \
    \        ^^^^^^^^^^^^^^^^^^^^^^ method not found in `()`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(r\"(\\([^\\(\\)]*\\))\").collect()\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp7jwa6jb4.rs:8:43\n     |\n8  \
    \  |     paren_string.split(r\"(\\([^\\(\\)]*\\))\").collect()\n     |       \
    \                                    ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // TODO: implement this\n    vec![]\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpomz2_iqm.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n\n    for group in paren_string.split(')')\
    \ {\n        let mut group = group.to_string();\n        let mut next_open_brace\
    \ = false;\n\n        for c in group.chars() {\n            if c == '(' {\n  \
    \              next_open_brace = true;\n            } else if c == '[' {\n   \
    \             group.push(c);\n            } else if c == ']' {\n             \
    \   group.push(c);\n            } else if c == ')' {\n                if next_open_brace\
    \ {\n                    group.push(c);\n                } else {\n          \
    \          paren_groups.push(group);\n                    group = String::new();\n\
    \                }\n            } else {\n                group.push(c);\n   \
    \         }\n        }\n\n        paren_groups.push(group);\n    }\n\n    paren_groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0502]: cannot borrow `group` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpozhyf6mz.rs:18:17\n   |\n14 |         for c in group.chars()\
    \ {\n   |                  -------------\n   |                  |\n   |      \
    \            immutable borrow occurs here\n   |                  immutable borrow\
    \ later used here\n...\n18 |                 group.push(c);\n   |            \
    \     ^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]: cannot borrow\
    \ `group` as mutable because it is also borrowed as immutable\n  --> /tmp/tmpozhyf6mz.rs:20:17\n\
    \   |\n14 |         for c in group.chars() {\n   |                  -------------\n\
    \   |                  |\n   |                  immutable borrow occurs here\n\
    \   |                  immutable borrow later used here\n...\n20 |           \
    \      group.push(c);\n   |                 ^^^^^^^^^^^^^ mutable borrow occurs\
    \ here\n\nerror[E0502]: cannot borrow `group` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpozhyf6mz.rs:23:21\n   |\n14 |         for c in group.chars()\
    \ {\n   |                  -------------\n   |                  |\n   |      \
    \            immutable borrow occurs here\n   |                  immutable borrow\
    \ later used here\n...\n23 |                     group.push(c);\n   |        \
    \             ^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0505]: cannot\
    \ move out of `group` because it is borrowed\n  --> /tmp/tmpozhyf6mz.rs:25:39\n\
    \   |\n14 |         for c in group.chars() {\n   |                  -------------\
    \ borrow of `group` occurs here\n...\n25 |                     paren_groups.push(group);\n\
    \   |                                       ^^^^^ move out of `group` occurs here\n\
    \nerror[E0506]: cannot assign to `group` because it is borrowed\n    --> /tmp/tmpozhyf6mz.rs:26:21\n\
    \     |\n14   |         for c in group.chars() {\n     |                  -------------\n\
    \     |                  |\n     |                  borrow of `group` occurs here\n\
    \     |                  borrow later used here\n...\n26   |                 \
    \    group = String::new();\n     |                     ^^^^^ assignm"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n\n    for paren in paren_string.split('(')\
    \ {\n        if paren.ends_with(')') {\n            paren.push(')');\n       \
    \ }\n        result.push(paren.trim_right_matches(' '));\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp5qzhm4zt.rs:12:19\n   |\n12 |             paren.push(')');\n\
    \   |                   ^^^^ method not found in `&str`\n\nwarning: use of deprecated\
    \ associated function `core::str::<impl str>::trim_right_matches`: superseded\
    \ by `trim_end_matches`\n  --> /tmp/tmp5qzhm4zt.rs:14:27\n   |\n14 |         result.push(paren.trim_right_matches('\
    \ '));\n   |                           ^^^^^^^^^^^^^^^^^^ help: replace the use\
    \ of the deprecated associated function: `trim_end_matches`\n   |\n   = note:\
    \ `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5qzhm4zt.rs:17:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n17 |  \
    \   result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec = vec![];\n    let mut open = 0;\n    let mut last = 0;\n   \
    \ let mut brace_count = 0;\n    let mut last_brace = 1;\n    let mut last_paren\
    \ = 1;\n    let mut i = 0;\n    while i < paren_string.len() {\n        match\
    \ paren_string[i] {\n            ' ' => {}\n            '(' | ')' => {}\n    \
    \        '[' | ']' => {}\n            '{' | '}' => {}\n            '#' => {}\n\
    \            '/' | '*' => {}\n            _ => {\n                if paren_string[i]\
    \ == '(' {\n                    if open != 1 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 1;\n                    last\
    \ = i;\n                } else if paren_string[i] == ')' {\n                 \
    \   if open > 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open -= 1;\n                    last\
    \ = i;\n                } else if paren_string[i] == '[' {\n                 \
    \   if open != 2 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 2;\n                    last\
    \ = i;\n                } else if paren_string[i] == ']' {\n                 \
    \   if open > 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open -= 2;\n                    last\
    \ = i;\n                } else if paren_string[i] == '{' {\n                 \
    \   if open != 3 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 3;\n                    last\
    \ = i;\n                } else if paren_string[i] == '}' {\n                 \
    \   if open > 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open -= 3;\n                    last\
    \ = i;\n                } else if paren_string[i] == '#' {\n                 \
    \   if open != 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 0;\n                    last\
    \ = i;\n                } else if paren_string[i] == '/' {\n                 \
    \   if open != 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 0;\n                    last\
    \ = i;\n                } else if paren_string[i] == '*' {\n                 \
    \   if open != 0 {\n                        vec.push(paren_string[last..i]);\n\
    \                    }\n                    open += 0;\n                    last\
    \ = i;\n                } else {\n                    if open != 0 {\n       \
    \                 vec.push(paren_string[last..i]);\n                    }\n  \
    \                  open = 0;\n                    last = i;\n                }\n\
    \            }\n        }\n        i += 1;\n    }\n    if open != 0 {\n      \
    \  vec.push(paren_string[last..paren_string.len()]);\n    }\n    vec\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpbiuci96i.rs:16:15\n\
    \   |\n16 |         match paren_string[i] {\n   |               ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpbiuci96i.rs:24:20\n   |\n24 |                 if paren_string[i]\
    \ == '(' {\n   |                    ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n   --> /tmp/tmpbiuci96i.rs:26:34\n    |\n26  |        \
    \                 vec.push(paren_string[last..i]);\n    |                    \
    \         ---- ^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                             |\n    |                             required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmpbiuci96i.rs:8:19\n    |\n8   |     let mut vec = v"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut iter = paren_string.char_indices().filter_map(|(i, _)| {\n      \
    \  if let Some(i) = (i, paren_string.chars().position(paren_string.as_bytes().get()).unwrap_or(i))\
    \ {\n            (i, Some(i))\n        } else {\n            None\n        }\n\
    \    });\n\n    let mut groups = Vec::new();\n    let mut last_open_brace = 0;\n\
    \n    while let Some((_, open_brace)) = iter.next() {\n        if open_brace >\
    \ last_open_brace {\n            groups.push(paren_string.clone());\n        \
    \    last_open_brace = open_brace;\n        }\n    }\n\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpwdz6b9_q.rs:9:84\n    |\n9   |         if let Some(i) = (i, paren_string.chars().position(paren_string.as_bytes().get()).unwrap_or(i))\
    \ {\n    |                                                                   \
    \                 ^^^- supplied 0 arguments\n    |                           \
    \                                                         |\n    |           \
    \                                                                         expected\
    \ 1 argument\n    |\nnote: associated function defined here\n\nerror[E0277]: expected\
    \ a `FnMut<(char,)>` closure, found `Option<&_>`\n    --> /tmp/tmpwdz6b9_q.rs:9:60\n\
    \     |\n9    |         if let Some(i) = (i, paren_string.chars().position(paren_string.as_bytes().get()).unwrap_or(i))\
    \ {\n     |                                                   -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `FnMut<(char,)>` closure, found `Option<&_>`\n     |           \
    \                                        |\n     |                           \
    \                        required by a bound introduced by this call\n     |\n\
    \     = help: the trait `FnMut<(char,)>` is not implemented for `Option<&_>`\n\
    note: required by a bound in `position`\n\nerror[E0308]: mismatched types\n -->\
    \ /tmp/tmpwdz6b9_q.rs:9:16\n  |\n9 |         if let Some(i) = (i, paren_string.chars().position(paren_string.as_bytes().get()).unwrap_or(i))\
    \ {\n  |                ^^^^^^^   ------------------------------------------------------------------------------\
    \ this expression has type `(usize, usize)`\n  |                |\n  |       \
    \         expected tuple, found enum `Option`\n  |\n  = note: expected tuple `(usize,\
    \ usize)`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwdz6b9_q.rs:10:13\n   |\n10 |             (i, Some(i))\n   |  \
    \           ^^^^^^^^^^^^ expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<_>`\n             found tuple `(_, Option<_>)`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n10 |             Som"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut groups: Vec<String>\
    \ = Vec::new();\n    let mut inside_brace = false;\n    let mut open_brace_count\
    \ = 0;\n    for c in paren_string.chars() {\n        match c {\n            '\
    \ ' | ')' | '(' => inside_brace = false,\n            '(' | ')' | '{' => inside_brace\
    \ = true,\n            '{' => open_brace_count += 1,\n            _ => {\n   \
    \             inside_brace = open_brace_count > 0;\n                open_brace_count\
    \ = 0;\n            }\n        }\n        if !inside_brace {\n            groups.push(paren_string.subchar(i:\
    \ paren_string.position() + 1).unwrap());\n        }\n    }\n    groups\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmp97cl5_zs.rs:23:46\n\
    \   |\n23 |             groups.push(paren_string.subchar(i: paren_string.position()\
    \ + 1).unwrap());\n   |                                              ^--------------\n\
    \   |                                               |\n   |                  \
    \                             help: remove the type ascription\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmp97cl5_zs.rs:23:46\n   |\n\
    23 |             groups.push(paren_string.subchar(i: paren_string.position() +\
    \ 1).unwrap());\n   |                                              ^ expecting\
    \ a type here because of type ascription\n\nerror[E0573]: expected type, found\
    \ local variable `paren_string`\n  --> /tmp/tmp97cl5_zs.rs:23:49\n   |\n23 | \
    \            groups.push(paren_string.subchar(i: paren_string.position() + 1).unwrap());\n\
    \   |                                                 ^^^^^^^^^^^^ expecting a\
    \ type here because of type ascription\n\nerror[E0599]: no method named `subchar`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmp97cl5_zs.rs:23:38\n\
    \   |\n23 |             groups.push(paren_string.subchar(i: paren_string.position()\
    \ + 1).unwrap());\n   |                                      ^^^^^^^ method not\
    \ found in `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0425, E0573, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split_whitespace().filter(|w| w != \").\").map(|w| w.replace(\"\
    )\", \"\"))\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `str`\n --> /tmp/tmpvm7cguu_.rs:8:50\n\
    \  |\n8 |     paren_string.split_whitespace().filter(|w| w != \").\").map(|w|\
    \ w.replace(\")\", \"\"))\n  |                                               \
    \   ^^ no implementation for `&str == str`\n  |\n  = help: the trait `PartialEq<str>`\
    \ is not implemented for `&str`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            <&'a str as PartialEq<OsString>>\n    \
    \        <&'a str as PartialEq<String>>\n            <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<&'a str>>\n            <String as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<str>>\n            <String as PartialEq>\n\
    \            <str as PartialEq<Cow<'a, str>>>\n          and 4 others\n  = note:\
    \ required because of the requirements on the impl of `PartialEq<&str>` for `&&str`\n\
    \nerror[E0308]: mismatched types\n --> /tmp/tmpvm7cguu_.rs:8:5\n  |\n7 | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n  |                                              \
    \     ----------- expected `Vec<String>` because of return type\n8 |     paren_string.split_whitespace().filter(|w|\
    \ w != \").\").map(|w| w.replace(\")\", \"\"))\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Map`\n  |\n  = note: expected struct `Vec<String>`\n\
    \             found struct `Map<Filter<SplitWhitespace<'_>, [closure@/tmp/tmpvm7cguu_.rs:8:44:\
    \ 8:57]>, [closure@/tmp/tmpvm7cguu_.rs:8:63: 8:85]>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut parens = Vec::new();\n    let mut open_braces = Vec::new();\n   \
    \ for c in paren_string.chars() {\n        if c == ')' {\n            parens.push(paren_string[..]);\n\
    \            open_braces.push(c.to_string());\n        }\n        else if c ==\
    \ '{' {\n            parens.push(paren_string[..]);\n        }\n    }\n    let\
    \ mut current_open_braces: Vec<&str> = Vec::new();\n    for paren in parens {\n\
    \        if !open_braces.is_empty() {\n            open_braces.pop();\n      \
    \      if paren.starts_with(open_braces.last().to_string()) {\n              \
    \  current_open_braces.push(paren);\n            }\n        }\n        else {\n\
    \            current_open_braces.push(paren);\n        }\n    }\n    if open_braces.is_empty()\
    \ {\n        vec![String::from(\"\")]\n    }\n    else {\n        let mut open_groups\
    \ = Vec::new();\n        for brace in open_braces {\n            open_groups.push(String::from(\"\
    \"));\n        }\n        open_groups.extend(current_open_braces);\n    }\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp_9sixysq.rs:12:25\n    |\n12  |             parens.push(paren_string[..]);\n\
    \    |                    ---- ^^^^^^^^^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |                    |\n    |                    required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for\
    \ values of type `str` cannot be known at compilation time\n   --> /tmp/tmp_9sixysq.rs:8:22\n\
    \    |\n8   |     let mut parens = Vec::new();\n    |                      ^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |\n    = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp_9sixysq.rs:8:22\n    |\n8   |     let mut parens = Vec::new();\n\
    \    |                      ^^^ doesn't have a size known at compile-time\n  \
    \  |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec`\n\nerror[E0599]: the method `push` exists for struct `Vec<str>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmp_9sixysq.rs:16:20\n \
    \  |\n16 |             parens.push(paren_string[..]);\n   |                  \
    \  ^^^^ method cannot be called on `Vec<str>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `str:\
    \ Sized`\n\nerror[E0277]: the trait bound `Vec<str>: IntoIterator` is not satisfied\n\
    \  --> /tmp/tmp_9sixysq.rs:20:18\n   |\n20 |     for paren in parens {\n   | \
    \                 ^^^^^^ the trait `IntoIterator` is not implemented for `Vec<str>`\n\
    \   |\n   = help: the following other types implement trait `IntoIterator`:\n\
    \             &'a Vec<T, A>\n             &'a mut Vec<T, A>\n             Vec<T,\
    \ A>\n\nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp_9sixysq.rs:20:18\n    |\n20  |     "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().take_while(|c| !c.is_whitespace()).cloned()\n      \
    \  .collect::<String>()\n        .split_whitespace()\n        .map(|x| paren_matcher(x))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_matcher` in this scope\n  -->\
    \ /tmp/tmpn40v43aj.rs:11:18\n   |\n11 |         .map(|x| paren_matcher(x))\n \
    \  |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type\
    \ mismatch resolving `<TakeWhile<Chars<'_>, [closure@/tmp/tmpn40v43aj.rs:8:37:\
    \ 8:59]> as Iterator>::Item == &_`\n    --> /tmp/tmpn40v43aj.rs:8:61\n     |\n\
    8    |     paren_string.chars().take_while(|c| !c.is_whitespace()).cloned()\n\
    \     |                                                             ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<TakeWhile<Chars<'_>,\
    \ [closure@/tmp/tmpn40v43aj.rs:8:37: 8:59]>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpn40v43aj.rs:9:10\n   |\n9  |            .collect::<String>()\n\
    \   |             ^^^^^^^ method cannot be called on `Cloned<TakeWhile<Chars<'_>,\
    \ [closure@/tmp/tmpn40v43aj.rs:8:37: 8:59]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<TakeWhile<Chars<'_>,\
    \ [closure@/tmp/tmpn40v43aj.rs:8:37: 8:59]> as Iterator>::Item = &_`\n       \
    \    which is required by `Cloned<TakeWhile<Chars<'_>, [closure@/tmp/tmpn40v43aj.rs:8:37:\
    \ 8:59]>>: Iterator`\n           `Cloned<TakeWhile<Chars<'_>, [closure@/tmp/tmpn40v43aj.rs:8:37:\
    \ 8:59]>>: Iterator`\n           which is required by `&mut Cloned<TakeWhile<Chars<'_>,\
    \ [closure@/tmp/tmpn40v43aj.rs:8:37: 8:59]>>: Iterator`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0271, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.trim().split_whitespace().filter_map(|s| {\n        if s.is_empty()\
    \ {\n            None\n        } else {\n            Some(s.into_iter().collect::<String>())\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for reference `&str`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp9ou__jfr.rs:12:20\n   |\n12 |\
    \             Some(s.into_iter().collect::<String>())\n   |                  \
    \  ^^^^^^^^^ method cannot be called on `&str` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `&str:\
    \ Iterator`\n           which is required by `&str: IntoIterator`\n          \
    \ `&&str: Iterator`\n           which is required by `&&str: IntoIterator`\n \
    \          `&mut &str: Iterator`\n           which is required by `&mut &str:\
    \ IntoIterator`\n           `str: Sized`\n           which is required by `str:\
    \ IntoIterator`\n           `str: Iterator`\n           which is required by `str:\
    \ IntoIterator`\n           `&mut str: Iterator`\n           which is required\
    \ by `&mut str: IntoIterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ou__jfr.rs:8:5\n\
    \   |\n7  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                     ----------- expected\
    \ `Vec<String>` because of return type\n8  | /     paren_string.trim().split_whitespace().filter_map(|s|\
    \ {\n9  | |         if s.is_empty() {\n10 | |             None\n11 | |       \
    \  } else {\n12 | |             Some(s.into_iter().collect::<String>())\n13 |\
    \ |         }\n14 | |     })\n   | |______^ expected struct `Vec`, found struct\
    \ `FilterMap`\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp9ou__jfr.rs:8:55: 14:6]>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut group_stack = Vec::new();\n    let mut group_tokens = Vec::new();\n\
    \    paren_string.split_whitespace().filter(|x| x.len() > 0).for_each(|x| {\n\
    \        let mut open_brace_count = 0;\n        let mut open_brace_index = -1;\n\
    \        for x in x.chars() {\n            if x == '(' {\n                open_brace_count\
    \ += 1;\n                if open_brace_count == 1 {\n                    open_brace_index\
    \ = x.index();\n                }\n            }\n            match x == '{' {\n\
    \                true => group_stack.push(x.index()),\n                false =>\
    \ break,\n            }\n        }\n        group_stack.push(x.len());\n     \
    \   group_tokens.push(String::from(&x[open_brace_index..]));\n    })\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp7dlb61in.rs:17:42\n   |\n17 |                     open_brace_index\
    \ = x.index();\n   |                                          ^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `index` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp7dlb61in.rs:21:44\n   |\n21 |          \
    \       true => group_stack.push(x.index()),\n   |                           \
    \                 ^^^^^ method not found in `char`\n\nerror[E0277]: the trait\
    \ bound `usize: Neg` is not satisfied\n  --> /tmp/tmp7dlb61in.rs:12:36\n   |\n\
    12 |         let mut open_brace_index = -1;\n   |                            \
    \        ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the\
    \ following other types implement trait `Neg`:\n             &f32\n          \
    \   &f64\n             &i128\n             &i16\n             &i32\n         \
    \    &i64\n             &i8\n             &isize\n           and 8 others\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp7dlb61in.rs:10:5\n   |\n7  |   fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                            ----------- expected `Vec<String>`\
    \ because of return type\n...\n10 | /     paren_string.split_whitespace().filter(|x|\
    \ x.len() > 0).for_each(|x| {\n11 | |         let mut open_brace_count = 0;\n\
    12 | |         let mut open_brace_index = -1;\n13 | |         for x in x.chars()\
    \ {\n...  |\n26 | |         group_tokens.push(String::from(&x[open_brace_index..]));\n\
    27 | |     })\n   | |______^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<String>`\n           found unit type `()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack = Vec::new();\n    let mut current_group = String::new();\n\
    \    for c in paren_string {\n        if c == ')' {\n            paren_stack.pop();\n\
    \            current_group.append(c);\n        } else if c == '(' && !paren_stack.len()\
    \ {\n            current_group.append(c);\n        } else {\n            if current_group.is_empty()\
    \ || !paren_stack.is_empty() {\n                panic!(\"unexpected character:\
    \ {:?}\", c);\n            }\n            current_group.append(c);\n         \
    \   paren_stack.push(c);\n        }\n    }\n    current_group.trim().into_iter().collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpgb9yblqu.rs:10:14\n\
    \   |\n10 |     for c in paren_string {\n   |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpgb9yblqu.rs:13:27\n   |\n13 |             current_group.append(c);\n\
    \   |                           ^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgb9yblqu.rs:14:31\n   |\n14 |         } else\
    \ if c == '(' && !paren_stack.len() {\n   |                               ^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found `usize`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpgb9yblqu.rs:15:27\n\
    \   |\n15 |             current_group.append(c);\n   |                       \
    \    ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpgb9yblqu.rs:20:27\n\
    \   |\n20 |             current_group.append(c);\n   |                       \
    \    ^^^^^^ method not found in `String`\n\nerror[E0599]: the method `into_iter`\
    \ exists for reference `&str`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpgb9yblqu.rs:24:26\n   |\n24 |     current_group.trim().into_iter().collect()\n\
    \   |                          ^^^^^^^^^ method cannot be called on `&str` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `&str: Iterator`\n           which is required by\
    \ `&str: IntoIterator`\n           `&&str: Iterator`\n           which is required\
    \ by `&&str: IntoIterator`\n           `&mut &str: Iterator`\n           which\
    \ is required by `&mut &str: IntoIterator`\n           `str: Sized`\n        \
    \   which is required by `str: IntoIterator`\n           `str: Iterator`\n   \
    \        which is required by `str: IntoItera"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string.split(' ').collect::<Vec<String>>();\n    let\
    \ mut paren_groups = Vec::new();\n\n    let mut bracket_stack = Vec::new();\n\n\
    \    for group in groups {\n        if !group.starts_with('(') {\n           \
    \ if let Some(mut paren) = bracket_stack.last() {\n                *paren = *paren.push('(');\n\
    \            }\n            continue;\n        }\n\n        if group.ends_with(')')\
    \ {\n            let mut paren = bracket_stack.pop();\n            if paren.len()\
    \ == 1 {\n                paren.push(*paren.push('('));\n            }\n     \
    \       paren_groups.push(paren);\n            continue;\n        }\n\n      \
    \  bracket_stack.push(group.clone());\n    }\n\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp0a_44nt0.rs:8:46\n     |\n8  \
    \  |     let mut groups = paren_string.split(' ').collect::<Vec<String>>();\n\
    \     |                                              ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| c.is_ascii_alphanumeric()\
    \ || c == '(' || c == ')')\n        .filter(|c| !c.is_whitespace())\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_ucn226.rs:10:52\n\
    \   |\n10 |         .filter(|c| c.is_ascii_alphanumeric() || c == '(' || c ==\
    \ ')')\n   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa_ucn226.rs:10:64\n\
    \   |\n10 |         .filter(|c| c.is_ascii_alphanumeric() || c == '(' || c ==\
    \ ')')\n   |                                                                ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpa_ucn226.rs:8:5\n\
    \   |\n7  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                     ----------- expected\
    \ `Vec<String>` because of return type\n8  | /     paren_string\n9  | |      \
    \   .chars()\n10 | |         .filter(|c| c.is_ascii_alphanumeric() || c == '('\
    \ || c == ')')\n11 | |         .filter(|c| !c.is_whitespace())\n12 | |       \
    \  .collect::<Vec<_>>()\n   | |____________________________^ expected struct `String`,\
    \ found `char`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut paren_string = paren_string.as_bytes();\n\
    \    let mut cur_paren_group_start = 0;\n    let mut cur_paren_group = \"\";\n\
    \    let mut is_open = false;\n    loop {\n        // Keep track of which paren\
    \ group is opened.\n        if is_open {\n            paren_groups.push(cur_paren_group);\n\
    \            cur_paren_group = \"\";\n        }\n        // If we encounter a\
    \ closing paren then we set our previous group to empty.\n        if paren_string.len()\
    \ > cur_paren_group_start {\n            let mut next_char = paren_string[cur_paren_group_start];\n\
    \            if next_char == b'(' {\n                is_open = true;\n       \
    \     } else {\n                is_open = false;\n            }\n        }\n \
    \       // If we are not open then we copy the next char.\n        if !is_open\
    \ {\n            cur_paren_group += &paren_string[cur_paren_group_start..];\n\
    \            cur_paren_group_start += 1;\n        }\n        // Get the next char.\n\
    \        if paren_string.len() > cur_paren_group_start {\n            next_char\
    \ = paren_string[cur_paren_group_start];\n        } else {\n            break;\n\
    \        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `next_char` in this scope\n  --> /tmp/tmp922y9gil.rs:35:13\n\
    \   |\n35 |             next_char = paren_string[cur_paren_group_start];\n   |\
    \             ^^^^^^^^^ not found in this scope\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp922y9gil.rs:30:13\n\
    \   |\n30 |             cur_paren_group += &paren_string[cur_paren_group_start..];\n\
    \   |             ---------------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp922y9gil.rs:40:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n40 |  \
    \   paren_groups\n   |     ^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_paren_strings = Vec::new();\n    let mut close_paren_strings\
    \ = Vec::new();\n    let mut paren_strings = Vec::new();\n\n    paren_string.split_whitespace().for_each(|string|\
    \ {\n        if string.is_empty() {\n            return;\n        }\n        let\
    \ mut paren_count = 0;\n        let mut open_parens = false;\n        let mut\
    \ close_parens = false;\n\n        for char of string.chars() {\n            open_parens\
    \ = false;\n            close_parens = false;\n            if char == ')' {\n\
    \                close_parens = true;\n            }\n            if char == '('\
    \ {\n                open_parens = true;\n            }\n\n            if close_parens\
    \ && !open_parens {\n                close_paren_strings.push(&string);\n    \
    \            continue;\n            }\n            if open_parens && !close_parens\
    \ {\n                open_paren_strings.push(&string);\n                continue;\n\
    \            }\n\n            if open_parens {\n                paren_count +=\
    \ 1;\n            }\n        }\n\n        if open_paren_strings.len() != paren_count\
    \ {\n            paren_strings.push(String::from(\n                \"(\n     \
    \               \",\n                    open_paren_strings\n                \
    \        .into_iter()\n                        .take(paren_count)\n          \
    \              .collect::<Vec<_>>()\n                        .join(\",\"),\n \
    \                   \")\n                \"));\n        }\n        if close_paren_strings.len()\
    \ != paren_count {\n            paren_strings.push(String::from(\n           \
    \     \"(\n                    \",\n                    close_paren_strings\n\
    \                        .into_iter()\n                        .take(paren_count)\n\
    \                        .collect::<Vec<_>>()\n                        .join(\"\
    ,\"),\n                    \")\n                \"));\n        }\n    });\n  \
    \  paren_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmpadpvd4k7.rs:20:18\n  \
    \ |\n20 |         for char of string.chars() {\n   |                  ^^ help:\
    \ try using `in` here instead\n\nerror[E0599]: the method `join` exists for struct\
    \ `Vec<&&str>`, but its trait bounds were not satisfied\n  --> /tmp/tmpadpvd4k7.rs:52:26\n\
    \   |\n52 |                         .join(\",\"),\n   |                      \
    \    ^^^^ method cannot be called on `Vec<&&str>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `[&&str]:\
    \ Join<_>`\n\nerror[E0061]: this function takes 1 argument but 3 arguments were\
    \ supplied\n   --> /tmp/tmpadpvd4k7.rs:45:32\n    |\n45  |               paren_strings.push(String::from(\n\
    \    |                                  ^^^^^^^^^^^^ expected 1 argument\n46 \
    \ | /                 \"(\n47  | |                     \",\n    | |_____________________-\n\
    48  | /                     open_paren_strings\n49  | |                      \
    \   .into_iter()\n50  | |                         .take(paren_count)\n51  | |\
    \                         .collect::<Vec<_>>()\n52  | |                      \
    \   .join(\",\"),\n    | |__________________________________-\n53  | /       \
    \              \")\n54  | |                 \"));\n    | |_________________- supplied\
    \ 3 arguments\n    |\nnote: associated function defined here\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<&&str>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpadpvd4k7.rs:64:26\n   |\n64 |                 \
    \        .join(\",\"),\n   |                          ^^^^ method cannot be called\
    \ on `Vec<&&str>` due to unsatisfied trait bounds\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `[&&str]: Join<_>`\n\nerror[E0061]:\
    \ this function takes 1 argument but 3 arguments were supplied\n   --> /tmp/tmpadpvd4k7.rs:57:32\n\
    \    |\n57  |               paren_strings.push(String::from(\n    |          \
    \                        ^^^^^^^^^^^^ expected 1 argument\n58  | /           \
    \      \"(\n59  | |                     \",\n    | |_____________________-\n60\
    \  | /            "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec = vec![];\n\n    // Create a stack of parens to check against\n\
    \    let mut paren_stack = vec![String::from(\"\")];\n\n    for char in paren_string.chars()\
    \ {\n        match char {\n            // If there is an empty paren, then we\
    \ are done with this paren\n            '(' => {\n                // Check if\
    \ the current paren stack still has anything\n                if paren_stack.len()\
    \ > 0 {\n                    // Pop the top stack element and append the char\
    \ to the string\n                    vec.push(paren_stack.pop());\n          \
    \          // Push back onto stack\n                    paren_stack.push(char);\n\
    \                }\n                // If there are no more paren stacks, then\
    \ we are done\n                else\n                    vec.push(char);\n   \
    \         }\n            // Else, just push onto stack\n            c => {\n \
    \               paren_stack.push(char);\n            }\n        }\n    }\n\n \
    \   // Pop off the last paren stack item\n    vec.push(paren_stack.pop());\n\n\
    \    vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `vec`\n  --> /tmp/tmplkqabbq2.rs:26:21\n   |\n\
    26 |                     vec.push(char);\n   |                     ^^^ expected\
    \ `{`\n   |\nhelp: try placing this code inside a block\n   |\n26 |          \
    \           { vec.push(char); }\n   |                     +                 +\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplkqabbq2.rs:30:34\n   |\n30 |\
    \                 paren_stack.push(char);\n   |                              \
    \    ^^^^- help: try using a conversion method: `.to_string()`\n   |         \
    \                         |\n   |                                  expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkqabbq2.rs:38:5\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                   ----------- expected `Vec<String>`\
    \ because of return type\n...\n38 |     vec\n   |     ^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `Vec<String>`\n      \
    \        found struct `Vec<Option<String>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.lines()\n        .filter(|l| !l.is_empty() && l.chars().all(|c|\
    \ c == '('))\n        .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpijd643r8.rs:10:10\n     |\n10\
    \   |         .collect::<Vec<String>>()\n     |          ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Create a stack to hold the open parens we are currently processing.\n\
    \    let mut stack = Stack::new();\n\n    // Split the input string by opening\
    \ and closing parentheses.\n    // If the current char in the input is one of\
    \ the opening parenthesis,\n    // push it into the stack. Otherwise, pop the\
    \ stack to process the parenthesis.\n    // The return value will be an empty\
    \ string if there are no more parenthesis.\n    paren_string.chars().filter_map(|c|\
    \ match c {\n        '(' => {\n            stack.push(c);\n            Some(\"\
    \")\n        }\n        c => {\n            let mut s = stack.to_string();\n \
    \           s.push_str(&format!(\"{}\", c));\n            Some(s.to_string())\n\
    \        }\n    }).collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmp4tuf220r.rs:9:21\n\
    \  |\n9 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror[E0277]: a value of type `Vec<String>` cannot\
    \ be built from an iterator over elements of type `&str`\n    --> /tmp/tmp4tuf220r.rs:25:8\n\
    \     |\n25   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().skip_while(|c| !c.is_whitespace())\n        .take_while(|c|\
    \ !c.is_whitespace()).collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmppedvsd7p.rs:9:45\n     |\n9  \
    \  |         .take_while(|c| !c.is_whitespace()).collect()\n     |           \
    \                                  ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait\
    \ `FromIterator<char>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.chars().collect::<Vec<_>>();\n    let\
    \ mut in_string = String::from(\"(\");\n    paren_string.iter().enumerate().filter_map(|(i,\
    \ _)| {\n        if i == paren_string.len() - 1 {\n            in_string.push(')');\n\
    \            return Some(in_string);\n        }\n\n        if paren_string[i +\
    \ 1] == '(' {\n            in_string.push(')');\n            return Some(in_string);\n\
    \        }\n        Some(paren_string[i])\n    }).map(|x| x.unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9mmy4gsm.rs:20:14\n   |\n\
    20 |         Some(paren_string[i])\n   |              ^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |              |\n   |       \
    \       expected struct `String`, found `char`\n\nerror[E0599]: no method named\
    \ `unwrap` found for struct `String` in the current scope\n  --> /tmp/tmp9mmy4gsm.rs:21:18\n\
    \   |\n21 |     }).map(|x| x.unwrap()).collect()\n   |                  ^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_re = Regex::new(\n        r#\"\\((?P<open>[-\\w]+)\\s*\\((?P<inner>[-\\\
    w]+)\\)\\s*\\)(?P<close>[-\\w]+)\\s*\\)\"#,\n    );\n\n    paren_string\n    \
    \    .lines()\n        .flat_map(|line| line.chars().filter_map(char::is_whitespace))\n\
    \        .map(|char| char.to_string())\n        .filter_map(|char| paren_re.is_match(char))\n\
    \        .map(|(_, inner)| inner.to_string())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmp74_jgz2g.rs:8:20\n\
    \  |\n8 |     let paren_re = Regex::new(\n  |                    ^^^^^ use of\
    \ undeclared type `Regex`\n\nerror[E0271]: type mismatch resolving `<fn(char)\
    \ -> bool {char::methods::<impl char>::is_whitespace} as FnOnce<(char,)>>::Output\
    \ == Option<_>`\n   --> /tmp/tmp74_jgz2g.rs:14:39\n    |\n14  |         .flat_map(|line|\
    \ line.chars().filter_map(char::is_whitespace))\n    |                       \
    \                ^^^^^^^^^^ expected enum `Option`, found `bool`\n    |\n    =\
    \ note: expected enum `Option<_>`\n               found type `bool`\nnote: required\
    \ by a bound in `filter_map`\n\nerror[E0271]: type mismatch resolving `<fn(char)\
    \ -> bool {char::methods::<impl char>::is_whitespace} as FnOnce<(char,)>>::Output\
    \ == Option<_>`\n    --> /tmp/tmp74_jgz2g.rs:14:19\n     |\n14   |         .flat_map(|line|\
    \ line.chars().filter_map(char::is_whitespace))\n     |          -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n     |          |\n     |          required\
    \ by a bound introduced by this call\n     |\n     = note: expected enum `Option<_>`\n\
    \                found type `bool`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `FilterMap<Chars<'_>, fn(char) -> bool {char::methods::<impl\
    \ char>::is_whitespace}>`\n     = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `FilterMap<Chars<'_>, fn(char) -> bool {char::methods::<impl\
    \ char>::is_whitespace}>`\nnote: required by a bound in `flat_map`\n\nerror[E0599]:\
    \ the method `map` exists for struct `FlatMap<std::str::Lines<'_>, FilterMap<Chars<'_>,\
    \ fn(char) -> bool {char::methods::<impl char>::is_whitespace}>, [closure@/tmp/tmp74_jgz2g.rs:14:19:\
    \ 14:70]>`, but its trait bounds were not satisfied\n  --> /tmp/tmp74_jgz2g.rs:15:10\n\
    \   |\n15 |           .map(|char| char.to_string())\n   |            ^^^ method\
    \ cannot be called on `FlatMap<std::str::Lines<'_>, FilterMap<Chars<'_>, fn(char)\
    \ -> bool {char::methods::<impl char>:"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output = vec![];\n    let mut cur_paren = 0;\n    let mut paren_count\
    \ = 0;\n\n    for paren in paren_string.chars() {\n        if paren == '(' { //\
    \ Opening paren\n            paren_count += 1;\n            cur_paren += 1;\n\
    \        } else if paren == ')' { // Closing paren\n            paren_count -=\
    \ 1;\n            if paren_count == 0 {\n                output.push(paren_string.chars().take(cur_paren).collect::<String>());\n\
    \            }\n            cur_paren -= 1;\n        } else if paren == ',' {\
    \ // Comma\n            paren_count = 0;\n            cur_paren += 1;\n      \
    \  }\n    }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"(\", \"(\", \"(\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"\
    ((())()())\"]`', /tmp/tmpos1bsl44.rs:32:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string_arr = paren_string.split(' ').collect::<Vec<&str>>();\n\
    \    let mut result = Vec::new();\n    for i in 1..paren_string_arr.len() {\n\
    \        let mut open_paren = paren_string_arr[0..i].iter().count();\n       \
    \ let mut close_paren = paren_string_arr[i..].iter().count();\n        let mut\
    \ current = paren_string_arr[0..i];\n        for j in open_paren..close_paren\
    \ {\n            current = &current[j..];\n            result.push(current.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[&str]` cannot be known at compilation\
    \ time\n  --> /tmp/tmple5yh290.rs:13:13\n   |\n13 |         let mut current =\
    \ paren_string_arr[0..i];\n   |             ^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `[&str]`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\nhelp: consider borrowing here\n\
    \   |\n13 |         let mut current = &paren_string_arr[0..i];\n   |         \
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmple5yh290.rs:15:23\n\
    \   |\n13 |         let mut current = paren_string_arr[0..i];\n   |          \
    \                 ---------------------- expected due to this value\n14 |    \
    \     for j in open_paren..close_paren {\n15 |             current = &current[j..];\n\
    \   |                       ^^^^^^^^^^^^^ expected slice `[&str]`, found `&[&str]`\n\
    \   |\nhelp: consider removing the borrow\n   |\n15 -             current = &current[j..];\n\
    15 +             current = current[j..];\n   | \n\nerror[E0277]: the size for\
    \ values of type `[&str]` cannot be known at compilation time\n  --> /tmp/tmple5yh290.rs:15:13\n\
    \   |\n15 |             current = &current[j..];\n   |             ^^^^^^^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `[&str]`\n   = note: the left-hand-side of an assignment must\
    \ have a statically known size\n\nerror[E0599]: the method `to_string` exists\
    \ for slice `[&str]`, but its trait bounds were not satisfied\n  --> /tmp/tmple5yh290.rs:16:33\n\
    \   |\n16 |             result.push(current.to_string());\n   |              \
    \                   ^^^^^^^^^ method cannot be called on `[&str]` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `[&str]: std::fmt::Display`\n           which is required by `[&str]:\
    \ ToString`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n\n    for c in paren_string.chars()\
    \ {\n        if c.is_whitespace() {\n            continue;\n        }\n\n    \
    \    if c.is_parenthesized() {\n            if !paren_groups.is_empty() {\n  \
    \              paren_groups.pop();\n            }\n            paren_groups.push(c.to_owned());\n\
    \        } else {\n            paren_groups.push(c.to_owned());\n        }\n \
    \   }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_parenthesized` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpf6qh3jn8.rs:15:14\n   |\n15 |         if\
    \ c.is_parenthesized() {\n   |              ^^^^^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf6qh3jn8.rs:19:31\n\
    \   |\n19 |             paren_groups.push(c.to_owned());\n   |               \
    \                ^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf6qh3jn8.rs:21:31\n\
    \   |\n21 |             paren_groups.push(c.to_owned());\n   |               \
    \                ^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string_array = paren_string.chars().collect::<Vec<_>>();\n\
    \    let mut paren_string = String::from(\"\");\n    loop {\n        // If the\
    \ string is empty, we're done\n        if paren_string_array.len() == 0 {\n  \
    \          break;\n        }\n        // Find the index of the next open paren\n\
    \        let mut open_paren_index = 0;\n        for (index, char) in paren_string_array.iter().enumerate()\
    \ {\n            if char == '(' || char == '{'\n                || (char == ')'\
    \ && open_paren_index > index)\n                || (char == '}' && open_paren_index\
    \ > index)\n            {\n                open_paren_index = index;\n       \
    \     }\n        }\n        // If the next open paren is not the index of the\
    \ next close paren, we're done\n        if open_paren_index != paren_string_array.len()\
    \ {\n            break;\n        }\n        // Separate the string into its two\
    \ pieces\n        paren_string.push_str(paren_string_array[..open_paren_index]);\n\
    \        paren_string_array.remove(0..open_paren_index);\n    }\n    paren_string_array\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplalkc8qb.rs:18:21\n\
    \   |\n18 |             if char == '(' || char == '{'\n   |                  \
    \   ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplalkc8qb.rs:18:36\n\
    \   |\n18 |             if char == '(' || char == '{'\n   |                  \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmplalkc8qb.rs:19:26\n   |\n19 |                 ||\
    \ (char == ')' && open_paren_index > index)\n   |                          ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmplalkc8qb.rs:20:26\n\
    \   |\n20 |                 || (char == '}' && open_paren_index > index)\n   |\
    \                          ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplalkc8qb.rs:30:31\n   |\n30 |         paren_string.push_str(paren_string_array[..open_paren_index]);\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found slice `[char]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplalkc8qb.rs:31:35\n\
    \   |\n31 |         paren_string_array.remove(0..open_paren_index);\n   |    \
    \                               ^^^^^^^^^^^^^^^^^^^ expected `usize`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected type `usize`\n            found\
    \ struct `std::ops::Range<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplalkc8qb.rs:33:5\n\
    \   |\n7  "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(|&b| b == \" \" || b == '(' || b == '\"').collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0631]: type mismatch in closure arguments\n    --> /tmp/tmp958jjzl7.rs:8:18\n\
    \     |\n8    |     paren_string.split(|&b| b == \" \" || b == '(' || b == '\"\
    ').collect::<Vec<_>>()\n     |                  ^^^^^ -------------------------------------\
    \ found signature of `fn(&_) -> _`\n     |                  |\n     |        \
    \          expected signature of `fn(char) -> _`\n     |\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]`\nnote: required by a bound in `core::str::<impl str>::split`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `std::str::Split<'_, [closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]>`, but its trait bounds were not satisfied\n   --> /tmp/tmp958jjzl7.rs:8:63\n\
    \    |\n8   |       paren_string.split(|&b| b == \" \" || b == '(' || b == '\"\
    ').collect::<Vec<_>>()\n    |                          -------------------------------------\
    \  ^^^^^^^ method cannot be called on `std::str::Split<'_, [closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]>` due to unsatisfied trait bounds\n    |                          |\n\
    \    |                          doesn't satisfy `_: Pattern<'_>`\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `[closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]: Pattern<'_>`\n            which is required by `std::str::Split<'_, [closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]>: Iterator`\n            `std::str::Split<'_, [closure@/tmp/tmp958jjzl7.rs:8:24:\
    \ 8:61]>: Iterator`\n            which is required by `&mut std::str::Split<'_,\
    \ [closure@/tmp/tmp958jjzl7.rs:8:24: 8:61]>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0631.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.trim().rsplit(|c| {\n        match c {\n            '(' | ')'\
    \ | '[' | ']' | '{' | '}' | '{' | '}' => true,\n            _ => false,\n    \
    \    }\n    })\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppkuc4ztu.rs:8:5\n   |\n7\
    \  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   | \
    \                                                    ----------- expected `Vec<String>`\
    \ because of return type\n8  | /     paren_string.trim().rsplit(|c| {\n9  | |\
    \         match c {\n10 | |             '(' | ')' | '[' | ']' | '{' | '}' | '{'\
    \ | '}' => true,\n11 | |             _ => false,\n12 | |         }\n13 | |   \
    \  })\n   | |______^ expected struct `Vec`, found struct `std::str::RSplit`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `std::str::RSplit<'_,\
    \ [closure@/tmp/tmppkuc4ztu.rs:8:32: 13:6]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_lowercase().trim();\n    let mut open_braces:\
    \ Vec<bool> = Vec::new();\n    let mut closing_braces: Vec<bool> = Vec::new();\n\
    \    let mut strings: Vec<String> = Vec::new();\n\n    while paren_string.len()\
    \ > 0 {\n        let mut next_open_brace = false;\n        let mut next_closing_brace\
    \ = false;\n\n        // Find opening or closing brace and mark whether we found\
    \ it or not\n        for (i, c) in paren_string.chars().enumerate() {\n      \
    \      if c == '{' {\n                if open_braces.len() > 0 {\n           \
    \         let open_brace = open_braces.last().unwrap();\n                    if\
    \ !open_brace {\n                        open_braces.push(true);\n           \
    \             next_open_brace = true;\n                    } else {\n        \
    \                // We already found a new opening brace\n                   \
    \     break;\n                    }\n                } else {\n              \
    \      open_braces.push(true);\n                    next_open_brace = true;\n\
    \                }\n            } else if c == '}' {\n                if closing_braces.len()\
    \ > 0 {\n                    let closing_brace = closing_braces.last().unwrap();\n\
    \                    if !closing_brace {\n                        closing_braces.push(true);\n\
    \                        next_closing_brace = true;\n                    } else\
    \ {\n                        // We already found a closing brace\n           \
    \             break;\n                    }\n                } else {\n      \
    \              closing_braces.push(true);\n                    next_closing_brace\
    \ = true;\n                }\n            }\n\n            if open_braces.len()\
    \ == 1 {\n                open_braces.pop();\n            } else if closing_braces.len()\
    \ == 1 {\n                closing_braces.pop();\n            }\n\n           \
    \ if open_braces.len() == 0 && closing_braces.len() == 0 {\n                //\
    \ We found neither opening or closing brace\n                break;\n        \
    \    }\n        }\n\n        if next_open_brace {\n            strings.push(String::from(paren_string));\n\
    \            paren_string.clear();\n        } else {\n            paren_string.clear();\n\
    \        }\n\n        if next_closing_brace {\n            paren_string.push_str(\"\
    )\");\n        } else {\n            paren_string.push_str(\")\");\n        }\n\
    \    }\n\n    strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clear` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpf7ddkpbg.rs:63:26\n   |\n63 |             paren_string.clear();\n\
    \   |                          ^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `clear` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmpf7ddkpbg.rs:65:26\n   |\n65 |             paren_string.clear();\n  \
    \ |                          ^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpf7ddkpbg.rs:69:26\n   |\n69 |             paren_string.push_str(\"\
    )\");\n   |                          ^^^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push_str` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmpf7ddkpbg.rs:71:26\n   |\n71 |             paren_string.push_str(\"\
    )\");\n   |                          ^^^^^^^^ method not found in `&str`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_regex = Regex::new(r\"\\{(.*?)\\}\").unwrap();\n    let mut paren_matches\
    \ = paren_regex.captures(paren_string).unwrap();\n    let mut nested_paren_groups\
    \ = Vec::with_capacity(paren_matches.len());\n    for paren_group_string in paren_matches\
    \ {\n        let mut paren_group_string = paren_group_string.as_str();\n     \
    \   let mut paren_group_end = 0;\n        let mut nested_paren = String::with_capacity(paren_group_string.len());\n\
    \        for paren_group_start in 0..paren_group_string.len() {\n            if\
    \ paren_group_end == paren_group_start {\n                nested_paren.push_str(&paren_group_string[paren_group_start..]);\n\
    \            } else {\n                if paren_group_string[paren_group_end]\
    \ == '{' {\n                    paren_group_end += 1;\n                    nested_paren.push_str(&paren_group_string[paren_group_start..paren_group_end]);\n\
    \                } else {\n                    nested_paren.push_str(&paren_group_string[paren_group_start..]);\n\
    \                }\n            }\n        }\n        nested_paren_groups.push(nested_paren);\n\
    \    }\n    nested_paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpdohjno55.rs:8:23\n\
    \  |\n8 |     let paren_regex = Regex::new(r\"\\{(.*?)\\}\").unwrap();\n  |  \
    \                     ^^^^^ use of undeclared type `Regex`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars()\n        .filter(|c| *c != ' ' || c == ')' || c == '('\
    \ || c == '{' || c == '}' || c == '[' || c == ']')\n        .collect::<Vec<Char>>()\n\
    \        .filter(|c| *c != '(' || c == ')' || c == '{' || c == '}' || c == '['\
    \ || c == ']' || c == '{' || c == '}' || c == '[' || c == ']')\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpcyzbkpnj.rs:10:24\n\
    \   |\n10 |         .collect::<Vec<Char>>()\n   |                        ^^^^\n\
    \   |\nhelp: a builtin type with a similar name exists\n   |\n10 |         .collect::<Vec<char>>()\n\
    \   |                        ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n7  | fn separate_paren_groups<Char>(paren_string: String) -> Vec<String>\
    \ {\n   |                         ++++++\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n --> /tmp/tmpcyzbkpnj.rs:9:36\n  |\n9 |         .filter(|c| *c\
    \ != ' ' || c == ')' || c == '(' || c == '{' || c == '}' || c == '[' || c == ']')\n\
    \  |                                    ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \ = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmpcyzbkpnj.rs:9:48\n  |\n9 |       \
    \  .filter(|c| *c != ' ' || c == ')' || c == '(' || c == '{' || c == '}' || c\
    \ == '[' || c == ']')\n  |                                                ^^ no\
    \ implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpcyzbkpnj.rs:9:60\n\
    \  |\n9 |         .filter(|c| *c != ' ' || c == ')' || c == '(' || c == '{' ||\
    \ c == '}' || c == '[' || c == ']')\n  |                                     \
    \                       ^^ no implementation for `&char == char`\n  |\n  = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n --> /tmp/tmpcyzbkpnj.rs:9:72\n  |\n9 |         .filter(|c| *c\
    \ != ' ' || c == ')' || c == '(' || c == '{' || c == '}' || c == '[' || c == ']')\n\
    \  |                                                                        ^^\
    \ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not impleme"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = Vec::new();\n    let mut open_braces = Vec::new();\n   \
    \ let mut close_braces = Vec::new();\n\n    for c in paren_string.chars() {\n\
    \        match c {\n            '(' | ')' => {\n                close_braces.push(c);\n\
    \            }\n            c if c.is_whitespace() => continue,\n            '{'\
    \ => {\n                open_braces.push(c);\n            }\n            c if\
    \ c.is_whitespace() => continue,\n            _ => {\n                if open_braces.len()\
    \ > 0 {\n                    result.push(String::from_utf8_lossy(&open_braces));\n\
    \                }\n                open_braces = Vec::new();\n              \
    \  result.push(c);\n            }\n        }\n    }\n    if open_braces.len()\
    \ > 0 {\n        result.push(String::from_utf8_lossy(&open_braces));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5ducuotx.rs:24:57\n   |\n\
    24 |                     result.push(String::from_utf8_lossy(&open_braces));\n\
    \   |                                                         ^^^^^^^^^^^^ expected\
    \ slice `[u8]`, found struct `Vec`\n   |\n   = note: expected reference `&[u8]`\n\
    \              found reference `&Vec<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5ducuotx.rs:27:29\n   |\n27 |                 result.push(c);\n\
    \   |                             ^ expected enum `Cow`, found `char`\n   |\n\
    \   = note: expected enum `Cow<'_, str>`\n              found type `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp5ducuotx.rs:32:45\n   |\n32 |  \
    \       result.push(String::from_utf8_lossy(&open_braces));\n   |            \
    \                                 ^^^^^^^^^^^^ expected slice `[u8]`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&[u8]`\n              found reference\
    \ `&Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5ducuotx.rs:34:5\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                   ----------- expected `Vec<String>`\
    \ because of return type\n...\n34 |     result\n   |     ^^^^^^ expected struct\
    \ `String`, found enum `Cow`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<Cow<'_, str>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = paren_string.chars().group_by()\n        .by_ref()\n\
    \        .enumerate()\n        .filter(|&(idx, _)| idx % 2 == 0)\n        .map(|(idx,\
    \ _)| paren_string.chars()\n            .skip(idx)\n            .take_while(|&c|\
    \ c != '(' && c != ')')\n            .collect::<Vec<_>>())\n        .collect::<Vec<_>>();\n\
    \n    // Add some extra empty groups that will be removed later\n    paren_groups.push((paren_string.len()\
    \ + 2) as usize);\n\n    // Create empty string and move groups there\n    let\
    \ mut paren_groups_with_empty = Vec::new();\n    for (idx, group) in paren_groups.into_iter().enumerate()\
    \ {\n        paren_groups_with_empty.push((group.get(0), group.get(1)));\n   \
    \ }\n\n    // Remove empty groups\n    paren_groups.retain(|g| g.get(1).is_none());\n\
    \n    // Create separate group for each pair of consecutive parens\n    // The\
    \ last group will be unpaired right after the loop\n    let mut groups = Vec::new();\n\
    \    let mut cur_groups = Vec::new();\n    for (idx, group) in paren_groups.into_iter().enumerate()\
    \ {\n        if group.get(1).is_none() {\n            cur_groups.push(group);\n\
    \            continue;\n        }\n\n        // Create new group\n        let\
    \ mut group = group;\n        let mut idx = cur_groups.len();\n        group.push((idx,\
    \ group.get(1).unwrap()));\n        cur_groups.push(group);\n        groups.push(cur_groups);\n\
    \n        // Remove old group\n        cur_groups.remove(idx);\n    }\n\n    //\
    \ Add last group\n    groups.push(cur_groups);\n\n    // Remove extra empty group\n\
    \    groups.retain(|g| g.get(1).is_none());\n\n    // Separate groups\n    groups\n\
    \        .into_iter()\n        .flat_map(|g| g\n            .into_iter()\n   \
    \         .filter(|&(_, group)| group.is_empty())\n            .map(|&(_, group)|\
    \ group))\n        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `group_by` found for struct `Chars` in the\
    \ current scope\n --> /tmp/tmpp87gd8rr.rs:8:49\n  |\n8 |     let mut paren_groups\
    \ = paren_string.chars().group_by()\n  |                                     \
    \            ^^^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut curr_paren_count = 0;\n \
    \   let mut paren_open = String::from(\"\");\n    let mut paren_closed = String::from(\"\
    \");\n\n    for c in paren_string.chars() {\n        paren_groups.push(paren_open);\n\
    \        if c == '(' {\n            paren_open = String::from(\"\");\n       \
    \     paren_closed += c;\n            curr_paren_count += 1;\n        }\n    \
    \    if c == ')' {\n            paren_open += c;\n            curr_paren_count\
    \ -= 1;\n        }\n        if paren_open != \"\" && paren_closed != \"\" && paren_count\
    \ != curr_paren_count {\n            paren_groups.push(paren_closed);\n      \
    \      curr_paren_count = 0;\n        }\n    }\n    paren_groups.push(paren_closed);\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `paren_count` in this scope\n  --> /tmp/tmpwv6ay6at.rs:24:54\n\
    \   |\n24 |         if paren_open != \"\" && paren_closed != \"\" && paren_count\
    \ != curr_paren_count {\n   |                                                \
    \      ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwv6ay6at.rs:17:29\n   |\n17 |             paren_closed += c;\n\
    \   |                             ^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwv6ay6at.rs:21:27\n   |\n21 |             paren_open\
    \ += c;\n   |                           ^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut tokens = paren_string.split(' ').collect::<Vec<_>>();\n    let mut\
    \ paren_groups = vec![];\n    let mut open_curly = 0;\n    let mut closed_curly\
    \ = 0;\n    let mut open_braces = 0;\n    let mut closed_braces: usize = 0;\n\n\
    \    while tokens.len() > 0 {\n        let mut token = tokens.pop().unwrap();\n\
    \        let mut token_is_open = false;\n\n        // If this token is (, it is\
    \ either open or closed already\n        match token {\n            \"(\" => token_is_open\
    \ = open_curly == 0 || open_curly == 1,\n            \"{\" => token_is_open =\
    \ open_braces == 0 || open_braces == 1,\n            _ => token_is_open = false,\n\
    \        }\n\n        // If this token is ), it is either close or open already\n\
    \        match token {\n            \")\" => token_is_open = closed_curly == 0\
    \ || closed_curly == 1,\n            \"}\" => token_is_open = closed_braces ==\
    \ 0 || closed_braces == 1,\n            _ => token_is_open = false,\n        }\n\
    \n        // If this token is a (, then close previous open paren\n        match\
    \ token {\n            \"(\" => {\n                if open_curly != 0 {\n    \
    \                paren_groups.push(String::from(\n                        format!(\"\
    {}\", &open_curly - 1)));\n                }\n            }\n            _ =>\
    \ {}\n        }\n\n        // If this token is a (, then open new open paren\n\
    \        match token {\n            \"(\" => {\n                paren_groups.push(String::from(\n\
    \                    format!(\"{}\", &open_braces + 1)));\n            }\n   \
    \         _ => {}\n        }\n\n        // If this token is an ), then close open\
    \ paren\n        match token {\n            \")\" => {\n                paren_groups.push(String::from(\n\
    \                    format!(\"{}\", &closed_braces + 1)));\n            }\n \
    \           _ => {}\n        }\n\n        // If this token is either } or {, then\
    \ close current close paren\n        match token {\n            \"}\" => {\n \
    \               if closed_curly != 0 {\n                    paren_groups.push(String::from(\n\
    \                        format!(\"{}\", &closed_curly - 1)));\n             \
    \   }\n            }\n            \"{\" => {\n                if closed_braces\
    \ != 0 {\n                    paren_groups.push(String::from(\n              \
    \          format!(\"{}\", &closed_braces - 1)));\n                }\n       \
    \     }\n            _ => {}\n        }\n\n        // If this token is an }, then\
    \ open new close paren\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmplov4w51p.rs:88:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n15 |     while tokens.len() > 0 {\n   |                    \
    \        - this delimiter might not be properly closed...\n...\n80 | }\n   | -\
    \ ...as it matches this but it has different indentation\n...\n88 | }\n   |  \
    \ ^\n\nerror[E0308]: mismatched types\n --> /tmp/tmplov4w51p.rs:7:51\n  |\n7 |\
    \ fn separate_paren_groups(paren_string: String) -> Vec<String> {\n  |    ---------------------\
    \                          ^^^^^^^^^^^ expected struct `Vec`, found `()`\n  |\
    \    |\n  |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \  |\n  = note: expected struct `Vec<String>`\n          found unit type `()`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n    let mut paren_index = 0;\n\
    \    let mut paren_open = paren_index;\n    let mut paren_closed = paren_index;\n\
    \    let mut paren_open_padded = paren_index;\n    let mut paren_closed_padded\
    \ = paren_index;\n    let mut paren_level = 0;\n    paren_string.chars()\n   \
    \     .filter(|c| !c.is_whitespace())\n        .for_each(|c| {\n            match\
    \ c {\n                '(' => {\n                    paren_open_padded += 1;\n\
    \                    paren_open += 1;\n                }\n                '['\
    \ => {\n                    paren_open_padded += 1;\n                    paren_level\
    \ += 1;\n                }\n                '{' => {\n                    paren_open_padded\
    \ += 1;\n                    paren_level += 1;\n                }\n          \
    \      '(' | '[' | '{' => {\n                    paren_closed += 1;\n        \
    \        }\n                _ => {\n                    if paren_level == 0 {\n\
    \                        paren_groups.push(String::from(\"(\"));\n           \
    \         } else {\n                        paren_groups.push(String::from(\"\
    (\"));\n                        paren_level -= 1;\n                    }\n   \
    \             }\n            }\n        });\n    if paren_closed < paren_open\
    \ {\n        paren_groups.push(String::from(\"()\"));\n    }\n    if paren_open_padded\
    \ < paren_closed {\n        paren_groups.push(String::from(\"(())\"));\n    }\n\
    \    if paren_open_padded > paren_closed && paren_open_padded < paren_closed +\
    \ 1 {\n        paren_groups.push(String::from(\"(()())\"));\n    }\n    if paren_open_padded\
    \ == paren_closed && paren_open_padded == paren_closed + 1 {\n        paren_groups.push(String::from(\"\
    ()()\"));\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\", \"(\"\
    , \"(\", \"()\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`',\
    \ /tmp/tmpyin8d022.rs:61:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut open_braces = Vec::new();\n\
    \    let mut closed_braces = Vec::new();\n    let mut cur_char_pos = 0;\n    loop\
    \ {\n        if paren_string.chars().all(|c| *c == ' ') {\n            if closed_braces.len()\
    \ != 0 {\n                paren_string = paren_string.split_to(cur_char_pos +\
    \ 1);\n            }\n            cur_char_pos += 1;\n        } else {\n     \
    \       if closed_braces.len() != 0 {\n                closed_braces.pop();\n\
    \                open_braces.push(paren_string[cur_char_pos - 1]);\n         \
    \   }\n            open_braces.push(paren_string[cur_char_pos]);\n           \
    \ cur_char_pos += 1;\n        }\n        if cur_char_pos == paren_string.len()\
    \ {\n            break;\n        }\n    }\n    if closed_braces.len() != 0 {\n\
    \        paren_string = paren_string.split_to(cur_char_pos + 1);\n    }\n    paren_string\n\
    \        .chars()\n        .map(|c| c.to_string())\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpjf4x4of2.rs:13:41\n\
    \   |\n13 |         if paren_string.chars().all(|c| *c == ' ') {\n   |       \
    \                                  ^^\n\nerror[E0599]: no method named `split_to`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpjf4x4of2.rs:15:45\n\
    \   |\n15 |                 paren_string = paren_string.split_to(cur_char_pos\
    \ + 1);\n   |                                             ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpjf4x4of2.rs:21:34\n\
    \   |\n21 |                 open_braces.push(paren_string[cur_char_pos - 1]);\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpjf4x4of2.rs:23:30\n\
    \   |\n23 |             open_braces.push(paren_string[cur_char_pos]);\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ string indices are ranges\
    \ of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0599]: no method named `split_to` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpjf4x4of2.rs:31:37\n "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Split string at every possible opening paren\n    // but only if it's\
    \ followed by a closing paren.\n    // That way, the split string will end at\
    \ every possible closing paren.\n    // The first item of the split string is\
    \ the one we should get rid of.\n    // We also need to ignore all spaces in that\
    \ split string.\n    let mut split_string = paren_string.split(\"(\");\n    let\
    \ mut split_string = split_string.skip(1).collect();\n    let mut result: Vec<String>\
    \ = vec![];\n\n    // If there's an even number of split strings, we can just\
    \ ignore them.\n    if split_string.len() % 2 == 0 {\n        let even = split_string.iter().enumerate().filter_map(|(i,\
    \ s)| {\n            // Check if first item of the split string has spaces\n \
    \           s.contains(char::is_whitespace)\n        }).collect::<Vec<_>>();\n\
    \        if even.len() % 2 == 0 {\n            // If there are an even number\
    \ of split strings, we can just ignore them.\n            return result\n    \
    \    }\n    }\n    for element in split_string {\n        // Remove any space\
    \ characters contained in the split string.\n        let element: String = element.replace(r\"\
    \\s+\", \"\");\n        // Ignore empty elements.\n        if element.len() ==\
    \ 0 {\n            continue;\n        }\n        result.push(element);\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp2m6viyvn.rs:18:8\n\
    \   |\n14 |     let mut split_string = split_string.skip(1).collect();\n   | \
    \        ---------------- consider giving `split_string` a type\n...\n18 |   \
    \  if split_string.len() % 2 == 0 {\n   |        ^^^^^^^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter_map(|c| match c {\n     \
    \       c if c == '(' || c == ')' => {\n                Some('(')\n          \
    \  }\n            _ => {\n                Some(c)\n            }\n        })\n\
    \        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2qunf1vs.rs:8:5\n   |\n7\
    \  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   | \
    \                                                    ----------- expected `Vec<String>`\
    \ because of return type\n8  | /     paren_string\n9  | |         .chars()\n10\
    \ | |         .filter_map(|c| match c {\n11 | |             c if c == '(' || c\
    \ == ')' => {\n...  |\n17 | |         })\n18 | |         .collect::<Vec<_>>()\n\
    \   | |____________________________^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result: Vec<String> = vec![];\n\n    let mut stack = VecDeque::new();\n\
    \    stack.push_back(0);\n\n    let mut in_string: Vec<u16> = vec![];\n    in_string.push(b'(');\n\
    \    in_string.push(b'(');\n    in_string.push(b'(');\n    in_string.push(b'(');\n\
    \n    let mut in_paren_string = false;\n    for c in paren_string.as_bytes() {\n\
    \        if in_paren_string {\n            if c == b'(' {\n                stack.push_back(0);\n\
    \            } else {\n                stack.push_back(stack.last().checked_add(1));\n\
    \            }\n        }\n\n        if c == b'(' {\n            in_paren_string\
    \ = true;\n        }\n\n        if c == b')' {\n            in_paren_string =\
    \ false;\n        }\n\n        if c == b' ' {\n            result.push(String::from_utf8(in_string.to_vec()).unwrap());\n\
    \            in_string = vec![];\n        }\n\n        in_string.push(c);\n  \
    \  }\n\n    if in_paren_string {\n        stack.push_back(0);\n        result.push(String::from_utf8(in_string.to_vec()).unwrap());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpgkgfcpk4.rs:10:21\n   |\n10 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgkgfcpk4.rs:14:20\n   |\n14 |  \
    \   in_string.push(b'(');\n   |                    ^^^^ expected `u16`, found\
    \ `u8`\n   |\nhelp: you can convert a `u8` to a `u16`\n   |\n14 |     in_string.push(b'('.into());\n\
    \   |                        +++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgkgfcpk4.rs:15:20\n   |\n15 |     in_string.push(b'(');\n   |      \
    \              ^^^^ expected `u16`, found `u8`\n   |\nhelp: you can convert a\
    \ `u8` to a `u16`\n   |\n15 |     in_string.push(b'('.into());\n   |         \
    \               +++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgkgfcpk4.rs:16:20\n\
    \   |\n16 |     in_string.push(b'(');\n   |                    ^^^^ expected `u16`,\
    \ found `u8`\n   |\nhelp: you can convert a `u8` to a `u16`\n   |\n16 |     in_string.push(b'('.into());\n\
    \   |                        +++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpgkgfcpk4.rs:17:20\n   |\n17 |     in_string.push(b'(');\n   |      \
    \              ^^^^ expected `u16`, found `u8`\n   |\nhelp: you can convert a\
    \ `u8` to a `u16`\n   |\n17 |     in_string.push(b'('.into());\n   |         \
    \               +++++++\n\nerror[E0277]: can't compare `&u8` with `u8`\n  -->\
    \ /tmp/tmpgkgfcpk4.rs:22:18\n   |\n22 |             if c == b'(' {\n   |     \
    \             ^^ no implementation for `&u8 == u8`\n   |\n   = help: the trait\
    \ `PartialEq<u8>` is not implemented for `&u8`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             f32\n             f64\n\
    \             i128\n             i16\n             i32\n             i64\n   \
    \          i8\n             isize\n           and 6 others\n\nerror[E0277]: can't\
    \ compare `&u8` with `u8`\n  --> /tmp/tmpgkgfcpk4.rs:29:14\n   |\n29 |       \
    \  if c == b'(' {\n   |              ^^ no implementation for `&u8 "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut splits = paren_string.split(' ').collect::<Vec<_>>();\n    splits.retain(|x|\
    \ !x.is_empty());\n    splits\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppj7qymbf.rs:10:5\n   |\n\
    7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |   \
    \                                                ----------- expected `Vec<String>`\
    \ because of return type\n...\n10 |     splits\n   |     ^^^^^^ expected struct\
    \ `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups: Vec<String> = vec![];\n    let mut last_group_ended: usize\
    \ = 0;\n    for c in paren_string.chars() {\n        if last_group_ended != 0\
    \ && c == '(' {\n            groups.push(paren_string.chars().skip_while(|c| !(c\
    \ == '(' && c == ')')).take(last_group_ended + 1).collect::<String>());\n    \
    \        last_group_ended = 0;\n        } else if c == ')' {\n            last_group_ended\
    \ = 1;\n        }\n    }\n    if last_group_ended == 1 {\n        groups.push(paren_string.chars().skip_while(|c|\
    \ !(c == '(' && c == ')')).take(last_group_ended + 1).collect::<String>());\n\
    \    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxy3c99cp.rs:12:65\n\
    \   |\n12 |             groups.push(paren_string.chars().skip_while(|c| !(c ==\
    \ '(' && c == ')')).take(last_group_ended + 1).collect::<String>());\n   |   \
    \                                                              ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxy3c99cp.rs:12:77\n\
    \   |\n12 |             groups.push(paren_string.chars().skip_while(|c| !(c ==\
    \ '(' && c == ')')).take(last_group_ended + 1).collect::<String>());\n   |   \
    \                                                                          ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxy3c99cp.rs:19:61\n\
    \   |\n19 |         groups.push(paren_string.chars().skip_while(|c| !(c == '('\
    \ && c == ')')).take(last_group_ended + 1).collect::<String>());\n   |       \
    \                                                      ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpxy3c99cp.rs:19:73\n\
    \   |\n19 |         groups.push(paren_string.chars().skip_while(|c| !(c == '('\
    \ && c == ')')).take(last_group_ended + 1).collect::<String>());\n   |       \
    \                                                                  ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut parts = vec![];\n    let mut current_paren_level = 0;\n\n    paren_string.char_indices()\n\
    \        .filter_map(|(idx, _)| {\n            if idx < paren_string.len() - 1\
    \ {\n                Some(idx)\n            } else {\n                None\n \
    \           }\n        })\n        .for_each(|idx| {\n            let open_brace_level\
    \ = paren_string[idx].len_utf8();\n\n            if open_brace_level > current_paren_level\
    \ {\n                current_paren_level = open_brace_level;\n               \
    \ parts.push(paren_string[..idx]);\n            } else {\n                current_paren_level\
    \ += open_brace_level;\n            }\n        });\n\n    parts\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp953kdgu2.rs:20:36\n\
    \   |\n20 |             let open_brace_level = paren_string[idx].len_utf8();\n\
    \   |                                    ^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n   --> /tmp/tmp953kdgu2.rs:24:28\n    |\n24  |        \
    \         parts.push(paren_string[..idx]);\n    |                       ---- ^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                       |\n \
    \   |                       required by a bound introduced by this call\n    |\n\
    \    = help: the trait `Sized` is not implemented for `str`\nnote: required by\
    \ a bound in `Vec::<T, A>::push`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmp953kdgu2.rs:8:21\n\
    \    |\n8   |     let mut parts = vec![];\n    |                     ^^^^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec::<T>::new`\n    = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0277]: the size for values of type `str` cannot be\
    \ known at compilation time\n   --> /tmp/tmp953kdgu2.rs:8:21\n    |\n8   |   \
    \  let mut parts = vec![];\n    |                     ^^^^^^ doesn't have a size\
    \ known at compile-time\n    |\n    = help: the trait `Sized` is not implemented\
    \ for `str`\nnote: required by a bound in `Vec`\n    = note: this error origina"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Stack::new();\n    let mut tokens = TokenStream::new();\n\
    \    let mut paren_tokens: Vec<Token> = vec![];\n    let mut last = 0;\n    for\
    \ c in paren_string.chars() {\n        match c {\n            ' ' => {\n     \
    \           if stack.is_empty() {\n                    panic!(\"Unbalanced Parenthesis\"\
    )\n                }\n                stack.push((last, stack.last().unwrap().1));\n\
    \                last = 0;\n            }\n            '(' | '[' | '{' => {\n\
    \                stack.push(c);\n                last = c;\n            }\n  \
    \          ')' | ']' | '}' => if stack.is_empty() {\n                panic!(\"\
    Unbalanced Parenthesis\")\n            } else {\n                let (_, e) =\
    \ stack.pop();\n                if e != c {\n                    panic!(\"Mismatched\
    \ parenthesis pair\")\n                }\n                last = c\n         \
    \   }\n            _ => (),\n        }\n        tokens.insert(&c, None);\n   \
    \ }\n    if stack.is_empty() {\n        panic!(\"Unbalanced Parenthesis\")\n \
    \   }\n    if last != 0 {\n        stack.push((last, stack.last().unwrap().1));\n\
    \    }\n    paren_tokens.extend(tokens.into_iter().map(|t| t.to_string()));\n\
    \    paren_tokens\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n --> /tmp/tmpm51b_wr7.rs:8:21\n\
    \  |\n8 |     let mut stack = Stack::new();\n  |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `TokenStream`\n --> /tmp/tmpm51b_wr7.rs:9:22\n  |\n9 |     let mut tokens\
    \ = TokenStream::new();\n  |                      ^^^^^^^^^^^ use of undeclared\
    \ type `TokenStream`\n\nerror[E0412]: cannot find type `Token` in this scope\n\
    \  --> /tmp/tmpm51b_wr7.rs:10:31\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                         - help: you might be\
    \ missing a type parameter: `<Token>`\n...\n10 |     let mut paren_tokens: Vec<Token>\
    \ = vec![];\n   |                               ^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm51b_wr7.rs:23:24\n   |\n11 |\
    \     let mut last = 0;\n   |                    - expected due to this value\n\
    ...\n23 |                 last = c;\n   |                        ^ expected integer,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm51b_wr7.rs:32:24\n\
    \   |\n11 |     let mut last = 0;\n   |                    - expected due to this\
    \ value\n...\n32 |                 last = c\n   |                        ^ expected\
    \ integer, found `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0412, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string.chars().filter_map(|c| match c {\n        '('\
    \ => Some('('),\n        ')' => Some(')'),\n        _ => None,\n    }).collect();\n\
    \    let mut remaining = paren_string.chars().take(groups.len());\n    let mut\
    \ result = Vec::new();\n    while !remaining.is_empty() {\n        let mut current\
    \ = remaining.next();\n        let mut group_start = groups.last().unwrap();\n\
    \        while current.is_some() {\n            if current.unwrap() == group_start\
    \ {\n                let group = remaining.next();\n                groups.push((group,\
    \ None));\n            } else {\n                let group = groups.last().unwrap();\n\
    \                let mut current2 = remaining.next();\n                while current2.is_some()\
    \ {\n                    let start = current2.unwrap();\n                    if\
    \ start == group {\n                        break;\n                    }\n  \
    \                  groups.push((group, Some(start)));\n                    current2\
    \ = remaining.next();\n                }\n            }\n            current =\
    \ remaining.next();\n        }\n        if groups[groups.len() - 1].1 == Some(groups.last().unwrap())\
    \ {\n            groups.pop();\n        }\n        result.push(groups.clone());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4ntsuskd.rs:13:51\n\
    \   |\n8  |     let mut groups = paren_string.chars().filter_map(|c| match c {\n\
    \   |         ---------- consider giving `groups` a type\n...\n13 |     let mut\
    \ remaining = paren_string.chars().take(groups.len());\n   |                 \
    \                                  ^^^^^^ cannot infer type\n   |\n   = note:\
    \ type must be known at this point\n\nerror[E0599]: the method `is_empty` exists\
    \ for struct `std::iter::Take<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp4ntsuskd.rs:15:22\n   |\n15 |       while !remaining.is_empty()\
    \ {\n   |                        ^^^^^^^^ method cannot be called on `std::iter::Take<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `Chars<'_>: ExactSizeIterator`\n           which\
    \ is required by `std::iter::Take<Chars<'_>>: ExactSizeIterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0282, E0599.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars()\n        .filter(|c| !c.is_whitespace())\n        .filter_map(|c|\
    \ c.is_ascii_letter())\n        .filter(|c| c != '(' && c != ')')\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpo_yb8l1a.rs:10:27\n   |\n10 |         .filter_map(|c|\
    \ c.is_ascii_letter())\n   |                           ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0277]: can't\
    \ compare `&_` with `char`\n  --> /tmp/tmpo_yb8l1a.rs:11:23\n   |\n11 |      \
    \   .filter(|c| c != '(' && c != ')')\n   |                       ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpo_yb8l1a.rs:11:35\n\
    \   |\n11 |         .filter(|c| c != '(' && c != ')')\n   |                  \
    \                 ^^ no implementation for `&_ == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&_`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output = vec![];\n    let mut in_string = false;\n    let mut paren_count\
    \ = 0;\n\n    for char in paren_string.chars() {\n        if char == '(' {\n \
    \           paren_count += 1;\n        } else if char == ')' {\n            paren_count\
    \ -= 1;\n            if paren_count == 0 {\n                in_string = !in_string;\n\
    \            }\n        }\n\n        if paren_count > 0 {\n            if !in_string\
    \ {\n                output.push(char.to_string());\n            }\n        }\n\
    \    }\n\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"(\", \"(\", \")\", \"(\", \")\", \"(\"]`,\n right: `[\"(()())\", \"((()))\"\
    , \"()\", \"((())()())\"]`', /tmp/tmpkmi9ns67.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.clone();\n    let mut char_iter = paren_string.chars();\n\
    \n    let mut chars_left = paren_string.char_indices().filter_map(|i| {\n    \
    \    let (_, cs) = i;\n        if cs.is_none() {\n            None\n        }\
    \ else {\n            Some(c.clone())\n        }\n    });\n\n    let mut chars_right\
    \ = paren_string.char_indices().rev();\n\n    let mut paren_stack = Vec::new();\n\
    \    let mut current_index = 0;\n\n    for (char, _) in chars_left\n        .filter_map(|i|\
    \ {\n            let (_, cs) = i;\n            if cs.is_some() {\n           \
    \     Some(c.clone())\n            } else {\n                None\n          \
    \  }\n        })\n    {\n        paren_stack.push(char);\n    }\n\n    for (char,\
    \ _) in chars_right\n        .filter_map(|i| {\n            let (_, cs) = i;\n\
    \            if cs.is_some() {\n                Some(c.clone())\n            }\
    \ else {\n                None\n            }\n        })\n    {\n        paren_stack.push(char);\n\
    \    }\n\n    while !paren_stack.is_empty() {\n        let first_char = paren_stack.pop();\n\
    \n        if paren_string.starts_with(first_char.to_string()) {\n            if\
    \ paren_string.ends_with(first_char.to_string()) {\n                // the left\
    \ group finished and the right group started so we have 2 groups\n           \
    \     // if we keep going then we will never be able to finish this group\n  \
    \              let mut chars_right = paren_string.char_indices().rev();\n    \
    \            let mut chars_left = paren_string.char_indices();\n             \
    \   while !chars_left.is_empty() {\n                    let (next_char, _) = chars_left.remove();\n\
    \                    let mut next_string_pos = next_char.position() + 1;\n   \
    \                 if paren_string.ends_with(next_char.to_string()) {\n       \
    \                 let mut next_string_end_pos = next_char.position() + 1;\n  \
    \                      if !chars_right.is_empty() {\n                        \
    \    let (next_char_2, _) = chars_right.remove();\n                          \
    \  if next_char_2.to_string() == next_char.to_string() {\n                   \
    \             next_string_end_pos += 1;\n                            }\n     \
    \                   }\n                        let string_end = paren_string.len();\n\
    \                        let mut next_string = paren_string.chars().take(next_string_end_pos)\n\
    \                            .cloned().collect::<String>();\n                \
    \        let mut next_string_end_pos = 0;\n                        let mut next_string_start_pos\
    \ = next_string_end_pos;\n                        if next_string.len() > next_string_start_pos\
    \ {\n                            let next_char_pos = chars_right.next()\n    \
    \                            .or_else(|| chars_left.next())\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmph9x3452u.rs:87:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n51 |     while !paren_stack.is_empty() {\n   |             \
    \                      - unclosed delimiter\n...\n54 |         if paren_string.starts_with(first_char.to_string())\
    \ {\n   |                                                             - unclosed\
    \ delimiter\n55 |             if paren_string.ends_with(first_char.to_string())\
    \ {\n   |                                                               - unclosed\
    \ delimiter\n...\n60 |                 while !chars_left.is_empty() {\n   |  \
    \                                            - unclosed delimiter\n...\n63 | \
    \                    if paren_string.ends_with(next_char.to_string()) {\n   |\
    \                                                                      - unclosed\
    \ delimiter\n...\n76 |                         if next_string.len() > next_string_start_pos\
    \ {\n   |                                                                    \
    \  - this delimiter might not be properly closed...\n...\n79 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n87 | }\n   |   ^\n\n\
    error: expected `;`, found `}`\n  --> /tmp/tmph9x3452u.rs:78:63\n   |\n78 |  \
    \                               .or_else(|| chars_left.next())\n   |         \
    \                                                      ^ help: add `;` here\n\
    79 | }\n   | - unexpected token\n\nerror[E0425]: cannot find value `c` in this\
    \ scope\n  --> /tmp/tmph9x3452u.rs:16:18\n   |\n16 |             Some(c.clone())\n\
    \   |                  ^ help: a local variable with a similar name exists: `cs`\n\
    \nerror[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmph9x3452u.rs:29:22\n\
    \   |\n29 |                 Some(c.clone())\n   |                      ^ help:\
    \ a local variable with a similar name exists: `cs`\n\nerror[E0425]: cannot find\
    \ value `c` in this scope\n  --> /tmp/tmph9x3452u.rs:42:22\n   |\n42 |       \
    \          Some(c.clone())"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Split up string by parentheses.\n    let mut paren_groups = paren_string.char_indices().filter_map(|i|\
    \ {\n        // If group has a character within it, it's a group.\n        if\
    \ i.next().is_some() {\n            // Grouping will be done by opening and closing\
    \ parentheses.\n            Some(paren_group(&paren_string[i.next()], i.next()))\n\
    \        } else {\n            None\n        }\n    });\n\n    // Add groups with\
    \ extra parentheses as the last element of the vector.\n    paren_groups.push(paren_group);\n\
    \n    // Remove the grouping parentheses from the string and return the vector.\n\
    \    let mut paren_group_strings = paren_string.chars().filter(|c| !paren_groups.contains(c));\n\
    \    paren_group_strings.collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_group` in this scope\n  --> /tmp/tmpe1066vnl.rs:13:18\n\
    \   |\n13 |             Some(paren_group(&paren_string[i.next()], i.next()))\n\
    \   |                  ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `paren_group` in this scope\n  --> /tmp/tmpe1066vnl.rs:20:23\n  \
    \ |\n20 |     paren_groups.push(paren_group);\n   |                       ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_groups`\n\nerror[E0599]:\
    \ no method named `next` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmpe1066vnl.rs:11:14\n   |\n11 |         if i.next().is_some() {\n\
    \   |              ^^^^ method not found in `(usize, char)`\n\nerror[E0599]: no\
    \ method named `next` found for tuple `(usize, char)` in the current scope\n \
    \ --> /tmp/tmpe1066vnl.rs:13:46\n   |\n13 |             Some(paren_group(&paren_string[i.next()],\
    \ i.next()))\n   |                                              ^^^^ method not\
    \ found in `(usize, char)`\n\nerror[E0599]: no method named `next` found for tuple\
    \ `(usize, char)` in the current scope\n  --> /tmp/tmpe1066vnl.rs:13:57\n   |\n\
    13 |             Some(paren_group(&paren_string[i.next()], i.next()))\n   |  \
    \                                                       ^^^^ method not found\
    \ in `(usize, char)`\n\nerror[E0599]: no method named `push` found for struct\
    \ `FilterMap` in the current scope\n  --> /tmp/tmpe1066vnl.rs:20:18\n   |\n20\
    \ |     paren_groups.push(paren_group);\n   |                  ^^^^ method not\
    \ found in `FilterMap<CharIndices<'_>, [closure@/tmp/tmpe1066vnl.rs:9:67: 17:6]>`\n\
    \nerror[E0599]: no method named `contains` found for struct `FilterMap` in the\
    \ current scope\n  --> /tmp/tmpe1066vnl.rs:23:81\n   |\n23 |     let mut paren_group_strings\
    \ = paren_string.chars().filter(|c| !paren_groups.contains(c));\n   |        \
    \                                                                         ^^^^^^^^\
    \ method not found in `FilterMap<CharIndices<'_>, [closure@/tmp/tmpe1066vnl.rs:9:67:\
    \ 17:6]>`\n\nerror[E0277]: a value of type `Vec<String>` cannot be built from "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = paren_string.split(')');\n    for paren_group in paren_groups.iter()\
    \ {\n        paren_group.replace(\n            paren_group.find('('),\n      \
    \      paren_group.replace(paren_group.find('(') + 1, \"\").len(),\n        );\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmpww9vkhza.rs:9:37\n  |\n9 |     for paren_group\
    \ in paren_groups.iter() {\n  |                                     ^^^^ method\
    \ not found in `std::str::Split<'_, char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpww9vkhza.rs:15:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n15 |  \
    \   paren_groups\n   |     ^^^^^^^^^^^^ expected struct `Vec`, found struct `std::str::Split`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `std::str::Split<'_,\
    \ char>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = vec![];\n    let mut pos = 0;\n    while pos < paren_string.len()\
    \ {\n        match paren_string[pos] {\n            '(' => {\n               \
    \ stack.push((paren_string.len() - pos));\n            }\n            '[' => {\n\
    \                stack.push((paren_string.len() - pos));\n            }\n    \
    \        '{' => {\n                stack.push((paren_string.len() - pos));\n \
    \           }\n            _ => {\n                while stack.is_empty() && !paren_string.chars().all(|c|\
    \ c == ' ') {\n                    pos += 1;\n                }\n            \
    \    if stack.is_empty() {\n                    stack.unshift(paren_string.len()\
    \ - pos);\n                } else {\n                    stack.last()\n      \
    \          }\n            }\n        }\n        pos += 1;\n    }\n    stack\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp5yec4p6a.rs:13:28\n\
    \   |\n13 |                 stack.push((paren_string.len() - pos));\n   |    \
    \                        ^                        ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n13 -                 stack.push((paren_string.len()\
    \ - pos));\n13 +                 stack.push(paren_string.len() - pos);\n   | \n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmp5yec4p6a.rs:16:28\n\
    \   |\n16 |                 stack.push((paren_string.len() - pos));\n   |    \
    \                        ^                        ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n16 -                 stack.push((paren_string.len() - pos));\n\
    16 +                 stack.push(paren_string.len() - pos);\n   | \n\nwarning:\
    \ unnecessary parentheses around method argument\n  --> /tmp/tmp5yec4p6a.rs:19:28\n\
    \   |\n19 |                 stack.push((paren_string.len() - pos));\n   |    \
    \                        ^                        ^\n   |\nhelp: remove these\
    \ parentheses\n   |\n19 -                 stack.push((paren_string.len() - pos));\n\
    19 +                 stack.push(paren_string.len() - pos);\n   | \n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5yec4p6a.rs:11:15\n\
    \   |\n11 |         match paren_string[pos] {\n   |               ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `unshift` found for struct `Vec<usize>`\
    \ in the current scope\n  --> /tmp/tmp5yec4p6a.rs:26:27\n   |\n26 |          \
    \           stack.unshift(p"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut current_paren = String::new();\n\n    let mut bracket_stack: Vec<String>\
    \ = vec![];\n    let mut open_braces = false;\n\n    for ch in paren_string.chars()\
    \ {\n        // Ignore spaces in the string.\n        if ch == ' ' {\n       \
    \     continue;\n        }\n\n        // If we have an open brace, add it to the\
    \ stack.\n        if ch == '(' {\n            open_braces = true;\n          \
    \  current_paren = ch.to_string();\n            bracket_stack.push(current_paren);\n\
    \        }\n\n        // If we're at a close brace, pop off the last element of\
    \ the stack\n        // and add the string to the vector of results if it's balanced.\n\
    \        if ch == ')' {\n            bracket_stack.pop();\n            if bracket_stack.len()\
    \ == 0 {\n                return vec![current_paren.clone()];\n            }\n\
    \n            if !open_braces {\n                return vec![current_paren.clone()];\n\
    \            }\n        }\n    }\n\n    return vec![];\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `current_paren`\n  --> /tmp/tmphbce31f_.rs:31:29\n\
    \   |\n8  |     let mut current_paren = String::new();\n   |         -----------------\
    \ move occurs because `current_paren` has type `String`, which does not implement\
    \ the `Copy` trait\n...\n23 |             bracket_stack.push(current_paren);\n\
    \   |                                ------------- value moved here\n...\n31 |\
    \                 return vec![current_paren.clone()];\n   |                  \
    \           ^^^^^^^^^^^^^^^^^^^^^ value borrowed here after move\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups_vec: Vec<String> = Vec::new();\n    let mut current_group_end\
    \ = 0;\n    for paren in paren_string.chars() {\n        if paren == '(' {\n \
    \           current_group_end = paren_string.len();\n        } else if paren ==\
    \ ')' {\n            let group_length = current_group_end - paren_string.len();\n\
    \            paren_groups_vec.push(paren_string.split_at(group_length).to_owned());\n\
    \            current_group_end = paren_string.len();\n        }\n    }\n    paren_groups_vec\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp35z97a_a.rs:15:35\n   |\n\
    15 |             paren_groups_vec.push(paren_string.split_at(group_length).to_owned());\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found tuple\n   |\n   = note: expected struct `String`\n\
    \               found tuple `(&str, &str)`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut bracket_stack: Vec<usize> = vec![];\n    let mut cur_pos = 0;\n \
    \   let mut cur_group = String::from(\"\");\n\n    for c in paren_string.chars()\
    \ {\n        cur_pos += 1;\n\n        if c == '(' && cur_pos < paren_string.len()\
    \ {\n            bracket_stack.push(bracket_stack.len());\n            cur_pos\
    \ += 1;\n        } else if c == ')' {\n            let top = bracket_stack.len();\n\
    \            cur_pos += 1;\n            bracket_stack.pop();\n\n            if\
    \ top < bracket_stack.len() {\n                cur_group = cur_group.trim_end_matches(')');\n\
    \            }\n        }\n    }\n\n    cur_group\n        .split_whitespace()\n\
    \        .map(|x| x.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tfovjnv.rs:24:29\n   |\n\
    10 |     let mut cur_group = String::from(\"\");\n   |                       \
    \  ---------------- expected due to this value\n...\n24 |                 cur_group\
    \ = cur_group.trim_end_matches(')');\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \           |\n   |                             expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: -1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = vec![];\n    let mut current = paren_string.clone();\n\
    \    while let Some(next) = current.chars().next() {\n        if next == '(' {\n\
    \            current = paren_string.clone();\n        } else {\n            if\
    \ current != paren_string {\n                output.push(current);\n         \
    \   }\n            current = paren_string.clone();\n        }\n    }\n    if current\
    \ != paren_string {\n        output.push(current);\n    }\n    output\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Timeout
  stderr: ''
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack: Vec<Vec<String>> = vec![vec![]];\n    let mut group_vector:\
    \ Vec<String> = vec![];\n    let mut group_vector_index = 0;\n    paren_string.chars()\n\
    \        .filter_map(|ch|\n            if ch == ' ' {\n                false\n\
    \            } else {\n                let mut group_vector = stack.last().unwrap();\n\
    \                let group_vector_index = group_vector.len() - 1;\n          \
    \      stack.push(Vec::new());\n                group_vector.push(String::from(\"\
    \"));\n                Some(group_vector_index)\n            })\n        .for_each(|char_at_index|\n\
    \            match stack.last().get(char_at_index) {\n                Some(group_vector_index)\
    \ => {\n                    let mut group_vector = stack.last().unwrap();\n  \
    \                  let group_vector = &mut group_vector[group_vector_index];\n\
    \                    let group_string = &group_vector[group_vector_index];\n \
    \                   group_string.push(char_at_index.to_string());\n          \
    \          group_vector_index += 1;\n                },\n                None\
    \ => {}\n            }\n        );\n\n    group_vector\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3d2o8lpw.rs:14:17\n   |\n\
    14 |                 false\n   |                 ^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n14 |       \
    \          Some(false)\n   |                 +++++     +\n\nerror[E0599]: no method\
    \ named `get` found for enum `Option` in the current scope\n  --> /tmp/tmp3d2o8lpw.rs:23:32\n\
    \   |\n23 |             match stack.last().get(char_at_index) {\n   |        \
    \                        ^^^ method not found in `Option<&Vec<String>>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut paren_characters\
    \ = paren_string.chars();\n    let mut paren_groups = Vec::new();\n    let mut\
    \ has_paren = false;\n    let mut paren_groups_stack = Vec::new();\n    for paren\
    \ in paren_characters {\n        if paren == ' ' {\n            continue;\n  \
    \      }\n        if paren == '(' {\n            has_paren = true;\n        }\n\
    \        if paren == ')' {\n            has_paren = false;\n        }\n      \
    \  if has_paren {\n            if paren_groups_stack.is_empty() {\n          \
    \      // if there is no previous group then this is a new group\n           \
    \     // add it to the stack\n                paren_groups_stack.push(paren_groups);\n\
    \                // add this group to the group\n                paren_groups\
    \ = Vec::new();\n            }\n            else {\n                // else just\
    \ pop this group and add it to the stack\n                paren_groups_stack.pop();\n\
    \                paren_groups.push(paren_groups);\n            }\n        }\n\
    \        else {\n            // if the paren does not have parenthesis, add it\
    \ to the group\n            paren_groups.push(paren);\n        }\n    }\n    if\
    \ paren_groups_stack.is_empty() {\n        paren_groups.push(paren_groups);\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpndy0_aw8.rs:34:35\n   |\n\
    34 |                 paren_groups.push(paren_groups);\n   |                  \
    \                 ^^^^^^^^^^^^- help: try using a conversion method: `.to_vec()`\n\
    \   |                                   |\n   |                              \
    \     cyclic type of infinite size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpndy0_aw8.rs:43:27\n\
    \   |\n43 |         paren_groups.push(paren_groups);\n   |                   \
    \        ^^^^^^^^^^^^ expected `char`, found struct `Vec`\n   |\n   = note: expected\
    \ type `char`\n            found struct `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpndy0_aw8.rs:45:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n45 |  \
    \   paren_groups\n   |     ^^^^^^^^^^^^ expected struct `String`, found `char`\n\
    \   |\n   = note: expected struct `Vec<String>`\n              found struct `Vec<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .into_string()\n        .split_whitespace()\n     \
    \   .map(|item| item.trim())\n        .filter(|item| !item.is_empty())\n     \
    \   .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_string` found for struct `String` in\
    \ the current scope\n --> /tmp/tmp2rqmj8t6.rs:9:10\n  |\n9 |         .into_string()\n\
    \  |          ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Initialize an empty vector to hold the output.\n    let mut output = Vec::new();\n\
    \n    // Iterate over every character in the string.\n    for (index, char) in\
    \ paren_string.chars().enumerate() {\n        // If this character is close to\
    \ a closing brace, push it to the vector.\n        if char == ')' {\n        \
    \    // If we haven't yet added this character to an output vector and there is\
    \ more than one in an\n            // input string, then we have a nested set\
    \ of parens.\n            if output.len() != 0 && !output[output.len() - 1].contains('(')\
    \ {\n                output.push('(');\n            }\n            output.push(&paren_string[index..(index\
    \ + 2)]);\n        }\n\n        // If we haven't yet added this character to an\
    \ output vector and there is only one in an\n        // input string, then we\
    \ have a single paren.\n        if output.len() != 0 && !output[output.len() -\
    \ 1].contains('(') {\n            output.push('(');\n        }\n    }\n\n    //\
    \ Return the output.\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpagemip2r.rs:17:38\n\
    \   |\n9  |     let mut output = Vec::new();\n   |         ---------- consider\
    \ giving `output` the explicit type `Vec<T>`, with the type parameters specified\n\
    ...\n17 |             if output.len() != 0 && !output[output.len() - 1].contains('(')\
    \ {\n   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^ cannot\
    \ infer type\n   |\n   = note: type must be known at this point\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = vec![];\n    for paren in paren_string.chars().skip_while(|c|\
    \ !c.is_ascii_alphanumeric()) {\n        let mut paren_group = \"\";\n       \
    \ for c in paren.chars().skip_while(|c| !c.is_ascii_alphanumeric()) {\n      \
    \      if c == '(' {\n                paren_group += '(';\n            } else\
    \ if c == ')' {\n                paren_group += ')';\n            } else if paren_group.is_empty()\
    \ {\n                paren_group += c;\n            } else {\n               \
    \ paren_group += c;\n            }\n        }\n        paren_groups.push(paren_group);\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpve2dq04p.rs:11:24\n   |\n11 |         for c in paren.chars().skip_while(|c|\
    \ !c.is_ascii_alphanumeric()) {\n   |                        ^^^^^ method not\
    \ found in `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be\
    \ applied to type `&str`\n  --> /tmp/tmpve2dq04p.rs:13:17\n   |\n13 |        \
    \         paren_group += '(';\n   |                 -----------^^^^^^^\n   | \
    \                |\n   |                 cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpve2dq04p.rs:15:17\n\
    \   |\n15 |                 paren_group += ')';\n   |                 -----------^^^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmpve2dq04p.rs:17:17\n   |\n17 |                 paren_group += c;\n\
    \   |                 -----------^^^^^\n   |                 |\n   |         \
    \        cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `&str`\n  --> /tmp/tmpve2dq04p.rs:19:17\n   |\n\
    19 |                 paren_group += c;\n   |                 -----------^^^^^\n\
    \   |                 |\n   |                 cannot use `+=` on type `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpve2dq04p.rs:24:5\n   |\n7  | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                          ----------- expected `Vec<String>`\
    \ because of return type\n...\n24 |     paren_groups\n   |     ^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<&str>`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_regex_str = r\"\\(\\s*\\((?P<paren_group>.*?)\\)\\s*\\)\"; // Match\
    \ any number of nested parens\n    let paren_regex = Regex::new(paren_regex_str.as_str()).unwrap();\
    \ // Create a regex\n    let paren_matches = paren_regex.captures_iter(paren_string.as_bytes());\
    \ // Find all paren matches\n    let mut output_vec: Vec<String> = Vec::new();\
    \ // Create a vector to hold each of the paren groups\n    for paren_match in\
    \ paren_matches {\n        if paren_match.is_match(paren_string.as_bytes()) {\n\
    \            output_vec.push(String::from(paren_match.group(\"paren_group\").unwrap()));\n\
    \        } else {\n            panic!(\"Something went wrong with Regex matching!\"\
    );\n        }\n    }\n    output_vec\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpb8q8nptk.rs:9:23\n\
    \  |\n9 |     let paren_regex = Regex::new(paren_regex_str.as_str()).unwrap();\
    \ // Create a regex\n  |                       ^^^^^ use of undeclared type `Regex`\n\
    \nerror[E0599]: no method named `as_str` found for reference `&str` in the current\
    \ scope\n --> /tmp/tmpb8q8nptk.rs:9:50\n  |\n9 |     let paren_regex = Regex::new(paren_regex_str.as_str()).unwrap();\
    \ // Create a regex\n  |                                                 -^^^^^^--\
    \ help: remove this method call\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut tokens = paren_string.split_whitespace();\n    let mut groups = Vec::new();\n\
    \    while tokens.len() > 0 {\n        let mut cur_group: Vec<String> = Vec::new();\n\
    \        let mut current_token: String = String::from(\"(\");\n        while tokens.len()\
    \ > 0 && tokens[0].contains(&current_token) {\n            cur_group.push(tokens[0]);\n\
    \            tokens.remove(0);\n        }\n        groups.push(cur_group);\n \
    \       while tokens.len() > 0 && current_token == String::from(\")\") {\n   \
    \         tokens.remove(0);\n        }\n        current_token = String::from(\"\
    )\");\n    }\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpdcu1p8_4.rs:10:18\n   |\n10 |     while\
    \ tokens.len() > 0 {\n   |                  ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpdcu1p8_4.rs:13:22\n   |\n13 |         while tokens.len()\
    \ > 0 && tokens[0].contains(&current_token) {\n   |                      ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0608]: cannot index into a value\
    \ of type `SplitWhitespace<'_>`\n  --> /tmp/tmpdcu1p8_4.rs:13:35\n   |\n13 | \
    \        while tokens.len() > 0 && tokens[0].contains(&current_token) {\n   |\
    \                                   ^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpdcu1p8_4.rs:14:28\n   |\n\
    14 |             cur_group.push(tokens[0]);\n   |                            ^^^^^^^^^\n\
    \nerror[E0599]: no method named `remove` found for struct `SplitWhitespace` in\
    \ the current scope\n  --> /tmp/tmpdcu1p8_4.rs:15:20\n   |\n15 |             tokens.remove(0);\n\
    \   |                    ^^^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpdcu1p8_4.rs:18:22\n   |\n18 |         while tokens.len()\
    \ > 0 && current_token == String::from(\")\") {\n   |                      ^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `remove`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpdcu1p8_4.rs:19:20\n\
    \   |\n19 |             tokens.remove(0);\n   |                    ^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpdcu1p8_4.rs:23:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n23 |  \
    \   groups\n   |     ^^^^^^ expected struct `String`, found struct `Vec`\n   |\n\
    \   = note: expec"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_group = Vec::new();\n    let mut paren_count = 0;\n    let\
    \ mut paren_start_pos = 0;\n    let mut paren_end_pos = 0;\n\n    for c in paren_string.chars()\
    \ {\n        if paren_count == 0 {\n            paren_start_pos = paren_end_pos\
    \ + 1;\n            paren_end_pos += 1;\n        }\n\n        if paren_count >=\
    \ 2 && paren_count % 2 == 0 {\n            paren_end_pos += 1;\n        }\n\n\
    \        if c == ' ' {\n            paren_count += 1;\n        }\n\n        if\
    \ c == '(' {\n            paren_count += 1;\n        }\n\n        if c == ')'\
    \ {\n            paren_count -= 1;\n        }\n\n        if c == ')' {\n     \
    \       if paren_count == 0 {\n                paren_group.push(paren_string.chars().nth(paren_start_pos).unwrap());\n\
    \                paren_start_pos = paren_end_pos + 1;\n                paren_end_pos\
    \ += 1;\n            }\n        }\n    }\n\n    paren_group\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo7ayv2bp.rs:44:5\n   |\n\
    7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |   \
    \                                                ----------- expected `Vec<String>`\
    \ because of return type\n...\n44 |     paren_group\n   |     ^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = paren_string.par_char_indices();\n    paren_groups\
    \ = paren_groups.map(|c| {\n        paren_groups[c].map(|idx|\n            paren_string.chars().nth(idx).ok_or(IndexOutOfBounds)?\n\
    \        )\n    });\n\n    let mut groups: Vec<String> = vec![];\n    for (i,\
    \ paren_group) in paren_groups.enumerate() {\n        if paren_group.is_none()\
    \ {\n            continue;\n        }\n\n        let mut group_started = false;\n\
    \        for paren_char in paren_group {\n            if paren_char == char::ParenthesisOpeningBrace\
    \ {\n                group_started = true;\n                continue;\n      \
    \      }\n\n            if group_started {\n                break;\n         \
    \   }\n\n            groups.push(paren_string);\n        }\n    }\n\n    return\
    \ groups.into_iter().collect();\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `IndexOutOfBounds` in this scope\n  -->\
    \ /tmp/tmp9av13r8_.rs:11:49\n   |\n11 |             paren_string.chars().nth(idx).ok_or(IndexOutOfBounds)?\n\
    \   |                                                 ^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `par_char_indices` found for\
    \ struct `String` in the current scope\n --> /tmp/tmp9av13r8_.rs:8:41\n  |\n8\
    \ |     let mut paren_groups = paren_string.par_char_indices();\n  |         \
    \                                ^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `char_indices`\n\nerror[E0277]: the `?` operator\
    \ can only be used in a closure that returns `Result` or `Option` (or another\
    \ type that implements `FromResidual`)\n  --> /tmp/tmp9av13r8_.rs:11:66\n   |\n\
    10 |           paren_groups[c].map(|idx|\n   |  _____________________________-\n\
    11 | |             paren_string.chars().nth(idx).ok_or(IndexOutOfBounds)?\n  \
    \ | |                                                                  ^\n   |\
    \ |                                                                  |\n   | |__________________________________________________________________cannot\
    \ use the `?` operator in a closure that returns `char`\n   |                \
    \                                                    this function should return\
    \ `Result` or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<Result<Infallible,\
    \ _>>` is not implemented for `char`\n\nerror[E0599]: no associated item named\
    \ `ParenthesisOpeningBrace` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp9av13r8_.rs:23:36\n   |\n23 |             if paren_char == char::ParenthesisOpeningBrace\
    \ {\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^ associated\
    \ item not found in `char`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| c.is_whitespace())\n\
    \        .collect()\n        .filter_map(|c| {\n            if c == '{' || c ==\
    \ '[' {\n                Some(c)\n            } else if c == '}' || c == ']' {\n\
    \                Some(c)\n            } else {\n                None\n       \
    \     }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpc1axyn5w.rs:11:10\n\
    \   |\n11 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n11 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Use regex and capture parens to separate groups\n    let mut parens: Vec<_>\
    \ = paren_string\n        .chars()\n        .flat_map(|c| match c {\n        \
    \    ' ' => Vec::new(),\n            '(' => Some('('),\n            ')' => Some(')'),\n\
    \            _ => None,\n        })\n        .collect();\n\n    // Start by removing\
    \ all previous paren groups\n    while !parens.is_empty() {\n        parens.pop();\n\
    \    }\n\n    // Re-add all current paren groups\n    while parens.is_none() {\n\
    \        parens.push(parens.pop().unwrap());\n    }\n\n    // Remove spaces from\
    \ groups and remove them from the original string\n    let mut result = parens.iter().filter(|&c|\
    \ c != '(' && c != ')').collect::<Vec<_>>();\n    parens.iter_mut().filter(|&c|\
    \ c != ' ').for_each(|c| result.push(c));\n    result\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpm05folx3.rs:13:20\n\
    \   |\n11 |           .flat_map(|c| match c {\n   |  _______________________-\n\
    12 | |             ' ' => Vec::new(),\n   | |                    ---------- this\
    \ is found to be of type `Vec<_>`\n13 | |             '(' => Some('('),\n   |\
    \ |                    ^^^^^^^^^ expected struct `Vec`, found enum `Option`\n\
    14 | |             ')' => Some(')'),\n15 | |             _ => None,\n16 | |  \
    \       })\n   | |_________- `match` arms have incompatible types\n   |\n   =\
    \ note: expected struct `Vec<_>`\n                found enum `Option<char>`\n\n\
    error[E0599]: no method named `is_none` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpm05folx3.rs:25:18\n   |\n25 |     while parens.is_none()\
    \ {\n   |                  ^^^^^^^ method not found in `Vec<_>`\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n  --> /tmp/tmpm05folx3.rs:30:50\n   |\n30 |\
    \     let mut result = parens.iter().filter(|&c| c != '(' && c != ')').collect::<Vec<_>>();\n\
    \   |                                                  ^^ no implementation for\
    \ `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpm05folx3.rs:30:62\n\
    \   |\n30 |     let mut result = parens.iter().filter(|&c| c != '(' && c != ')').collect::<Vec<_>>();\n\
    \   |                                                              ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&mut _` with `char`\n  --> /tmp/tmpm05folx3.rs:31:37\n\
    \   |\n31 |     parens.iter_mut().filter(|&c| c != ' ').for_each(|c| result.push(c));\n\
    \   |                                     ^^ no implementation for `&mut _ ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&mut\
    \ _`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm05folx3.rs:32:5\n   |\n\
    7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |   \
    \                                                ---------"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter_map(|c| match c {\n     \
    \       b'(' => Some((b'(', 1)),\n            b')' => Some((b'(', 1)) => Some((b'(',\
    \ 1)),\n            _ => None,\n        })\n        .collect::<Vec<_>>()\n   \
    \     .into_iter()\n        .filter_map(|(e, count)| if count == 1 {\n       \
    \     let s = e.to_string();\n            if s.len() == 0 {\n                None\n\
    \            } else {\n                Some(s)\n            }\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `=>`\n\
    \  --> /tmp/tmpg__az9ue.rs:12:37\n   |\n12 |             b')' => Some((b'(', 1))\
    \ => Some((b'(', 1)),\n   |                  --                 ^^ expected one\
    \ of `,`, `.`, `?`, `}`, or an operator\n   |                  |\n   |       \
    \           while parsing the `match` arm starting here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg__az9ue.rs:11:13\n   |\n10 |         .filter_map(|c| match\
    \ c {\n   |                               - this expression has type `char`\n\
    11 |             b'(' => Some((b'(', 1)),\n   |             ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmpg__az9ue.rs:17:34\n\
    \   |\n17 |            .filter_map(|(e, count)| if count == 1 {\n   |   __________________________________^\n\
    18 |  |             let s = e.to_string();\n19 |  |             if s.len() ==\
    \ 0 {\n   |  |_____________-\n20 | ||                 None\n21 | ||          \
    \   } else {\n22 | ||                 Some(s)\n23 | ||             }\n   | ||_____________-\
    \ found here\n24 |  |         })\n   |  |_________^ expected `()`, found enum\
    \ `Option`\n   |\n   = note: expected unit type `()`\n                   found\
    \ enum `Option<String>`\n   = note: `if` expressions without `else` evaluate to\
    \ `()`\n   = help: consider adding an `else` block that evaluates to the expected\
    \ type\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0317.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = vec![];\n    let mut paren_depth = 1;\n    let mut\
    \ last_open_paren_depth = 0;\n    for ch in paren_string.chars() {\n        match\
    \ ch {\n            ' ' | '\\t' => {\n                // Ignore whitespace\n \
    \           }\n            '(' | ')' | '[' | ']' | '{' | '}' => {\n          \
    \      paren_depth -= 1;\n                if paren_depth > last_open_paren_depth\
    \ {\n                    paren_depth -= 1;\n                }\n              \
    \  paren_groups.push(paren_string.chars().take(paren_depth).collect());\n    \
    \            last_open_paren_depth = paren_depth;\n            }\n           \
    \ ch => {\n                last_open_paren_depth -= 1;\n                paren_groups.push(paren_string.chars().take(paren_depth).collect());\n\
    \                paren_groups.push(String::from(ch.to_string()));\n          \
    \  }\n        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmptldbvt3o.rs:17:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Initialize the empty vector\n    let mut groups = Vec::new();\n    let\
    \ mut in_paren = false;\n    for c in paren_string.chars() {\n        // If not\
    \ inside a group, read next character\n        if !in_paren {\n            match\
    \ c {\n                '(' | ')' | ' ' | '\\t' | ' ' => {\n                  \
    \  // If in open paren, close it and push to group\n                    if c ==\
    \ ' ' && !in_paren {\n                        in_paren = true;\n             \
    \       } else {\n                        in_paren = false;\n                \
    \    }\n                }\n                _ => {\n                    // If in\
    \ open group, just ignore it\n                    if in_paren {\n            \
    \            continue;\n                    }\n                }\n           \
    \ }\n        }\n        // If inside group, then add the character to the group\n\
    \        match c {\n            ')' | ' ' | '\\t' | ' ' => {\n               \
    \ // If not in open group, just ignore it\n                if !in_paren {\n  \
    \                  continue;\n                }\n            }\n            '('\
    \ | ' ' | ')' | ':' | ',' | ';' | '=' => {\n                // If not in open\
    \ group, just ignore it\n                if !in_paren {\n                    continue;\n\
    \                }\n            }\n            _ => {\n                groups.push(c);\n\
    \            }\n        }\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0u9fvwux.rs:50:5\n   |\n\
    7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   |   \
    \                                                ----------- expected `Vec<String>`\
    \ because of return type\n...\n50 |     groups\n   |     ^^^^^^ expected struct\
    \ `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n   \
    \           found struct `Vec<char>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Regex to match a string that contains a balanced parenthesis\n    let\
    \ re_balanced = Regex::new(r\"\\([^()]*\\)\").unwrap();\n    let mut result =\
    \ vec![];\n    for paren in paren_string.chars() {\n        if paren == '(' ||\
    \ paren == ')' {\n            // This parenthesis has a match\n            let\
    \ mut match_str = \"\";\n            while paren != ')' {\n                if\
    \ paren == '(' {\n                    // If we are currently in a parenthesis,\
    \ add a ')'\n                    match_str += paren;\n                } else {\n\
    \                    // If we reach the end, then break\n                    if\
    \ paren == ')' {\n                        break;\n                    }\n    \
    \                // Otherwise, this is a mismatching parenthesis, so add some\
    \ more chars\n                    match_str += paren;\n                }\n   \
    \             paren = paren_string.chars().next().unwrap();\n            }\n \
    \           if paren == ')' {\n                // The match ended, so this parenthesis\
    \ is properly closed\n                result.push(String::from(match_str));\n\
    \            } else {\n                // The match did not end but there is a\
    \ mismatch, so add some more chars\n                result.push(String::from(match_str));\n\
    \            }\n        } else {\n            // The parenthesis did not have\
    \ a match, so append this char to our match_str\n            result.push(paren);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmporid399t.rs:9:23\n\
    \  |\n9 |     let re_balanced = Regex::new(r\"\\([^()]*\\)\").unwrap();\n  | \
    \                      ^^^^^ use of undeclared type `Regex`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmporid399t.rs:18:21\n\
    \   |\n18 |                     match_str += paren;\n   |                    \
    \ ---------^^^^^^^^^\n   |                     |\n   |                     cannot\
    \ use `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmporid399t.rs:25:21\n   |\n25 |     \
    \                match_str += paren;\n   |                     ---------^^^^^^^^^\n\
    \   |                     |\n   |                     cannot use `+=` on type\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmporid399t.rs:38:25\n\
    \   |\n38 |             result.push(paren);\n   |                         ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \       |\n   |                         expected struct `String`, found `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = vec![];\n    let mut paren_depth = 0;\n\n    for (i,\
    \ char) in paren_string.chars().enumerate() {\n        if char == '(' {\n    \
    \        paren_depth += 1;\n        }\n        if char == ')' {\n            paren_depth\
    \ -= 1;\n        }\n        if paren_depth == 0 {\n            paren_groups.push(paren_string.chars().skip(i).collect::<String>());\n\
    \        }\n    }\n\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\") ((())) () ((())()())\", \" ((())) () ((())()())\", \") () ((())()())\"\
    , \" () ((())()())\", \") ((())()())\", \" ((())()())\", \")\"]`,\n right: `[\"\
    (()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpk5kiwapl.rs:28:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.into_iter()\n        .flat_map(|c| c.chars().filter(|&c| !c.is_whitespace()))\n\
    \        .filter_map(|c| c.is_ascii_letter)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp4i6yeppi.rs:8:18\n    |\n8 \
    \  |       paren_string.into_iter()\n    |                    ^^^^^^^^^\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `String: IntoIterator`\n       \
    \     `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .lines()\n        .filter_map(|line| line.chars().collect::<Vec<_>>())\n\
    \        .filter_map(|c| c.chars().filter_map(|c| c != '(' && c != ')').collect())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdk38qzoy.rs:10:28\n   |\n\
    10 |         .filter_map(|line| line.chars().collect::<Vec<_>>())\n   |      \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found struct `Vec`\n   |\n   = note: expected enum `Option<_>`\n           \
    \ found struct `Vec<char>`\nhelp: try wrapping the expression in `Some`\n   |\n\
    10 |         .filter_map(|line| Some(line.chars().collect::<Vec<_>>()))\n   |\
    \                            +++++                                +\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.into_owned();\n    let mut result = Vec::new();\n\
    \    while !paren_string.is_empty() {\n        let mut current = paren_string.clone();\n\
    \        if current.is_empty() {\n            paren_string = &mut paren_string[1..];\n\
    \            continue;\n        }\n\n        let mut next = current[1..];\n  \
    \      let mut open_brace_position = 0;\n        let mut close_brace_position\
    \ = 0;\n        while !next.is_empty() {\n            if next[open_brace_position..].is_empty()\
    \ {\n                close_brace_position += open_brace_position;\n          \
    \      open_brace_position = 0;\n            }\n\n            let mut brace_open\
    \ = next[open_brace_position..];\n            let mut brace_closed = brace_open[..brace_open.len()-1];\n\
    \            let mut open_paren = next[next.len()-brace_open.len()..];\n     \
    \       let mut close_paren = open_paren[..open_paren.len()-1];\n            while\
    \ brace_closed.is_empty() {\n                let mut char = close_paren[0];\n\
    \                close_paren = &close_paren[1..];\n                if char !=\
    \ ' ' {\n                    break;\n                }\n            }\n      \
    \      let mut string_open = brace_open[..brace_open.len()-brace_closed.len()];\n\
    \            let mut string_close = brace_closed[..brace_closed.len()];\n    \
    \        while !string_open.is_empty() && string_close.is_empty() {\n        \
    \        let mut char = string_open[0];\n                string_open = &string_open[1..];\n\
    \                if char != ' ' {\n                    break;\n              \
    \  }\n            }\n            result.push(string_open.to_owned());\n      \
    \      paren_string = &mut paren_string[brace_closed.len()..];\n            next\
    \ = next[brace_open.len()-brace_closed.len()..];\n            string_close = brace_closed[..brace_closed.len()];\n\
    \        }\n        result.push(current.to_owned());\n        paren_string = &mut\
    \ paren_string[next.len()..];\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n --> /tmp/tmp8hv1s_lc.rs:8:41\n  |\n8 |     let mut paren_string\
    \ = paren_string.into_owned();\n  |                                         ^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .lines()\n        .filter_map(|x| x.chars().filter(|c|\
    \ *c != ' '))\n        .filter(|x| x.is_some())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdyiwc6n1.rs:10:25\n   |\n\
    10 |         .filter_map(|x| x.chars().filter(|c| *c != ' '))\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ struct `Filter`\n   |\n   = note: expected enum `Option<_>`\n            found\
    \ struct `Filter<Chars<'_>, [closure@/tmp/tmpdyiwc6n1.rs:10:42: 10:55]>`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n10 |         .filter_map(|x| Some(x.chars().filter(|c|\
    \ *c != ' ')))\n   |                         +++++                           \
    \    +\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string.chars().filter(|c| !c.is_whitespace()).groups();\n\
    \    let mut paren_strings: Vec<String> = Vec::new();\n    while let Some(group)\
    \ = groups.next() {\n        let mut s = String::from(\"\").into_boxed_str();\n\
    \        for e in group {\n            s.push_str(&e.to_string());\n        }\n\
    \        paren_strings.push(s);\n    }\n    paren_strings\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `groups` found for struct `Filter` in the\
    \ current scope\n --> /tmp/tmpv4et25je.rs:8:74\n  |\n8 |     let mut groups =\
    \ paren_string.chars().filter(|c| !c.is_whitespace()).groups();\n  |         \
    \                                                                 ^^^^^^ method\
    \ not found in `Filter<Chars<'_>, [closure@/tmp/tmpv4et25je.rs:8:50: 8:72]>`\n\
    \nerror[E0599]: no method named `push_str` found for struct `Box<str>` in the\
    \ current scope\n  --> /tmp/tmpv4et25je.rs:13:15\n   |\n13 |             s.push_str(&e.to_string());\n\
    \   |               ^^^^^^^^ method not found in `Box<str>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv4et25je.rs:15:28\n   |\n15 |         paren_strings.push(s);\n\
    \   |                            ^- help: try using a conversion method: `.to_string()`\n\
    \   |                            |\n   |                            expected struct\
    \ `String`, found struct `Box`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Box<str>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut input_string = paren_string.clone();\n    let mut open_braces = 0;\n\
    \    let mut close_braces = 0;\n    while let Some(c) = input_string.pop() {\n\
    \        match c {\n            ' ' => {\n                input_string.push(c);\n\
    \            }\n            '(' | *'(' ) => {\n                open_braces++;\n\
    \            }\n            ')' => {\n                close_braces++;\n      \
    \      }\n            ')' | *'*(') => {\n                close_braces--;\n   \
    \         }\n            ']' => {\n                close_braces--;\n         \
    \   }\n            '[' => {\n                open_braces++;\n            }\n \
    \           _ => {\n                return vec![];\n            }\n        }\n\
    \    }\n    if open_braces == 0 || close_braces == 0 {\n        return vec![];\n\
    \    }\n    let mut open_parens = String::new();\n    let mut close_parens = String::new();\n\
    \    let mut prev_open_parens = String::new();\n    while let Some(c) = input_string.pop()\
    \ {\n        match c {\n            ' ' => {\n                input_string.push(c);\n\
    \            }\n            '(' => {\n                open_parens += c;\n    \
    \        }\n            ')' => {\n                close_parens += c;\n       \
    \     }\n            ')' | *'*(') => {\n                close_parens += c;\n \
    \           }\n            _ => {\n                break;\n            }\n   \
    \     }\n        if prev_open_parens == open_parens {\n            if close_parens\
    \ == prev_open_parens {\n                return vec![open_parens];\n         \
    \   }\n        }\n        prev_open_parens = open_parens;\n        open_parens\
    \ = String::new();\n        close_parens = String::new();\n    }\n    vec![]\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp27xubyvp.rs:22:20\n\
    \   |\n22 |             ')' | *'*(') => {\n   |                    ^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n22 |   \
    \          ')' | *\"*(\") => {\n   |                    ~~~~\n\nerror: unexpected\
    \ closing delimiter: `}`\n  --> /tmp/tmp27xubyvp.rs:35:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \                  - this opening brace...\n...\n34 |         }\n   |        \
    \ - ...matches this closing brace\n35 |     }\n   |     ^ unexpected closing delimiter\n\
    \nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp27xubyvp.rs:12:17\n\
    \   |\n12 |         match c {\n   |                 ^ unclosed delimiter\n...\n\
    16 |             '(' | *'(' ) => {\n   |                        ^ mismatched closing\
    \ delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp27xubyvp.rs:11:44\n\
    \   |\n11 |     while let Some(c) = input_string.pop() {\n   |               \
    \                             ^ unclosed delimiter\n...\n22 |             ')'\
    \ | *'*(') => {\n   |                        ^ mismatched closing delimiter\n\n\
    error: aborting due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = Vec::new();\n    let mut cur_str = paren_string;\n    let\
    \ mut cur_len = paren_string.len();\n    while cur_len > 0 {\n        if cur_str[0..cur_len\
    \ - 1].is_empty() {\n            cur_str = &cur_str[cur_len..];\n        } else\
    \ {\n            cur_str = &cur_str[cur_len..];\n            groups.push(cur_str);\n\
    \        }\n        cur_len = paren_string.len();\n    }\n    groups\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp__o4v634.rs:13:23\n   |\n\
    9  |     let mut cur_str = paren_string;\n   |                       ------------\
    \ expected due to this value\n...\n13 |             cur_str = &cur_str[cur_len..];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n13 |             cur_str\
    \ = (&cur_str[cur_len..]).to_string();\n   |                       +         \
    \          +++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp__o4v634.rs:15:23\n\
    \   |\n9  |     let mut cur_str = paren_string;\n   |                       ------------\
    \ expected due to this value\n...\n15 |             cur_str = &cur_str[cur_len..];\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `&str`\n   |\nhelp: try using a conversion method\n   |\n15 |             cur_str\
    \ = (&cur_str[cur_len..]).to_string();\n   |                       +         \
    \          +++++++++++++\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut bracket_stack = Vec::new();\n    let mut open_braces = 0;\n    let\
    \ mut open_parentheses = 0;\n    let mut open_braces_set = false;\n    let mut\
    \ close_braces_set = false;\n    let mut close_braces = 0;\n    let mut close_parentheses\
    \ = 0;\n    let mut parentheses_set = false;\n    let mut current_group: Vec<String>\
    \ = Vec::new();\n    for char in paren_string.chars() {\n        if char == '('\
    \ {\n            open_parentheses += 1;\n            parentheses_set = true;\n\
    \        }\n        if char == ')' {\n            close_parentheses += 1;\n  \
    \      }\n        if char == '{' {\n            open_braces += 1;\n          \
    \  open_braces_set = true;\n        }\n        if char == '}' {\n            close_braces\
    \ += 1;\n            close_braces_set = true;\n        }\n        if char == '\
    \ ' && !open_braces_set && !close_braces_set && !parentheses_set {\n         \
    \   current_group.push(char);\n        }\n        if char == ' ' {\n         \
    \   if open_braces_set && !close_braces_set && !parentheses_set {\n          \
    \      open_braces_set = false;\n            }\n            if close_braces_set\
    \ && !parentheses_set {\n                close_braces_set = false;\n         \
    \   }\n            if open_braces_set && close_braces_set && parentheses_set {\n\
    \                parentheses_set = false;\n            }\n            if open_braces_set\
    \ && close_braces_set && parentheses_set && open_braces == close_braces {\n  \
    \              open_braces_set = false;\n                close_braces_set = false;\n\
    \                parentheses_set = false;\n                open_parentheses -=\
    \ 1;\n            }\n        }\n        if char == ')' {\n            if open_parentheses\
    \ > 0 {\n                open_parentheses -= 1;\n            }\n        }\n  \
    \      if char == '{' {\n            if open_braces > 0 {\n                open_braces\
    \ -= 1;\n            }\n        }\n        if char == '}' {\n            if close_braces\
    \ > 0 {\n                close_braces -= 1;\n            }\n        }\n    }\n\
    \    current_group\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkh_ijtic.rs:34:32\n   |\n\
    34 |             current_group.push(char);\n   |                             \
    \   ^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \                      |\n   |                                expected struct\
    \ `String`, found `char`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.clone();\n    let mut in_group = false;\n\
    \    let mut paren_count = 0;\n    let mut result = Vec::new();\n    for (i, c)\
    \ in paren_string.chars().enumerate() {\n        if c == ')' {\n            paren_count\
    \ -= 1;\n            if paren_count == 0 {\n                if in_group {\n  \
    \                  result.push(String::from(paren_string.clone()[..i]));\n   \
    \             }\n                in_group = false;\n            }\n        } else\
    \ if c == '(' && !in_group {\n            paren_count += 1;\n            in_group\
    \ = true;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmps_9rftyd.rs:17:46\n    |\n17  |                     result.push(String::from(paren_string.clone()[..i]));\n\
    \    |                                 ------------ ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n    |                           \
    \      |\n    |                                 required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `from`\n\nerror[E0277]: the trait bound `String:\
    \ From<str>` is not satisfied\n  --> /tmp/tmps_9rftyd.rs:17:33\n   |\n17 |   \
    \                  result.push(String::from(paren_string.clone()[..i]));\n   |\
    \                                 ^^^^^^^^^^^^ the trait `From<str>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .lines()\n        .filter(|line| line.contains(\"(\"\
    ))\n        .map(|line| line.split(\"(\").collect::<Vec<String>>())\n        .flatten()\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp34d1y1cn.rs:11:37\n     |\n11\
    \   |         .map(|line| line.split(\"(\").collect::<Vec<String>>())\n     |\
    \                                     ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = Vec::new();\n    let mut brace_depth: usize = 0;\n\n   \
    \ for (i, c) in paren_string.char_indices() {\n        if brace_depth > 0 {\n\
    \            groups.push(paren_string.chars(i .. i + 1));\n            brace_depth\
    \ -= 1;\n        }\n\n        if c == '{' {\n            brace_depth += 1;\n \
    \       }\n\n        if c == '}' {\n            brace_depth -= 1;\n        }\n\
    \    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmp6icdeq21.rs:13:38\n    |\n13  |             groups.push(paren_string.chars(i\
    \ .. i + 1));\n    |                                      ^^^^^ ---------- supplied\
    \ 1 argument\n    |                                      |\n    |            \
    \                          expected 0 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6icdeq21.rs:26:5\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                   ----------- expected `Vec<String>`\
    \ because of return type\n...\n26 |     groups\n   |     ^^^^^^ expected struct\
    \ `String`, found struct `Chars`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<Chars<'_>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Space characters can be used as a delimiter\n    let mut splits: Vec<String>\
    \ = paren_string.split_whitespace().collect();\n    let mut depth = 0;\n\n   \
    \ while let Some(mut split) = splits.pop() {\n        // Ignore the initial '('\n\
    \        if split.is_empty() {\n            depth += 1;\n            continue;\n\
    \        }\n\n        if depth == 0 {\n            // First open bracket\n   \
    \         splits.push(split);\n        } else {\n            // First close bracket\n\
    \            // Check for an open parenthesis that needs to be closed\n      \
    \      // Keep track of the last paren that was closed\n            let mut last_open\
    \ = String::new();\n            for split in splits.iter_mut() {\n           \
    \     if split == last_open {\n                    break;\n                }\n\
    \                last_open = split;\n            }\n            let mut next_open\
    \ = String::new();\n            for split in splits.iter_mut() {\n           \
    \     if split == last_open {\n                    break;\n                }\n\
    \                if split == next_open {\n                    next_open = String::new();\n\
    \                } else {\n                    next_open = split;\n          \
    \      }\n            }\n            if next_open.is_empty() {\n             \
    \   splits.push(split);\n            } else {\n                splits.push(next_open);\n\
    \            }\n        }\n        depth += 1;\n    }\n\n    splits\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp31lf1a6c.rs:9:67\n     |\n9  \
    \  |     let mut splits: Vec<String> = paren_string.split_whitespace().collect();\n\
    \     |                                                                   ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp31lf1a6c.rs:31:29\n\
    \   |\n26 |             let mut last_open = String::new();\n   |             \
    \                    ------------- expected due to this value\n...\n31 |     \
    \            last_open = split;\n   |                             ^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \     |\n   |                             expected struct `String`, found `&mut\
    \ String`\n\nerror[E0277]: can't compare `&mut String` with `String`\n  --> /tmp/tmp31lf1a6c.rs:28:26\n\
    \   |\n28 |                 if split == last_open {\n   |                    \
    \      ^^ no implementation for `&mut String == String`\n   |\n   = help: the\
    \ trait `PartialEq<String>` is not implemented for `&mut String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&mut String` with `String`\n  --> /tmp/tmp31lf1a6c.rs:35:26\n   |\n35 |   \
    \              if split == last_open {\n   |                          ^^ no implementation\
    \ for `&mut String == String`\n   |\n   = help: the trait `PartialEq<Strin"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack: Vec<String> = vec![];\n    let mut paren_group_string\
    \ = paren_string.to_string();\n    while !paren_group_string.is_empty() {\n  \
    \      if paren_group_string.starts_with('(') {\n            paren_stack.push(paren_group_string.trim_right().to_string());\n\
    \            paren_group_string = paren_group_string.trim_left();\n        } else\
    \ if paren_group_string.starts_with(')') {\n            let current_paren_group_string\
    \ = paren_stack.last_mut().unwrap();\n            let first_paren = current_paren_group_string.find('(').unwrap();\n\
    \            let last_paren = current_paren_group_string.rfind(')').unwrap();\n\
    \            let mut parens_inside_group = current_paren_group_string.slice(first_paren,\
    \ last_paren).to_string();\n            parens_inside_group += \")\";\n      \
    \      paren_group_string = paren_group_string.trim_right().to_string();\n   \
    \         paren_stack.pop();\n            if paren_stack.len() != 0 {\n      \
    \          let current_stack_string = paren_stack\n                    .iter()\n\
    \                    .map(|s| s.trim_right().to_string())\n                  \
    \  .collect::<Vec<_>>();\n                paren_group_string = parens_inside_group\
    \ + &current_stack_string;\n            } else {\n                paren_group_string\
    \ = parens_inside_group;\n            }\n        } else {\n            paren_group_string\
    \ = paren_group_string.trim_right().to_string();\n        }\n    }\n    paren_stack\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "warning: use of deprecated associated function `core::str::<impl str>::trim_right`:\
    \ superseded by `trim_end`\n  --> /tmp/tmpsbv79e4q.rs:12:49\n   |\n12 |      \
    \       paren_stack.push(paren_group_string.trim_right().to_string());\n   | \
    \                                                ^^^^^^^^^^ help: replace the\
    \ use of the deprecated associated function: `trim_end`\n   |\n   = note: `#[warn(deprecated)]`\
    \ on by default\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_left`: superseded by `trim_start`\n  --> /tmp/tmpsbv79e4q.rs:13:53\n\
    \   |\n13 |             paren_group_string = paren_group_string.trim_left();\n\
    \   |                                                     ^^^^^^^^^ help: replace\
    \ the use of the deprecated associated function: `trim_start`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsbv79e4q.rs:13:34\n   |\n9  |     let mut paren_group_string\
    \ = paren_string.to_string();\n   |                                  ------------------------\
    \ expected due to this value\n...\n13 |             paren_group_string = paren_group_string.trim_left();\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \      |\n   |                                  expected struct `String`, found\
    \ `&str`\n\nerror[E0599]: no method named `slice` found for mutable reference\
    \ `&mut String` in the current scope\n  --> /tmp/tmpsbv79e4q.rs:18:70\n   |\n\
    18 |             let mut parens_inside_group = current_paren_group_string.slice(first_paren,\
    \ last_paren).to_string();\n   |                                             \
    \                         ^^^^^ help: there is an associated function with a similar\
    \ name: `split_once`\n\nwarning: use of deprecated associated function `core::str::<impl\
    \ str>::trim_right`: superseded by `trim_end`\n  --> /tmp/tmpsbv79e4q.rs:20:53\n\
    \   |\n20 |             paren_group_string = paren_group_string.trim_right().to_string();\n\
    \   |                                                     ^^^^^^^^^^ help: replace\
    \ the use of the dep"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string;\n\n    let mut open_braces = Vec::new();\n\
    \    let mut closed_parens = Vec::new();\n    let mut open_braces_index = -1;\n\
    \    let mut closed_parens_index = -1;\n\n    while paren_string.chars().any(|c|\
    \ !c.is_whitespace()) {\n        if paren_string.chars().any(|c| c == '(') {\n\
    \            open_braces.push(paren_string.chars().next());\n            open_braces_index\
    \ += 1;\n            paren_string = paren_string.chars().take_while(|c| !c.is_whitespace());\n\
    \        }\n        if paren_string.chars().any(|c| c == ')') {\n            closed_parens.push(paren_string.chars().next());\n\
    \            closed_parens_index += 1;\n            paren_string = paren_string.chars().take_while(|c|\
    \ !c.is_whitespace());\n        }\n    }\n\n    if paren_string.chars().any(|c|\
    \ c != ')') {\n        return vec![paren_string];\n    }\n\n    let mut result\
    \ = Vec::new();\n    let mut open_brace = open_braces[open_braces_index];\n  \
    \  result.push(open_brace);\n    for _ in 0..(closed_parens_index - open_braces_index\
    \ - 1) {\n        result.push(*open_brace);\n        result.push(closed_parens[closed_parens_index]);\n\
    \        open_brace = open_braces[open_braces_index];\n        closed_parens_index\
    \ += 1;\n    }\n    for _ in 0..(closed_parens_index - 1) {\n        result.push(*open_brace);\n\
    \        result.push(closed_parens[closed_parens_index]);\n        open_brace\
    \ = open_braces[open_braces_index];\n        closed_parens_index += 1;\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphuzp6yak.rs:19:28\n   |\n\
    8  |     let mut paren_string = paren_string;\n   |                          \
    \  ------------ expected due to this value\n...\n19 |             paren_string\
    \ = paren_string.chars().take_while(|c| !c.is_whitespace());\n   |           \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `TakeWhile`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `TakeWhile<Chars<'_>, [closure@/tmp/tmphuzp6yak.rs:19:60:\
    \ 19:82]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphuzp6yak.rs:24:28\n\
    \   |\n8  |     let mut paren_string = paren_string;\n   |                   \
    \         ------------ expected due to this value\n...\n24 |             paren_string\
    \ = paren_string.chars().take_while(|c| !c.is_whitespace());\n   |           \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `TakeWhile`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `TakeWhile<Chars<'_>, [closure@/tmp/tmphuzp6yak.rs:24:60:\
    \ 24:82]>`\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n  -->\
    \ /tmp/tmphuzp6yak.rs:12:33\n   |\n12 |     let mut open_braces_index = -1;\n\
    \   |                                 ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmphuzp6yak.rs:13:35\n   |\n13 |     let mut closed_parens_index\
    \ = -1;\n   |                                   ^^ the trait `Neg` is not implemented\
    \ for `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0614]: "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // The vector that will contain the result\n    let mut vec = Vec::new();\n\
    \n    let mut open_braces: Vec<usize> = vec![0];\n\n    let mut current_tokens:\
    \ Vec<String> = vec![0];\n\n    // Iterate through the string and build up our\
    \ state\n    for char in paren_string.chars() {\n        if char == ' ' {\n  \
    \          // Ignore spaces\n        } else if char == '(' {\n            // Starting\
    \ a new group\n            open_braces.push(0)\n            current_tokens.push(String::from(\"\
    (\"));\n        } else if char == ')' {\n            // Ending a group\n     \
    \       if open_braces.len() == 1 {\n                // The last brace was closed,\
    \ so we're done\n                break;\n            } else if open_braces.len()\
    \ > 1 {\n                // The last brace was open, but there were still open\
    \ braces left so we're done\n                break;\n            } else if current_tokens.len()\
    \ == 1 {\n                // We don't have a group, so we just add the closing\
    \ brace to the output\n                vec.push(current_tokens.pop().unwrap());\n\
    \            } else {\n                // We do have a group, so we append the\
    \ remaining parens\n                let len = open_braces.last().unwrap() - open_braces.last().unwrap()\
    \ + 1;\n                vec.push(current_tokens.pop().unwrap().push_str(&paren_string[open_braces.last().unwrap()\
    \ + len..]));\n            }\n            open_braces.pop();\n            current_tokens.push(String::from(\"\
    )\"));\n        } else {\n            // Current character is not a space, opening\
    \ or closing paren, so\n            // just add the character to the current token\n\
    \            current_tokens.push(char);\n        }\n    }\n\n    vec\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `current_tokens`\n  --> /tmp/tmph20qcsoe.rs:21:32\n\
    \   |\n21 |             open_braces.push(0)\n   |                            \
    \    ^ help: add `;` here\n22 |             current_tokens.push(String::from(\"\
    (\"));\n   |             -------------- unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph20qcsoe.rs:13:48\n   |\n13 |     let mut current_tokens:\
    \ Vec<String> = vec![0];\n   |                                               \
    \ ^- help: try using a conversion method: `.to_string()`\n   |               \
    \                                 |\n   |                                    \
    \            expected struct `String`, found integer\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmph20qcsoe.rs:37:26\n   |\n37 |                 vec.push(current_tokens.pop().unwrap().push_str(&paren_string[open_braces.last().unwrap()\
    \ + len..]));\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmph20qcsoe.rs:37:56\n   |\n37 |         \
    \        vec.push(current_tokens.pop().unwrap().push_str(&paren_string[open_braces.last().unwrap()\
    \ + len..]));\n   |                          ----------------------------- ^^^^^^^^\
    \ this call modifies its receiver in-place\n   |                          |\n\
    \   |                          you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmph20qcsoe.rs:44:33\n   |\n44 |\
    \             current_tokens.push(char);\n   |                               \
    \  ^^^^- help: try using a conversion method: `.to_string()`\n   |           \
    \                      |\n   |                                 expected struct\
    \ `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut open_braces = Vec::new();\n\
    \    let mut close_braces = Vec::new();\n    let mut nested_parens = Vec::new();\n\
    \    for char in paren_string.chars() {\n        let mut char_groups = Vec::new();\n\
    \        let mut is_nested_paren = false;\n        for group in &mut paren_groups\
    \ {\n            let pos = group.len();\n            let char_match = group.last().unwrap().contains(&char);\n\
    \            if char_match {\n                char_groups.push(group);\n     \
    \           is_nested_paren = false;\n            } else if group.is_empty() {\n\
    \                char_groups.push((char.to_string()));\n                is_nested_paren\
    \ = true;\n            } else {\n                char_groups.push((group[group.len()\
    \ - 1].to_string()));\n            }\n        }\n\n        if is_nested_paren\
    \ {\n            nested_parens.push(char_groups);\n        } else {\n        \
    \    paren_groups.push(char_groups);\n        }\n    }\n\n    for paren_group\
    \ in &nested_parens {\n        paren_groups.push(paren_group);\n    }\n\n    for\
    \ open_brace in &mut open_braces {\n        for char in open_brace.iter() {\n\
    \            if char == '(' {\n                open_brace.push((char.to_string()));\n\
    \            } else if char == ')' {\n                open_brace.pop();\n    \
    \        }\n        }\n    }\n\n    for close_brace in &mut close_braces {\n \
    \       for char in close_brace.iter() {\n            if char == '(' {\n     \
    \           close_brace.push((char.to_string()));\n            } else if char\
    \ == ')' {\n                close_brace.pop();\n            }\n        }\n   \
    \ }\n\n    for paren_group in &mut paren_groups {\n        let mut open_brace_groups\
    \ = Vec::new();\n        let mut close_brace_groups = Vec::new();\n        for\
    \ paren_group_char in &paren_group {\n            let mut open_brace_group_char\
    \ = String::from(\"(\");\n            for char in paren_group_char {\n       \
    \         if open_brace_group_char == \"(\" {\n                    if char ==\
    \ '(' {\n                        open_brace_group_char += (char.to_string());\n\
    \                    } else {\n                        open_brace_group_char +=\
    \ (char.to_string());\n                        close_brace_groups.push(open_brace_group_char);\n\
    \                        open_brace_group_char = String::from(\"(\");\n      \
    \              }\n                } else {\n                    if char == ')'\
    \ {\n                        open_brace_group_char += (char.to_\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpl9twd2wc.rs:85:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n60 |     for paren_group in &mut paren_groups {\n   |      \
    \                                    - unclosed delimiter\n...\n63 |         for\
    \ paren_group_char in &paren_group {\n   |                                   \
    \           - unclosed delimiter\n64 |             let mut open_brace_group_char\
    \ = String::from(\"(\");\n65 |             for char in paren_group_char {\n  \
    \ |                                          - unclosed delimiter\n...\n74 | \
    \                } else {\n   |                        - unclosed delimiter\n\
    75 |                     if char == ')' {\n   |                              \
    \      - this delimiter might not be properly closed...\n76 |                \
    \         open_brace_group_char += (char.to_\n77 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n85 | }\n   |   ^\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpl9twd2wc.rs:76:50\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \                  - closing delimiter possibly meant for this\n...\n76 |    \
    \                     open_brace_group_char += (char.to_\n   |               \
    \                                   ^ unclosed delimiter\n77 | }\n   | ^ mismatched\
    \ closing delimiter\n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmpl9twd2wc.rs:22:34\n   |\n22 |                 char_groups.push((char.to_string()));\n\
    \   |                                  ^                ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n22 -                 char_groups.push((char.to_string()));\n\
    22 +                 char_groups.push(char.to_string());\n   | \n\nwarning: unnecessary\
    \ parentheses around method argument\n  --> /tmp/tmpl9twd2wc.rs:25:34\n   |\n\
    25 |                 char_groups.push((group[grou"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n    let mut current_open_brace:\
    \ usize = 0;\n    let mut depth = 0;\n\n    for paren in paren_string.chars()\
    \ {\n        if paren == char::ParenthesisOpenBrace() {\n            paren_groups.push(paren_string.clone());\n\
    \            current_open_brace = paren;\n            depth = 0;\n        } else\
    \ {\n            depth += 1;\n        }\n\n        if depth == 0 {\n         \
    \   continue;\n        }\n\n        if paren == char::ParenthesisCloseBrace()\
    \ {\n            depth -= 1;\n            current_open_brace += 1;\n        }\n\
    \n        if depth == 0 {\n            paren_groups.push(paren_string.clone());\n\
    \            current_open_brace = 0;\n            depth = 0;\n        }\n    }\n\
    \n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `ParenthesisOpenBrace` found for\
    \ type `char` in the current scope\n  --> /tmp/tmps5femdgl.rs:13:27\n   |\n13\
    \ |         if paren == char::ParenthesisOpenBrace() {\n   |                 \
    \          ^^^^^^^^^^^^^^^^^^^^ associated item not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmps5femdgl.rs:15:34\n   |\n9  |     let mut current_open_brace:\
    \ usize = 0;\n   |                                 ----- expected due to this\
    \ type\n...\n15 |             current_open_brace = paren;\n   |              \
    \                    ^^^^^ expected `usize`, found `char`\n\nerror[E0599]: no\
    \ associated item named `ParenthesisCloseBrace` found for type `char` in the current\
    \ scope\n  --> /tmp/tmps5femdgl.rs:25:27\n   |\n25 |         if paren == char::ParenthesisCloseBrace()\
    \ {\n   |                           ^^^^^^^^^^^^^^^^^^^^^ associated item not\
    \ found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n    let mut cur: Option<String>\
    \ = None;\n    for ch in paren_string.chars() {\n        if cur.is_some() {\n\
    \            if ch == '(' {\n                paren_groups.push(cur.unwrap());\n\
    \                cur = None;\n            } else {\n                cur = Some(ch);\n\
    \            }\n        } else if ch != ' ' {\n            cur = Some(ch);\n \
    \       }\n    }\n    if cur.is_some() {\n        paren_groups.push(cur.unwrap());\n\
    \    }\n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyezhddvv.rs:16:28\n   |\n\
    16 |                 cur = Some(ch);\n   |                            ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyezhddvv.rs:19:24\n   |\n19 |\
    \             cur = Some(ch);\n   |                        ^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_string();\n    let mut left_paren_count\
    \ = 0;\n    let mut right_paren_count = 0;\n    let mut last_left_paren = String::new();\n\
    \    let mut last_right_paren = String::new();\n    while !paren_string.is_empty()\
    \ {\n        let left_paren_count = paren_string.rfind(\"(\", &mut paren_string);\n\
    \        let right_paren_count = paren_string.rfind(\")\", &mut paren_string);\n\
    \        if left_paren_count < right_paren_count {\n            last_left_paren.clear();\n\
    \            last_right_paren.clear();\n        }\n        if left_paren_count\
    \ < 0 {\n            last_left_paren.clear();\n        }\n        if right_paren_count\
    \ < 0 {\n            last_right_paren.clear();\n        }\n        if left_paren_count\
    \ < right_paren_count {\n            last_left_paren = paren_string[left_paren_count\
    \ + 1 .. left_paren_count];\n            last_right_paren = paren_string[right_paren_count\
    \ + 1 .. right_paren_count];\n        }\n        paren_string = paren_string[left_paren_count\
    \ + 1 .. right_paren_count];\n    }\n    let mut left_paren_str = String::from(last_left_paren);\n\
    \    let mut right_paren_str = String::from(last_right_paren);\n    let mut mut\
    \ current_str = String::new();\n    let mut current_pos = 0;\n    let mut open_parens\
    \ = String::new();\n    while !left_paren_str.is_empty() || !right_paren_str.is_empty()\
    \ {\n        let left_paren_pos = left_paren_str.rfind(\"(\", &mut left_paren_str);\n\
    \        let right_paren_pos = right_paren_str.rfind(\")\", &mut right_paren_str);\n\
    \        if left_paren_pos < right_paren_pos {\n            if left_paren_pos\
    \ == -1 {\n                current_str = String::from(left_paren_str);\n     \
    \           open_parens = String::from(open_parens + left_paren_str);\n      \
    \      }\n            left_paren_str = left_paren_str[left_paren_pos + 1 .. left_paren_pos];\n\
    \        } else {\n            if right_paren_pos == -1 {\n                current_str\
    \ = String::from(right_paren_str);\n                open_parens = String::from(open_parens\
    \ + right_paren_str);\n            }\n            right_paren_str = right_paren_str[right_paren_pos\
    \ + 1 .. right_paren_pos];\n        }\n        if left_paren_str.len() != 0 ||\
    \ right_paren_str.len() != 0 {\n            let mut new_str = current_str + current_str[open_paren\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp4ja71u__.rs:63:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n37 |     while !left_paren_str.is_empty() || !right_paren_str.is_empty()\
    \ {\n   |                                                                    \
    \ - unclosed delimiter\n...\n53 |         if left_paren_str.len() != 0 || right_paren_str.len()\
    \ != 0 {\n   |                                                               \
    \     - this delimiter might not be properly closed...\n54 |             let mut\
    \ new_str = current_str + current_str[open_paren\n55 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n63 | }\n   |   ^\n\nerror: `mut`\
    \ on a binding may not be repeated\n  --> /tmp/tmp4ja71u__.rs:34:13\n   |\n34\
    \ |     let mut mut current_str = String::new();\n   |             ^^^ help: remove\
    \ the additional `mut`s\n\nerror: expected one of `.`, `;`, `?`, `else`, or an\
    \ operator, found `}`\n  --> /tmp/tmp4ja71u__.rs:55:1\n   |\n55 | }\n   | ^ expected\
    \ one of `.`, `;`, `?`, `else`, or an operator\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp4ja71u__.rs:54:56\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \                  - closing delimiter possibly meant for this\n...\n54 |    \
    \         let mut new_str = current_str + current_str[open_paren\n   |       \
    \                                                 ^ unclosed delimiter\n55 | }\n\
    \   | ^ mismatched closing delimiter\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n    --> /tmp/tmp4ja71u__.rs:14:45\n     |\n14\
    \   |         let left_paren_count = paren_string.rfind(\"(\", &mut paren_string);\n\
    \     |                                             ^^^^^ ---  -----------------\
    \ supplied 2 arguments\n     |                                             |\n\
    \     |                                             expected 1 argument\n    \
    \ |\nnote: associated "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut output: Vec<String> = Vec::new();\n    let mut inside_brace = false;\n\
    \    let mut paren_group: Vec<String> = Vec::new();\n\n    for c in paren_string.chars()\
    \ {\n        if c == '(' {\n            if inside_brace {\n                paren_group.push(String::from(\"\
    \"));\n                inside_brace = false;\n            }\n            paren_group.push(String::from(\"\
    \"));\n        } else if c == ')' {\n            if paren_group.is_empty() {\n\
    \                // This should be impossible because of the above if checks\n\
    \                panic!();\n            }\n            output.push(paren_group.last().unwrap());\n\
    \            paren_group.pop();\n            inside_brace = true;\n        } else\
    \ {\n            if inside_brace {\n                paren_group.push(String::from(\"\
    \"));\n                inside_brace = false;\n            }\n            paren_group.push(String::from(c));\n\
    \        }\n    }\n    if paren_group.is_empty() {\n        // This should be\
    \ impossible because of the above if checks\n        panic!();\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuoht7ifa.rs:24:25\n   |\n\
    24 |             output.push(paren_group.last().unwrap());\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `&String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|x| x.is_whitespace())\n\
    \        .filter(|x| !x.is_ascii_letter())\n        .filter_map(|x| {\n      \
    \      if x == '(' {\n                Some(x)\n            } else {\n        \
    \        None\n            }\n        })\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpv3xq7pms.rs:11:24\n   |\n11 |         .filter(|x|\
    \ !x.is_ascii_letter())\n   |                        ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0277]: a\
    \ value of type `Vec<String>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpv3xq7pms.rs:19:10\n     |\n19   |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut open_braces = Vec::new();\n    let mut open_brace_depth = 0;\n  \
    \  let mut depth = 0;\n    let mut depth_to_paren_depth = Vec::new();\n    let\
    \ mut depth_to_paren_lengths = Vec::new();\n\n    let mut s = String::from(paren_string);\n\
    \    while !s.is_empty() {\n        let c = s[0];\n        if c == '(' {\n   \
    \         open_braces.push(1);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  } else if c == '{' {\n            open_braces.push(2);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  } else if c == '[' {\n            open_braces.push(3);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  } else if c == '<' {\n            open_braces.push(4);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  } else if c == '>' {\n            open_braces.push(5);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  } else if c == '\"' {\n            open_braces.push(6);\n            depth_to_paren_depth.push(depth);\n\
    \            depth_to_paren_lengths.push(0);\n            depth += 1;\n      \
    \  }\n\n        s = &s[1..];\n    }\n\n    let mut s = String::from(paren_string);\n\
    \    let mut cur = 0;\n    let mut depth = 0;\n    while !s.is_empty() {\n   \
    \     if depth_to_paren_depth[depth] == depth_to_paren_lengths[depth] {\n    \
    \        depth += 1;\n        } else {\n            depth += 1;\n            open_brace_depth\
    \ -= depth_to_paren_depth[depth];\n            if open_brace_depth <= 0 {\n  \
    \              open_braces.pop();\n                open_brace_depth -= 1;\n  \
    \              cur = depth_to_paren_lengths[depth];\n            }\n        }\n\
    \        let c = s[0];\n        if c == '(' {\n            depth_to_paren_depth[depth]\
    \ += 1;\n        } else if c == '{' {\n            depth_to_paren_depth[depth]\
    \ += 1;\n        } else if c == '[' {\n            depth_to_paren_depth[depth]\
    \ += 1;\n        } else if c == '<' {\n            depth_to_paren_depth[depth\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpts8x1hu9.rs:84:3\n\
    \   |\n7  | fn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \   |                                                               - unclosed\
    \ delimiter\n...\n55 |     while !s.is_empty() {\n   |                       \
    \  - unclosed delimiter\n...\n74 |         } else if c == '<' {\n   |        \
    \                    - this delimiter might not be properly closed...\n75 |  \
    \           depth_to_paren_depth[depth\n76 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n84 | }\n   |   ^\n\nerror: mismatched closing\
    \ delimiter: `}`\n  --> /tmp/tmpts8x1hu9.rs:75:33\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \                  - closing delimiter possibly meant for this\n...\n75 |    \
    \         depth_to_paren_depth[depth\n   |                                 ^ unclosed\
    \ delimiter\n76 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpts8x1hu9.rs:16:17\n\
    \   |\n16 |         let c = s[0];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpts8x1hu9.rs:49:13\n\
    \   |\n14 |     let mut s = String::from(paren_string);\n   |                \
    \ -------------------------- expected due to this value\n...\n49 |         s =\
    \ &s[1..];\n   |             ^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n49 |         s = (&s[1..]).to_string();\n\
    \   |         "
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Create a vector to return\n    let mut groups = vec![];\n    let mut current\
    \ = String::from(\"\");\n    for c in paren_string.chars() {\n        // If this\
    \ character is a left paren\n        if c == '(' {\n            // If the current\
    \ group is not empty and is not the same as the last group\n            if !current.is_empty()\
    \ && (current != groups[groups.len() - 1] as String) {\n                // Then\
    \ add the current group to the vector and reset it\n                groups.push(current);\n\
    \                current = String::from(\"\");\n            }\n            //\
    \ Add the character to the current group\n            current += c.to_string();\n\
    \        } else {\n            // If the current group is not empty and is the\
    \ same as the last group\n            if !current.is_empty() && current == groups[groups.len()\
    \ - 1] as String {\n                // Then add the character to the current group\n\
    \                current += c.to_string();\n            } else {\n           \
    \     // If the current group is not empty and is not the same as the last group\n\
    \                if !current.is_empty() && current != groups[groups.len() - 1]\
    \ as String {\n                    // Then add the current group to the vector\
    \ and reset it\n                    groups.push(current);\n                  \
    \  current = String::from(\"\");\n                }\n                // Add this\
    \ character to the current group\n                current += c.to_string();\n\
    \            }\n        }\n    }\n\n    // If the current group is not empty\n\
    \    if !current.is_empty() {\n        // Then add the current group to the vector\n\
    \        groups.push(current);\n    }\n\n    // Return the vector\n    groups\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbdbvjyga.rs:21:24\n   |\n\
    21 |             current += c.to_string();\n   |                        ^^^^^^^^^^^^^\n\
    \   |                        |\n   |                        expected `&str`, found\
    \ struct `String`\n   |                        help: consider borrowing here:\
    \ `&c.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbdbvjyga.rs:26:28\n\
    \   |\n26 |                 current += c.to_string();\n   |                  \
    \          ^^^^^^^^^^^^^\n   |                            |\n   |            \
    \                expected `&str`, found struct `String`\n   |                \
    \            help: consider borrowing here: `&c.to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbdbvjyga.rs:35:28\n   |\n35 |              \
    \   current += c.to_string();\n   |                            ^^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&c.to_string()`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars()\n        .flat_map(|c| {\n            if c == '(' {\n\
    \                Some(c + '(')\n            } else if c == ')' {\n           \
    \     Some(c + ')')\n            } else if c == ')' {\n                Some(c\
    \ + '(')\n            } else if c == ' ' {\n                None\n           \
    \ } else {\n                None\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmp6f8xzrod.rs:11:24\n\
    \   |\n11 |                 Some(c + '(')\n   |                      - ^ --- char\n\
    \   |                      |\n   |                      char\n\nerror[E0369]:\
    \ cannot add `char` to `char`\n  --> /tmp/tmp6f8xzrod.rs:13:24\n   |\n13 |   \
    \              Some(c + ')')\n   |                      - ^ --- char\n   |   \
    \                   |\n   |                      char\n\nerror[E0369]: cannot\
    \ add `char` to `char`\n  --> /tmp/tmp6f8xzrod.rs:15:24\n   |\n15 |          \
    \       Some(c + '(')\n   |                      - ^ --- char\n   |          \
    \            |\n   |                      char\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split_whitespace().filter(|&c| c == '(' || c == ')')\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n --> /tmp/tmpmswlymyq.rs:8:51\n\
    \  |\n8 |     paren_string.split_whitespace().filter(|&c| c == '(' || c == ')')\n\
    \  |                                                   ^^ no implementation for\
    \ `&str == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \ --> /tmp/tmpmswlymyq.rs:8:63\n  |\n8 |     paren_string.split_whitespace().filter(|&c|\
    \ c == '(' || c == ')')\n  |                                                 \
    \              ^^ no implementation for `&str == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&str`\n  = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n            <&'a str as PartialEq<OsString>>\n\
    \            <&'a str as PartialEq<String>>\n            <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<&'a str>>\n            <String as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<str>>\n            <String as PartialEq>\n\
    \            <str as PartialEq<Cow<'a, str>>>\n          and 4 others\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpmswlymyq.rs:9:10\n     |\n9    |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous error"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = paren_string.chars().peekable().collect::<Stack<String>>();\n\
    \    let mut output = Vec::new();\n    loop {\n        let current_char = stack.pop().unwrap();\n\
    \        if current_char == ')' {\n            if stack.is_empty() {\n       \
    \         return output;\n            }\n            let last_char = stack.pop().unwrap();\n\
    \            if last_char == '(' {\n                stack.push(')');\n       \
    \         continue;\n            }\n        }\n        if current_char == ' '\
    \ || current_char == ')' || current_char == ']' || current_char == '[' {\n   \
    \         continue;\n        }\n        output.push(current_char);\n    }\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Stack` in this scope\n --> /tmp/tmp7qbmp091.rs:8:63\n\
    \  |\n8 |     let mut stack = paren_string.chars().peekable().collect::<Stack<String>>();\n\
    \  |                                                               ^^^^^ not found\
    \ in this scope\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp7qbmp091.rs:12:25\n\
    \   |\n12 |         if current_char == ')' {\n   |                         ^^\
    \ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmp7qbmp091.rs:22:25\n   |\n22 |         if current_char == ' ' ||\
    \ current_char == ')' || current_char == ']' || current_char == '[' {\n   |  \
    \                       ^^ no implementation for `String == char`\n   |\n   =\
    \ help: the trait `PartialEq<char>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp7qbmp091.rs:22:48\n   |\n22 |         if\
    \ current_char == ' ' || current_char == ')' || current_char == ']' || current_char\
    \ == '[' {\n   |                                                ^^ no implementation\
    \ for"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.lines().reduce(vec![]) {\n        Vec::from(&mut it).iter().enumerate().fold(vec![],\
    \ |mut acc, (i, it)| {\n            if i != 0 {\n                if acc[acc.len()\
    \ - 1].contains('(') {\n                    acc.push(it.to_string());\n      \
    \          } else {\n                    acc.push((it.to_string()).into());\n\
    \                }\n            } else {\n                if it.contains('(')\
    \ {\n                    acc.push(it.to_string());\n                } else {\n\
    \                    acc.push((it.to_string()).into());\n                }\n \
    \           }\n            acc\n        }).clone()\n    }\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n\
    \ --> /tmp/tmpsju0mkf3.rs:8:41\n  |\n8 |     paren_string.lines().reduce(vec![])\
    \ {\n  |                                         ^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Your code here\n    let mut group_count = 1;\n    let mut groups: Vec<String>\
    \ = vec![];\n    let mut parens_stack: Vec<bool> = vec![];\n    let mut parens_length\
    \ = 0;\n    let mut is_group_opened = false;\n\n    for c in paren_string.chars()\
    \ {\n        if c == ')' {\n            if parens_length != 0 {\n            \
    \    groups.push(String::from(\"()\"));\n                group_count += 1;\n \
    \           }\n            parens_stack.pop();\n            parens_length -= 1;\n\
    \        } else if c == '(' {\n            if parens_length == 0 {\n         \
    \       groups.push(String::from(\"()\"));\n                group_count += 1;\n\
    \            }\n            parens_stack.push(true);\n            parens_length\
    \ += 1;\n        } else if parens_length == 0 {\n            groups.push(String::from(c.to_string()));\n\
    \            group_count += 1;\n        }\n\n        if parens_stack.len() ==\
    \ 1 {\n            groups.push(String::from(c.to_string()));\n            group_count\
    \ += 1;\n        }\n    }\n\n    if parens_stack.is_empty() {\n        for _ in\
    \ 0..group_count {\n            groups.push(String::from(\"()\"));\n        }\n\
    \    }\n\n    groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"()\", \"(\", \"()\", \")\", \"()\", \")\", \"()\", \" \", \"()\", \"(\"\
    , \"()\", \"()\", \")\", \"()\", \" \", \"()\", \"(\", \"()\", \" \", \"()\",\
    \ \"(\", \"()\", \"()\", \")\", \"()\", \")\", \"()\", \")\", \"()\", \"()\",\
    \ \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"\
    , \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\", \"()\"]`,\n\
    \ right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmppdi3obxk.rs:52:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut paren_string = paren_string.chars();\n\
    \    paren_string.skip(paren_string.windows(2).count()).collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `windows` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmpxl126pjk.rs:10:36\n   |\n10 |     paren_string.skip(paren_string.windows(2).count()).collect::<Vec<_>>()\n\
    \   |                                    ^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxl126pjk.rs:10:5\n   |\n7  | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                          ----------- expected `Vec<String>`\
    \ because of return type\n...\n10 |     paren_string.skip(paren_string.windows(2).count()).collect::<Vec<_>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_group_stack = vec![];\n    let mut paren_groups = vec![];\n\
    \    let mut i = 0;\n    for ch in paren_string.chars() {\n        if ch == '\
    \ ' {\n            paren_group_stack.push(paren_groups);\n            paren_groups\
    \ = vec![];\n            i += 1;\n        }\n        else {\n            if paren_group_stack.len()\
    \ == 1 {\n                paren_groups.push(paren_groups.pop().to_owned());\n\
    \            }\n            paren_groups.push(ch);\n            i += 1;\n    \
    \    }\n    }\n    paren_groups.push(paren_groups.pop().to_owned());\n    paren_group_stack.pop();\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8bxd1yuh.rs:19:35\n   |\n\
    19 |                 paren_groups.push(paren_groups.pop().to_owned());\n   | \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cyclic type of\
    \ infinite size\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8bxd1yuh.rs:25:23\n\
    \   |\n25 |     paren_groups.push(paren_groups.pop().to_owned());\n   |      \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found enum `Option`\n\
    \   |\n   = note: expected type `char`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8bxd1yuh.rs:27:5\n   |\n7  | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                          ----------- expected `Vec<String>`\
    \ because of return type\n...\n27 |     paren_groups\n   |     ^^^^^^^^^^^^ expected\
    \ struct `String`, found `char`\n   |\n   = note: expected struct `Vec<String>`\n\
    \              found struct `Vec<char>`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_stack = Vec::new();\n    for ch in paren_string.chars() {\n\
    \        if let Char::Brace(c) = ch {\n            paren_stack.push(c);\n    \
    \    }\n        if let Char::Parenthesis(c) = ch {\n            let next_ch =\
    \ paren_stack.last().unwrap();\n            if next_ch.is_open_brace() && c ==\
    \ next_ch {\n                paren_stack.pop();\n            } else {\n      \
    \          panic!(\"The input string contains unbalanced parenthesis.\");\n  \
    \          }\n        }\n    }\n    let mut result = Vec::new();\n    for ch in\
    \ paren_stack {\n        result.push(String::from(&ch.to_string()));\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n  \
    \  assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmp0imlanef.rs:10:16\n\
    \   |\n10 |         if let Char::Brace(c) = ch {\n   |                ^^^^ use\
    \ of undeclared type `Char`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Char`\n  --> /tmp/tmp0imlanef.rs:13:16\n   |\n13 |         if let Char::Parenthesis(c)\
    \ = ch {\n   |                ^^^^ use of undeclared type `Char`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut paren_depth = 0;\n    for\
    \ (i, char) in paren_string.chars().enumerate() {\n        if char == char!('(')\
    \ {\n            if paren_depth == 0 {\n                paren_groups.push(paren_string.clone());\n\
    \            } else {\n                paren_depth += 1;\n            }\n    \
    \    } else if char == char!(')') {\n            if paren_depth == 0 {\n     \
    \           return vec![];\n            }\n            paren_depth -= 1;\n   \
    \     } else {\n            if paren_depth == 0 {\n                paren_groups.push(paren_string.clone());\n\
    \            }\n        }\n    }\n    paren_groups\n}\n\nfn main() {\n    let\
    \ candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `char` in this scope\n  --> /tmp/tmprb748hkx.rs:11:20\n\
    \   |\n11 |         if char == char!('(') {\n   |                    ^^^^\n  \
    \ |\n   = note: `char` is in scope, but it is a builtin type, not a macro\n\n\
    error: cannot find macro `char` in this scope\n  --> /tmp/tmprb748hkx.rs:17:27\n\
    \   |\n17 |         } else if char == char!(')') {\n   |                     \
    \      ^^^^\n   |\n   = note: `char` is in scope, but it is a builtin type, not\
    \ a macro\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(\"((?=(\\\\()|\\\\()(?!\\\\)))*\\\\))\")\n        .map(|s|\
    \ s.trim())\n        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp1_62_in5.rs:10:10\n     |\n10\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut vec = vec![];\n\n    // Track our current position in the string.\n\
    \    let mut pos = 0;\n\n    // We want to split at the start of the string, not\
    \ necessarily at the start of a new\n    // parenthesis. Keep track of what we're\
    \ currently at in the parenthesis group.\n    let mut paren_count = 0;\n\n   \
    \ // Keep track of how many open parens we've seen in the parenthesis group.\n\
    \    let mut paren_opens = 0;\n\n    // Keep track of how many open parens we've\
    \ seen in the whole string.\n    let mut total_paren_opens = 0;\n\n    // Iterate\
    \ over every character in the string.\n    for c in paren_string.chars() {\n \
    \       if c == '(' {\n            // This means we've opened a new parenthesis\
    \ group. Increment our total counter.\n            paren_opens += 1;\n       \
    \     paren_count += 1;\n        } else if c == ')' {\n            // We opened\
    \ a new parenthesis group when we hit a ')'. Decrement our total counter.\n  \
    \          paren_opens -= 1;\n            if paren_count == 0 {\n            \
    \    // We closed all the parenthesis groups we found in the string. Put out this\
    \ one.\n                vec.push(paren_string.chars().take(pos).collect::<String>());\n\
    \            }\n        } else if c == ' ' {\n            // We hit a space in\
    \ the string. Keep track of how many spaces we've seen so far.\n            paren_count\
    \ += 1;\n            total_paren_opens += 1;\n        } else if paren_opens >\
    \ 0 {\n            // We hit an open paren. Decrement our total counter.\n   \
    \         paren_opens -= 1;\n        }\n\n        pos += 1;\n    }\n\n    vec\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"]`', /tmp/tmpoeddi2p2.rs:53:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut group_tokens: Vec<String>\
    \ = Vec::new();\n    let mut open_braces: Vec<usize> = Vec::new();\n\n    let\
    \ mut stack = paren_string.chars().enumerate().filter_map(|(_, c)| {\n       \
    \ if c == '(' {\n            open_braces.push(c); Some(true)\n        } else if\
    \ c == ')' {\n            open_braces.pop();\n            Some(true)\n       \
    \ } else {\n            None\n        }\n    });\n\n    for index in 0..stack.len()\
    \ {\n        if stack.iter().all(|c| c == ' ') {\n            group_tokens.push(String::from(stack.iter().take(index).collect()));\n\
    \            index = index;\n        }\n    }\n    group_tokens.push(String::from(stack.iter().take(stack.len()).collect()));\n\
    \n    group_tokens\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm13slbg6.rs:14:30\n   |\n\
    14 |             open_braces.push(c); Some(true)\n   |                       \
    \       ^ expected `usize`, found `char`\n\nerror[E0599]: no method named `len`\
    \ found for struct `FilterMap` in the current scope\n  --> /tmp/tmpm13slbg6.rs:23:27\n\
    \   |\n23 |     for index in 0..stack.len() {\n   |                          \
    \ ^^^ method not found in `FilterMap<Enumerate<Chars<'_>>, [closure@/tmp/tmpm13slbg6.rs:12:65:\
    \ 21:6]>`\n\nerror[E0599]: no method named `iter` found for struct `FilterMap`\
    \ in the current scope\n  --> /tmp/tmpm13slbg6.rs:24:18\n   |\n24 |         if\
    \ stack.iter().all(|c| c == ' ') {\n   |                  ^^^^ private field,\
    \ not a method\n\nerror[E0599]: no method named `iter` found for struct `FilterMap`\
    \ in the current scope\n  --> /tmp/tmpm13slbg6.rs:25:50\n   |\n25 |          \
    \   group_tokens.push(String::from(stack.iter().take(index).collect()));\n   |\
    \                                                  ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `iter` found for struct `FilterMap` in the current\
    \ scope\n  --> /tmp/tmpm13slbg6.rs:29:42\n   |\n29 |     group_tokens.push(String::from(stack.iter().take(stack.len()).collect()));\n\
    \   |                                          ^^^^ private field, not a method\n\
    \nerror[E0599]: no method named `len` found for struct `FilterMap` in the current\
    \ scope\n  --> /tmp/tmpm13slbg6.rs:29:60\n   |\n29 |     group_tokens.push(String::from(stack.iter().take(stack.len()).collect()));\n\
    \   |                                                            ^^^ method not\
    \ found in `FilterMap<Enumerate<Chars<'_>>, [closure@/tmp/tmpm13slbg6.rs:12:65:\
    \ 21:6]>`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(\" \").map(|x| {\n        let mut paren_count = x.len();\n\
    \        loop {\n            let c = x.chars().next().unwrap();\n            if\
    \ c == '(' {\n                paren_count += 1;\n            } else if c == ')'\
    \ {\n                paren_count -= 1;\n                if paren_count == 0 {\n\
    \                    break;\n                }\n            } else {\n       \
    \         break;\n            }\n        }\n        x\n    })\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjm7u9ol3.rs:8:5\n   |\n7\
    \  |   fn separate_paren_groups(paren_string: String) -> Vec<String> {\n   | \
    \                                                    ----------- expected `Vec<String>`\
    \ because of return type\n8  | /     paren_string.split(\" \").map(|x| {\n9  |\
    \ |         let mut paren_count = x.len();\n10 | |         loop {\n11 | |    \
    \         let c = x.chars().next().unwrap();\n...  |\n23 | |         x\n24 | |\
    \     })\n   | |______^ expected struct `Vec`, found struct `Map`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Map<std::str::Split<'_,\
    \ &str>, [closure@/tmp/tmpjm7u9ol3.rs:8:33: 24:6]>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = vec![];\n    let mut stack = vec![];\n    let mut s = paren_string.chars().skip(1).take(paren_string.len()).collect::<String>();\n\
    \    let mut is_open = true;\n    while let Some(c) = s.next() {\n        match\
    \ c {\n            ' ' => break,\n            '(' if is_open => {\n          \
    \      let mut group = String::from(\"\");\n                while let Some(next)\
    \ = s.next() {\n                    match next {\n                        ')'\
    \ if is_open => {\n                            stack.pop_back();\n           \
    \                 is_open = false;\n                            break '(';\n \
    \                       } => {\n                            group += next;\n \
    \                       },\n                        _ => group += next,\n    \
    \                }\n                }\n                groups.push(group);\n \
    \               stack.push(c);\n            },\n            _ => groups.push(c),\n\
    \        }\n    }\n    if !stack.is_empty() {\n        stack.pop_back();\n   \
    \     is_open = false;\n    }\n    groups\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected pattern, found `=>`\n  --> /tmp/tmpstvie0xs.rs:23:27\n\
    \   |\n23 |                         } => {\n   |                           ^^\
    \ expected pattern\n\nerror[E0571]: `break` with value from a `while` loop\n \
    \ --> /tmp/tmpstvie0xs.rs:22:29\n   |\n17 |                 while let Some(next)\
    \ = s.next() {\n   |                 ------------------------------- you can't\
    \ `break` with a value in a `while` loop\n...\n22 |                          \
    \   break '(';\n   |                             ^^^^^^^^^ can only break with\
    \ a value inside `loop` or breakable block\n   |\nhelp: use `break` on its own\
    \ without a value inside this `while` loop\n   |\n22 |                       \
    \      break;\n   |                             ~~~~~\n\nerror[E0599]: no method\
    \ named `next` found for struct `String` in the current scope\n  --> /tmp/tmpstvie0xs.rs:12:27\n\
    \   |\n12 |     while let Some(c) = s.next() {\n   |                         \
    \  ^^^^ method not found in `String`\n\nerror[E0599]: no method named `next` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpstvie0xs.rs:17:42\n\
    \   |\n17 |                 while let Some(next) = s.next() {\n   |          \
    \                                ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<_>` in the current scope\n\
    \  --> /tmp/tmpstvie0xs.rs:20:35\n   |\n20 | ...                   stack.pop_back();\n\
    \   |                             ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpstvie0xs.rs:32:30\n   |\n32 |             _\
    \ => groups.push(c),\n   |                              ^- help: try using a conversion\
    \ method: `.to_string()`\n   |                              |\n   |          \
    \                    expected struct `String`, found `char`\n\nerror[E0599]: no\
    \ method named `pop_back` found for struct `Vec<char>` in the current scope\n\
    \  --> /tmp/tmpstvie0xs.rs:36:15\n   |\n36 |         stack.pop_back();\n   | \
    \              ^^^^^^^^ method not found in `Vec<char>`\n\nerror: aborting due\
    \ to 7 previous errors\n\nSome errors have detailed explanati"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut out: Vec<String> = vec![];\n    let mut open_braces = vec![];\n\n\
    \    for s in paren_string.chars() {\n        match s {\n            c if c ==\
    \ '(' {\n                open_braces.push(c);\n            }\n            c if\
    \ c == ')' => {\n                if open_braces.len() == 1 {\n               \
    \     break;\n                }\n\n                open_braces.pop();\n\n    \
    \            out.push(String::from(\"(\" + open_braces.join(\"\") + \")\"));\n\
    \            }\n            c if c != '(' && c != ')' && c != ' ' => {\n     \
    \           out.push(String::from(c));\n            }\n        }\n    }\n\n  \
    \  out\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `=>`, `?`, or an operator, found `{`\n  -->\
    \ /tmp/tmpuqkwge7z.rs:13:27\n   |\n13 |             c if c == '(' {\n   |    \
    \                       ^ expected one of `.`, `=>`, `?`, or an operator\n\nerror[E0282]:\
    \ type annotations needed for `Vec<T>`\n --> /tmp/tmpuqkwge7z.rs:9:27\n  |\n9\
    \ |     let mut open_braces = vec![];\n  |         ---------------   ^^^^^^ cannot\
    \ infer type for type parameter `T`\n  |         |\n  |         consider giving\
    \ `open_braces` the explicit type `Vec<T>`, where the type parameter `T` is specified\n\
    \  |\n  = note: this error originates in the macro `vec` (in Nightly builds, run\
    \ with -Z macro-backtrace for more info)\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().map(|c| match c {\n        c if c == '(' => Some(c),\n\
    \        c if c == ')' => Some(c),\n        c if c == '[' => Some(c),\n      \
    \  c if c == ']' => Some(c),\n        c if c == '{' => Some(c),\n        c if\
    \ c == '}' => Some(c),\n        _ => None,\n    }).filter(|x| x.is_some()).collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `Option<char>`\n    --> /tmp/tmpwzcxl1lb.rs:16:32\n  \
    \   |\n16   |     }).filter(|x| x.is_some()).collect()\n     |               \
    \                 ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=Option<char>>`\n\
    \     |\n     = help: the trait `FromIterator<Option<char>>` is not implemented\
    \ for `Vec<String>`\n     = help: the trait `FromIterator<T>` is implemented for\
    \ `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    paren_string.replace(chars::REPLACEMENTS,\
    \ \"\").split(chars::PARENTHESES_REGEX)\n        .filter_map(|x| x.is_empty()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \ --> /tmp/tmpx27ly430.rs:9:26\n  |\n9 |     paren_string.replace(chars::REPLACEMENTS,\
    \ \"\").split(chars::PARENTHESES_REGEX)\n  |                          ^^^^^ use\
    \ of undeclared crate or module `chars`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `chars`\n --> /tmp/tmpx27ly430.rs:9:57\n  |\n\
    9 |     paren_string.replace(chars::REPLACEMENTS, \"\").split(chars::PARENTHESES_REGEX)\n\
    \  |                                                         ^^^^^ use of undeclared\
    \ crate or module `chars`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx27ly430.rs:10:25\n\
    \   |\n10 |         .filter_map(|x| x.is_empty()).collect::<Vec<String>>()\n \
    \  |                         ^^^^^^^^^^^^ expected enum `Option`, found `bool`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `bool`\n\
    help: try wrapping the expression in `Some`\n   |\n10 |         .filter_map(|x|\
    \ Some(x.is_empty())).collect::<Vec<String>>()\n   |                         +++++\
    \            +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().filter_map(|c|\n        if c.is_whitespace() => None\n\
    \        else if c == '(' || c == '[' || c == '{' {\n            Some(c + 1)\n\
    \        } else {\n            None\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `=>`\n --> /tmp/tmpyhob5tfy.rs:9:30\n  |\n9\
    \ |         if c.is_whitespace() => None\n  |         --                   ^^\
    \ expected `{`\n  |         |\n  |         this `if` expression has a condition,\
    \ but no block\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = paren_string.trim().chars().enumerate().filter(|(_,\
    \ c)| c == '(' || c == ')');\n    paren_groups.sort_by_key(|(_, c)| c.to_string());\n\
    \    let mut paren_group_counter = 0;\n    paren_groups\n        .into_iter()\n\
    \        .filter_map(|(index, paren_group)| {\n            paren_group_counter\
    \ += 1;\n            let mut result = Vec::new();\n            for char in paren_group\
    \ {\n                if char == '(' {\n                    result.push((paren_group_counter,\
    \ char));\n                }\n                if char == ')' {\n             \
    \       if paren_group_counter == index {\n                        result.push((paren_group_counter,\
    \ char));\n                    }\n                }\n            }\n         \
    \   result.sort_by_key(|(_, c)| c.to_string());\n            result\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpzgxvuk2r.rs:8:86\n\
    \  |\n8 |     let mut paren_groups = paren_string.trim().chars().enumerate().filter(|(_,\
    \ c)| c == '(' || c == ')');\n  |                                            \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmpzgxvuk2r.rs:8:98\n  |\n8 |     let\
    \ mut paren_groups = paren_string.trim().chars().enumerate().filter(|(_, c)| c\
    \ == '(' || c == ')');\n  |                                                  \
    \                                                ^^ no implementation for `&char\
    \ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `Filter` in the current scope\n\
    \ --> /tmp/tmpzgxvuk2r.rs:9:18\n  |\n9 |     paren_groups.sort_by_key(|(_, c)|\
    \ c.to_string());\n  |                  ^^^^^^^^^^^ method not found in `Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpzgxvuk2r.rs:8:75: 8:104]>`\n\nerror[E0277]: `char` is not an\
    \ iterator\n  --> /tmp/tmpzgxvuk2r.rs:16:25\n   |\n16 |             for char in\
    \ paren_group {\n   |                         ^^^^^^^^^^^ `char` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `char`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `char`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_string = paren_string.trim();\n    let mut paren_strings = Vec::new();\n\
    \    let mut group_length: usize = 0;\n\n    paren_string.split_whitespace().filter_map(|x|\
    \ match x {\n        \" \" => Ok(None),\n        _ => Ok(Some(x)),\n    }).for_each(|x|\
    \ {\n        if x.is_some() {\n            let current_length = x.unwrap().len();\n\
    \n            if group_length != current_length {\n                paren_strings.push(String::from(&paren_string[..group_length]));\n\
    \                paren_strings.push(String::from(&paren_string[group_length..]));\n\
    \                group_length = current_length;\n            }\n\n           \
    \ paren_strings.push(x.unwrap());\n        }\n    });\n\n    if group_length >\
    \ 0 {\n        paren_strings.push(String::from(&paren_string[..group_length]));\n\
    \    }\n\n    paren_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpljf1yhh3.rs:13:16\n   |\n\
    13 |         \" \" => Ok(None),\n   |                ^^^^^^^^ expected enum `Option`,\
    \ found enum `Result`\n   |\n   = note: expected enum `Option<_>`\n          \
    \    found enum `Result<Option<_>, _>`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n13 |         \" \" => Some(Ok(None)),\n   |                +++++      \
    \  +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 101
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n    let mut current_paren =\
    \ String::new();\n    let mut depth = 0;\n\n    for c in paren_string.chars()\
    \ {\n        let c_str = &c.to_string();\n        if depth == 0 {\n          \
    \  if c_str == \")\" || c_str == \"]\" || c_str == \"}\" || c_str == \")(\" {\n\
    \                depth = -1;\n                paren_groups.push(current_paren);\n\
    \                current_paren = String::new();\n            } else {\n      \
    \          current_paren.push_str(c_str);\n            }\n        } else if c_str\
    \ == \")\" || c_str == \"]\" || c_str == \"}\" {\n            depth -= 1;\n  \
    \          if depth <= 0 {\n                paren_groups.push(current_paren);\n\
    \                current_paren = String::new();\n            }\n        } else\
    \ if c_str == \")(\" {\n            depth += 1;\n            current_paren.push_str(c_str);\n\
    \        } else {\n            current_paren.push_str(c_str);\n        }\n   \
    \ }\n\n    paren_groups.push(current_paren);\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"((\", \"(\", \"\", \" (((\", \"\", \"\", \" (\", \" (((\", \"\", \"(\",\
    \ \"(\", \"\", \"\"]`,\n right: `[\"(()())\", \"((()))\", \"()\", \"((())()())\"\
    ]`', /tmp/tmplqrunu8f.rs:42:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_depths = paren_string.char_indices().map(|v| {\n        v.map(|i|\
    \ match paren_string[i] {\n            '(' | '[' | '{' | ')' => {\n          \
    \      paren_depths += 1;\n                i\n            }\n            _ =>\
    \ -1,\n        })\n        .collect()\n    });\n    paren_depths.sort_unstable();\n\
    \    let mut paren_groups = Vec::new();\n    let mut paren_group_iter = paren_depths.into_iter().filter_map(|v|\
    \ {\n        if *v == -1 {\n            None\n        } else {\n            Some(paren_groups.last().unwrap().into_iter().take(*v\
    \ + 1).count())\n        }\n    }).collect();\n    while let Some(_) = paren_group_iter.next()\
    \ {\n        paren_groups.push(paren_groups.last().unwrap());\n    }\n    paren_groups.reverse();\n\
    \    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `paren_depths` in this scope\n  --> /tmp/tmpjb6eqqky.rs:11:17\n\
    \   |\n11 |                 paren_depths += 1;\n   |                 ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: `(usize, char)` is not an iterator\n\
    \ --> /tmp/tmpjb6eqqky.rs:9:11\n  |\n9 |         v.map(|i| match paren_string[i]\
    \ {\n  |           ^^^ `(usize, char)` is not an iterator\n  |\n  = note: the\
    \ following trait bounds were not satisfied:\n          `(usize, char): Iterator`\n\
    \          which is required by `&mut (usize, char): Iterator`\n\nerror[E0599]:\
    \ no method named `sort_unstable` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpjb6eqqky.rs:18:18\n   |\n18 |     paren_depths.sort_unstable();\n\
    \   |                  ^^^^^^^^^^^^^ method not found in `Map<CharIndices<'_>,\
    \ _>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let paren_groups = paren_string.chars().filter_map(|c| match c {\n      \
    \  '(' => Some(1),\n        '[' | '(' | '{' => Some(2),\n        '[' => Some(2),\n\
    \        '{' => Some(2),\n        _ => None,\n    }).collect();\n\n    if paren_groups.is_empty()\
    \ {\n        vec![\"(\" as String]\n    } else {\n        let mut result: Vec<String>\
    \ = Vec::new();\n        let mut depth = 1;\n        for group in paren_groups\
    \ {\n            if !group.is_some() {\n                continue;\n          \
    \  }\n\n            if group == 1 {\n                if depth > 1 {\n        \
    \            result.push(\" \");\n                }\n                continue;\n\
    \            }\n\n            if group == 2 {\n                depth += 1;\n \
    \               continue;\n            }\n\n            if depth == 1 {\n    \
    \            result.push(\" \");\n            }\n\n            if depth > 1 {\n\
    \                result.push(\"(\");\n            }\n\n            depth += 1;\n\
    \            for c in group {\n                result.push(c);\n            }\n\
    \            result.push(\")\");\n        }\n\n        result\n    }\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpx692vb92.rs:16:8\n\
    \   |\n8  |     let paren_groups = paren_string.chars().filter_map(|c| match c\
    \ {\n   |         ------------ consider giving `paren_groups` a type\n...\n16\
    \ |     if paren_groups.is_empty() {\n   |        ^^^^^^^^^^^^ cannot infer type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpx692vb92.rs:28:33\n   |\n28 |                     result.push(\"\
    \ \");\n   |                                 ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                 |\n   |       \
    \                          expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx692vb92.rs:39:29\n   |\n39 |              \
    \   result.push(\" \");\n   |                             ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                             |\n  \
    \ |                             expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx692vb92.rs:43:29\n   |\n43 |              \
    \   result.push(\"(\");\n   |                             ^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                             |\n  \
    \ |                             expected struct `String`, found `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx692vb92.rs:50:25\n   |\n50 |             result.push(\"\
    )\");\n   |                         ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                         |\n   |                       \
    \  expected struct `String`, found `&str`\n\nerror[E0605]: non-primitive cast:\
    \ `&'static str` as `String`\n  --> /tmp/tmpx692vb92.rs:17:14\n   |\n17 |    \
    \     vec![\"(\" as String]\n   |              ^^^^^^^^^^^^^ help: consider using\
    \ the `From` trait instead: `String::from(\"(\")`\n   |\n   = note: an `as` expression\
    \ can only be used to convert between primitive types or to coerce to a specific\
    \ trait object\n\nerror: aborting due to 6 previous errors\n\nSome errors have\
    \ detailed explanations: E0282, E0308, E0605.\nFor more information"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut tokens = paren_string.split(\"((?=([^()]*?)))\").map(|x| x.trim()).collect::<Vec<_>>();\n\
    \    let mut parens: Vec<String> = vec![];\n    while !tokens.is_empty() {\n \
    \       let mut curr_token_iter = tokens.iter();\n        let mut paren_tokens:\
    \ Vec<String> = vec![];\n        while let Some(curr_token) = get_token_next_paren(curr_token_iter)\
    \ {\n            if curr_token.len() == 0 {\n                break;\n        \
    \    }\n            paren_tokens.push(curr_token);\n        }\n        tokens.clear();\n\
    \        parens.push(String::from(paren_tokens.join(\"\")));\n    }\n    parens\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_token_next_paren` in this scope\n\
    \  --> /tmp/tmpu3if8f6s.rs:13:38\n   |\n13 |         while let Some(curr_token)\
    \ = get_token_next_paren(curr_token_iter) {\n   |                            \
    \          ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut strings = paren_string.split_whitespace().collect::<Vec<_>>();\n\n\
    \    while strings.len() > 0 {\n        let mut cur_string = strings.pop().to_string();\n\
    \        strings.iter().for_each(|&mut a| {\n            if a.is_empty() {\n \
    \               return;\n            }\n            cur_string += &a.to_string();\n\
    \        });\n        if cur_string != strings.pop().to_string() {\n         \
    \   strings.insert(0, cur_string);\n        }\n    }\n    strings\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `to_string` exists for enum `Option<&str>`, but\
    \ its trait bounds were not satisfied\n   --> /tmp/tmp8pwfs5fi.rs:11:44\n    |\n\
    11  |           let mut cur_string = strings.pop().to_string();\n    |       \
    \                                       ^^^^^^^^^ method cannot be called on `Option<&str>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Option<&str>: std::fmt::Display`\n       \
    \     which is required by `Option<&str>: ToString`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8pwfs5fi.rs:12:34\n   |\n12 |         strings.iter().for_each(|&mut\
    \ a| {\n   |                                  ^^^^^--\n   |                  \
    \                |    |\n   |                                  |    expected due\
    \ to this\n   |                                  types differ in mutability\n\
    \   |                                  help: did you mean `a`: `&&&str`\n   |\n\
    \   = note:      expected reference `&&str`\n           found mutable reference\
    \ `&mut _`\n\nerror[E0599]: the method `to_string` exists for enum `Option<&str>`,\
    \ but its trait bounds were not satisfied\n   --> /tmp/tmp8pwfs5fi.rs:18:40\n\
    \    |\n18  |           if cur_string != strings.pop().to_string() {\n    |  \
    \                                        ^^^^^^^^^ method cannot be called on\
    \ `Option<&str>` due to unsatisfied trait bounds\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<&str>: std::fmt::Display`\n\
    \            which is required by `Option<&str>: ToString`\n\nerror[E0277]: cannot\
    \ add-assign `_` to `&str`\n  --> /tmp/tmp8pwfs5fi.rs:16:24\n   |\n16 |      \
    \       cur_string += &a.to_string();\n   |                        ^^ no implementation\
    \ for `&str += _`\n   |\n   = help: the trait `AddAssign<_>` is not implemented\
    \ for `&str`\n   = help: the trait `AddAssign<&str>` is implemented for `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8pwfs5fi.rs:22:5\n   |\n7  | fn\
    \ separate_paren_groups(paren_string: String) -> Vec<String> {\n   |         \
    \                                      "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack = Vec::new();\n\n    paren_string.chars().for_each(|c|\n  \
    \      match c {\n            '(' | ')' | ',' | '{' | '[' | ']' | ' ' => (),\n\
    \            _ => stack.unpush(c),\n        }\n    );\n\n    while !stack.is_empty()\
    \ {\n        match stack.pop() {\n            '(' | ')' | ',' | '{' | '[' | ']'\
    \ | ' ' => (),\n            _ => continue,\n        }\n\n        let s = String::from(\"\
    \");\n        while !stack.is_empty() {\n            match stack.pop() {\n   \
    \             '(' | ')' | ',' | '{' | '[' | ']' | ' ' => (),\n               \
    \ _ => (),\n            }\n\n            let c = stack.pop();\n            s.push_str(&c.to_string());\n\
    \        }\n        stack.push(s);\n    }\n\n    stack\n}\n\nfn main() {\n   \
    \ let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unpush` found for struct `Vec<_>` in the\
    \ current scope\n  --> /tmp/tmp9hty4ie5.rs:13:24\n   |\n13 |             _ =>\
    \ stack.unpush(c),\n   |                        ^^^^^^ help: there is an associated\
    \ function with a similar name: `push`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9hty4ie5.rs:19:13\n   |\n18 |         match stack.pop() {\n   |    \
    \           ----------- this expression has type `Option<_>`\n19 |           \
    \  '(' | ')' | ',' | '{' | '[' | ']' | ' ' => (),\n   |             ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n\
    19 |             Some('(') | ')' | ',' | '{' | '[' | ']' | ' ' => (),\n   |  \
    \           +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9hty4ie5.rs:19:19\n\
    \   |\n18 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<_>`\n19 |             '(' | ')' | ',' | '{' | '[' | ']' | '\
    \ ' => (),\n   |                   ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `char`\n\
    help: try wrapping the pattern in `Some`\n   |\n19 |             '(' | Some(')')\
    \ | ',' | '{' | '[' | ']' | ' ' => (),\n   |                   +++++   +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9hty4ie5.rs:19:25\n   |\n18 |         match\
    \ stack.pop() {\n   |               ----------- this expression has type `Option<_>`\n\
    19 |             '(' | ')' | ',' | '{' | '[' | ']' | ' ' => (),\n   |        \
    \                 ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `char`\nhelp: try wrapping the pattern\
    \ in `Some`\n   |\n19 |             '(' | ')' | Some(',') | '{' | '[' | ']' |\
    \ ' ' => (),\n   |                         +++++   +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9hty4ie5.rs:19:31\n   |\n18 |         match stack.pop()\
    \ {\n   |               ----------- this expression has type `Option<_>`\n19 |\
    \             '(' | ')' | ',' | '{' | '[' | ']' |"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = vec![];\n    let mut nested_paren_groups = vec![];\n\
    \n    for paren_char in paren_string.chars() {\n        let is_open_paren = paren_char\
    \ == '(';\n        let is_close_paren = paren_char == ')';\n        if is_open_paren\
    \ && !is_close_paren {\n            nested_paren_groups.push(paren_char);\n  \
    \      } else if is_close_paren {\n            nested_paren_groups.pop();\n  \
    \          paren_groups.push(paren_groups.pop().unwrap());\n        }\n    }\n\
    \n    paren_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0499]: cannot borrow `paren_groups` as mutable more than once at\
    \ a time\n  --> /tmp/tmplgxot8d8.rs:18:31\n   |\n18 |             paren_groups.push(paren_groups.pop().unwrap());\n\
    \   |             ------------------^^^^^^^^^^^^^^^^^^----------\n   |       \
    \      |            |    |\n   |             |            |    second mutable\
    \ borrow occurs here\n   |             |            first borrow later used by\
    \ call\n   |             first mutable borrow occurs here\n   |\nhelp: try adding\
    \ a local storing this argument...\n  --> /tmp/tmplgxot8d8.rs:18:31\n   |\n18\
    \ |             paren_groups.push(paren_groups.pop().unwrap());\n   |        \
    \                       ^^^^^^^^^^^^^^^^^^\nhelp: ...and then using that local\
    \ as the argument to this call\n  --> /tmp/tmplgxot8d8.rs:18:13\n   |\n18 |  \
    \           paren_groups.push(paren_groups.pop().unwrap());\n   |            \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0499`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().filter_map(|c| {\n        if c.is_whitespace() {\n \
    \           None\n        } else {\n            Some(c.to_ascii_lowercase())\n\
    \        }\n    }).collect::<Vec<String>>().into_iter().collect()\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp2_n4veb4.rs:14:8\n     |\n14 \
    \  |     }).collect::<Vec<String>>().into_iter().collect()\n     |        ^^^^^^^\
    \ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976155
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = paren_string\n        .chars()\n        .filter(|c|\
    \ c == '(' || c == '{' || c == '[')\n        .collect::<Vec<_>>();\n\n    while\
    \ !paren_groups.is_empty() {\n        let mut open_paren = paren_groups.remove(0).unwrap();\n\
    \        let mut last_open_paren = 0;\n        while !paren_groups.is_empty()\
    \ {\n            let mut close_paren = paren_groups.remove(0).unwrap();\n    \
    \        if open_paren == close_paren {\n                last_open_paren = close_paren;\n\
    \            } else {\n                paren_groups.push(close_paren);\n     \
    \           break;\n            }\n        }\n        if open_paren != last_open_paren\
    \ {\n            paren_groups.push(open_paren);\n        }\n    }\n    paren_groups\n\
    \        .into_iter()\n        .map(|x| x.to_string())\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa5n4eaji.rs:10:23\n\
    \   |\n10 |         .filter(|c| c == '(' || c == '{' || c == '[')\n   |      \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpa5n4eaji.rs:10:35\n   |\n10 |         .filter(|c|\
    \ c == '(' || c == '{' || c == '[')\n   |                                   ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpa5n4eaji.rs:10:47\n\
    \   |\n10 |         .filter(|c| c == '(' || c == '{' || c == '[')\n   |      \
    \                                         ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: no\
    \ method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpa5n4eaji.rs:14:53\n\
    \   |\n14 |         let mut open_paren = paren_groups.remove(0).unwrap();\n  \
    \ |                                                     ^^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `unwrap` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpa5n4eaji.rs:17:58\n   |\n17 |             let\
    \ mut close_paren = paren_groups.remove(0).unwrap();\n   |                   \
    \                                       ^^^^^^ method not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpa5n4eaji.rs:21:35\n   |\n21 |  \
    \               paren_groups.push(close_paren);\n   |                        \
    \           ^^^^^^^^^^^ expected `char`, found integer\n\nerror[E0277]: can't\
    \ compare `char` with `{integer}`\n  --> /tmp/tmpa5n4eaji.rs:18:27\n   |\n18 |\
    \             if open_paren == close_paren {\n   |                           ^^\
    \ no implementation for `char =="
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut input_vec = vec![];\n    let mut closed_paren_level = 0;\n    let\
    \ mut open_brace_level = 0;\n    let mut last_input = \"\";\n    let mut last_output\
    \ = \"\";\n    for (index, char) in paren_string.chars().enumerate() {\n     \
    \   if char == '(' {\n            open_brace_level += 1;\n        } else {\n \
    \           open_brace_level -= 1;\n        }\n        last_input += char;\n \
    \       if open_brace_level == 0 && closed_paren_level == 0 {\n            let\
    \ output_str = last_output + last_input;\n            last_output = \"\";\n  \
    \          last_input = \"\";\n            input_vec.push(output_str);\n     \
    \   }\n        if open_brace_level > 0 && char == '(' {\n            open_brace_level\
    \ += 1;\n        } else {\n            open_brace_level -= 1;\n        }\n   \
    \     if open_brace_level == 0 && closed_paren_level == 0 {\n            last_output\
    \ += char;\n        }\n    }\n    input_vec\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpfyz_vtfa.rs:19:9\n   |\n19 |         last_input += char;\n\
    \   |         ----------^^^^^^^^\n   |         |\n   |         cannot use `+=`\
    \ on type `&str`\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpfyz_vtfa.rs:21:42\n\
    \   |\n21 |             let output_str = last_output + last_input;\n   |     \
    \                         ----------- ^ ---------- &str\n   |                \
    \              |           |\n   |                              |           `+`\
    \ cannot be used to concatenate two `&str` strings\n   |                     \
    \         &str\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: create an owned `String` from a string reference\n   |\n\
    21 |             let output_str = last_output.to_owned() + last_input;\n   | \
    \                                        +++++++++++\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpfyz_vtfa.rs:32:13\n\
    \   |\n32 |             last_output += char;\n   |             -----------^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0368, E0369.\nFor more information about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n\n    let mut paren_string =\
    \ paren_string.chars();\n    let mut char_array: Vec<String> = Vec::new();\n\n\
    \    while let Some(next_char) = (paren_string.next()).clone() {\n        if next_char\
    \ == '(' {\n            // Add opening parenthesis to the character array\n  \
    \          char_array.push(next_char);\n        }\n        if next_char == ')'\
    \ {\n            // Add closing parenthesis to the character array\n         \
    \   char_array.push(next_char);\n            // If the stack is empty, there are\
    \ no nested parenthesis\n            if char_array.len() == 1 {\n            \
    \    return char_array.clone();\n            }\n        }\n        if next_char\
    \ == ',' {\n            // If the stack is empty, we are done\n            if\
    \ char_array.len() == 0 {\n                return char_array.clone();\n      \
    \      }\n\n            // Add comma to character array\n            char_array.push(next_char);\n\
    \        }\n    }\n\n    char_array\n        .iter()\n        .cloned()\n    \
    \    .collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppairhdle.rs:16:29\n   |\n\
    16 |             char_array.push(next_char);\n   |                           \
    \  ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |      \
    \                       |\n   |                             expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppairhdle.rs:20:29\n\
    \   |\n20 |             char_array.push(next_char);\n   |                    \
    \         ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                             |\n   |                             expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppairhdle.rs:33:29\n\
    \   |\n33 |             char_array.push(next_char);\n   |                    \
    \         ^^^^^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                             |\n   |                             expected struct\
    \ `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_count = paren_string.chars().filter(|c| *c != ' ').count();\n\
    \    let mut split_parens = Vec::new();\n    while *paren_count != 0 {\n     \
    \   if paren_string.chars().filter(|c| *c == ' ').count() == 0 {\n           \
    \ break;\n        }\n        if paren_string.chars().filter(|c| *c != ')').count()\
    \ == 1 {\n            paren_count -= 1;\n        } else {\n            paren_count\
    \ += 1;\n        }\n        split_parens.push(paren_string);\n    }\n    split_parens\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpbhz32d5y.rs:10:11\n\
    \   |\n10 |     while *paren_count != 0 {\n   |           ^^^^^^^^^^^^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string\n        .chars()\n        .filter(|c| !c.is_whitespace())\n\
    \        .filter(|c| !c.is_ascii_letter(c) && !c.is_ascii_digit(c))\n        .filter(|c|\
    \ !c.is_punctuation(c))\n        .filter(|c| !c.is_ascii_lowercase(c))\n     \
    \   .filter(|c| !c.is_ascii_uppercase(c))\n        .filter(|c| c != '(' && c !=\
    \ ')')\n        .filter(|c| c != '[')\n        .filter(|c| c != ']')\n       \
    \ .filter(|c| c != '{')\n        .filter(|c| c != '}')\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpngblwdr3.rs:11:24\n   |\n11 |         .filter(|c|\
    \ !c.is_ascii_letter(c) && !c.is_ascii_digit(c))\n   |                       \
    \ ^^^^^^^^^^^^^^^ help: there is an associated function with a similar name: `is_ascii`\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpngblwdr3.rs:11:49\n     |\n11   |         .filter(|c| !c.is_ascii_letter(c)\
    \ && !c.is_ascii_digit(c))\n     |                                           \
    \      ^^^^^^^^^^^^^^ - supplied 1 argument\n     |                          \
    \                       |\n     |                                            \
    \     expected 0 arguments\n     |\nnote: associated function defined here\n\n\
    error[E0599]: no method named `is_punctuation` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpngblwdr3.rs:12:24\n   |\n12 |         .filter(|c|\
    \ !c.is_punctuation(c))\n   |                        ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii_punctuation`\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpngblwdr3.rs:13:24\n\
    \     |\n13   |         .filter(|c| !c.is_ascii_lowercase(c))\n     |        \
    \                ^^^^^^^^^^^^^^^^^^ - supplied 1 argument\n     |            \
    \            |\n     |                        expected 0 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 0 arguments\
    \ but 1 argument was supplied\n    --> /tmp/tmpngblwdr3.rs:14:24\n     |\n14 \
    \  |         .filter(|c| !c.is_ascii_uppercase(c))\n     |                   \
    \     ^^^^^^^^^^^^^^^^^^ - supplied 1 argument\n     |                       \
    \ |\n     |                        expected 0 arguments\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmpngblwdr3.rs:15:23\n   |\n15 |         .filter(|c| c != '(' && c\
    \ != ')')\n   |                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the tr"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_depth = 0;\n    let mut current_string = \"\";\n    let mut\
    \ groups: Vec<String> = Vec::new();\n    for c in paren_string.chars() {\n   \
    \     if c == '(' {\n            paren_depth += 1;\n            current_string\
    \ += c;\n        } else if c == ')' {\n            paren_depth -= 1;\n       \
    \     if paren_depth == 0 {\n                groups.push(current_string);\n  \
    \              current_string = \"\";\n            }\n        } else if paren_depth\
    \ > 0 {\n            current_string += c;\n        }\n    }\n    \n    if current_string.is_empty()\
    \ {\n        groups.push(current_string);\n    }\n    \n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmp_j45l6do.rs:14:13\n   |\n14 |             current_string\
    \ += c;\n   |             --------------^^^^^\n   |             |\n   |      \
    \       cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_j45l6do.rs:18:29\n   |\n18 |                 groups.push(current_string);\n\
    \   |                             ^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                             |\n   |           \
    \                  expected struct `String`, found `&str`\n\nerror[E0368]: binary\
    \ assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp_j45l6do.rs:22:13\n\
    \   |\n22 |             current_string += c;\n   |             --------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_j45l6do.rs:27:21\n   |\n27 |         groups.push(current_string);\n\
    \   |                     ^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                     |\n   |                     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string.chars().group_by::<Char>().collect::<Vec<_>>();\n\
    \n    let mut last_open_brace_index = 0;\n    let mut last_closed_brace_index\
    \ = groups.len();\n    while last_open_brace_index < groups.len() {\n        if\
    \ groups[last_open_brace_index].is_open_paren {\n            last_open_brace_index\
    \ += 1;\n        } else {\n            last_open_brace_index += 1;\n         \
    \   last_closed_brace_index -= 1;\n        }\n    }\n\n    if groups.len() ==\
    \ 0 {\n        return Vec::new();\n    }\n\n    match &groups[groups.len() - 1]\
    \ {\n        Some(mut group) => {\n            if group.c == '}' {\n         \
    \       last_closed_brace_index -= 1;\n            }\n        }\n        _ =>\
    \ {}\n    }\n\n    let mut result = vec![String::from(\"()\")];\n    for (index,\
    \ _) in groups.into_iter().enumerate() {\n        if index == last_open_brace_index\
    \ {\n            result.push(group.0);\n        } else if index == last_closed_brace_index\
    \ {\n            result.push(group.0);\n        } else {\n            result.push(\"\
    (())\");\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n --> /tmp/tmpkzg2gloq.rs:8:54\n\
    \  |\n8 |     let mut groups = paren_string.chars().group_by::<Char>().collect::<Vec<_>>();\n\
    \  |                                                      ^^^^\n  |\nhelp: a builtin\
    \ type with a similar name exists\n  |\n8 |     let mut groups = paren_string.chars().group_by::<char>().collect::<Vec<_>>();\n\
    \  |                                                      ~~~~\nhelp: you might\
    \ be missing a type parameter\n  |\n7 | fn separate_paren_groups<Char>(paren_string:\
    \ String) -> Vec<String> {\n  |                         ++++++\n\nerror[E0425]:\
    \ cannot find value `group` in this scope\n  --> /tmp/tmpkzg2gloq.rs:37:25\n \
    \  |\n37 |             result.push(group.0);\n   |                         ^^^^^\
    \ help: a local variable with a similar name exists: `groups`\n\nerror[E0425]:\
    \ cannot find value `group` in this scope\n  --> /tmp/tmpkzg2gloq.rs:39:25\n \
    \  |\n39 |             result.push(group.0);\n   |                         ^^^^^\
    \ help: a local variable with a similar name exists: `groups`\n\nerror[E0599]:\
    \ no method named `group_by` found for struct `Chars` in the current scope\n -->\
    \ /tmp/tmpkzg2gloq.rs:8:43\n  |\n8 |     let mut groups = paren_string.chars().group_by::<Char>().collect::<Vec<_>>();\n\
    \  |                                           ^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkzg2gloq.rs:41:25\n   |\n41 |\
    \             result.push(\"(())\");\n   |                         ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \ |\n   |                         expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0412, E0425, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.to_string();\n    paren_string.clear();\n\
    \n    let mut paren_groups: Vec<String> = Vec::new();\n\n    let mut position\
    \ = 0;\n    while position < paren_string.len() {\n        let open_paren_index\
    \ = paren_string\n            .char_indices()\n            .filter_map(|i| i.unwrap().0.is_ascii_lowercase())\n\
    \            .find(|i| i.unwrap() == position)\n            .unwrap();\n     \
    \   let close_paren_index = paren_string\n            .char_indices()\n      \
    \      .filter_map(|i| i.unwrap().0.is_ascii_lowercase())\n            .find(|i|\
    \ i.unwrap() == position + 2)\n            .unwrap();\n\n        let open_paren_text\
    \ = paren_string.split_at_mut(open_paren_index).next().unwrap();\n        let\
    \ close_paren_text = paren_string.split_at_mut(close_paren_index).next().unwrap();\n\
    \n        if open_paren_index.is_none() {\n            paren_groups.push(close_paren_text);\n\
    \            paren_groups.push(String::from(\"(...)\"));\n        } else if close_paren_index.is_none()\
    \ {\n            paren_groups.push(open_paren_text);\n            paren_groups.push(String::from(\"\
    (...)\"));\n        } else {\n            paren_groups.push(open_paren_text);\n\
    \            paren_groups.push(close_paren_text);\n        }\n\n        position\
    \ = close_paren_index.unwrap() + 3;\n    }\n\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for tuple `(usize, char)`\
    \ in the current scope\n  --> /tmp/tmpuk773h3z.rs:17:31\n   |\n17 |          \
    \   .filter_map(|i| i.unwrap().0.is_ascii_lowercase())\n   |                 \
    \              ^^^^^^ method not found in `(usize, char)`\n\nerror[E0599]: no\
    \ method named `unwrap` found for tuple `(usize, char)` in the current scope\n\
    \  --> /tmp/tmpuk773h3z.rs:22:31\n   |\n22 |             .filter_map(|i| i.unwrap().0.is_ascii_lowercase())\n\
    \   |                               ^^^^^^ method not found in `(usize, char)`\n\
    \nerror[E0599]: no method named `next` found for tuple `(&mut str, &mut str)`\
    \ in the current scope\n  --> /tmp/tmpuk773h3z.rs:26:75\n   |\n26 |         let\
    \ open_paren_text = paren_string.split_at_mut(open_paren_index).next().unwrap();\n\
    \   |                                                                        \
    \   ^^^^ method not found in `(&mut str, &mut str)`\n\nerror[E0599]: no method\
    \ named `next` found for tuple `(&mut str, &mut str)` in the current scope\n \
    \ --> /tmp/tmpuk773h3z.rs:27:77\n   |\n27 |         let close_paren_text = paren_string.split_at_mut(close_paren_index).next().unwrap();\n\
    \   |                                                                        \
    \     ^^^^ method not found in `(&mut str, &mut str)`\n\nerror[E0599]: no method\
    \ named `is_none` found for type `usize` in the current scope\n  --> /tmp/tmpuk773h3z.rs:29:29\n\
    \   |\n29 |         if open_paren_index.is_none() {\n   |                    \
    \         ^^^^^^^ method not found in `usize`\n\nerror[E0599]: no method named\
    \ `is_none` found for type `usize` in the current scope\n  --> /tmp/tmpuk773h3z.rs:32:37\n\
    \   |\n32 |         } else if close_paren_index.is_none() {\n   |            \
    \                         ^^^^^^^ method not found in `usize`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `usize` in the current scope\n  -->\
    \ /tmp/tmpuk773h3z.rs:40:38\n   |\n40 |         position = close_paren_index.unwrap()\
    \ + 3;\n   |                                      ^^^^^^ method not found in `usize`\n\
    \nerror: aborting due to 7 previous "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut groups = paren_string.split_by_whitespace();\n    let mut current_group\
    \ = \"\";\n    let mut current_paren_depth = -1;\n    let mut result_groups =\
    \ Vec::new();\n    for group in groups {\n        let mut current_group_string\
    \ = current_group;\n        let mut last_group_end = false;\n        let mut paren_depth\
    \ = 0;\n        for c in group {\n            if c == '(' {\n                last_group_end\
    \ = false;\n                paren_depth += 1;\n            } else if c == '{'\
    \ {\n                last_group_end = true;\n                paren_depth += 1;\n\
    \            } else if c == ')' {\n                paren_depth -= 1;\n       \
    \         if paren_depth == 0 {\n                    current_group_string += \"\
    )\";\n                }\n            } else if c == '}' {\n                if\
    \ paren_depth == 0 {\n                    current_group_string += \")\";\n   \
    \             } else {\n                    last_group_end = true;\n         \
    \       }\n            } else if c == '(' {\n                last_group_end =\
    \ false;\n                paren_depth += 1;\n            } else if c == '}' {\n\
    \                if last_group_end {\n                    current_group_string\
    \ += \")\";\n                } else {\n                    current_group_string\
    \ += c\")\";\n                }\n            } else if c == '[' {\n          \
    \      if paren_depth == 0 {\n                    current_group_string += \"[]\"\
    ;\n                } else {\n                    last_group_end = true;\n    \
    \            }\n            } else if c == ']' {\n                if last_group_end\
    \ {\n                    current_group_string += \"]\";\n                } else\
    \ {\n                    current_group_string += \"[]\";\n                }\n\
    \            } else if c == '{' {\n                if last_group_end {\n     \
    \               current_group_string += \")\";\n                } else {\n   \
    \                 current_group_string += \"{\";\n                }\n        \
    \    }\n            current_group += c;\n        }\n        result_groups.push(current_group_string);\n\
    \    }\n    result_groups\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found `\")\"`\n  --> /tmp/tmpzkr47dt_.rs:41:46\n   |\n41 |                 \
    \    current_group_string += c\")\";\n   |                                   \
    \           ^^^ expected one of 8 possible tokens\n\nerror[E0599]: no method named\
    \ `split_by_whitespace` found for struct `String` in the current scope\n --> /tmp/tmpzkr47dt_.rs:8:35\n\
    \  |\n8 |     let mut groups = paren_string.split_by_whitespace();\n  |      \
    \                             ^^^^^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `split_whitespace`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpzkr47dt_.rs:26:21\n\
    \   |\n26 |                     current_group_string += \")\";\n   |         \
    \            --------------------^^^^^^^\n   |                     |\n   |   \
    \                  cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpzkr47dt_.rs:30:21\n\
    \   |\n30 |                     current_group_string += \")\";\n   |         \
    \            --------------------^^^^^^^\n   |                     |\n   |   \
    \                  cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpzkr47dt_.rs:39:21\n\
    \   |\n39 |                     current_group_string += \")\";\n   |         \
    \            --------------------^^^^^^^\n   |                     |\n   |   \
    \                  cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpzkr47dt_.rs:45:21\n\
    \   |\n45 |                     current_group_string += \"[]\";\n   |        \
    \             --------------------^^^^^^^^\n   |                     |\n   | \
    \                    cannot use `+=` on type `&str`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpzkr47dt_.rs:51:21\n\
    \   |\n51 |                     current_group_string += \"]\";\n   |         \
    \            -------------------"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut result = vec![];\n\n    for paren in paren_string.chars() {\n   \
    \     match paren {\n            ' ' => result.push(String::from(\"()\")),\n \
    \           '(' => {\n                let mut new_result = vec![];\n         \
    \       result.push(new_result);\n                new_result.push(String::from(\"\
    (\"));\n                continue 'LOOP\n            }\n            ')' => {\n\
    \                let mut new_result = vec![];\n                result.push(new_result);\n\
    \                new_result.push(String::from(\")\"));\n                continue\
    \ 'LOOP\n            }\n            _ => continue,\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0426]: use of undeclared label `'LOOP`\n  --> /tmp/tmpbnjvt3o2.rs:17:26\n\
    \   |\n17 |                 continue 'LOOP\n   |                          ^^^^^\
    \ undeclared label `'LOOP`\n\nerror[E0426]: use of undeclared label `'LOOP`\n\
    \  --> /tmp/tmpbnjvt3o2.rs:23:26\n   |\n23 |                 continue 'LOOP\n\
    \   |                          ^^^^^ undeclared label `'LOOP`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbnjvt3o2.rs:15:29\n   |\n15 |              \
    \   result.push(new_result);\n   |                             ^^^^^^^^^^ expected\
    \ struct `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n\
    \              found struct `Vec<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpbnjvt3o2.rs:21:29\n   |\n21 |                 result.push(new_result);\n\
    \   |                             ^^^^^^^^^^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0426.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Write your code here\n    println!(\"separate_paren_groups()\");\n   \
    \ \n    // Handle edge case for empty string\n    let mut groups: Vec<String>\
    \ = vec![\"\"];\n    let mut has_paren = false;\n    let mut group = \"\";\n \
    \   for c in paren_string.chars() {\n        if c == '(' && !has_paren {\n   \
    \         has_paren = true;\n            group.push_str(&mut groups);\n      \
    \      group.push_str(&mut groups);\n        } else if c == ')' {\n          \
    \  if has_paren {\n                group.push_str(&mut groups);\n            \
    \    has_paren = false;\n            } else {\n                group.push_str(&mut\
    \ groups);\n            }\n        } else if c == '{' && !has_paren {\n      \
    \      group.push_str(&mut groups);\n            group.push_str(&mut groups);\n\
    \        } else if c == '}' {\n            if has_paren {\n                group.push_str(&mut\
    \ groups);\n                has_paren = false;\n            } else {\n       \
    \         group.push_str(&mut groups);\n            }\n        } else {\n    \
    \        group.push_str(&mut groups);\n        }\n    }\n    groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpoxmvp_49.rs:12:40\n   |\n\
    12 |     let mut groups: Vec<String> = vec![\"\"];\n   |                     \
    \                   ^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                        |\n   |                         \
    \               expected struct `String`, found `&str`\n\nerror[E0599]: no method\
    \ named `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:18:19\n\
    \   |\n18 |             group.push_str(&mut groups);\n   |                   ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:19:19\n\
    \   |\n19 |             group.push_str(&mut groups);\n   |                   ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:22:23\n\
    \   |\n22 |                 group.push_str(&mut groups);\n   |               \
    \        ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:25:23\n\
    \   |\n25 |                 group.push_str(&mut groups);\n   |               \
    \        ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `push_str` found for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:28:19\n\
    \   |\n28 |             group.push_str(&mut groups);\n   |                   ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:29:19\n\
    \   |\n29 |             group.push_str(&mut groups);\n   |                   ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpoxmvp_49.rs:32:23\n\
    \   |\n32 |                 group.push_str(&mut groups);\n   |               \
    \        ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `push_str` found for re"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups = Vec::new();\n    let mut open_braces = Vec::new();\n\
    \    let mut open_paren = Vec::new();\n\n    paren_string.chars().for_each(|c|\
    \ match c {\n        ' ' | ')' => {\n            if !open_braces.is_empty() {\n\
    \                paren_groups.push(\n                    open_paren\n        \
    \                .iter()\n                        .chain(open_braces.iter())\n\
    \                        .collect::<Vec<_>>()\n                        .join(\"\
    (\"),\n                );\n                open_braces.clear();\n            \
    \    open_paren = Vec::new();\n            }\n        }\n        '(' | '{' =>\
    \ {\n            if !open_paren.is_empty() {\n                open_braces.push(c);\n\
    \            } else {\n                open_paren.push(c);\n            }\n  \
    \      }\n        _ => (),\n    });\n    if !open_braces.is_empty() {\n      \
    \  paren_groups.push(\n            open_paren\n                .iter()\n     \
    \           .chain(open_braces.iter())\n                .collect::<Vec<_>>()\n\
    \                .join(\"(\"),\n        );\n    }\n    paren_groups\n}\n\nfn main()\
    \ {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp1_v42k0k.rs:19:26\n   |\n19 |                         .collect::<Vec<_>>()\n\
    \   |                          ^^^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = help: the\
    \ trait `Iterator` is implemented for `std::iter::Chain<A, B>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n   = note: 1 redundant requirement hidden\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `std::iter::Chain<std::slice::Iter<'_,\
    \ str>, std::slice::Iter<'_, str>>`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n  --> /tmp/tmp1_v42k0k.rs:16:21\n\
    \   |\n16 | /                     open_paren\n17 | |                         .iter()\n\
    18 | |                         .chain(open_braces.iter())\n19 | |            \
    \             .collect::<Vec<_>>()\n   | |____________________________________________^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\nnote: required by a bound in `std::slice::Iter`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp1_v42k0k.rs:18:26\n   |\n18 |                         .chain(open_braces.iter())\n\
    \   |                          ^^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\n   = help: the\
    \ trait `Iterator` is implemented for `std::slice::Iter<'a, T>`\n   = note: required\
    \ because of the requirements on the impl of `Iterator` for `std::slice::Iter<'_,\
    \ str>`\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n  --> /tmp/tmp1_v42k0k.rs:16:21\n   |\n16 | /            \
    \         open_paren\n17 | |                         .iter()\n18 | |         \
    \                .chain(open_braces.iter())\n   | |__________________________________________________^\
    \ doesn't have a size known at"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_groups: Vec<String> = vec![];\n    let mut inside_group = false;\n\
    \    let mut paren_len = paren_string.len();\n    while paren_len > 0 {\n    \
    \    let mut paren_group_start = paren_len;\n        while !paren_string.starts_with(paren_string[paren_group_start\
    \ ..]) {\n            paren_group_start += 1;\n        }\n        let mut paren_group_end\
    \ = paren_group_start;\n        while !paren_string[paren_group_end + 1].contains(char::parenthesis)\
    \ {\n            paren_group_end += 1;\n        }\n        if paren_group_start\
    \ == paren_group_end {\n            inside_group = true;\n        }\n        if\
    \ paren_string[paren_group_start] == '(' {\n            paren_groups.push(paren_string.clone());\n\
    \            paren_groups.push(String::from(\"\"));\n            paren_groups.push(String::from(\"\
    \"));\n        } else {\n            paren_groups.push(String::from(\"\"));\n\
    \            paren_groups.push(paren_string[paren_group_start .. paren_group_end].to_string());\n\
    \        }\n        paren_len -= paren_group_end - paren_group_start - 1;\n  \
    \  }\n    if paren_groups[paren_groups.len() - 1].len() == 0 {\n        paren_groups.pop();\n\
    \    }\n    if inside_group {\n        separate_paren_groups(paren_string)\n \
    \   } else {\n        paren_groups\n    }\n}\n\nfn main() {\n    let candidate\
    \ = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n    --> /tmp/tmp5ggg7pca.rs:13:41\n     |\n13   |         while !paren_string.starts_with(paren_string[paren_group_start\
    \ ..]) {\n     |                             ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n     |                          \
    \   |\n     |                             required by a bound introduced by this\
    \ call\n     |\n     = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `core::str::<impl str>::starts_with`\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `str`\n    --> /tmp/tmp5ggg7pca.rs:13:41\n\
    \     |\n13   |         while !paren_string.starts_with(paren_string[paren_group_start\
    \ ..]) {\n     |                             ----------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an implementor of trait `Pattern<'_>`\n     |                     \
    \        |\n     |                             required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `str: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `str`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n13   |         while !paren_string.starts_with(&paren_string[paren_group_start\
    \ ..]) {\n     |                                         +\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmp5ggg7pca.rs:17:16\n\
    \   |\n17 |         while !paren_string[paren_group_end + 1].contains(char::parenthesis)\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars().filter(|c| c != '(' && c != ')').collect()\n}\n\nfn\
    \ main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpzjb4nt4j.rs:8:39\n\
    \  |\n8 |     paren_string.chars().filter(|c| c != '(' && c != ')').collect()\n\
    \  |                                       ^^ no implementation for `&char ==\
    \ char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmpzjb4nt4j.rs:8:51\n  |\n8 |     paren_string.chars().filter(|c|\
    \ c != '(' && c != ')').collect()\n  |                                       \
    \            ^^ no implementation for `&char == char`\n  |\n  = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: a value of type `Vec<String>` cannot\
    \ be built from an iterator over elements of type `char`\n    --> /tmp/tmpzjb4nt4j.rs:8:59\n\
    \     |\n8    |     paren_string.chars().filter(|c| c != '(' && c != ')').collect()\n\
    \     |                                                           ^^^^^^^ value\
    \ of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut strings = vec![];\n    for group in paren_string.chars().filter_map(|c|\
    \ match c {\n        ' ' => false,\n        '(' => true,\n        _ => false,\n\
    \    }) {\n        if !group {\n            continue;\n        }\n        let\
    \ mut has_closed = false;\n        let mut is_open = false;\n        for c in\
    \ group {\n            if c == ')' {\n                if is_open {\n         \
    \           has_closed = true;\n                }\n                is_open = false;\n\
    \                continue;\n            }\n            if is_open {\n        \
    \        continue;\n            }\n            if c == '(' {\n               \
    \ has_closed = true;\n                is_open = true;\n                continue;\n\
    \            }\n            strings.push(group);\n            break;\n       \
    \ }\n        if !has_closed {\n            strings.push(group);\n        }\n \
    \   }\n    strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz4a15123.rs:10:16\n   |\n\
    10 |         ' ' => false,\n   |                ^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ type `bool`\nhelp: try wrapping the expression in `Some`\n   |\n10 |       \
    \  ' ' => Some(false),\n   |                +++++     +\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut split = paren_string.char_indices().collect::<Vec<_>>();\n    let\
    \ mut output = Vec::new();\n    let mut depth = 0;\n    for c in split.into_iter()\
    \ {\n        let (open, close) = c.next();\n        match open {\n           \
    \ None => (),\n            Some(_) => (),\n        }\n        if depth > 0 {\n\
    \            output.push(paren_string[c.0..c.1]);\n        }\n        depth +=\
    \ 1;\n    }\n    output\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for tuple `(usize, char)` in\
    \ the current scope\n  --> /tmp/tmp4jz8wfvb.rs:12:31\n   |\n12 |         let (open,\
    \ close) = c.next();\n   |                               ^^^^ method not found\
    \ in `(usize, char)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4jz8wfvb.rs:18:43\n\
    \   |\n18 |             output.push(paren_string[c.0..c.1]);\n   |           \
    \                                ^^^ expected `usize`, found `char`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp4jz8wfvb.rs:18:25\n    |\n18  |             output.push(paren_string[c.0..c.1]);\n\
    \    |                    ---- ^^^^^^^^^^^^^^^^^^^^^^ doesn't have a size known\
    \ at compile-time\n    |                    |\n    |                    required\
    \ by a bound introduced by this call\n    |\n    = help: the trait `Sized` is\
    \ not implemented for `str`\nnote: required by a bound in `Vec::<T, A>::push`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp4jz8wfvb.rs:9:22\n    |\n9   |     let mut output = Vec::new();\n\
    \    |                      ^^^^^^^^ doesn't have a size known at compile-time\n\
    \    |\n    = help: the trait `Sized` is not implemented for `str`\nnote: required\
    \ by a bound in `Vec::<T>::new`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n   --> /tmp/tmp4jz8wfvb.rs:9:22\n    |\n\
    9   |     let mut output = Vec::new();\n    |                      ^^^ doesn't\
    \ have a size known at compile-time\n    |\n    = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `Vec`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4jz8wfvb.rs:22:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n22 |  \
    \   output\n   |     ^^^^^^ expected struct `String`, found `str`\n   |\n   =\
    \ note: expected struct `Vec<String>`\n              found struct `Vec<str>`\n\
    \nerror: aborting due"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Use a stack to push each open paren string into separate\n    // strings,\
    \ and then pop each string from stack when the last\n    // open paren string\
    \ is closed.\n    let mut open_braces = Vec::<String>::new();\n    let mut open_brace_to_string\
    \ = Vec::new();\n    for (i, c) in paren_string.chars().enumerate() {\n      \
    \  match c {\n            // Handle an opening paren. Push it to a stack if\n\
    \            // it is not already there.\n            ' ' if open_braces.is_empty()\
    \ => {\n                open_braces.push(c);\n                open_brace_to_string.push(i);\n\
    \            }\n            // Handle a closing paren\n            ')' => {\n\
    \                // Pop the top open paren string from the stack\n           \
    \     // and append its contents to the current string\n                // and\
    \ push this string back into the stack.\n                let popped = open_braces.pop();\n\
    \                open_brace_to_string.push(popped);\n                open_braces.push(c);\n\
    \            }\n            _ => {\n                // If open brace is not equal\
    \ to closing brace, append the character\n                // to the current string\
    \ and push this string back into the stack.\n                open_brace_to_string.push(c);\n\
    \            }\n        }\n    }\n    open_brace_to_string\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc7hr772y.rs:18:34\n   |\n\
    18 |                 open_braces.push(c);\n   |                              \
    \    ^- help: try using a conversion method: `.to_string()`\n   |            \
    \                      |\n   |                                  expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc7hr772y.rs:27:43\n\
    \   |\n27 |                 open_brace_to_string.push(popped);\n   |         \
    \                                  ^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<String>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc7hr772y.rs:28:34\n   |\n28 |\
    \                 open_braces.push(c);\n   |                                 \
    \ ^- help: try using a conversion method: `.to_string()`\n   |               \
    \                   |\n   |                                  expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc7hr772y.rs:33:43\n\
    \   |\n33 |                 open_brace_to_string.push(c);\n   |              \
    \                             ^ expected `usize`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc7hr772y.rs:37:5\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \      ----------- expected `Vec<String>` because of return type\n...\n37 |  \
    \   open_brace_to_string\n   |     ^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<String>`\n            \
    \  found struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut strings = vec![];\n    let mut i = 0;\n    paren_string.chars().filter_map(|c|\
    \ c).for_each(|c| {\n        if c != '(' { panic!(\"Invalid char at index {:?}\
    \ {:?}\", i, c); }\n        if paren_string[..i].is_empty() { panic!(\"Empty string\
    \ at index {:?} {:?}\", i, c); }\n        if paren_string[i..].contains(&c as\
    \ char) {\n            panic!(\"Found nested parens at index {:?} {:?}\", i, c);\n\
    \        }\n        i += 1;\n        strings.push(c); // push opening bracket\n\
    \        i += 1;\n    });\n    strings\n}\n\nfn main() {\n    let candidate =\
    \ separate_paren_groups;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"((()))\"),\
    \ String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmgvi3hv6.rs:10:41\n   |\n\
    10 |     paren_string.chars().filter_map(|c| c).for_each(|c| {\n   |         \
    \                                ^ expected enum `Option`, found `char`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found type `char`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n10 |     paren_string.chars().filter_map(|c|\
    \ Some(c)).for_each(|c| {\n   |                                         +++++\
    \ +\n\nerror[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpmgvi3hv6.rs:11:14\n\
    \   |\n11 |         if c != '(' { panic!(\"Invalid char at index {:?} {:?}\",\
    \ i, c); }\n   |              ^^ no implementation for `String == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0606]: casting `&String`\
    \ as `char` is invalid\n  --> /tmp/tmpmgvi3hv6.rs:13:39\n   |\n13 |         if\
    \ paren_string[i..].contains(&c as char) {\n   |                             \
    \          ^^^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0606.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.split(|c| {\n        c.is_whitespace()\n    })\n        .filter(|c|\n\
    \            // Ignore spaces within a paren\n            !c.is_whitespace() &&\
    \ c == '(' && paren_string.chars().any(|c| *c == ')')\n        )\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n --> /tmp/tmpz40__jif.rs:8:25\n\
    \  |\n8 |     paren_string.split(|c| {\n  |                         ^ consider\
    \ giving this closure parameter a type\n  |\n  = note: type must be known at this\
    \ point\n\nerror[E0599]: no method named `is_whitespace` found for reference `&&str`\
    \ in the current scope\n  --> /tmp/tmpz40__jif.rs:13:16\n   |\n13 |          \
    \   !c.is_whitespace() && c == '(' && paren_string.chars().any(|c| *c == ')')\n\
    \   |                ^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `split_ascii_whitespace`\n\nerror[E0277]: can't compare `&&str`\
    \ with `char`\n  --> /tmp/tmpz40__jif.rs:13:37\n   |\n13 |             !c.is_whitespace()\
    \ && c == '(' && paren_string.chars().any(|c| *c == ')')\n   |               \
    \                      ^^ no implementation for `&&str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpz40__jif.rs:13:76\n   |\n13 |             !c.is_whitespace() &&\
    \ c == '(' && paren_string.chars().any(|c| *c == ')')\n   |                  \
    \                                                          ^^\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpz40__jif.rs:15:10\n     |\n15   |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_count = 0;\n    let mut paren_strings: Vec<String> = vec![];\n\
    \n    for (i, c) in paren_string.chars().enumerate() {\n        if c == '(' {\n\
    \            paren_count += 1;\n        }\n\n        if c == ')' {\n         \
    \   paren_count -= 1;\n        }\n\n        if paren_count == 0 {\n          \
    \  paren_strings.push(paren_string.to_string()[..i]);\n        }\n    }\n\n  \
    \  paren_strings\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2rrsngxa.rs:21:32\n   |\n\
    21 |             paren_strings.push(paren_string.to_string()[..i]);\n   |    \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |                                |\n \
    \  |                                expected struct `String`, found `str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut paren_string = paren_string.trim();\n    let mut paren_string = paren_string.replace(\"\
    (\", \"()\");\n    let mut paren_string = paren_string.replace(\")\", \"()\");\n\
    \    let mut paren_string = paren_string.replace(\",\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\".\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\")\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    (\", \"()\");\n\n    let mut paren_string = paren_string.replace(\"(\", \"()\"\
    );\n    let mut paren_string = paren_string.replace(\")\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\",\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\".\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    )\", \"()\");\n    let mut paren_string = paren_string.replace(\"(\", \"()\");\n\
    \n    let mut paren_string = paren_string.replace(\"(\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\")\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\",\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    .\", \"()\");\n    let mut paren_string = paren_string.replace(\")\", \"()\");\n\
    \    let mut paren_string = paren_string.replace(\"(\", \"()\");\n\n    let mut\
    \ paren_string = paren_string.replace(\"(\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\")\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    ,\", \"()\");\n    let mut paren_string = paren_string.replace(\".\", \"()\");\n\
    \    let mut paren_string = paren_string.replace(\")\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\"(\", \"()\");\n\n    let mut paren_string\
    \ = paren_string.replace(\"(\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    )\", \"()\");\n    let mut paren_string = paren_string.replace(\",\", \"()\");\n\
    \    let mut paren_string = paren_string.replace(\".\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\")\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\"(\", \"()\");\n\n    let mut paren_string = paren_string.replace(\"\
    (\", \"()\");\n    let mut paren_string = paren_string.replace(\")\", \"()\");\n\
    \    let mut paren_string = paren_string.replace(\",\", \"()\");\n    let mut\
    \ paren_string = paren_string.replace(\".\", \"()\");\n    let mut paren_string\
    \ = paren_string.replace(\")\", \"()\");\n    let mut paren_string = paren_string.replace(\"\
    (\"\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpq0kyt1zm.rs:50:1\n   |\n50 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpq0kyt1zm.rs:49:48\n   |\n7  | fn separate_paren_groups(paren_string:\
    \ String) -> Vec<String> {\n   |                                             \
    \                  - closing delimiter possibly meant for this\n...\n49 |    \
    \ let mut paren_string = paren_string.replace(\"(\"\n   |                    \
    \                            ^ unclosed delimiter\n50 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    let mut stack: Vec<String> = Vec::new();\n    for (i, e) in paren_string.char_indices().rev().skip(1).enumerate()\n\
    \    {\n        if e.ptr - i == 1 {\n            stack.push(paren_string.chars().nth(i).unwrap());\n\
    \        } else {\n            let mut j = i;\n            while j < e.ptr &&\
    \ paren_string.chars().nth(j).unwrap() == '(' {\n                j += 1;\n   \
    \         }\n            if j != e.ptr {\n                while j != e.ptr &&\
    \ paren_string.chars().nth(j).unwrap() == ')' {\n                    j += 1;\n\
    \                }\n                if j == e.ptr {\n                    stack.push(paren_string.chars().nth(j).unwrap());\n\
    \                } else {\n                    stack.push(paren_string.chars()\n\
    \                        .nth(j)\n                        .unwrap()\n        \
    \                .cloned()\n                        .split('(')\n            \
    \            .map(|e| e[1..].to_string())\n                        .join('(')\n\
    \                    );\n                }\n            }\n        }\n    }\n\
    \    return stack;\n}\n\nfn main() {\n    let candidate = separate_paren_groups;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![String::from(\"\
    (()())\"), String::from(\"((()))\"), String::from(\"()\"), String::from(\"((())()())\"\
    )]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\")), vec![String::from(\"\
    ()\"), String::from(\"(())\"), String::from(\"((()))\"), String::from(\"(((())))\"\
    )]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\")), vec![String::from(\"\
    (()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"( ) (( )) (( )(\
    \ ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"(()())\"\
    )]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `ptr` on type `(usize, char)`\n  --> /tmp/tmpzodarl1k.rs:11:14\n\
    \   |\n11 |         if e.ptr - i == 1 {\n   |              ^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzodarl1k.rs:12:24\n   |\n12 |             stack.push(paren_string.chars().nth(i).unwrap());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                        |\n   |   \
    \                     expected struct `String`, found `char`\n\nerror[E0609]:\
    \ no field `ptr` on type `(usize, char)`\n  --> /tmp/tmpzodarl1k.rs:15:25\n  \
    \ |\n15 |             while j < e.ptr && paren_string.chars().nth(j).unwrap()\
    \ == '(' {\n   |                         ^^^\n\nerror[E0609]: no field `ptr` on\
    \ type `(usize, char)`\n  --> /tmp/tmpzodarl1k.rs:18:23\n   |\n18 |          \
    \   if j != e.ptr {\n   |                       ^^^\n\nerror[E0609]: no field\
    \ `ptr` on type `(usize, char)`\n  --> /tmp/tmpzodarl1k.rs:19:30\n   |\n19 | \
    \                while j != e.ptr && paren_string.chars().nth(j).unwrap() == ')'\
    \ {\n   |                              ^^^\n\nerror[E0609]: no field `ptr` on\
    \ type `(usize, char)`\n  --> /tmp/tmpzodarl1k.rs:22:27\n   |\n22 |          \
    \       if j == e.ptr {\n   |                           ^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzodarl1k.rs:23:32\n   |\n23 |                     stack.push(paren_string.chars().nth(j).unwrap());\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \        |\n   |                                expected struct `String`, found\
    \ `char`\n\nerror[E0599]: `char` is not an iterator\n  --> /tmp/tmpzodarl1k.rs:28:26\n\
    \   |\n28 |                         .cloned()\n   |                          ^^^^^^\
    \ `char` is not an iterator\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `char: Iterator`\n           which is required by\
    \ `&mut char: Iterator`\n\nerror: aborting due to 8 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0609.\n"
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    // Find the first position of a left paren open\n    let mut left_paren_open_idx\
    \ = paren_string.find(String::from(\"(\"));\n\n    // If the left paren position\
    \ is less than zero, return the original string\n    if left_paren_open_idx <\
    \ 0 {\n        return vec![paren_string];\n    }\n\n    // Find the last position\
    \ of a right paren close\n    let mut right_paren_close_idx = paren_string.rfind(String::from(\"\
    )\"));\n\n    // If the right paren position is greater than the length of input\
    \ string, return an empty vector\n    if right_paren_close_idx > paren_string.len()\
    \ {\n        return vec![];\n    }\n\n    // Get the string between paren open\
    \ and close positions\n    let mut sub_string = paren_string.chars()\n       \
    \ .skip_while(|c| c.is_ascii_alphanumeric())\n        .take(right_paren_close_idx\
    \ - left_paren_open_idx + 1)\n        .collect::<Vec<String>>()\n        .to_owned();\n\
    \n    // Return the vector of strings\n    vec![sub_string]\n}\n\nfn main() {\n\
    \    let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n   \
    \ --> /tmp/tmpu3u_k7lo.rs:9:53\n     |\n9    |     let mut left_paren_open_idx\
    \ = paren_string.find(String::from(\"(\"));\n     |                          \
    \                      ---- ^^^^^^^^^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n     |                                                |\n   \
    \  |                                                required by a bound introduced\
    \ by this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is\
    \ not satisfied\n     = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl\
    \ str>::find`\nhelp: consider borrowing here\n     |\n9    |     let mut left_paren_open_idx\
    \ = paren_string.find(&String::from(\"(\"));\n     |                         \
    \                            +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu3u_k7lo.rs:12:30\n\
    \   |\n12 |     if left_paren_open_idx < 0 {\n   |                           \
    \   ^ expected enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n12 |     if left_paren_open_idx < Some(0) {\n   |                     \
    \         +++++ +\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found\
    \ `String`\n  --> /tmp/tmpu3u_k7lo.rs:17:56\n   |\n17 |     let mut right_paren_close_idx\
    \ = paren_string.rfind(String::from(\")\"));\n   |                           \
    \                       ----- ^^^^^^^^^^^^^^^^^ expected an implementor of trait\
    \ `Pattern<'_>`\n   |                                                  |\n   |\
    \                                                  required by a bound introduced\
    \ by this call\n   |\n   = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n   = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nhelp: consider borrowing here\n   |\n17 |     let mut right_paren_close_idx\
    \ = paren_string.rfind(&String::from(\")\"));\n   |                          \
    \            "
  stdout: ''
  timestamp: 1659976156
- exit_code: 1
  program: "/// Input to this function is a string containing multiple groups of nested\
    \ parentheses. Your goal is to\n/// separate those group into separate strings\
    \ and return the vector of those.\n/// Separate groups are balanced (each open\
    \ brace is properly closed) and not nested within each other\n/// Ignore any spaces\
    \ in the input string.\n/// >>> separate_paren_groups(String::from(\"( ) (( ))\
    \ (( )( ))\"))\n/// vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]\nfn separate_paren_groups(paren_string: String) -> Vec<String> {\n\
    \    paren_string.chars()\n        .filter_map(|c| {\n            if c.is_whitespace()\
    \ {\n                None\n            } else {\n                Some(c.to_ascii_lowercase().collect::<String>())\n\
    \            }\n        })\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n \
    \   let candidate = separate_paren_groups;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![String::from(\"(()())\"), String::from(\"\
    ((()))\"), String::from(\"()\"), String::from(\"((())()())\")]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![String::from(\"()\"), String::from(\"(())\"\
    ), String::from(\"((()))\"), String::from(\"(((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![String::from(\"(()(())((())))\")]);\n    assert_eq!(candidate(String::from(\"\
    ( ) (( )) (( )( ))\")), vec![String::from(\"()\"), String::from(\"(())\"), String::from(\"\
    (()())\")]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `char` is not an iterator\n  --> /tmp/tmp9d5hsg1j.rs:13:45\n\
    \   |\n13 |                 Some(c.to_ascii_lowercase().collect::<String>())\n\
    \   |                                             ^^^^^^^ `char` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `char:\
    \ Iterator`\n           which is required by `&mut char: Iterator`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976156
