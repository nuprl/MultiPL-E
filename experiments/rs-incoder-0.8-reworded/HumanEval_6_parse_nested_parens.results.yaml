language: rs
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_levels =\
    \ vec![];\n    for c in paren_string {\n        if c == '(' {\n            paren_levels.push(level);\n\
    \            level += 1;\n        } else if c == ')' {\n            level -= 1;\n\
    \            if level == 0 {\n                paren_levels.push(level);\n    \
    \        }\n        } else {\n            level += 1;\n        }\n    }\n    if\
    \ paren_levels[paren_levels.len() - 1] == 0 {\n        paren_levels.pop();\n \
    \   }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n --> /tmp/tmp2p3j1t8_.rs:9:14\n\
    \  |\n9 |     for c in paren_string {\n  |              ^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n  |\n  = help: the\
    \ trait `Iterator` is not implemented for `String`\n  = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .filter_map(|x| x.parse::<usize>().ok())\n        .filter_map(|x| x.checked_add(1).ok())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ok` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpbecd0xzu.rs:10:42\n   |\n10 |         .filter_map(|x| x.checked_add(1).ok())\n\
    \   |                                          ^^ help: there is an associated\
    \ function with a similar name: `or`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let parens: Vec<_> = paren_string.chars().filter_map(|c|\
    \ if c == '(' { Some(0) } else { None }).collect();\n    let mut paren_counts\
    \ = parens.iter().enumerate().collect::<Vec<_>>();\n    let mut counts: Vec<_>\
    \ = paren_counts\n        .iter()\n        .map(|(i, p)| {\n            match\
    \ p {\n                0 => 0,\n                _ => {\n                    let\
    \ j = i + 1;\n                    let mut i = 0;\n                    for n in\
    \ &counts[i..] {\n                        i += n;\n                        if\
    \ j >= i {\n                            return Some(i);\n                    \
    \    }\n                    }\n                    None\n                }\n \
    \           }\n        })\n        .collect();\n    let mut i = 0;\n    let mut\
    \ result: Vec<_> = counts\n        .into_iter()\n        .map(|n| {\n        \
    \    if *n >= i {\n                i += *n;\n                *n\n            }\
    \ else {\n                *n\n            }\n        })\n        .collect();\n\
    \    for i in 0..result.len() {\n        if result[i] < 2 {\n            result[i]\
    \ = 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `counts` in this scope\n  --> /tmp/tmp9xbyu4o0.rs:17:31\n\
    \   |\n17 |                     for n in &counts[i..] {\n   |                \
    \               ^^^^^^ not found in this scope\n\nerror[E0614]: type `Option<usize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp9xbyu4o0.rs:32:16\n   |\n32 |        \
    \     if *n >= i {\n   |                ^^\n\nerror[E0614]: type `Option<usize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp9xbyu4o0.rs:33:22\n   |\n33 |        \
    \         i += *n;\n   |                      ^^\n\nerror[E0614]: type `Option<usize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp9xbyu4o0.rs:34:17\n   |\n34 |        \
    \         *n\n   |                 ^^\n\nerror[E0614]: type `Option<usize>` cannot\
    \ be dereferenced\n  --> /tmp/tmp9xbyu4o0.rs:36:17\n   |\n36 |               \
    \  *n\n   |                 ^^\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut counter: isize = 0;\n\n    let mut paren_levels\
    \ = paren_string.chars().filter_map(|c| {\n        if c == '(' {\n           \
    \ counter += 1;\n            Some(counter)\n        } else {\n            counter\
    \ -= 1;\n            None\n        }\n    }).collect::<Vec<Option<usize>>>();\n\
    \n    paren_levels.push(None);\n\n    let mut levels = paren_levels\n        .iter()\n\
    \        .cloned()\n        .enumerate()\n        .filter_map(|(i, o)| {\n   \
    \         match o {\n                Some(i) => i.is_some(),\n               \
    \ None => false,\n            }\n        })\n        .collect::<Vec<usize>>();\n\
    \n    let mut levels_vec = levels.into_iter().collect::<Vec<_>>();\n    let mut\
    \ max_level: usize = 0;\n    loop {\n        let mut levels_iter = levels_vec.iter();\n\
    \        if levels_iter.is_empty() {\n            break;\n        }\n        let\
    \ level = levels_iter.next().unwrap();\n        if level == max_level {\n    \
    \        levels_iter = levels_vec.iter();\n        }\n        if level > max_level\
    \ {\n            max_level = level;\n        }\n    }\n    levels_vec\n      \
    \  .into_iter()\n        .take(max_level)\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<Option<usize>>` cannot be built from\
    \ an iterator over elements of type `isize`\n    --> /tmp/tmpbf2xrvso.rs:17:8\n\
    \     |\n17   |     }).collect::<Vec<Option<usize>>>();\n     |        ^^^^^^^\
    \ value of type `Vec<Option<usize>>` cannot be built from `std::iter::Iterator<Item=isize>`\n\
    \     |\n     = help: the trait `FromIterator<isize>` is not implemented for `Vec<Option<usize>>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `is_some` found for\
    \ type `usize` in the current scope\n  --> /tmp/tmpbf2xrvso.rs:27:30\n   |\n27\
    \ |                 Some(i) => i.is_some(),\n   |                            \
    \  ^^^^^^^ method not found in `usize`\n\nerror[E0658]: use of unstable library\
    \ feature 'exact_size_is_empty'\n  --> /tmp/tmpbf2xrvso.rs:37:24\n   |\n37 | \
    \        if levels_iter.is_empty() {\n   |                        ^^^^^^^^\n \
    \  |\n   = note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428>\
    \ for more information\n\nerror[E0277]: can't compare `&usize` with `usize`\n\
    \  --> /tmp/tmpbf2xrvso.rs:41:18\n   |\n41 |         if level == max_level {\n\
    \   |                  ^^ no implementation for `&usize == usize`\n   |\n   =\
    \ help: the trait `PartialEq<usize>` is not implemented for `&usize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpbf2xrvso.rs:44:20\n   |\n44 |\
    \         if level > max_level {\n   |                    ^^^^^^^^^\n   |    \
    \                |\n   |                    expected `&usize`, found `usize`\n\
    \   |                    help: consider borrowing here: `&max_level`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbf2xrvso.rs:45:25\n   |\n34 |     let mut max_level:\
    \ usize = 0;\n   |                        ----- expected due to this type\n...\n\
    45 |             max_level = level;\n   |     "
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut parens: Vec<isize>\
    \ = Vec::new();\n\n    for char in paren_string.chars() {\n        if char ==\
    \ '(' { level += 1; }\n        if char == ')' { level -= 1; }\n\n        if level\
    \ == 0 {\n            parens.push(level);\n        }\n    }\n\n    parens\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpvkkmogtr.rs:24:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut paren_stack\
    \ = vec![];\n\n    for (i, char) in paren_string.chars().enumerate() {\n     \
    \   if char == ' ' {\n            paren_count += 1;\n        } else if char ==\
    \ '(' {\n            paren_stack.push(paren_count);\n        } else if char ==\
    \ ')' {\n            paren_stack.push(paren_stack.last());\n            if paren_stack.len()\
    \ > 0 {\n                paren_count -= 1;\n            }\n        } else {\n\
    \            paren_count += 1;\n        }\n\n        if paren_stack.len() > 0\
    \ {\n            if paren_count == paren_stack.last() {\n                paren_count\
    \ += 1;\n            }\n        } else {\n            paren_stack.push(paren_count);\n\
    \        }\n    }\n\n    paren_stack.len()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp46jmipg6.rs:16:30\n   |\n\
    16 |             paren_stack.push(paren_stack.last());\n   |                 \
    \             ^^^^^^^^^^^^^^^^^^ expected integer, found enum `Option`\n   |\n\
    \   = note: expected type `{integer}`\n              found enum `Option<&{integer}>`\n\
    \nerror[E0277]: can't compare `{integer}` with `Option<&{integer}>`\n  --> /tmp/tmp46jmipg6.rs:25:28\n\
    \   |\n25 |             if paren_count == paren_stack.last() {\n   |         \
    \                   ^^ no implementation for `{integer} == Option<&{integer}>`\n\
    \   |\n   = help: the trait `PartialEq<Option<&{integer}>>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp46jmipg6.rs:33:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n33 |     paren_stack.len()\n   |     ^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = vec![0];\n    let mut stack =\
    \ paren_string.chars().enumerate().rev();\n    while let Some((index, ch)) = stack.pop()\
    \ {\n        if ch == ')' {\n            levels = levels.iter().cloned().chain(levels);\n\
    \        }\n        if ch == '(' {\n            levels.push(0);\n            stack.push((index\
    \ + 1, ch));\n        }\n    }\n    levels.iter().cloned().collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \    --> /tmp/tmp3oepklh6.rs:8:54\n     |\n8    |     let mut stack = paren_string.chars().enumerate().rev();\n\
    \     |                                                      ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0599]:\
    \ no method named `pop` found for struct `Rev` in the current scope\n --> /tmp/tmp3oepklh6.rs:9:41\n\
    \  |\n9 |     while let Some((index, ch)) = stack.pop() {\n  |               \
    \                          ^^^ method not found in `Rev<Enumerate<Chars<'_>>>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3oepklh6.rs:11:22\n   |\n7  |\
    \     let mut levels = vec![0];\n   |                      ------- expected due\
    \ to this value\n...\n11 |             levels = levels.iter().cloned().chain(levels);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `std::iter::Chain`\n   |\n   = note: expected struct `Vec<{integer}>`\n\
    \              found struct `std::iter::Chain<Cloned<std::slice::Iter<'_, {integer}>>,\
    \ std::vec::IntoIter<{integer}>>`\n\nerror[E0599]: no method named `push` found\
    \ for struct `Rev` in the current scope\n  --> /tmp/tmp3oepklh6.rs:15:19\n   |\n\
    15 |             stack.push((index + 1, ch));\n   |                   ^^^^ method\
    \ not found in `Rev<Enumerate<Chars<'_>>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Reverse the input string so it is easier to\
    \ find matching\n    let paren_string = paren_string.chars()\n        .iter()\n\
    \        .enumerate()\n        .map(|(i, c)| (i, c.to_ascii_lowercase().chars().enumerate().rev().skip_while(|&(c,\
    \ _)| c >= '(').collect::<Vec<_>>()))\n        .fold(String::new(), |mut acc,\
    \ pair| {\n            acc.push_str(&(\n                if pair[0].chars().any(|&(_,\
    \ c2)| c2 != '(' && c2 != ')') {\n                    String::from(\"(\")\n  \
    \              } else {\n                    String::from(\")\")\n           \
    \     }\n            ));\n            acc.push_str(&(\n                if pair[1].chars().any(|&(_,\
    \ c2)| c2 != '(' && c2 != ')') {\n                    String::from(\"(\")\n  \
    \              } else {\n                    String::from(\")\")\n           \
    \     }\n            ));\n            acc\n        });\n    let mut result = vec![];\n\
    \    let mut curr_level = 0;\n    for group in paren_string.chars().group_by(|&c|\
    \ c).values() {\n        if group.next().unwrap().count() == 1 {\n           \
    \ result.push(curr_level);\n            curr_level += 1;\n        } else {\n \
    \           result.push(curr_level);\n            curr_level += 2;\n        }\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n --> /tmp/tmpe3wwdprn.rs:9:10\n  |\n9 |         .iter()\n  |        \
    \  ^^^^ private field, not a method\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth = 0;\n    let mut paren_level\
    \ = 0;\n\n    let mut paren_level_index = 0;\n    let mut paren_level_stack =\
    \ vec![0; MAX_NESTING_DEPTH];\n\n    for paren in paren_string.chars() {\n   \
    \     if paren_level > MAX_NESTING_DEPTH {\n            paren_level = 0;\n   \
    \         paren_level_index = 0;\n        }\n\n        if paren == '(' {\n   \
    \         paren_level_stack[paren_level_index] = paren_level;\n            paren_level\
    \ += 1;\n        }\n\n        if paren == ')' {\n            paren_level -= 1;\n\
    \            if paren_level == 0 {\n                paren_level_index += 1;\n\
    \                paren_level_stack[paren_level_index] = 0;\n            }\n  \
    \      }\n    }\n\n    paren_level_stack.iter()\n        .map(|level| {\n    \
    \        let max_level = *level;\n            let max_level_index = paren_level_stack.iter().position(|i|\
    \ {\n                *i == *level\n            });\n\n            if max_level_index\
    \ == paren_level_stack.len() - 1 {\n                max_level_index\n        \
    \    } else {\n                max_level_index + 1\n            }\n        })\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_NESTING_DEPTH` in this scope\n  -->\
    \ /tmp/tmp7uivbfoo.rs:11:41\n   |\n11 |     let mut paren_level_stack = vec![0;\
    \ MAX_NESTING_DEPTH];\n   |                                         ^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `MAX_NESTING_DEPTH`\
    \ in this scope\n  --> /tmp/tmp7uivbfoo.rs:14:26\n   |\n14 |         if paren_level\
    \ > MAX_NESTING_DEPTH {\n   |                          ^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7uivbfoo.rs:40:35\n\
    \   |\n40 |             if max_level_index == paren_level_stack.len() - 1 {\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum\
    \ `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n40 |             if max_level_index == Some(paren_level_stack.len() - 1)\
    \ {\n   |                                   +++++                           +\n\
    \nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp7uivbfoo.rs:43:33\n\
    \   |\n43 |                 max_level_index + 1\n   |                 ---------------\
    \ ^ - {integer}\n   |                 |\n   |                 Option<usize>\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_map = paren_string\n        .chars()\n\
    \        .map(|c| c as char)\n        .collect::<HashMap<u32, String>>();\n  \
    \  let mut stack: Vec<isize> = vec![];\n    for (i, c) in paren_map.iter().enumerate()\
    \ {\n        if c.is_ascii_alphanumeric() {\n            stack.push(0);\n    \
    \        continue;\n        }\n\n        let n = stack.len();\n        stack[n\
    \ - 1] += 1;\n        if c == '(' {\n            stack.push(n - 1);\n        }\n\
    \        if c == ')' {\n            stack.push(n - 1);\n        }\n    }\n   \
    \ stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpwl4y3b65.rs:10:20\n\
    \   |\n10 |         .collect::<HashMap<u32, String>>();\n   |                \
    \    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwl4y3b65.rs:21:24\n   |\n21 |             stack.push(n - 1);\n\
    \   |                        ^^^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n21 |             stack.push((n - 1).try_into().unwrap());\n   | \
    \                       +     +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwl4y3b65.rs:24:24\n   |\n24 |             stack.push(n\
    \ - 1);\n   |                        ^^^^^ expected `isize`, found `usize`\n \
    \  |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n24 |             stack.push((n - 1).try_into().unwrap());\n\
    \   |                        +     +++++++++++++++++++++\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .lines()\n        .filter_map(|line|\
    \ line.trim().to_string())\n        .filter_map(|line| parse_parens_group(line))\n\
    \        .max_by_key(|group| group.1)\n        .unwrap_or_else(|| panic!(\"Cannot\
    \ parse parens string {:?}\", paren_string))\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_parens_group` in this scope\n\
    \  --> /tmp/tmpvgpkx7vx.rs:10:28\n   |\n10 |         .filter_map(|line| parse_parens_group(line))\n\
    \   |                            ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n --> /tmp/tmpvgpkx7vx.rs:9:28\n  |\n9 |      \
    \   .filter_map(|line| line.trim().to_string())\n  |                         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found struct `String`\n  |\n\
    \  = note: expected enum `Option<_>`\n           found struct `String`\nhelp:\
    \ try wrapping the expression in `Some`\n  |\n9 |         .filter_map(|line| Some(line.trim().to_string()))\n\
    \  |                            +++++                       +\n\nerror[E0609]:\
    \ no field `1` on type `&_`\n  --> /tmp/tmpvgpkx7vx.rs:11:35\n   |\n11 |     \
    \    .max_by_key(|group| group.1)\n   |                                   ^\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut paren_chars:\
    \ Vec<u8> = paren_string.chars().collect();\n    let mut paren_count = paren_chars.iter().filter(|c|\
    \ c == '(' || c == '[' || c == '{').count();\n    paren_count.push(paren_count);\n\
    \    paren_chars.iter().filter(|c| c == ')' || c == ']' || c == '}').for_each(|c|\
    \ {\n        paren_count.push(*c - '(');\n    });\n    paren_count.push(paren_count);\n\
    \    paren_chars.iter().filter(|c| c == ')' || c == ']' || c == '}' || c == '('\
    \ || c == '[').for_each(|c| {\n        paren_count.push(*c - '(');\n    });\n\
    \    paren_count.push(paren_count);\n    paren_chars.iter().filter(|c| c == '('\
    \ || c == '[' || c == '{' || c == ')' || c == ']' || c == '}' || c == ')' || c\
    \ == ']' || c == '}').for_each(|c| {\n        paren_count.push(*c - '(');\n  \
    \  });\n    paren_count.push(paren_count);\n    paren_chars.iter().filter(|c|\
    \ c == ')' || c == ']' || c == '}' || c == '(' || c == '[' || c == ']' || c ==\
    \ '}' || c == ')' || c == ']' || c == '}').for_each(|c| {\n        paren_count.push(*c\
    \ - '(');\n    });\n    paren_count.push(paren_count);\n    paren_chars.iter().filter(|c|\
    \ c == ')' || c == ']' || c == '}' || c == '(' || c == '[' || c == '{' || c ==\
    \ ']' || c == '}' || c == '(' || c == ']' || c == '}').for_each(|c| {\n      \
    \  paren_count.push(*c - '(');\n    });\n    paren_count\n}\n\nfn main() {\n \
    \   let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmphkawicrw.rs:8:57\n     |\n8  \
    \  |     let mut paren_chars: Vec<u8> = paren_string.chars().collect();\n    \
    \ |                                                         ^^^^^^^ value of type\
    \ `Vec<u8>` cannot be built from `std::iter::Iterator<Item=char>`\n     |\n  \
    \   = help: the trait `FromIterator<char>` is not implemented for `Vec<u8>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&&u8` with `char`\n\
    \ --> /tmp/tmphkawicrw.rs:9:59\n  |\n9 |     let mut paren_count = paren_chars.iter().filter(|c|\
    \ c == '(' || c == '[' || c == '{').count();\n  |                            \
    \                               ^^ no implementation for `&&u8 == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&&u8`\n  = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n            f32\n\
    \            f64\n            i128\n            i16\n            i32\n       \
    \     i64\n            i8\n            isize\n          and 6 others\n\nerror[E0277]:\
    \ can't compare `&&u8` with `char`\n --> /tmp/tmphkawicrw.rs:9:71\n  |\n9 |  \
    \   let mut paren_count = paren_chars.iter().filter(|c| c == '(' || c == '[' ||\
    \ c == '{').count();\n  |                                                    \
    \                   ^^ no implementation for `&&u8 == char`\n  |\n  = help: the\
    \ trait `PartialEq<char>` is not implemented for `&&u8`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            f32\n           \
    \ f64\n            i128\n            i16\n            i32\n            i64\n \
    \           i8\n            isize\n          and 6 others\n\nerror[E0277]: can't\
    \ compare `&&u8` with `char`\n --> /tmp/tmphkawicrw.rs:9:83\n  |\n9 |     let\
    \ mut paren_count = paren_chars.iter().filter(|c| c == '(' || c == '[' || c ==\
    \ '{').count();\n  |                                                         \
    \                          ^^ no implementation for `&&u8 == char`\n  |\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens = paren_string.char_indices().map(|(_,\
    \ x)| x).collect();\n    let mut paren_index = 0;\n    let mut parent_depth =\
    \ 0;\n    let mut parent_end = 0;\n    let mut parent_level = std::u16::MAX;\n\
    \n    let mut depth = 1;\n    while paren_index < parens.len() {\n        let\
    \ char = parens[paren_index];\n\n        if char == ')' {\n            parent_end\
    \ = paren_index + 1;\n            let last_level = depth - 1;\n            if\
    \ parent_level > last_level {\n                parens.pop();\n            } else\
    \ {\n                parens[parent_end] = 0;\n                parent_depth +=\
    \ 1;\n            }\n        } else if char == '(' {\n            let last_level\
    \ = depth - 1;\n            if parent_level > last_level {\n                parens.pop();\n\
    \            } else {\n                parens[paren_index] = 0;\n            \
    \    parent_depth += 1;\n                depth += 1;\n            }\n        }\
    \ else {\n            parens[paren_index] = 0;\n            parent_depth += 1;\n\
    \        }\n\n        paren_index += 1;\n    }\n\n    parens\n        .into_iter()\n\
    \        .map(|x| x.parse::<usize>().unwrap())\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp4dy04h2w.rs:14:25\n\
    \   |\n7  |     let mut parens = paren_string.char_indices().map(|(_, x)| x).collect();\n\
    \   |         ---------- consider giving `parens` a type\n...\n14 |     while\
    \ paren_index < parens.len() {\n   |                         ^^^^^^ cannot infer\
    \ type\n   |\n   = note: type must be known at this point\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = paren_string.chars().map(|c|\
    \ *c).filter(|c| c != '(' || c != ')').count();\n    let mut parens = paren_count;\n\
    \    let mut i = 0;\n    while i < paren_count {\n        let c = paren_string[i];\n\
    \        if c == '(' {\n            parens += 1;\n            i += 1;\n      \
    \  } else if c == ')' {\n            parens -= 1;\n            i += 1;\n     \
    \   } else {\n            i += 1;\n        }\n    }\n    parens\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmppsj0hayz.rs:7:56\n\
    \  |\n7 |     let mut paren_count = paren_string.chars().map(|c| *c).filter(|c|\
    \ c != '(' || c != ')').count();\n  |                                        \
    \                ^^\n\nerror[E0277]: can't compare `&_` with `char`\n --> /tmp/tmppsj0hayz.rs:7:73\n\
    \  |\n7 |     let mut paren_count = paren_string.chars().map(|c| *c).filter(|c|\
    \ c != '(' || c != ')').count();\n  |                                        \
    \                                 ^^ no implementation for `&_ == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n --> /tmp/tmppsj0hayz.rs:7:85\n  |\n7 |    \
    \ let mut paren_count = paren_string.chars().map(|c| *c).filter(|c| c != '(' ||\
    \ c != ')').count();\n  |                                                    \
    \                                 ^^ no implementation for `&_ == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppsj0hayz.rs:11:17\n\
    \   |\n11 |         let c = paren_string[i];\n   |                 ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppsj0hayz.rs:22:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n22 |     parens\n   |     ^^^^^^ expected struct\
    \ `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth: isize = 0;\n    let mut paren_depth_stack:\
    \ Vec<isize> = Vec::new();\n    let mut paren_depth_stack_append = |new_depth|\
    \ paren_depth_stack.push(paren_depth);\n    let mut paren_depth_stack_push_back\
    \ = |old_depth| paren_depth = paren_depth_stack.pop();\n    paren_depth_stack.append(paren_depth);\n\
    \    let mut group_start = 0;\n    let mut group_end = 0;\n\n    let mut paren_len\
    \ = paren_string.len();\n    let mut paren_char = paren_string[paren_len - 1];\n\
    \n    while paren_depth_stack.is_empty() == false {\n        let paren_depth =\
    \ paren_depth_stack.pop_back();\n        let paren_char = paren_string[paren_end];\n\
    \        paren_end = paren_end + 1;\n        paren_len = paren_string.len();\n\
    \        if paren_char == ' ' {\n            paren_len = paren_end - paren_start\
    \ + 1;\n        }\n        let mut group_end = paren_len;\n        if paren_char\
    \ == '(' { //if opening group\n            group_end = paren_end;\n          \
    \  group_start = paren_end;\n            paren_depth_stack.append(paren_depth);\n\
    \        }\n        if paren_char == ')' { //if closing group\n            group_end\
    \ = paren_len + 1;\n            if group_end > group_start {\n               \
    \ paren_depth_stack_append(paren_depth);\n                paren_depth_stack_push_back(paren_depth);\n\
    \            }\n        }\n        if group_end > group_start {\n            paren_depth_stack_append(paren_depth);\n\
    \            paren_depth_stack_push_back(paren_depth);\n        }\n    }\n\n \
    \   if paren_depth_stack.is_empty() == false {\n        paren_depth_stack_append(paren_depth);\n\
    \    }\n\n    paren_depth_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `paren_end` in this scope\n  --> /tmp/tmpiq9o9548.rs:20:39\n\
    \   |\n20 |         let paren_char = paren_string[paren_end];\n   |          \
    \                             ^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_len`\n\nerror[E0425]: cannot find value `paren_end` in this\
    \ scope\n  --> /tmp/tmpiq9o9548.rs:21:9\n   |\n21 |         paren_end = paren_end\
    \ + 1;\n   |         ^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `paren_len`\n\nerror[E0425]: cannot find value `paren_end` in this scope\n \
    \ --> /tmp/tmpiq9o9548.rs:21:21\n   |\n21 |         paren_end = paren_end + 1;\n\
    \   |                     ^^^^^^^^^ help: a local variable with a similar name\
    \ exists: `paren_len`\n\nerror[E0425]: cannot find value `paren_end` in this scope\n\
    \  --> /tmp/tmpiq9o9548.rs:24:25\n   |\n24 |             paren_len = paren_end\
    \ - paren_start + 1;\n   |                         ^^^^^^^^^ help: a local variable\
    \ with a similar name exists: `paren_len`\n\nerror[E0425]: cannot find value `paren_start`\
    \ in this scope\n  --> /tmp/tmpiq9o9548.rs:24:37\n   |\n24 |             paren_len\
    \ = paren_end - paren_start + 1;\n   |                                     ^^^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_char`\n\nerror[E0425]:\
    \ cannot find value `paren_end` in this scope\n  --> /tmp/tmpiq9o9548.rs:28:25\n\
    \   |\n28 |             group_end = paren_end;\n   |                         ^^^^^^^^^\
    \ help: a local variable with a similar name exists: `paren_len`\n\nerror[E0425]:\
    \ cannot find value `paren_end` in this scope\n  --> /tmp/tmpiq9o9548.rs:29:27\n\
    \   |\n29 |             group_start = paren_end;\n   |                       \
    \    ^^^^^^^^^ help: a local variable with a similar name exists: `paren_len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpiq9o9548.rs:10:69\n   |\n7  |\
    \     let mut paren_depth: isize = 0;\n   |                          ----- expected\
    \ due to this type\n...\n10 |     let mut paren_depth_stack_push_back = |old_depth|\
    \ paren_depth = paren_depth_stack.pop();\n   |                               \
    \         "
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<isize> = vec![];\n   \
    \ for paren in paren_string.chars() {\n        if paren == ' ' || paren == '('\
    \ || paren == ')' {\n            if paren_stack.len() == 0 {\n               \
    \ return vec![];\n            }\n            paren_stack.pop();\n            continue;\n\
    \        }\n        if paren == '{' || paren == '}' {\n            paren_stack.push(paren\
    \ as isize);\n            continue;\n        }\n        paren_stack.push(paren\
    \ as isize);\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpcseej60r.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut counter = 0;\n    let mut parens = paren_string.chars().enumerate();\n\
    \    parens.take_while(|&(_, c)| c != '(' && c != ')').collect::<Vec<isize>>().reverse().map(|x|\
    \ {\n        counter = if x.0 >= counter {\n            x.0 - counter\n      \
    \  } else {\n            counter\n        };\n        counter = x.0 + 1;\n   \
    \     counter\n    })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `(usize, char)`\n    --> /tmp/tmpuahnoqor.rs:9:55\n  \
    \   |\n9    |     parens.take_while(|&(_, c)| c != '(' && c != ')').collect::<Vec<isize>>().reverse().map(|x|\
    \ {\n     |                                                       ^^^^^^^ value\
    \ of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ char)>`\n     |\n     = help: the trait `FromIterator<(usize, char)>` is not\
    \ implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]: `()` is\
    \ not an iterator\n --> /tmp/tmpuahnoqor.rs:9:89\n  |\n9 |     parens.take_while(|&(_,\
    \ c)| c != '(' && c != ')').collect::<Vec<isize>>().reverse().map(|x| {\n  | \
    \                                                                            \
    \            ^^^ `()` is not an iterator\n  |\n  = note: the following trait bounds\
    \ were not satisfied:\n          `(): Iterator`\n          which is required by\
    \ `&mut (): Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter(|c|\
    \ *c != '(')\n        .filter(|c| *c != ')')\n        .filter(|c| *c != '\\0')\n\
    \        .fold(Vec::new(), |mut v, c| {\n            v.push((*c - '0') as isize);\n\
    \            if *c == '(' {\n                v.push(1);\n            } else if\
    \ *c == ')' {\n                v.last().unwrap() += 1;\n            }\n      \
    \      v\n        })\n        .unwrap()\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpoml0o_zz.rs:13:21\n\
    \   |\n13 |             v.push((*c - '0') as isize);\n   |                   \
    \  ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpoml0o_zz.rs:14:16\n\
    \   |\n14 |             if *c == '(' {\n   |                ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpoml0o_zz.rs:16:23\n   |\n\
    16 |             } else if *c == ')' {\n   |                       ^^\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&{integer}`\n  -->\
    \ /tmp/tmpoml0o_zz.rs:17:17\n   |\n17 |                 v.last().unwrap() += 1;\n\
    \   |                 -----------------^^^^^\n   |                 |\n   |   \
    \              cannot use `+=` on type `&{integer}`\n   |\nhelp: `+=` can be used\
    \ on `{integer}`, you can dereference `v.last().unwrap()`\n   |\n17 |        \
    \         *v.last().unwrap() += 1;\n   |                 +\n\nerror[E0067]: invalid\
    \ left-hand side of assignment\n  --> /tmp/tmpoml0o_zz.rs:17:35\n   |\n17 |  \
    \               v.last().unwrap() += 1;\n   |                 -----------------\
    \ ^^\n   |                 |\n   |                 cannot assign to this expression\n\
    \nerror[E0599]: no method named `unwrap` found for struct `Vec<{integer}>` in\
    \ the current scope\n  --> /tmp/tmpoml0o_zz.rs:21:10\n   |\n21 |         .unwrap()\n\
    \   |          ^^^^^^ help: there is an associated function with a similar name:\
    \ `swap`\n\nerror: aborting due to 6 previous errors\n\nSome errors have detailed\
    \ explanations: E0067, E0368, E0599, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0067`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split_whitespace().map(|s| s.chars().count()).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmp7h80tq87.rs:7:64\n     |\n7 \
    \   |     paren_string.split_whitespace().map(|s| s.chars().count()).collect()\n\
    \     |                                                                ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.lines()\n        .filter(|e| !e.is_empty()\
    \ && e.chars().any(|c| c == '(' || c == '[' || c == '{'))\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .enumerate()\n        .filter_map(|(idx, &line)|\
    \ {\n            line.trim()\n                .chars()\n                .enumerate()\n\
    \                .filter(|(_, c, _)| *c == ')')\n                .filter(|(_,\
    \ c, _)| *c == ']')\n                .filter(|(_, c, _)| *c == '}')\n        \
    \        .filter_map(|(_, c, _)| {\n                    if c == '(' {\n      \
    \                  Some(idx)\n                    } else if c == ']' {\n     \
    \                   Some(idx - 1)\n                    } else if c == '}' {\n\
    \                        Some(idx)\n                    } else {\n           \
    \             None\n                    }\n                })\n              \
    \  .collect::<Vec<_>>()\n        })\n        .filter_map(|idx| idx.map(|idx| idx\
    \ as usize))\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpclo64o6x.rs:12:29\n   |\n12 |         .filter_map(|(idx,\
    \ &line)| {\n   |                             ^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: all local variables must have a statically known size\n   = help:\
    \ unsized locals are gated as an unstable feature\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpclo64o6x.rs:16:26\n   |\n16 |                 .filter(|(_,\
    \ c, _)| *c == ')')\n   |                          ^^^^^^^^-\n   |           \
    \               |       |\n   |                          |       expected due\
    \ to this\n   |                          expected a tuple with 2 elements, found\
    \ one with 3 elements\n   |\n   = note: expected tuple `(usize, char)`\n     \
    \         found tuple `(_, _, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpclo64o6x.rs:17:26\n\
    \   |\n17 |                 .filter(|(_, c, _)| *c == ']')\n   |             \
    \             ^^^^^^^^-\n   |                          |       |\n   |       \
    \                   |       expected due to this\n   |                       \
    \   expected a tuple with 2 elements, found one with 3 elements\n   |\n   = note:\
    \ expected tuple `(usize, char)`\n              found tuple `(_, _, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpclo64o6x.rs:18:26\n   |\n18 |              \
    \   .filter(|(_, c, _)| *c == '}')\n   |                          ^^^^^^^^-\n\
    \   |                          |       |\n   |                          |    \
    \   expected due to this\n   |                          expected a tuple with\
    \ 2 elements, found one with 3 elements\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n              found tuple `(_, _, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpclo64o6x.rs:19:30\n   |\n19 |                 .filter_map(|(_,\
    \ c, _)| {\n   |                              ^^^^^^^^-\n   |                \
    \              |       |\n   |                              |       expected due\
    \ to this\n   |                              expected a t"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split_whitespace().filter_map(|x|\
    \ {\n        let mut i = x.chars().position(|c| c == '(');\n        match i {\n\
    \            Some(start) => {\n                if *start == '(' {\n          \
    \          return Some(start + 1);\n                } else {\n               \
    \     return Some(x.len());\n                }\n            },\n            None\
    \ => None,\n        }\n    }).cloned()\n        .filter(|x| x != x.len())\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp0ehep49u.rs:11:20\n\
    \   |\n11 |                 if *start == '(' {\n   |                    ^^^^^^\n\
    \nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmp0ehep49u.rs:7:48: 19:6]\
    \ as FnOnce<(&str,)>>::Output == Option<&_>`\n    --> /tmp/tmp0ehep49u.rs:19:8\n\
    \     |\n19   |     }).cloned()\n     |        ^^^^^^ expected reference, found\
    \ `usize`\n     |\n     = note: expected enum `Option<&_>`\n                found\
    \ enum `Option<usize>`\n     = note: required because of the requirements on the\
    \ impl of `Iterator` for `FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp0ehep49u.rs:7:48:\
    \ 19:6]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `filter`\
    \ exists for struct `Cloned<FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp0ehep49u.rs:7:48:\
    \ 19:6]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmp0ehep49u.rs:20:10\n\
    \   |\n20 |            .filter(|x| x != x.len())\n   |             ^^^^^^ method\
    \ cannot be called on `Cloned<FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp0ehep49u.rs:7:48:\
    \ 19:6]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp0ehep49u.rs:7:48:\
    \ 19:6]> as Iterator>::Item = &_`\n           which is required by `Cloned<FilterMap<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmp0ehep49u.rs:7:48: 19:6]>>: Iterator`\n           `Cloned<FilterMap<SplitWhitespace<'_>,\
    \ [closure@/tmp/tmp0ehep49u.rs:7:48: 19:6]>>: Iterator`\n           which is required\
    \ by `&mut Cloned<FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmp0ehep49u.rs:7:48:\
    \ 19:6]>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .rtrim()\n        .chars()\n\
    \        .filter_map(|c| match c {\n            '(' => Some(1),\n            ')'\
    \ => Some(-1),\n            _ => None,\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rtrim` found for struct `String` in the\
    \ current scope\n --> /tmp/tmpfoi9dktl.rs:8:10\n  |\n8 |         .rtrim()\n  |\
    \          ^^^^^ help: there is an associated function with a similar name: `trim`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = vec![];\n    for (i,\
    \ item) in paren_string.chars().enumerate() {\n        if item == '(' {\n    \
    \        stack.push(i);\n        } else if item == ')' {\n            stack.pop();\n\
    \        }\n    }\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmo41n6yh.rs:10:24\n   |\n\
    10 |             stack.push(i);\n   |                        ^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n10 |             stack.push(i.try_into().unwrap());\n\
    \   |                         ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0\n    let mut paren_level\
    \ = 0\n    let mut paren_char = None;\n    let mut group_stack = Vec::new();\n\
    \    let mut group_stack_pos = 0;\n    let mut inside_group = false;\n\n    for\
    \ c in paren_string.chars() {\n        // We are in the middle of a group\n  \
    \      if inside_group {\n            group_stack.push(paren_char.clone());\n\
    \        }\n\n        // If we are in a group, push the last character of the\
    \ previous group\n        // and increment paren_level\n        if paren_char.is_some()\
    \ {\n            paren_stack.push(*paren_char.clone());\n            paren_level\
    \ += 1;\n        }\n\n        // Update paren count\n        if c == '(' {\n \
    \           paren_count += 1;\n        } else if c == ')' {\n            paren_count\
    \ -= 1;\n        }\n\n        // If we see a right paren, pop the last element\
    \ from the stack\n        if c == '(' {\n            paren_char = group_stack.pop().unwrap();\n\
    \        }\n\n        // If we see a left paren, push the last element to the\
    \ stack\n        if c == ')' {\n            group_stack_pos += 1;\n          \
    \  group_stack.push(paren_char.clone());\n        }\n\n        // If paren_count\
    \ reaches 0, we pop the last element from the stack\n        if paren_count <=\
    \ 0 {\n            group_stack_pos -= 1;\n            group_stack.push(paren_stack.pop().unwrap());\n\
    \        }\n\n        inside_group = paren_count > 0;\n\n        if c == ')' {\n\
    \            // The current level is equal to the length of the stack when the\n\
    \            // count is zero\n            paren_level = group_stack.len();\n\
    \        }\n\n        paren_char = None;\n    }\n\n    // The final level is equal\
    \ to the length of the stack\n    group_stack.len()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpxr3d2qd7.rs:7:28\n\
    \  |\n7 |     let mut paren_count = 0\n  |                            ^ help:\
    \ add `;` here\n8 |     let mut paren_level = 0\n  |     --- unexpected token\n\
    \nerror: expected `;`, found keyword `let`\n --> /tmp/tmpxr3d2qd7.rs:8:28\n  |\n\
    8 |     let mut paren_level = 0\n  |                            ^ help: add `;`\
    \ here\n9 |     let mut paren_char = None;\n  |     --- unexpected token\n\nerror[E0425]:\
    \ cannot find value `paren_stack` in this scope\n  --> /tmp/tmpxr3d2qd7.rs:23:13\n\
    \   |\n23 |             paren_stack.push(*paren_char.clone());\n   |         \
    \    ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `paren_stack`\
    \ in this scope\n  --> /tmp/tmpxr3d2qd7.rs:48:30\n   |\n48 |             group_stack.push(paren_stack.pop().unwrap());\n\
    \   |                              ^^^^^^^^^^^ not found in this scope\n\nerror[E0614]:\
    \ type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpxr3d2qd7.rs:23:30\n \
    \  |\n23 |             paren_stack.push(*paren_char.clone());\n   |          \
    \                    ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpxr3d2qd7.rs:63:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n63 |     group_stack.len()\n\
    \   |     ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level_count = 0;\n    for paren in paren_string.chars()\
    \ {\n        if paren == ('(' as char) {\n            level_count += 1;\n    \
    \    } else if paren == ')' as char {\n            level_count -= 1;\n       \
    \ }\n\n        if level_count == 0 {\n            return vec![level_count];\n\
    \        }\n    }\n\n    error!(\"invalid nested parens\");\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `error` in this scope\n  --> /tmp/tmpm4i75gyo.rs:20:5\n\
    \   |\n20 |     error!(\"invalid nested parens\");\n   |     ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpm4i75gyo.rs:6:49\n  |\n6 | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |    -------------------                        \
    \  ^^^^^^^^^^ expected struct `Vec`, found `()`\n  |    |\n  |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n          found unit type `()`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level: isize = 1;\n    let mut stack =\
    \ vec![false; paren_string.len()];\n\n    for paren in paren_string.chars().filter_map(|c|\
    \ {\n        if c == '(' || c == '[' || c == '{' {\n            stack.push(true);\n\
    \        }\n        if c == '}' || c == ']' || c == ')' {\n            stack.pop();\n\
    \        }\n        stack[stack.len()-1]\n    }) {\n        level = level.max(stack.iter().position(|s|\
    \ !s).unwrap_or(0)+1);\n    }\n    level\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr4jf30lt.rs:17:9\n   |\n\
    17 |         stack[stack.len()-1]\n   |         ^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         Some(stack[stack.len()-1])\n   |         +++++           \
    \         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr4jf30lt.rs:19:27\n\
    \   |\n19 |         level = level.max(stack.iter().position(|s| !s).unwrap_or(0)+1);\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n19 |         level = level.max((stack.iter().position(|s|\
    \ !s).unwrap_or(0)+1).try_into().unwrap());\n   |                           +\
    \                                            +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr4jf30lt.rs:21:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n21 |     level\n\
    \   |     ^^^^^ expected struct `Vec`, found `isize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `isize`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .rsplitn(2, ' ')\n      \
    \  .map(|x| x.parse().unwrap())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmplefmz6nc.rs:9:28

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![-1isize..];\n    let\
    \ mut depth_stack = vec![-1isize..];\n    let mut parentheses = vec![];\n    let\
    \ mut current_parentheses = &mut paren_stack;\n    for paren in paren_string.chars()\
    \ {\n        match paren {\n            '(' | '[' | '{' => {\n               \
    \ current_parentheses.push(*paren);\n            }\n            ')' | '}' | ']'\
    \ => {\n                current_parentheses.pop();\n            }\n          \
    \  _ => (),\n        }\n\n        match paren {\n            ')' => {\n      \
    \          let mut last = paren_stack.last().unwrap();\n                let mut\
    \ depth = depth_stack.pop().unwrap();\n                if last == *paren {\n \
    \                   parentheses.push(*paren - 1 + depth);\n                } else\
    \ {\n                    parentheses.push(-depth);\n                }\n      \
    \      }\n            _ => (),\n        }\n        depth_stack.push(*current_parentheses);\n\
    \        current_parentheses = &mut paren_stack;\n    }\n    parentheses.reverse()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp38w_y6nj.rs:14:42\n\
    \   |\n14 |                 current_parentheses.push(*paren);\n   |          \
    \                                ^^^^^^\n\nerror[E0614]: type `char` cannot be\
    \ dereferenced\n  --> /tmp/tmp38w_y6nj.rs:26:28\n   |\n26 |                 if\
    \ last == *paren {\n   |                            ^^^^^^\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp38w_y6nj.rs:27:38\n   |\n27 | \
    \                    parentheses.push(*paren - 1 + depth);\n   |             \
    \                         ^^^^^^\n\nerror[E0600]: cannot apply unary operator\
    \ `-` to type `RangeFrom<isize>`\n  --> /tmp/tmp38w_y6nj.rs:29:38\n   |\n29 |\
    \                     parentheses.push(-depth);\n   |                        \
    \              ^^^^^^ cannot apply unary operator `-`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp38w_y6nj.rs:34:26\n   |\n34 |         depth_stack.push(*current_parentheses);\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^ expected struct `RangeFrom`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `RangeFrom<_>`\n      \
    \        found struct `Vec<RangeFrom<_>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp38w_y6nj.rs:37:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n37 |     parentheses.reverse()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n           found unit type `()`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0600, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens_stack: Vec<isize> = Vec::new();\n\
    \    let mut parens_stack_size = parens_stack.len();\n    let mut parens_stack_p\
    \ = parens_stack.as_mut_slice();\n    parens_stack_p\n        .extend_from_slice(paren_string.chars().filter_map(|c|\
    \ {\n            match c {\n                '(' as c | ')' as c => Some(1),\n\
    \                _ => None,\n            }\n        }));\n    while parens_stack_size.saturating_sub(parens_stack.len())\
    \ > 0 {\n        let last_parens_stack_p = parens_stack_p.last().unwrap();\n \
    \       if parens_stack_size.saturating_sub(parens_stack.len()) == 0 {\n     \
    \       parens_stack_p = parens_stack;\n        } else {\n            let mut\
    \ parens_stack_p_copy = parens_stack_p.clone();\n            let mut parens_stack_size_copy\
    \ = parens_stack_size;\n            parens_stack_p_copy\n                .extend(parens_stack_p.pop().unwrap().into_iter().cloned());\n\
    \            parens_stack_p_copy\n                .extend(parens_stack_p.pop().unwrap().into_iter().cloned());\n\
    \            let mut last_parens_stack_p_copy = last_parens_stack_p.clone();\n\
    \            last_parens_stack_p_copy\n                .append(parens_stack_p_copy.pop().unwrap());\n\
    \            last_parens_stack_p_copy\n                .append(parens_stack_p_copy.pop().unwrap());\n\
    \            parens_stack = parens_stack_p_copy;\n            parens_stack_size\
    \ = parens_stack_size_copy;\n        }\n    }\n    parens_stack\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpsbym1fus.rs:13:21\n   |\n13 |                 '(' as c |\
    \ ')' as c => Some(1),\n   |                     ^^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror[E0599]: no method named `extend_from_slice`\
    \ found for mutable reference `&mut [isize]` in the current scope\n  --> /tmp/tmpsbym1fus.rs:11:10\n\
    \   |\n11 |         .extend_from_slice(paren_string.chars().filter_map(|c| {\n\
    \   |          ^^^^^^^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `clone_from_slice`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsbym1fus.rs:20:30\n\
    \   |\n9  |     let mut parens_stack_p = parens_stack.as_mut_slice();\n   |  \
    \                            --------------------------- expected due to this\
    \ value\n...\n20 |             parens_stack_p = parens_stack;\n   |          \
    \                    ^^^^^^^^^^^^ expected `&mut [isize]`, found struct `Vec`\n\
    \   |\n   = note: expected mutable reference `&mut [isize]`\n                \
    \         found struct `Vec<isize>`\nhelp: consider dereferencing here to assign\
    \ to the mutable borrowed piece of memory\n   |\n20 |             *parens_stack_p\
    \ = parens_stack;\n   |             +\n\nerror[E0599]: no method named `clone`\
    \ found for mutable reference `&mut [isize]` in the current scope\n  --> /tmp/tmpsbym1fus.rs:22:58\n\
    \   |\n22 |             let mut parens_stack_p_copy = parens_stack_p.clone();\n\
    \   |                                                          ^^^^^ method not\
    \ found in `&mut [isize]`\n\nerror[E0599]: no method named `pop` found for mutable\
    \ reference `&mut [isize]` in the current scope\n  --> /tmp/tmpsbym1fus.rs:25:40\n\
    \   |\n25 |                 .extend(parens_stack_p.pop().unwrap().into_iter().cloned());\n\
    \   |                                        ^^^ method not found in `&mut [isize]`\n\
    \nerror[E0599]: no method named `pop` found for mutable reference `&mut [isize]`\
    \ in the current scope\n  --> /tmp/tmpsbym1fus.rs:27:40\n   |\n27 |          \
    \       .extend(parens_stack_p.pop().unwrap().into_iter().clone"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut paren_depth\
    \ = 0;\n\n    for paren in paren_string.chars() {\n        if paren == ')' {\n\
    \            paren_depth += 1;\n        }\n        if paren == '(' {\n       \
    \     paren_depth += 1;\n        }\n        if paren_depth == paren.len() {\n\
    \            paren_stack.push(paren_depth);\n            paren_depth = 0;\n  \
    \      }\n    }\n\n    paren_stack.reverse();\n    paren_stack\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpasibswof.rs:17:33\n   |\n17 |         if paren_depth ==\
    \ paren.len() {\n   |                                 ^^^ method not found in\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Initialize an empty paren stack.\n    let mut\
    \ paren_stack: Vec<isize> = Vec::new();\n\n    // Keep a record of the deepest\
    \ level of parens we encountered.\n    let mut paren_depth = 0;\n    // Loop over\
    \ the string char-by-char.\n    for c in paren_string.chars() {\n        // If\
    \ c is a left paren, push it to the stack.\n        if c == '(' {\n          \
    \  paren_stack.push(paren_depth);\n        }\n        // If c is a right paren,\
    \ pop it from the stack.\n        if c == ')' {\n            paren_depth -= paren_stack.pop();\n\
    \        }\n    }\n\n    // Return the amount of nested parentheses encountered.\n\
    \    paren_depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `Option<isize>` from `isize`\n  -->\
    \ /tmp/tmpz16devz9.rs:20:25\n   |\n20 |             paren_depth -= paren_stack.pop();\n\
    \   |                         ^^ no implementation for `isize -= Option<isize>`\n\
    \   |\n   = help: the trait `SubAssign<Option<isize>>` is not implemented for\
    \ `isize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz16devz9.rs:25:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n25 |     paren_depth\n   |     ^^^^^^^^^^^ expected\
    \ struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .trim()\n        .chars()\n\
    \        .enumerate()\n        .filter_map(|(index, ch)| {\n            match\
    \ ch {\n                '(' => Some(index),\n                '(' | ')' => Some(index\
    \ - 1),\n                _ => None,\n            }\n        })\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps99nmzur.rs:7:5\n   |\n6\
    \  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |    \
    \                                               ---------- expected `Vec<isize>`\
    \ because of return type\n7  | /     paren_string\n8  | |         .trim()\n9 \
    \ | |         .chars()\n10 | |         .enumerate()\n...  |\n17 | |         })\n\
    18 | |         .collect::<Vec<_>>()\n   | |____________________________^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_char_count\
    \ = paren_string.chars().filter(|c| c == '(' || c == '[' || c == '{').count();\n\
    \    let mut paren_char_level = paren_string.chars().filter(|c| c == '(' || c\
    \ == '[' || c == '{').count();\n    let mut paren_levels = Vec::new();\n    paren_string.chars()\n\
    \        .filter(|c| c == '(' || c == '[' || c == '{')\n        .for_each(|c|\
    \ {\n            paren_char_count = 0;\n            paren_char_level = 0;\n  \
    \          if paren_char_level > paren_level {\n                paren_level =\
    \ paren_char_level;\n            }\n            if paren_char_level == paren_level\
    \ {\n                paren_levels.push(paren_level);\n            }\n        \
    \    paren_char_level += 1;\n            paren_char_count += 1;\n        });\n\
    \    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp7c24902k.rs:8:66\n\
    \  |\n8 |     let mut paren_char_count = paren_string.chars().filter(|c| c ==\
    \ '(' || c == '[' || c == '{').count();\n  |                                 \
    \                                 ^^ no implementation for `&char == char`\n \
    \ |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  =\
    \ help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmp7c24902k.rs:8:78\n  |\n8 |     let\
    \ mut paren_char_count = paren_string.chars().filter(|c| c == '(' || c == '['\
    \ || c == '{').count();\n  |                                                 \
    \                             ^^ no implementation for `&char == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n --> /tmp/tmp7c24902k.rs:8:90\n  |\n8 |     let mut paren_char_count\
    \ = paren_string.chars().filter(|c| c == '(' || c == '[' || c == '{').count();\n\
    \  |                                                                         \
    \                 ^^ no implementation for `&char == char`\n  |\n  = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n --> /tmp/tmp7c24902k.rs:9:66\n  |\n9 |     let mut paren_char_level\
    \ = paren_string.chars().filter(|c| c == '(' || c == '[' || c == '{').count();\n\
    \  |                                                                  ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n --> /tmp/tmp7c24902k.rs:9:78\n  |\n9 | \
    \    let mut paren_char_level = paren_string.chars().filter(|c| c == '(' || c\
    \ == '[' || c == '{').count();\n  |                                          \
    \                                    ^^ "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depths = vec![0];\n    let mut paren_levels\
    \ = vec![0];\n    for (i, c) in paren_string.chars().enumerate() {\n        if\
    \ c == '(' {\n            paren_depths.push(paren_depths.last().unwrap() + 1);\n\
    \            paren_levels.push(0);\n        } else if c == ')' {\n           \
    \ paren_depths.push(paren_depths.last().unwrap());\n            paren_levels.push(paren_levels.last().unwrap()\
    \ - 1);\n        } else {\n            let depth = paren_depths.last().unwrap();\n\
    \            let level = paren_levels.last().unwrap();\n            if level >=\
    \ depth {\n                paren_depths.push(depth);\n                paren_levels.push(level);\n\
    \            }\n        }\n    }\n    paren_depths\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxbk0c2ll.rs:14:31\n   |\n\
    14 |             paren_depths.push(paren_depths.last().unwrap());\n   |      \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer, found\
    \ `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n14 |    \
    \         paren_depths.push(*paren_depths.last().unwrap());\n   |            \
    \                   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxbk0c2ll.rs:20:35\n\
    \   |\n20 |                 paren_depths.push(depth);\n   |                  \
    \                 ^^^^^ expected integer, found `&{integer}`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n20 |                 paren_depths.push(*depth);\n\
    \   |                                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxbk0c2ll.rs:21:35\n   |\n21 |                 paren_levels.push(level);\n\
    \   |                                   ^^^^^ expected integer, found `&{integer}`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n21 |                 paren_levels.push(*level);\n\
    \   |                                   +\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Parse the string and split it into groups of\
    \ nested parentheses\n    let mut paren_groups = paren_string\n        .chars()\n\
    \        .filter(|c| c == '(' || c == ')')\n        .collect::<Vec<_>>();\n\n\
    \    // If there are more than two parens, then the string is not valid.\n   \
    \ if paren_groups.len() > 2 {\n        return vec![0];\n    }\n\n    // The deepest\
    \ nesting level of parenthesis is one more than the number of groups of parens\n\
    \    return paren_groups.iter().map(|c| paren_groups.iter().filter(c == c).count()\
    \ as isize + 1).collect();\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphomg2rhl.rs:10:23\n\
    \   |\n10 |         .filter(|c| c == '(' || c == ')')\n   |                  \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmphomg2rhl.rs:10:35\n\
    \   |\n10 |         .filter(|c| c == '(' || c == ')')\n   |                  \
    \                 ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: expected a `FnMut<(&&char,)>`\
    \ closure, found `bool`\n   --> /tmp/tmphomg2rhl.rs:19:67\n    |\n19  |     return\
    \ paren_groups.iter().map(|c| paren_groups.iter().filter(c == c).count() as isize\
    \ + 1).collect();\n    |                                                     \
    \       ------ ^^^^^^ expected an `FnMut<(&&char,)>` closure, found `bool`\n \
    \   |                                                            |\n    |    \
    \                                                        required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `for<'r> FnMut<(&'r &char,)>` is\
    \ not implemented for `bool`\nnote: required by a bound in `filter`\n\nerror[E0599]:\
    \ the method `count` exists for struct `Filter<std::slice::Iter<'_, char>, bool>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmphomg2rhl.rs:19:75\n \
    \  |\n19 |       return paren_groups.iter().map(|c| paren_groups.iter().filter(c\
    \ == c).count() as isize + 1).collect();\n   |                               \
    \                                              ^^^^^ method cannot be called on\
    \ `Filter<std::slice::Iter<'_, char>, bool>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<bool\
    \ as FnOnce<(&&char,)>>::Output = bool`\n           which is required by `Filter<std::slice::Iter<'_,\
    \ char>, bool>: Iterator`\n           `bool: FnMut<(&&char,)>"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = paren_string.chars().filter(|c|\
    \ c != '(').count() - 1;\n    levels = match levels {\n        0 => panic!(\"\
    Empty input\"),\n        1 => 0,\n        _ => levels,\n    };\n\n    paren_string.chars()\n\
    \        .filter(|c| c != '(')\n        .flat_map(|c| {\n            levels -\
    \ paren_string\n                .chars()\n                .filter(|d| d != c)\n\
    \                .count() - 1,\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmp1ffcoxr3.rs:20:29\n   |\n20 |                 .count() - 1,\n \
    \  |                             ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp1ffcoxr3.rs:7:56\n\
    \  |\n7 |     let mut levels = paren_string.chars().filter(|c| c != '(').count()\
    \ - 1;\n  |                                                        ^^ no implementation\
    \ for `&char == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n  = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp1ffcoxr3.rs:15:23\n   |\n15\
    \ |         .filter(|c| c != '(')\n   |                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().map(|c| {\n        match c\
    \ {\n            '(' | ')' | ' ' as i => i,\n            _ => unreachable!(\"\
    Cannot parse paren string: {}\", paren_string),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n --> /tmp/tmpvq8frwhq.rs:9:29\n  |\n9 |             '(' | ')' | ' ' as\
    \ i => i,\n  |                             ^^ expected one of `...`, `..=`, `..`,\
    \ `=>`, `if`, or `|`\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting_level = 1;\n    let mut nesting_levels:\
    \ Vec<isize> = Vec::new();\n    loop {\n        let mut i = paren_string.find('(');\n\
    \        if i == paren_string.len() {\n            break;\n        }\n       \
    \ let mut j = paren_string.rfind(')');\n        if j == paren_string.len() {\n\
    \            break;\n        }\n        if nesting_level == 1 {\n            nesting_levels.push(0);\n\
    \        }\n        nesting_levels.push(nesting_level);\n        while nesting_level\
    \ > 0 && i >= 0 && i < j {\n            let j = paren_string.rfind(')', i + 1);\n\
    \            if j == 0 {\n                break;\n            }\n            nesting_level\
    \ = nesting_level - 1;\n            i = j;\n        }\n        if nesting_level\
    \ == 1 {\n            nesting_levels.push(0);\n        }\n    }\n    let mut max_nesting_level\
    \ = nesting_level;\n    for i in nesting_levels.iter() {\n        if i >= max_nesting_level\
    \ {\n            max_nesting_level = i;\n        }\n    }\n    nesting_levels.iter().max().unwrap_or(max_nesting_level)\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_1dvm7mn.rs:11:17\n   |\n\
    11 |         if i == paren_string.len() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n11 |         if i == Some(paren_string.len()) {\n   |                 +++++\
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_1dvm7mn.rs:15:17\n\
    \   |\n15 |         if j == paren_string.len() {\n   |                 ^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |         if j == Some(paren_string.len()) {\n   |                 +++++\
    \                  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_1dvm7mn.rs:22:41\n\
    \   |\n22 |         while nesting_level > 0 && i >= 0 && i < j {\n   |       \
    \                                  ^ expected enum `Option`, found integer\n \
    \  |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n22 |         while nesting_level\
    \ > 0 && i >= Some(0) && i < j {\n   |                                       \
    \  +++++ +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmp_1dvm7mn.rs:23:47\n\
    \   |\n23 |             let j = paren_string.rfind(')', i + 1);\n   |        \
    \                                     - ^ - {integer}\n   |                  \
    \                           |\n   |                                          \
    \   Option<usize>\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmp_1dvm7mn.rs:23:34\n     |\n23   |           \
    \  let j = paren_string.rfind(')', i + 1);\n     |                           \
    \       ^^^^^ ---  ----- supplied 2 arguments\n     |                        \
    \          |\n     |                                  expected 1 argument\n  \
    \   |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth = 0;\n    let mut paren_nest_level\
    \ = -1;\n    let mut paren_nest_level_vec = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        paren_depth = paren_depth + (c.is_whitespace() ? 0 : 1);\n      \
    \  if paren_depth >= 0 {\n            paren_depth--;\n            paren_nest_level_vec.push(paren_nest_level);\n\
    \        }\n        if c == '(' {\n            paren_nest_level += 1;\n      \
    \  }\n        if c == ')' {\n            paren_nest_level -= 1;\n            if\
    \ paren_nest_level < 0 {\n                panic!(\"Found too many unmatched parens\"\
    );\n            }\n        }\n    }\n    paren_nest_level_vec\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `0`\n\
    \  --> /tmp/tmpxa_hm5fl.rs:11:58\n   |\n11 |         paren_depth = paren_depth\
    \ + (c.is_whitespace() ? 0 : 1);\n   |                                       \
    \                   ^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror:\
    \ expected one of `!`, `&&`, `&`, `(`, `)`, `*`, `...`, `.`, `;`, `<`, `?`, `[`,\
    \ `_`, `async`, `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, `}`,\
    \ `~`, an operator, lifetime, or path, found `1`\n  --> /tmp/tmpxa_hm5fl.rs:11:62\n\
    \   |\n11 |         paren_depth = paren_depth + (c.is_whitespace() ? 0 : 1);\n\
    \   |                                                              ^ expected\
    \ one of 26 possible tokens\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    paren_string.chars().filter_map(|c|\
    \ c.is_ascii()).for_each(|c| {\n        if c != '(' && c != ')' {\n          \
    \  return;\n        }\n        let mut index = 0;\n        for group in paren_string.split_whitespace()\
    \ {\n            let mut end = group.len();\n            if end > index {\n  \
    \              break;\n            }\n            index = end;\n            match\
    \ group.get(index) {\n                '(' | ')' => {}\n                ',' =>\
    \ break,\n                _ => {\n                    index += 1;\n          \
    \      }\n            }\n        }\n        index\n    })\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp49h7alqk.rs:8:41\n  |\n8 |\
    \     paren_string.chars().filter_map(|c| c.is_ascii()).for_each(|c| {\n  |  \
    \                                       ^^^^^^^^^^^^ expected enum `Option`, found\
    \ `bool`\n  |\n  = note: expected enum `Option<_>`\n             found type `bool`\n\
    help: try wrapping the expression in `Some`\n  |\n8 |     paren_string.chars().filter_map(|c|\
    \ Some(c.is_ascii())).for_each(|c| {\n  |                                    \
    \     +++++            +\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n   --> /tmp/tmp49h7alqk.rs:19:29\n    |\n19  |             match group.get(index)\
    \ {\n    |                         --- ^^^^^ string indices are ranges of `usize`\n\
    \    |                         |\n    |                         required by a\
    \ bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp49h7alqk.rs:20:17\n   |\n19 |             match\
    \ group.get(index) {\n   |                   ---------------- this expression\
    \ has type `Option<&_>`\n20 |                 '(' | ')' => {}\n   |          \
    \       ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<&_>`\n              found type `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp49h7alqk.rs:20:23\n   |\n19 |             match group.get(index)\
    \ {\n   |                   ---------------- this expression has type `Option<&_>`\n\
    20 |                 '(' | ')' => {}\n   |                       ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&_>`\n \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp49h7alqk.rs:21:17\n\
    \   |\n19 |             match group.get(index) {\n   |                   ----------------\
    \ this expression has type `Option<&_>`\n20 |                 '(' | ')' => {}\n\
    21 |                 ',' => break,\n   |                 ^^^ expected en"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.lines()\n        .filter_map(|line|\
    \ line.chars().count() > 0)\n        .filter(|c| c == ')')\n        .enumerate()\n\
    \        .filter_map(|(idx, c)| {\n            if c == '(' {\n               \
    \ Some(idx)\n            } else {\n                None\n            }\n     \
    \   })\n        .max()\n        .unwrap()\n        .clone()\n        .into()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmp9dtolqws.rs:8:28\n  |\n8 |\
    \         .filter_map(|line| line.chars().count() > 0)\n  |                  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n  |\n\
    \  = note: expected enum `Option<_>`\n             found type `bool`\nhelp: try\
    \ wrapping the expression in `Some`\n  |\n8 |         .filter_map(|line| Some(line.chars().count()\
    \ > 0))\n  |                            +++++                        +\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n --> /tmp/tmp9dtolqws.rs:9:23\n  |\n9 |    \
    \     .filter(|c| c == ')')\n  |                       ^^ no implementation for\
    \ `&_ == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: the trait bound `Vec<isize>: From<usize>` is not satisfied\n\
    \  --> /tmp/tmp9dtolqws.rs:21:10\n   |\n21 |         .into()\n   |          ^^^^\
    \ the trait `From<usize>` is not implemented for `Vec<isize>`\n   |\n   = help:\
    \ the following other types implement trait `From<T>`:\n             <Vec<T, A>\
    \ as From<Box<[T], A>>>\n             <Vec<T, A> as From<VecDeque<T, A>>>\n  \
    \           <Vec<T> as From<&[T]>>\n             <Vec<T> as From<&mut [T]>>\n\
    \             <Vec<T> as From<BinaryHeap<T>>>\n             <Vec<T> as From<Cow<'a,\
    \ [T]>>>\n             <Vec<T> as From<[T; N]>>\n             <Vec<u8> as From<&str>>\n\
    \           and 2 others\n   = note: required because of the requirements on the\
    \ impl of `Into<Vec<isize>>` for `usize`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.rsplitn(2, \" \").map(|elem| elem.len()).max()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmplzm5h5.rs:7:5\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |          \
    \                                       ---------- expected `Vec<isize>` because\
    \ of return type\n7 |     paren_string.rsplitn(2, \" \").map(|elem| elem.len()).max()\n\
    \  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found enum `Option`\n  |\n  = note: expected struct `Vec<isize>`\n  \
    \             found enum `Option<usize>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n    let mut level = 0;\n\
    \    let mut paren_level = 0;\n    for char in paren_string.chars() {\n      \
    \  paren_level += 1;\n        if char == '(' {\n            level += 1;\n    \
    \    } else if char == ')' {\n            level -= 1;\n            if level ==\
    \ 0 {\n                max_level = paren_level;\n            }\n        }\n  \
    \  }\n    Vec::new()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpu69yt8sq.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level = 0;\n    let mut paren_stack:\
    \ Vec<_> = Vec::new();\n    let mut paren_level_count: Vec<_> = Vec::new();\n\
    \    for (i, paren) in paren_string.char_indices().rev() {\n        if paren ==\
    \ '(' {\n            paren_stack.push(paren);\n            paren_level_count.push(paren_level);\n\
    \        }\n        if paren == ')' {\n            paren_level_count\n       \
    \         .pop()\n                .unwrap_or(0)\n                += paren_level_count\n\
    \                .pop()\n                .unwrap_or(0);\n            if paren_level_count.pop()\
    \ == 0 {\n                paren_stack.pop()\n            }\n        }\n      \
    \  if paren == ',' {\n            paren_level_count\n                .pop()\n\
    \                .unwrap_or(0)\n                += paren_level_count\n       \
    \         .pop()\n                .unwrap_or(0);\n        }\n    }\n    paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpm2qdg691.rs:19:17\n\
    \   |\n16 | /             paren_level_count\n17 | |                 .pop()\n18\
    \ | |                 .unwrap_or(0)\n   | |_____________________________- cannot\
    \ assign to this expression\n19 |                   += paren_level_count\n   |\
    \                   ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm2qdg691.rs:22:43\n\
    \   |\n22 |             if paren_level_count.pop() == 0 {\n   |              \
    \                             ^ expected enum `Option`, found integer\n   |\n\
    \   = note: expected enum `Option<{integer}>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n22 |             if paren_level_count.pop()\
    \ == Some(0) {\n   |                                           +++++ +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm2qdg691.rs:23:17\n   |\n22 | /            \
    \ if paren_level_count.pop() == 0 {\n23 | |                 paren_stack.pop()\n\
    \   | |                 ^^^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n\
    24 | |             }\n   | |_____________- expected this to be `()`\n   |\n  \
    \ = note: expected unit type `()`\n                   found enum `Option<char>`\n\
    help: consider using a semicolon here\n   |\n23 |                 paren_stack.pop();\n\
    \   |                                  +\nhelp: consider using a semicolon here\n\
    \   |\n24 |             };\n   |              +\n\nerror[E0067]: invalid left-hand\
    \ side of assignment\n  --> /tmp/tmpm2qdg691.rs:30:17\n   |\n27 | /          \
    \   paren_level_count\n28 | |                 .pop()\n29 | |                 .unwrap_or(0)\n\
    \   | |_____________________________- cannot assign to this expression\n30 | \
    \                  += paren_level_count\n   |                   ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpm2qdg691.rs:35:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n35 |     paren_level\n\
    \   |     ^^^^^^^^^^^ expected struct `Vec`, found integer\n   |\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level = 0;\n\
    \    let mut opening_paren_levels = 0;\n\n    let mut paren_levels: Vec<_> = paren_string.split_whitespace().flat_map(|x|\
    \ x.chars().filter(|x| *x != ',')).map(|x| {\n        if *x == ')' {\n       \
    \     *x = ')';\n            paren_levels\n        } else {\n            *x =\
    \ '(';\n            paren_levels += 1;\n            paren_level\n        }\n \
    \   }).collect();\n\n    while *paren_levels.last() == ',' {\n        *paren_levels.pop();\n\
    \        paren_level += 1;\n    }\n\n    while *paren_levels.last() == ')' {\n\
    \        *paren_levels.pop();\n        paren_level -= 1;\n    }\n\n    *paren_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `paren_levels` in this scope\n  --> /tmp/tmps0hta70g.rs:14:13\n\
    \   |\n14 |             paren_levels\n   |             ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `paren_level`\n\nerror[E0425]: cannot find\
    \ value `paren_levels` in this scope\n  --> /tmp/tmps0hta70g.rs:17:13\n   |\n\
    17 |             paren_levels += 1;\n   |             ^^^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `paren_level`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:12:12\n   |\n12 |        \
    \ if *x == ')' {\n   |            ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmps0hta70g.rs:13:13\n   |\n13 |             *x = ')';\n   |     \
    \        ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:16:13\n\
    \   |\n16 |             *x = '(';\n   |             ^^\n\nerror[E0614]: type `Option<&_>`\
    \ cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:22:11\n   |\n22 |     while\
    \ *paren_levels.last() == ',' {\n   |           ^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<_>` cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:23:9\n  \
    \ |\n23 |         *paren_levels.pop();\n   |         ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `Option<&_>` cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:27:11\n\
    \   |\n27 |     while *paren_levels.last() == ')' {\n   |           ^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmps0hta70g.rs:28:9\n\
    \   |\n28 |         *paren_levels.pop();\n   |         ^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmps0hta70g.rs:32:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n32 |     *paren_levels\n   |     ^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found slice\n   |\n   = note: expected struct `Vec<isize>`\n \
    \              found slice `[_]`\nhelp: try using a conversion method\n   |\n\
    32 |     (*paren_levels).to_vec()\n   |     +             ++++++++++\nhelp: parenthe"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = paren_string.chars().filter(|x|\
    \ *x != '(').collect::<Vec<_>>();\n    loop {\n        let top = stack.pop().unwrap();\n\
    \        let right = stack.last_mut().unwrap();\n        let next = right.chars().filter(|x|\
    \ *x != '(').collect::<Vec<_>>();\n        let mut level = next.len();\n     \
    \   while let Some(next) = next {\n            stack[level] = *next;\n       \
    \     stack.push(top);\n            level += 1;\n        }\n        if level ==\
    \ stack.len() {\n            stack.push(top);\n            break;\n        }\n\
    \    }\n    stack\n        .iter()\n        .map(|x| *x as isize)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for mutable reference `&mut\
    \ char` in the current scope\n  --> /tmp/tmpivf6ehbd.rs:11:26\n   |\n11 |    \
    \     let next = right.chars().filter(|x| *x != '(').collect::<Vec<_>>();\n  \
    \ |                          ^^^^^ method not found in `&mut char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels: Vec<isize> = paren_string.split_whitespace().collect();\n\
    \    let mut levels_sum: isize = 0;\n    for level in levels {\n        let mut\
    \ level_sum = 0;\n        for character in level {\n            if character !=\
    \ '(' && character != ')' {\n                level_sum += 1;\n            }\n\
    \        }\n        levels_sum += level_sum;\n    }\n\n    levels_sum.max()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp2gqp32og.rs:7:66\n     |\n7  \
    \  |     let mut levels: Vec<isize> = paren_string.split_whitespace().collect();\n\
    \     |                                                                  ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: `isize` is not an iterator\n  --> /tmp/tmp2gqp32og.rs:11:26\n\
    \   |\n11 |         for character in level {\n   |                          ^^^^^\
    \ `isize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `isize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `isize`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmp2gqp32og.rs:19:16\n    |\n19  |  \
    \   levels_sum.max()\n    |                ^^^- supplied 0 arguments\n    |  \
    \              |\n    |                expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2gqp32og.rs:19:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     levels_sum.max()\n   |     ^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars()\n        .filter_map(|c| match\
    \ c {\n            '(' => Some(1),\n            '[' => Some(2),\n            ']'\
    \ => Some(3),\n            _ => None,\n        })\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpxynx1176.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_count = 0;\n\
    \    let mut paren_string = paren_string.into_bytes();\n    paren_string.truncate(0);\n\
    \    let mut last_char = String::new();\n    let mut last_end = 0;\n    while\
    \ paren_string.len() != 0 {\n        let curr_char = paren_string.get_u8();\n\
    \        if curr_char == 0 {\n            level = 0;\n        } else {\n     \
    \       level += 1;\n        }\n        paren_count += 1;\n        if level ==\
    \ 0 {\n            last_end = paren_string.len();\n            paren_string.extend(&[255]);\n\
    \        } else {\n            if level == 1 && paren_string.len() == 1 {\n  \
    \              paren_string.extend(&[curr_char]);\n                continue;\n\
    \            }\n            last_char = paren_string.get_u8();\n        }\n  \
    \      if paren_count >= 2 {\n            break;\n        }\n    }\n    level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_u8` found for struct `Vec<u8>` in the\
    \ current scope\n  --> /tmp/tmpp5bnvec4.rs:14:38\n   |\n14 |         let curr_char\
    \ = paren_string.get_u8();\n   |                                      ^^^^^^ help:\
    \ there is an associated function with a similar name: `get`\n\nerror[E0599]:\
    \ no method named `get_u8` found for struct `Vec<u8>` in the current scope\n \
    \ --> /tmp/tmpp5bnvec4.rs:29:38\n   |\n29 |             last_char = paren_string.get_u8();\n\
    \   |                                      ^^^^^^ help: there is an associated\
    \ function with a similar name: `get`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpp5bnvec4.rs:35:5\n   |\n6  | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n   |                                                 ----------\
    \ expected `Vec<isize>` because of return type\n...\n35 |     level\n   |    \
    \ ^^^^^ expected struct `Vec`, found integer\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found type `{integer}`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_map = paren_string\n        .chars()\n\
    \        .filter_map(|ch| {\n            if ch == b'(' || ch == b'{'\n       \
    \         || ch == b'['\n                || ch == b'|'\n            {\n      \
    \          Some(ch)\n            } else {\n                None\n            }\n\
    \        })\n        .collect::<Vec<_>>();\n    let mut paren_stack: Vec<isize>\
    \ = paren_map.iter().cloned().collect();\n\n    let mut num_paren = paren_stack.len();\n\
    \n    for i in 0..paren_stack.len() {\n        if paren_stack[i] != ')' {\n  \
    \          paren_stack[i] += num_paren;\n            paren_stack[i] = paren_stack[i]\
    \ + i;\n        }\n    }\n\n    let mut stack: Vec<isize> = paren_stack.iter().cloned().collect();\n\
    \    let mut stack_size = 0;\n    while stack.len() > stack_size {\n        stack_size\
    \ += stack[stack.len() - 1];\n        stack.pop();\n    }\n    stack\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo_af7qkd.rs:10:22\n   |\n\
    10 |             if ch == b'(' || ch == b'{'\n   |                      ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_af7qkd.rs:10:36\n\
    \   |\n10 |             if ch == b'(' || ch == b'{'\n   |                    \
    \                ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo_af7qkd.rs:11:26\n   |\n11 |                 || ch ==\
    \ b'['\n   |                          ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpo_af7qkd.rs:12:26\n   |\n12 |              \
    \   || ch == b'|'\n   |                          ^^^^ expected `char`, found `u8`\n\
    \nerror[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpo_af7qkd.rs:20:65\n     |\n20\
    \   |     let mut paren_stack: Vec<isize> = paren_map.iter().cloned().collect();\n\
    \     |                                                                 ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo_af7qkd.rs:25:30\n\
    \   |\n25 |         if paren_stack[i] != ')' {\n   |                         \
    \     ^^^ expected `isize`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpo_af7qkd.rs:26:31\n   |\n26 |             paren_stack[i] += num_paren;\n\
    \   |                               ^^^^^^^^^ expected `isize`, found `usize`\n\
    \nerror[E0277]: cannot add-assign `usize` to `isize`\n  --> /tmp/tmpo_af7qkd.rs:26:28\n\
    \   |\n26 |             paren_stack[i] += num_paren;\n   |                   \
    \         ^^ no implementation for `isize += usize`\n   |\n   = help: the trait\
    \ `AddAssign<usize>` is not implemented for `isize`\n   = help: the following\
    \ other types implement trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n\
    \       "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0usize;\n    let mut depth\
    \ = 0usize;\n    for c in paren_string.chars() {\n        if c == '(' {\n    \
    \        paren_count += 1;\n            depth -= 1;\n        } else if c == ')'\
    \ {\n            paren_count -= 1;\n            depth += 1;\n        } else {\n\
    \            if paren_count == 0 {\n                depth -= 1;\n            }\n\
    \        }\n\n        if depth <= 0 {\n            break;\n        }\n    }\n\
    \    paren_count + depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzhjs7873.rs:26:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     paren_count + depth\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<isize> = vec![];\n    let mut\
    \ index = 0;\n    while index < paren_string.len() {\n        let ch = paren_string[index];\n\
    \        if ch == ')' {\n            result.append(index + 1);\n        }\n  \
    \      index += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpuibv6ci9.rs:10:18\n\
    \   |\n10 |         let ch = paren_string[index];\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuibv6ci9.rs:12:27\n\
    \   |\n12 |             result.append(index + 1);\n   |                      \
    \     ^^^^^^^^^ expected `&mut Vec<isize>`, found `usize`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<isize>`\n                           found type `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut open_curlies =\
    \ 0;\n    let mut close_curlies = 0;\n    let mut open_braces = 0;\n    let mut\
    \ close_braces = 0;\n    let mut open_angles = 0;\n    let mut close_angles =\
    \ 0;\n    let mut open_parens = 0;\n    let mut close_parens = 0;\n    let mut\
    \ open_parens_group = 0;\n    let mut close_parens_group = 0;\n    let mut open_angles_group\
    \ = 0;\n    let mut close_angles_group = 0;\n    let mut open_curlies_group =\
    \ 0;\n    let mut close_curlies_group = 0;\n    let mut open_curlies_string =\
    \ \"\";\n    let mut close_curlies_string = \"\";\n    let mut open_angles_string\
    \ = \"\";\n    let mut close_angles_string = \"\";\n\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        match c {\n            '(' {\n                if level == 0 && open_parens\
    \ == 0 && close_parens == 0 && open_braces == 0 && close_braces == 0 && open_angles\
    \ == 0 && close_angles == 0 && open_curlies == 0 && close_curlies == 0 && open_curlies_group\
    \ == 0 && close_curlies_group == 0 {\n                    open_parens_group =\
    \ i;\n                }\n                level += 1;\n            } else if ')'\
    \ {\n                if level == 1 {\n                    close_parens_group =\
    \ i;\n                    open_parens_group = 0;\n                }\n        \
    \        level -= 1;\n            } else if '{' {\n                if level ==\
    \ 1 && open_parens == 0 && close_parens == 0 && open_braces == 0 && close_braces\
    \ == 0 && open_angles == 0 && close_angles == 0 && open_curlies == 0 && close_curlies\
    \ == 0 && open_curlies_group == 0 && close_curlies_group == 0 {\n            \
    \        open_braces = i;\n                }\n                level += 1;\n  \
    \          } else if '}' {\n                if level == 1 {\n                \
    \    close_braces = i;\n                    open_braces = 0;\n               \
    \ }\n                level -= 1;\n            } else if '{' {\n              \
    \  if level == 1 && open_parens == 0 && close_parens == 0 && open_braces == 0\
    \ && close_braces == 0 && open_angles == 0 && close_angles == 0 && open_curlies\
    \ == 0 && close_curlies == 0 && open_curlies_group == 0 && close_curlies_group\
    \ == 0 {\n                    open_angles = i;\n                }\n          \
    \      level += 1;\n            } else if '}' {\n                if level == 1\
    \ {\n                    close_angles = i;\n                    open_angles =\
    \ 0;\n                }\n                level -= 1;\n            } else if '{'\
    \ {\n                if \n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp5q7l9hdy.rs:71:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n27 |     for (i, c) in paren_string.chars().enumerate() {\n   |         \
    \                                           - unclosed delimiter\n28 |       \
    \  match c {\n   |                 - unclosed delimiter\n...\n62 |           \
    \  } else if '{' {\n   |                           - this delimiter might not\
    \ be properly closed...\n63 |                 if \n64 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n71 | }\n   |   ^\n\nerror: expected\
    \ one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `{`\n  --> /tmp/tmp5q7l9hdy.rs:29:17\n\
    \   |\n29 |             '(' {\n   |                 ^ expected one of `...`, `..=`,\
    \ `..`, `=>`, `if`, or `|`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp5q7l9hdy.rs:27:5\n\
    \   |\n6  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n \
    \  |                                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n27 | /     for (i, c) in paren_string.chars().enumerate()\
    \ {\n28 | |         match c {\n29 | |             '(' {\n30 | |              \
    \   if level == 0 && open_parens == 0 && close_parens == 0 && open_braces == 0\
    \ && close_braces == 0 && open_angles == 0 && cl...\n...  |\n70 | |     assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n71 | | }\n   | |__^ expected struct `Vec`, found\
    \ `()`\n   |\n   = note: expected struct `Vec<isize>`\n           found unit type\
    \ `()`\n\nerror: aborting due to 3 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.lines()\n        .map(|s| s.as_bytes())\n\
    \        .flatten()\n        .scan(\n            |state: &mut [isize; 4],\n  \
    \          ch: char,\n        ) => {\n            let next = state[state.len()\
    \ - 1];\n            if next == ch && state.len() == 3 {\n                state.pop();\n\
    \                0\n            } else {\n                let ret = match ch {\n\
    \                    '(' => 1,\n                    ')' => 1,\n              \
    \      ')(' => 2,\n                    ')()' => 2,\n                    ')()('\
    \ => 3,\n                    _ => 0,\n                };\n                state.push(ret);\n\
    \                ret\n            }\n        }\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpzg9mw0_2.rs:22:21\n\
    \   |\n22 |                     ')(' => 2,\n   |                     ^^^^\n  \
    \ |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n22\
    \ |                     \")(\" => 2,\n   |                     ~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmpzg9mw0_2.rs:23:21\n\
    \   |\n23 |                     ')()' => 2,\n   |                     ^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    23 |                     \")()\" => 2,\n   |                     ~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmpzg9mw0_2.rs:24:21\n\
    \   |\n24 |                     ')()(' => 3,\n   |                     ^^^^^^\n\
    \   |\nhelp: if you meant to write a `str` literal, use double quotes\n   |\n\
    24 |                     \")()(\" => 3,\n   |                     ~~~~~~\n\nerror:\
    \ expected parameter name, found `)`\n  --> /tmp/tmpzg9mw0_2.rs:13:9\n   |\n13\
    \ |         ) => {\n   |         ^ expected parameter name\n\nerror: aborting\
    \ due to 4 previous errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().flat_map(|c| {\n        vec![paren_stack_push(c);\
    \ paren_stack_pop()]\n    })\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_stack_push` in this scope\n -->\
    \ /tmp/tmpf_4iiwbf.rs:8:14\n  |\n8 |         vec![paren_stack_push(c); paren_stack_pop()]\n\
    \  |              ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `paren_stack_pop` in this scope\n --> /tmp/tmpf_4iiwbf.rs:8:35\n\
    \  |\n8 |         vec![paren_stack_push(c); paren_stack_pop()]\n  |          \
    \                         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmpf_4iiwbf.rs:7:5\n  |\n6 |   fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n  |                                               \
    \    ---------- expected `Vec<isize>` because of return type\n7 | /     paren_string.chars().flat_map(|c|\
    \ {\n8 | |         vec![paren_stack_push(c); paren_stack_pop()]\n9 | |     })\n\
    \  | |______^ expected struct `Vec`, found struct `FlatMap`\n  |\n  = note: expected\
    \ struct `Vec<isize>`\n             found struct `FlatMap<Chars<'_>, Vec<_>, [closure@/tmp/tmpf_4iiwbf.rs:7:35:\
    \ 9:6]>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_count = paren_string.count('(');\n  \
    \  let mut level = 0;\n    let mut nested_parens = Vec::new();\n    for paren_index\
    \ in 0..paren_count {\n        nested_parens.push(paren_index);\n        level\
    \ = level + 1;\n        if paren_index == paren_count - 1 {\n            nested_parens.push(level);\n\
    \        } else {\n            nested_parens.push(level);\n            nested_parens.push(level\
    \ + 1);\n        }\n    }\n    nested_parens\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpvjktkkma.rs:7:36\n\
    \    |\n7   |       let paren_count = paren_string.count('(');\n    |        \
    \                              ^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `String: Iterator`\n            which is required\
    \ by `&mut String: Iterator`\n            `str: Iterator`\n            which is\
    \ required by `&mut str: Iterator`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parentheses_level = 0;\n    let mut group_counter\
    \ = 1;\n    let mut parentheses_group_counter = 0;\n    let mut paren_string =\
    \ paren_string.split_whitespace();\n    let mut max_level: isize = 0;\n    let\
    \ mut max_paren_string = \"\".to_string();\n    for s in paren_string.iter() {\n\
    \        if s == ')' {\n            parentheses_level--;\n        }\n        if\
    \ s == '(' { parentheses_level++; }\n        if s == ')' { parentheses_level++;\
    \ }\n        if s == '(' { parentheses_group_counter++; }\n        if s == '('\
    \ {\n            if parentheses_level > parentheses_group_counter {\n        \
    \        parentheses_group_counter = 0;\n            }\n        }\n        if\
    \ s == ')' {\n            if parentheses_level > parentheses_group_counter {\n\
    \                parentheses_group_counter = 0;\n            }\n        }\n  \
    \      if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                max_level = parentheses_level;\n                parentheses_group_counter\
    \ = 0;\n            }\n        }\n        if s == ')' {\n            if parentheses_level\
    \ > parentheses_group_counter {\n                max_level = parentheses_level;\n\
    \                parentheses_group_counter = 0;\n            }\n        }\n  \
    \      if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                max_level = parentheses_level;\n                parentheses_group_counter\
    \ = 0;\n            }\n        }\n        if s == ')' {\n            if parentheses_level\
    \ > parentheses_group_counter {\n                max_level = parentheses_level;\n\
    \                parentheses_group_counter = 0;\n            }\n        }\n  \
    \      if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                max_level = parentheses_level;\n                parentheses_group_counter\
    \ = 0;\n            }\n        }\n        if s == ')' {\n            if parentheses_level\
    \ > parentheses_group_counter {\n                max_level = parentheses_level;\n\
    \                parentheses_group_counter = 0;\n            }\n        }\n  \
    \      if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                max_level = parentheses_level;\n                parentheses_group_counter\
    \ = 0;\n            }\n        }\n        if s == '(' { parentheses_level++; }\n\
    \        if s == ')' { parentheses_level++; }\n        if s == '(' { parentheses_group_counter++;\
    \ }\n        if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                parentheses_group_counter = 0;\n            }\n        }\n\
    \        if s == ')' {\n            if parentheses_level > parentheses_group_counter\
    \ {\n                parentheses_group_counter = 0;\n            }\n        }\n\
    \        if s == ')' {\n            if parentheses_level > parenthese\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp117ngxmz.rs:94:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     for s in paren_string.iter() {\n   |                           \
    \       - unclosed delimiter\n...\n85 |         if s == ')' {\n   |          \
    \           - this delimiter might not be properly closed...\n86 |           \
    \  if parentheses_level > parenthese\n87 | }\n   | - ...as it matches this but\
    \ it has different indentation\n...\n94 | }\n   |   ^\n\nerror: Rust has no postfix\
    \ increment operator\n  --> /tmp/tmp117ngxmz.rs:17:40\n   |\n17 |         if s\
    \ == '(' { parentheses_level++; }\n   |                                      \
    \  ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n17 |\
    \         if s == '(' { { let tmp = parentheses_level; parentheses_level += 1;\
    \ tmp }; }\n   |                       +++++++++++                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    17 -         if s == '(' { parentheses_level++; }\n17 +         if s == '(' {\
    \ parentheses_level += 1; }\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmp117ngxmz.rs:18:40\n   |\n18 |         if s == ')' { parentheses_level++;\
    \ }\n   |                                        ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |         if s == ')' { { let tmp =\
    \ parentheses_level; parentheses_level += 1; tmp }; }\n   |                  \
    \     +++++++++++                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n18 -     \
    \    if s == ')' { parentheses_level++; }\n18 +         if s == ')' { parentheses_level\
    \ += 1; }\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp117ngxmz.rs:19:48\n\
    \   |\n19 |         if s == '(' { parentheses_group_counter++; }\n   |       \
    \                                         ^^ not a valid postfix operator\n  \
    \ |\nhelp: use `+= 1` instead\n   |\n19 |         if s == '(' { { let tmp = parentheses_group_counter;\
    \ parentheses_group_counter += 1; tmp }; }\n   |                       ++++"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut open_parens = String::new();\n    let mut\
    \ close_parens = String::new();\n    let mut level = 0;\n    for c in paren_string.chars()\
    \ {\n        match c {\n            ' ' => { open_parens = open_parens.clone();\
    \ close_parens = close_parens.clone(); level += 1; },\n            '(' => { open_parens\
    \ = open_parens.clone(); level += 1; },\n            ')' => { open_parens = open_parens.clone();\
    \ level -= 1; },\n            '[' => { open_parens = open_parens.clone(); level\
    \ += 1; },\n            ']' => { open_parens = open_parens.clone(); level -= 1;\
    \ },\n            '{' => { open_parens = open_parens.clone(); level += 1; },\n\
    \            '}' => { open_parens = open_parens.clone(); level -= 1; },\n    \
    \        _ => (),\n        }\n    }\n    open_parens.chars().enumerate().map(|(i,\
    \ c)| {\n        if c == ')' {\n            level\n        } else {\n        \
    \    level - 1\n        }\n    }).collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmprfz6xzrb.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_nestings: Vec<isize> = vec![1];\n\
    \    let mut stack: Vec<&str> = vec![paren_string];\n    let mut depth: isize\
    \ = 0;\n    loop {\n        let char = match stack.last() {\n            Some(v)\
    \ => v,\n            None => return paren_nestings.clone(),\n        };\n    \
    \    if char == ')' {\n            depth -= 1;\n            if depth == 0 {\n\
    \                paren_nestings.pop();\n            } else {\n               \
    \ paren_nestings.push(depth);\n            }\n            stack.pop();\n     \
    \   } else {\n            if char == '(' {\n                depth += 1;\n    \
    \        } else {\n                stack.append(char);\n            }\n      \
    \  }\n    }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpslpzxkyg.rs:8:37\n  |\n8 |\
    \     let mut stack: Vec<&str> = vec![paren_string];\n  |                    \
    \                 ^^^^^^^^^^^^\n  |                                     |\n  |\
    \                                     expected `&str`, found struct `String`\n\
    \  |                                     help: consider borrowing here: `&paren_string`\n\
    \nerror[E0277]: can't compare `&&str` with `char`\n  --> /tmp/tmpslpzxkyg.rs:15:17\n\
    \   |\n15 |         if char == ')' {\n   |                 ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&&str` with `char`\n  --> /tmp/tmpslpzxkyg.rs:24:21\n   |\n24 |           \
    \  if char == '(' {\n   |                     ^^ no implementation for `&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpslpzxkyg.rs:27:30\n   |\n27 |                 stack.append(char);\n\
    \   |                              ^^^^ types differ in mutability\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<&str>`\n                   "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = vec![paren_string.len()];\n  \
    \  let mut nest = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n \
    \       if c == ')' {\n            if nest == 0 {\n                result[i] =\
    \ i;\n                break;\n            } else {\n                nest--;\n\
    \            }\n        } else {\n            nest++;\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpqogwzmco.rs:15:23\n\
    \   |\n15 |                 nest--;\n   |                       ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpqogwzmco.rs:18:17\n\
    \   |\n18 |             nest++;\n   |                 ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n18 |             { let tmp = nest; nest\
    \ += 1; tmp };\n   |             +++++++++++     ~~~~~~~~~~~~~~~~~~\n18 -    \
    \         nest++;\n18 +             nest += 1;\n   | \n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqogwzmco.rs:21:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n21 |     result\n\
    \   |     ^^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .trim()\n        .split('\
    \ ').map(|x| x.parse().unwrap()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpsh2xzv8m.rs:9:39

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth_tracker = [0];\n\n    let mut\
    \ groups: Vec<Vec<isize>> = paren_string.split_whitespace().collect();\n    let\
    \ mut group_depth = Vec::new();\n    for group in groups.iter() {\n        if\
    \ group == String::from(\"\") {\n            continue;\n        }\n        if\
    \ group_depth.contains(group) {\n            // the group has already been counted,\
    \ so move to next group\n            group_depth = group_depth.clone();\n    \
    \        continue;\n        }\n\n        // add the group to the depth\n     \
    \   group_depth = group_depth.clone();\n        group_depth.push(group_depth.len()\
    \ - group.len());\n        paren_depth_tracker.push(0);\n\n        let group_str\
    \ = group.to_string();\n        let mut group_paren_depth = group.len();\n   \
    \     for paren in group_str.chars() {\n            if paren == ')' {\n      \
    \          group_paren_depth -= 1;\n            }\n            paren_depth_tracker.push(group_paren_depth);\n\
    \        }\n\n        // decrement the depth\n        group_depth = group_depth.clone();\n\
    \        group_depth.len() - group.len()\n    }\n\n    paren_depth_tracker.reverse().iter().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<Vec<isize>>` cannot be built from an\
    \ iterator over elements of type `&str`\n    --> /tmp/tmp121tr2bn.rs:9:71\n  \
    \   |\n9    |     let mut groups: Vec<Vec<isize>> = paren_string.split_whitespace().collect();\n\
    \     |                                                                      \
    \ ^^^^^^^ value of type `Vec<Vec<isize>>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<Vec<isize>>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: can't compare `&Vec<isize>` with `String`\n\
    \  --> /tmp/tmp121tr2bn.rs:12:18\n   |\n12 |         if group == String::from(\"\
    \") {\n   |                  ^^ no implementation for `&Vec<isize> == String`\n\
    \   |\n   = help: the trait `PartialEq<String>` is not implemented for `&Vec<isize>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as\
    \ PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n      \
    \       <Vec<T, A> as PartialEq<[U]>>\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp121tr2bn.rs:23:26\n   |\n23 |         group_depth.push(group_depth.len()\
    \ - group.len());\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror[E0599]: no method named `push` found\
    \ for array `[{integer}; 1]` in the current scope\n  --> /tmp/tmp121tr2bn.rs:24:29\n\
    \   |\n24 |         paren_depth_tracker.push(0);\n   |                       \
    \      ^^^^ method not found in `[{integer}; 1]`\n\nerror[E0599]: the method `to_string`\
    \ exists for reference `&Vec<isize>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmp121tr2bn.rs:26:31\n    |\n26  |           let group_str = group.to_string();\n\
    \    |                              "
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().map(|c| match c {\n      \
    \  '(' | ')' => 1,\n        _ => 0\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1,\
    \ 1, 1]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpoheqaz01.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parentheses_level = Vec::new();\n    for\
    \ parens in paren_string.split('(') {\n        if parens == paren_string.len()\
    \ {\n            parentheses_level += vec![0];\n            continue;\n      \
    \  }\n        let mut parens_level = Vec::new();\n        for paren in parens.split()\
    \ {\n            let level: isize = 2;\n            if paren == parens.len() {\n\
    \                parens_level += vec![level];\n                continue;\n   \
    \         }\n            if paren != parens.chars().nth(1).unwrap() {\n      \
    \          let char: char = \"(\".to_chars().nth(1).unwrap();\n              \
    \  let mut i = paren;\n                while paren != parens.chars().nth(i).unwrap()\
    \ {\n                    i += 1;\n                }\n                if paren\
    \ == parens.len() {\n                    parens_level += vec![level];\n      \
    \              continue;\n                }\n            }\n            parens_level\
    \ += vec![level];\n        }\n        parentheses_level += parens_level;\n   \
    \ }\n    parentheses_level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `usize`\n --> /tmp/tmpesejlsgy.rs:9:19\n\
    \  |\n9 |         if parens == paren_string.len() {\n  |                   ^^\
    \ no implementation for `&str == usize`\n  |\n  = help: the trait `PartialEq<usize>`\
    \ is not implemented for `&str`\n  = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n            <&'a str as PartialEq<OsString>>\n    \
    \        <&'a str as PartialEq<String>>\n            <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<&'a str>>\n            <String as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<str>>\n            <String as PartialEq>\n\
    \            <str as PartialEq<Cow<'a, str>>>\n          and 4 others\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Vec<_>`\n  --> /tmp/tmpesejlsgy.rs:10:13\n\
    \   |\n10 |             parentheses_level += vec![0];\n   |             -----------------^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `Vec<_>`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmpesejlsgy.rs:14:29\n\
    \     |\n14   |         for paren in parens.split() {\n     |                \
    \             ^^^^^- supplied 0 arguments\n     |                            \
    \ |\n     |                             expected 1 argument\n     |\nnote: associated\
    \ function defined here\n\nerror[E0277]: can't compare `&str` with `usize`\n \
    \ --> /tmp/tmpesejlsgy.rs:16:22\n   |\n16 |             if paren == parens.len()\
    \ {\n   |                      ^^ no implementation for `&str == usize`\n   |\n\
    \   = help: the trait `PartialEq<usize>` is not implemented for `&str`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             <&'a\
    \ str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n \
    \            <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n   "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    for\
    \ paren in paren_string.chars() {\n        if paren == '(' || paren == ')' {\n\
    \            stack.push(stack.last().unwrap());\n        } else if paren == ')'\
    \ {\n            while let Some(last) = stack.last() {\n                if last\
    \ > paren {\n                    stack.pop();\n                    break;\n  \
    \              }\n            }\n        }\n    }\n    stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzvx42zd4.rs:10:24\n   |\n\
    10 |             stack.push(stack.last().unwrap());\n   |                    \
    \    ^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n10 |             stack.push(*stack.last().unwrap());\n\
    \   |                        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzvx42zd4.rs:13:27\n\
    \   |\n13 |                 if last > paren {\n   |                          \
    \ ^^^^^ expected `&isize`, found `char`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut depth = 0;\n    let mut paren_groups: Vec<_>\
    \ = paren_string.chars().take_while(|c| c != b'(' || c != b')(')\n        .collect();\n\
    \    while paren_groups.len() > 0 {\n        let mut cur_depth = 0;\n        let\
    \ mut cur_group: Vec<_> = paren_groups.split_off(1);\n        for c in cur_group\
    \ {\n            match c {\n                b' ' => cur_depth = cur_depth + 1,\n\
    \                b'(' | b')' => cur_depth = cur_depth - 1,\n                _\
    \ => (),\n            }\n        }\n        depth = std::cmp::max(depth, cur_depth);\n\
    \        paren_groups = paren_groups.split_off(1);\n    }\n    depth + 1\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n --> /tmp/tmp23j2wm0p.rs:8:90\n\
    \  |\n8 |     let mut paren_groups: Vec<_> = paren_string.chars().take_while(|c|\
    \ c != b'(' || c != b')(')\n  |                                              \
    \                                            ^^^^^\n  |\nhelp: if you meant to\
    \ write a byte string literal, use double quotes\n  |\n8 |     let mut paren_groups:\
    \ Vec<_> = paren_string.chars().take_while(|c| c != b'(' || c != b\")(\")\n  |\
    \                                                                            \
    \              ~~~~~\n\nerror[E0308]: mismatched types\n --> /tmp/tmp23j2wm0p.rs:8:77\n\
    \  |\n8 |     let mut paren_groups: Vec<_> = paren_string.chars().take_while(|c|\
    \ c != b'(' || c != b')(')\n  |                                              \
    \                               ^^^^ expected `char`, found `u8`\n\nerror[E0277]:\
    \ can't compare `&char` with `u8`\n --> /tmp/tmp23j2wm0p.rs:8:74\n  |\n8 |   \
    \  let mut paren_groups: Vec<_> = paren_string.chars().take_while(|c| c != b'('\
    \ || c != b')(')\n  |                                                        \
    \                  ^^ no implementation for `&char == u8`\n  |\n  = help: the\
    \ trait `PartialEq<u8>` is not implemented for `&char`\n  = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp23j2wm0p.rs:15:17\n\
    \   |\n14 |             match c {\n   |                   - this expression has\
    \ type `char`\n15 |                 b' ' => cur_depth = cur_depth + 1,\n   | \
    \                ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp23j2wm0p.rs:16:17\n   |\n14 |             match c {\n \
    \  |                   - this expression has type `char`\n15 |               \
    \  b' ' => cur_depth = cur_depth + 1,\n16 |                 b'(' | b')' => cur_depth\
    \ = cur_depth - 1,\n   |                 ^^^^ expected `char`, found `u8`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp23j2wm0p.rs:16:24\n   |\n14 |  \
    \           match c {\n   |                   - this expression has type `char`\n\
    15 |                 b' ' => cur_dep"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = Vec::<isize>::new();\n    let mut\
    \ level = 0;\n    let mut paren_count = 0;\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            stack.pop_back();\n            paren_count\
    \ += 1;\n        }\n        if c == '{' {\n            stack.pop_back();\n   \
    \         paren_count += 1;\n            level += 1;\n        }\n        if c\
    \ == '}' {\n            stack.pop_back();\n            level -= 1;\n         \
    \   paren_count -= 1;\n        }\n        if paren_count == 0 && level == 0 &&\
    \ stack.is_empty() {\n            return vec![i as isize];\n        }\n      \
    \  if c == '(' {\n            stack.pop_back();\n            level += 1;\n   \
    \     }\n        if c == '{' {\n            stack.pop_back();\n            level\
    \ += 1;\n            paren_count += 1;\n        }\n        if c == '}' {\n   \
    \         stack.pop_back();\n            level -= 1;\n            paren_count\
    \ -= 1;\n        }\n    }\n    vec![]\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop_back` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmppbvi8yco.rs:12:19\n   |\n12 |          \
    \   stack.pop_back();\n   |                   ^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror[E0599]: no method named `pop_back` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmppbvi8yco.rs:16:19\n   |\n16 |             stack.pop_back();\n\
    \   |                   ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmppbvi8yco.rs:21:19\n   |\n21 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmppbvi8yco.rs:29:19\n   |\n29 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmppbvi8yco.rs:33:19\n   |\n33 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0599]:\
    \ no method named `pop_back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmppbvi8yco.rs:38:19\n   |\n38 |             stack.pop_back();\n \
    \  |                   ^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depths = vec![0; paren_string.len()];\n\
    \    let mut paren_positions = vec![0; paren_string.len()];\n    let mut paren_level\
    \ = 0;\n    let mut paren_start = paren_positions[0] = 0;\n    let mut paren_end\
    \ = paren_positions[paren_string.len() - 1] = 0;\n\n    for paren_pos in paren_string.char_indices().skip_while(|&(pos:\
    \ usize, _)| {\n        paren_start == 0\n    }) {\n        for paren_pos in paren_string.char_indices().skip_while(|&(pos:\
    \ usize, _)| {\n            paren_end == paren_pos + 1\n        }) {\n       \
    \     if paren_depths[paren_pos] >= paren_level {\n                paren_depths[paren_pos]\
    \ = paren_level;\n                paren_positions[paren_pos] = paren_start;\n\
    \            }\n            paren_depths[paren_pos] += 1;\n            paren_end\
    \ += 1;\n        }\n        paren_level += 1;\n        paren_start = paren_end\
    \ = paren_pos + 1;\n    }\n    let mut ret = vec![0; paren_string.len()];\n  \
    \  for paren_pos in paren_positions.iter().rev() {\n        ret[paren_pos] = paren_depths[paren_pos];\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmppwd49p06.rs:13:67\n\
    \   |\n13 |     for paren_pos in paren_string.char_indices().skip_while(|&(pos:\
    \ usize, _)| {\n   |                                                         \
    \          ^ expected one of `)`, `,`, `@`, or `|`\n\nerror: expected one of `:`\
    \ or `|`, found `)`\n  --> /tmp/tmppwd49p06.rs:13:77\n   |\n13 |     for paren_pos\
    \ in paren_string.char_indices().skip_while(|&(pos: usize, _)| {\n   |       \
    \                                                                      ^ expected\
    \ one of `:` or `|`\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_chars = paren_string.chars().filter(|c|\
    \ c == '(' || c == '[' || c == '{' || c == '<').collect::<Vec<_>>();\n\n    let\
    \ mut paren_depth = 0;\n    let mut paren_char_index = paren_chars.len();\n  \
    \  let mut paren_char_stack = vec![];\n    loop {\n        paren_char_stack.pop_back();\n\
    \        if paren_char_stack.len() == 0 {\n            paren_char_stack.push(paren_char_index);\n\
    \        }\n        let paren_index = paren_char_stack.pop().unwrap();\n     \
    \   if paren_char_stack.is_empty() {\n            paren_depth = paren_depth +\
    \ paren_index;\n        }\n        else {\n            paren_depth = paren_depth\
    \ + 1;\n        }\n        if paren_char_stack.len() == 0 {\n            paren_char_stack.push(paren_index);\n\
    \            paren_char_index = paren_char_index + 1;\n        }\n        if paren_char_stack.len()\
    \ == 1 {\n            return vec![paren_depth];\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp47hxu8me.rs:7:57\n\
    \  |\n7 |     let paren_chars = paren_string.chars().filter(|c| c == '(' || c\
    \ == '[' || c == '{' || c == '<').collect::<Vec<_>>();\n  |                  \
    \                                       ^^ no implementation for `&char == char`\n\
    \  |\n  = help: the trait `PartialEq<char>` is not implemented for `&char`\n \
    \ = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n --> /tmp/tmp47hxu8me.rs:7:69\n  |\n7 |     let\
    \ paren_chars = paren_string.chars().filter(|c| c == '(' || c == '[' || c == '{'\
    \ || c == '<').collect::<Vec<_>>();\n  |                                     \
    \                                ^^ no implementation for `&char == char`\n  |\n\
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n  = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n --> /tmp/tmp47hxu8me.rs:7:81\n  |\n7 |     let paren_chars\
    \ = paren_string.chars().filter(|c| c == '(' || c == '[' || c == '{' || c == '<').collect::<Vec<_>>();\n\
    \  |                                                                         \
    \        ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmp47hxu8me.rs:7:93\n\
    \  |\n7 |     let paren_chars = paren_string.chars().filter(|c| c == '(' || c\
    \ == '[' || c == '{' || c == '<').collect::<Vec<_>>();\n  |                  \
    \                                                                           ^^\
    \ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0599]: no method named `pop_back` found for struct `Vec<_>`\
    \ in the current scope\n  --> /tmp/tmp47hxu8me.rs:13:26\n   |\n13 |         paren_char_stack.pop_back();\n\
    \   |                          ^^^^^^^^ method not"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut vec = Vec::new();\n    let mut current_level\
    \ = 1;\n    for ch in paren_string.chars() {\n        let level = current_level;\n\
    \        if ch == '(' {\n            vec.push(level);\n            current_level++;\n\
    \        } else if ch == ')' {\n            vec.push(level);\n            current_level--;\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpnjfyh5jr.rs:13:26\n\
    \   |\n13 |             current_level++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n13 |       \
    \      { let tmp = current_level; current_level += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n13 -             current_level++;\n\
    13 +             current_level += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmpnjfyh5jr.rs:16:28\n   |\n16 |             current_level--;\n\
    \   |                            ^ expected expression\n\nerror: aborting due\
    \ to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = Vec::new();\n    let\
    \ mut open_char: char = paren_string[0];\n    let mut level = 0;\n    for ch in\
    \ paren_string.chars().filter_map(|c| {\n        if open_char != c\n         \
    \   && (open_char == ')' || open_char == '(')\n        {\n            stack.push(level);\n\
    \            open_char = c\n        }\n        open_char\n    }) {\n        level\
    \ = stack.last().unwrap() + 1;\n    }\n\n    stack\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n -->\
    \ /tmp/tmpa2m23qg5.rs:8:31\n  |\n8 |     let mut open_char: char = paren_string[0];\n\
    \  |                               ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n  |\n  = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n  = help: the following other types implement trait `Index<Idx>`:\n\
    \            <String as Index<RangeFrom<usize>>>\n            <String as Index<RangeFull>>\n\
    \            <String as Index<RangeInclusive<usize>>>\n            <String as\
    \ Index<RangeTo<usize>>>\n            <String as Index<RangeToInclusive<usize>>>\n\
    \            <String as Index<std::ops::Range<usize>>>\n            <str as Index<I>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpa2m23qg5.rs:17:9\n   |\n17 | \
    \        open_char\n   |         ^^^^^^^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n17 |         Some(open_char)\n\
    \   |         +++++         +\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels: Vec<isize> = vec![];\n  \
    \  let mut open_brace_index = 0;\n    let mut close_brace_index = 0;\n    let\
    \ mut open_brace_count = 1;\n    let mut close_brace_count = 1;\n\n    for c in\
    \ paren_string.chars() {\n        if c == '(' {\n            if open_brace_count\
    \ > 1 {\n                paren_levels.push(open_brace_count);\n            }\n\
    \            open_brace_index += 1;\n            open_brace_count += 1;\n    \
    \    }\n        if c == ')' {\n            close_brace_index += 1;\n         \
    \   close_brace_count += 1;\n        }\n        if open_brace_index == close_brace_index\
    \ {\n            paren_levels.push(close_brace_count);\n        }\n    }\n   \
    \ paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[2, 3, 4, 4, 4, 5, 6, 7, 7, 7, 8, 8, 8, 9, 10, 11, 12, 13]`,\n right: `[2,\
    \ 3, 1, 3]`', /tmp/tmpc0sk124q.rs:34:5\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_counts = HashMap::new();\n    let\
    \ mut depth = 0i32;\n    let mut paren_groups = paren_string.split_whitespace().collect::<Vec<_>>();\n\
    \    while paren_groups.len() > 0 {\n        let group = paren_groups.pop().unwrap();\n\
    \        depth += 1;\n        if paren_counts.contains_key(&group) {\n       \
    \     paren_counts.entry(group).or_insert(depth).clone()\n        } else {\n \
    \           paren_counts.insert(group, depth);\n        }\n    }\n    paren_counts\n\
    \        .iter()\n        .filter_map(|(_, depth)| depth)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n -->\
    \ /tmp/tmpgzyrdus5.rs:7:28\n  |\n7 |     let mut paren_counts = HashMap::new();\n\
    \  |                            ^^^^^^^ not found in this scope\n  |\nhelp: consider\
    \ importing this struct\n  |\n1 | use std::collections::HashMap;\n  |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result: Vec<_> = vec![];\n    let mut nesting\
    \ = 0;\n    paren_string.split_whitespace().for_each(|c|\n        if c == ')'\
    \ {\n            nesting--;\n        } else {\n            if nesting != 0 {\n\
    \                result.push(nesting);\n            }\n            nesting++;\n\
    \        }\n    );\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmp9yn6xg6g.rs:11:22\n\
    \   |\n11 |             nesting--;\n   |                      ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmp9yn6xg6g.rs:16:20\n\
    \   |\n16 |             nesting++;\n   |                    ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |             { let tmp =\
    \ nesting; nesting += 1; tmp };\n   |             +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n\
    16 -             nesting++;\n16 +             nesting += 1;\n   | \n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmp9yn6xg6g.rs:10:14\n   |\n10\
    \ |         if c == ')' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = Vec::new();\n    let mut paren_depth\
    \ = 0;\n\n    for c in paren_string.chars() {\n        if paren_depth >= 0 {\n\
    \            paren_depth = paren_depth - 1;\n        }\n\n        if c == '('\
    \ {\n            paren_depth += 1;\n        }\n        if c == '[' {\n       \
    \     paren_depth += 1;\n        }\n        if c == '{' {\n            paren_depth\
    \ += 1;\n        }\n        if c == ')' {\n            paren_depth -= 1;\n   \
    \     }\n        if c == ']' {\n            paren_depth -= 1;\n        }\n   \
    \     if c == '}' {\n            paren_depth -= 1;\n        }\n        if c ==\
    \ '\\\\' {\n            continue;\n        }\n        result.push(paren_depth);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, -2, -1, -2, -3, -3, -2, -1, 0, -2, -3, -4, -4, -3, -4, -4, -3, -2, -1,\
    \ -2, -3, -2, -3, -2, -3, -4]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp7x0zp_kt.rs:43:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_levels = paren_string.char_indices().map(|c|\
    \ {\n        // get index of the '('\n        let paren_index = c.0;\n       \
    \ let paren_level = paren_index;\n        // find the first ')' of (\n       \
    \ let mut paren_end_index = paren_index;\n        // iterate through all ')' in\
    \ the paren_string and find out the minimum parenthesis level of nested parenthesis\n\
    \        while paren_end_index != paren_string.chars().last().unwrap() {\n   \
    \         if paren_end_index == paren_string.chars().last().unwrap() {\n     \
    \           break;\n            }\n            if paren_string[paren_end_index]\
    \ == '(' {\n                // increase the paren_level of nested parenthesis\n\
    \                paren_level += 1;\n            } else {\n                // increase\
    \ the paren_level of last open parenthesis\n                paren_level += 2;\n\
    \            }\n            // move on to the next ')'\n            paren_end_index\
    \ += 1;\n        }\n        paren_level\n    });\n    // find the deepest level\
    \ of parenthesis\n    let deepest_level: isize = paren_levels.iter().max().unwrap();\n\
    \    // convert the vector (paren_levels) to a vector (deepest_level)\n    paren_levels[..deepest_level].iter().cloned().collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3vavt068.rs:14:34\n   |\n\
    14 |         while paren_end_index != paren_string.chars().last().unwrap() {\n\
    \   |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `usize`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3vavt068.rs:15:35\n\
    \   |\n15 |             if paren_end_index == paren_string.chars().last().unwrap()\
    \ {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `usize`, found `char`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp3vavt068.rs:18:16\n   |\n18 |            \
    \ if paren_string[paren_end_index] == '(' {\n   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `iter` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmp3vavt068.rs:31:45\n   |\n31 |     let deepest_level:\
    \ isize = paren_levels.iter().max().unwrap();\n   |                          \
    \                   ^^^^ private field, not a method\n\nerror[E0608]: cannot index\
    \ into a value of type `Map<CharIndices<'_>, [closure@/tmp/tmp3vavt068.rs:7:56:\
    \ 29:6]>`\n  --> /tmp/tmp3vavt068.rs:33:5\n   |\n33 |     paren_levels[..deepest_level].iter().cloned().collect()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599, E0608.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().enumerate()\n        .map(|(i,\
    \ char)| {\n            if char == '(' {\n                return i + 1;\n    \
    \        }\n            if char == ')' {\n                return i - 1;\n    \
    \        }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0317]: `if` may be missing an `else` clause\n  --> /tmp/tmp2w2pvngy.rs:12:13\n\
    \   |\n12 | /             if char == ')' {\n13 | |                 return i -\
    \ 1;\n14 | |             }\n   | |_____________^ expected `()`, found `usize`\n\
    \   |\n   = note: `if` expressions without `else` evaluate to `()`\n   = help:\
    \ consider adding an `else` block that evaluates to the expected type\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `usize`\n    --> /tmp/tmp2w2pvngy.rs:16:10\n     |\n16   |         .collect()\n\
    \     |          ^^^^^^^ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0317.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .filter_map(|c| c.is_ascii_alphanumeric())\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_alphanumeric` found for reference\
    \ `&str` in the current scope\n --> /tmp/tmp6tmuqlw4.rs:9:27\n  |\n9 |       \
    \  .filter_map(|c| c.is_ascii_alphanumeric())\n  |                           ^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `&str`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars()\n        .filter_map(|c| match\
    \ c {\n            '(' | ')' | ' ' => {\n                let len = c.len_utf8();\n\
    \                Some(len + 1)\n            }\n            _ => None,\n      \
    \  })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpcjdmiswm.rs:15:10\n     |\n15\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.char_indices()\n        .filter_map(|i|\
    \ {\n            let start = i.0;\n            let end = i.1;\n            if\
    \ start == end {\n                None\n            } else {\n               \
    \ Some(start as isize)\n            }\n        })\n        .skip(1)\n        .take(paren_string.len()\
    \ - 2)\n        .cloned()\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl1aef4n6.rs:11:25\n   |\n\
    11 |             if start == end {\n   |                         ^^^ expected\
    \ `usize`, found `char`\n\nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmpl1aef4n6.rs:8:21:\
    \ 16:10] as FnOnce<((usize, char),)>>::Output == Option<&_>`\n    --> /tmp/tmpl1aef4n6.rs:19:10\n\
    \     |\n19   |         .cloned()\n     |          ^^^^^^ expected reference,\
    \ found `isize`\n     |\n     = note: expected enum `Option<&_>`\n           \
    \     found enum `Option<isize>`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `FilterMap<CharIndices<'_>, [closure@/tmp/tmpl1aef4n6.rs:8:21:\
    \ 16:10]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<std::iter::Take<Skip<FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpl1aef4n6.rs:8:21: 16:10]>>>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpl1aef4n6.rs:20:10\n   |\n20 |            .collect()\n\
    \   |             ^^^^^^^ method cannot be called on `Cloned<std::iter::Take<Skip<FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpl1aef4n6.rs:8:21: 16:10]>>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<std::iter::Take<Skip<FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpl1aef4n6.rs:8:21: 16:10]>>> as Iterator>::Item = &_`\n    \
    \       which is required by `Cloned<std::iter::Take<Skip<FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpl1aef4n6.rs:8:21: 16:10]>>>>: Iterator`\n           `Cloned<std::iter::Take<Skip<FilterMap<CharIndices<'_>,\
    \ [closure@/tmp/tmpl1aef4n6.rs:8:21: 16:10]>>>>: Iterator`\n           which is\
    \ required by `&mut Cloned<std::iter::Take<Skip<FilterMap<CharIndices<'_>, [closure@/tmp/tmpl1aef4n6.rs:8:21:\
    \ 16:10]>>>>: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.lines()\n        .map(|l| {\n    \
    \        l.trim_end().parse().unwrap_or(0)\n        })\n        .scan(vec![],\
    \ |mut acc, c| {\n            match (c, acc.len() - 1) {\n                ((),\
    \ _) => acc.push(acc.len() as isize),\n                (((), _), _) => {\n   \
    \                 acc.push(acc.len() as isize);\n                }\n         \
    \       (mut c, _) => {\n                    match c {\n                     \
    \   ')' => {\n                            acc.pop();\n                       \
    \ }\n                        ']' => {\n                            acc.pop();\n\
    \                        }\n                        _ => ()\n                \
    \    }\n                }\n            }\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6hwbjo95.rs:13:18\n   |\n\
    12 |             match (c, acc.len() - 1) {\n   |                   ------------------\
    \ this expression has type `({integer}, usize)`\n13 |                 ((), _)\
    \ => acc.push(acc.len() as isize),\n   |                  ^^ expected integer,\
    \ found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6hwbjo95.rs:14:18\n\
    \   |\n12 |             match (c, acc.len() - 1) {\n   |                   ------------------\
    \ this expression has type `({integer}, usize)`\n13 |                 ((), _)\
    \ => acc.push(acc.len() as isize),\n14 |                 (((), _), _) => {\n \
    \  |                  ^^^^^^^ expected integer, found tuple\n   |\n   = note:\
    \ expected type `{integer}`\n             found tuple `(_, _)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6hwbjo95.rs:13:28\n   |\n13 |              \
    \   ((), _) => acc.push(acc.len() as isize),\n   |                           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `()`\n   |\n   =\
    \ note:   expected enum `Option<_>`\n           found unit type `()`\nhelp: try\
    \ wrapping the expression in `Some`\n   |\n13 |                 ((), _) => Some(acc.push(acc.len()\
    \ as isize)),\n   |                            +++++                         \
    \   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6hwbjo95.rs:14:33\n   |\n\
    14 |                   (((), _), _) => {\n   |  _________________________________^\n\
    15 | |                     acc.push(acc.len() as isize);\n16 | |             \
    \    }\n   | |_________________^ expected enum `Option`, found `()`\n   |\n  \
    \ = note:   expected enum `Option<_>`\n           found unit type `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6hwbjo95.rs:19:25\n   |\n18 |              \
    \       match c {\n   |                           - this expression has type `{integer}`\n\
    19 |                         ')' => {\n   |                         ^^^ expected\
    \ integer, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6hwbjo95.rs:22:25\n\
    \   |\n18 |                     match c {\n   |                           - this\
    \ expression has type "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_string = paren_string.trim();\n    if\
    \ paren_string.is_empty() {\n        return Vec::new();\n    }\n\n    let mut\
    \ levels = Vec::new();\n    let mut level = -1;\n    let mut paren_count = 0;\n\
    \    let mut paren_start = paren_string.chars();\n    let mut paren_end = paren_start;\n\
    \    loop {\n        if paren_count == 0 {\n            // If we have any parenthesis\
    \ in the string, start at 0\n            let mut pos = 0;\n            while pos\
    \ < paren_string.len() {\n                let char = paren_start.next().unwrap_or('(');\n\
    \                if char == '(' {\n                    level += 1;\n         \
    \           pos = 0;\n                } else if char == ')' {\n              \
    \      level -= 1;\n                    pos = 0;\n                } else {\n \
    \                   pos += 1;\n                }\n            }\n        }\n \
    \       let char = paren_start.next().unwrap_or('(');\n        if char == '('\
    \ {\n            paren_count += 1;\n        } else if char == ')' {\n        \
    \    paren_count -= 1;\n        }\n        if level == 0 && paren_count > 0 {\n\
    \            return levels;\n        }\n        let mut pos: Option<usize> = None;\n\
    \        while let Some(pos) = paren_end.next() {\n            if pos == '(' {\n\
    \                level += 1;\n            } else if pos == '(' && paren_count\
    \ > 0 {\n                level += 1;\n            } else if pos == ')' {\n   \
    \             level -= 1;\n            } else if pos == ')' && paren_count > 0\
    \ {\n                level -= 1;\n            }\n        }\n        if let Some(pos)\
    \ = pos {\n            paren_end = paren_string.position(pos, pos.end());\n  \
    \      }\n    }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `position` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpdacycj08.rs:56:38\n   |\n56 |             paren_end\
    \ = paren_string.position(pos, pos.end());\n   |                             \
    \         ^^^^^^^^ method not found in `&str`\n\nerror[E0599]: no method named\
    \ `end` found for type `usize` in the current scope\n  --> /tmp/tmpdacycj08.rs:56:56\n\
    \   |\n56 |             paren_end = paren_string.position(pos, pos.end());\n \
    \  |                                                        ^^^ method not found\
    \ in `usize`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut depth = 0;\n    let mut paren_depth = paren_string.len();\n\
    \    let mut nesting_levels: Vec<isize> = Vec::new();\n\n    while paren_depth\
    \ != 0 {\n        let paren_depth -= 1;\n        let chars_to_remove = paren_depth\
    \ - 1;\n\n        paren_depth = paren_string.chars()\n            .enumerate()\n\
    \            .filter(|(i, c)| c != ')' && c != '(')\n            .map(|(i, _)|\
    \ i)\n            .count();\n\n        depth += 1;\n        nesting_levels.push(depth);\n\
    \    }\n\n    nesting_levels.sort_unstable();\n    nesting_levels.reverse();\n\
    \n    nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: can't reassign to an uninitialized variable\n  --> /tmp/tmpi6jvb0rl.rs:12:25\n\
    \   |\n12 |         let paren_depth -= 1;\n   |                         ^^ help:\
    \ initialize the variable\n   |\n   = help: if you meant to overwrite, remove\
    \ the `let` binding\n\nerror[E0277]: can't compare `&char` with `char`\n  -->\
    \ /tmp/tmpi6jvb0rl.rs:17:32\n   |\n17 |             .filter(|(i, c)| c != ')'\
    \ && c != '(')\n   |                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpi6jvb0rl.rs:17:44\n   |\n17\
    \ |             .filter(|(i, c)| c != ')' && c != '(')\n   |                 \
    \                           ^^ no implementation for `&char == char`\n   |\n \
    \  = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_groups = paren_string.chars().filter_map(|c|\
    \ {\n        match c {\n            ')' if c != '(' | c == '\\n' => false,\n \
    \           c => true,\n        }\n    });\n\n    let mut paren_levels = vec![1isize];\n\
    \    let mut levels = 0;\n    for paren_group in paren_groups {\n        if paren_group\
    \ != ')' {\n            levels += paren_levels.last_mut().unwrap() + 1;\n    \
    \    }\n        paren_levels.push(levels);\n    }\n\n    let mut levels = paren_levels.clone();\n\
    \    while !levels.is_empty() {\n        let curr_level = levels.pop().unwrap();\n\
    \        if curr_level == 1 {\n            break;\n        }\n        levels.push(curr_level);\n\
    \    }\n    levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n --> /tmp/tmpfkgjzc5y.rs:9:22\n\
    \  |\n9 |             ')' if c != '(' | c == '\\n' => false,\n  |            \
    \          ^^         ^^\n\nerror[E0369]: no implementation for `char | char`\n\
    \ --> /tmp/tmpfkgjzc5y.rs:9:29\n  |\n9 |             ')' if c != '(' | c == '\\\
    n' => false,\n  |                         --- ^ - char\n  |                  \
    \       |\n  |                         char\n\nerror[E0308]: mismatched types\n\
    \ --> /tmp/tmpfkgjzc5y.rs:9:36\n  |\n9 |             ')' if c != '(' | c == '\\\
    n' => false,\n  |                                    ^^^^ expected `bool`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n --> /tmp/tmpfkgjzc5y.rs:9:44\n  |\n\
    9 |             ')' if c != '(' | c == '\\n' => false,\n  |                  \
    \                          ^^^^^ expected enum `Option`, found `bool`\n  |\n \
    \ = note: expected enum `Option<_>`\n             found type `bool`\nhelp: try\
    \ wrapping the expression in `Some`\n  |\n9 |             ')' if c != '(' | c\
    \ == '\\n' => Some(false),\n  |                                            +++++\
    \     +\n\nerror[E0369]: cannot add `{integer}` to `&mut isize`\n  --> /tmp/tmpfkgjzc5y.rs:18:56\n\
    \   |\n18 |             levels += paren_levels.last_mut().unwrap() + 1;\n   |\
    \                       -------------------------------- ^ - {integer}\n   | \
    \                      |\n   |                       &mut isize\n   |\nhelp: `+`\
    \ can be used on `isize`, you can dereference `paren_levels.last_mut().unwrap()`\n\
    \   |\n18 |             levels += *paren_levels.last_mut().unwrap() + 1;\n   |\
    \                       +\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens_chars = paren_string.chars();\n\
    \    let mut parens_level = Vec::new();\n\n    let mut parens_level_mut = parens_level.as_mut();\n\
    \    let mut parens_chars_mut = parens_chars.as_mut();\n\n    while parens_chars_mut.next().is_some()\
    \ {\n        let char = parens_chars_mut.next().unwrap();\n        if char ==\
    \ ')' {\n            if parens_level_mut.unwrap() < 2 {\n                return\
    \ parens_level_mut;\n            }\n            parens_level_mut = parens_level.clone();\n\
    \            parens_level_mut = parens_level_mut.push(parens_level_mut.len() -\
    \ 1);\n            parens_level_mut = parens_level_mut.clone();\n            parens_level_mut\
    \ = parens_level_mut.push(0);\n            parens_level_mut = parens_level_mut.clone();\n\
    \            parens_level_mut = parens_level_mut.push(1);\n        }\n       \
    \ if char == '(' {\n            parens_level_mut = parens_level.clone();\n   \
    \         parens_level_mut = parens_level_mut.push(parens_level_mut.len() - 1);\n\
    \            parens_level_mut = parens_level_mut.clone();\n            parens_level_mut\
    \ = parens_level_mut.push(0);\n            parens_level_mut = parens_level_mut.clone();\n\
    \            parens_level_mut = parens_level_mut.push(1);\n        }\n       \
    \ if char == ')' || char == ')(' {\n            parens_level_mut = parens_level_mut.clone();\n\
    \            parens_level_mut = parens_level_mut.push(0);\n            parens_level_mut\
    \ = parens_level_mut.clone();\n            parens_level_mut = parens_level_mut.push(0);\n\
    \            parens_level_mut = parens_level_mut.clone();\n            parens_level_mut\
    \ = parens_level_mut.push(1);\n        }\n        if char == ')(' {\n        \
    \    parens_level_mut = parens_level_mut.clone();\n            parens_level_mut\
    \ = parens_level_mut.push(0);\n            parens_level_mut = parens_level_mut.clone();\n\
    \            parens_level_mut = parens_level_mut.push(0);\n            parens_level_mut\
    \ = parens_level_mut.clone();\n            parens_level_mut = parens_level_mut.push(2);\n\
    \        }\n        parens_level_mut = parens_level_mut.clone();\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpnlpcnjaa.rs:34:35\n\
    \   |\n34 |         if char == ')' || char == ')(' {\n   |                   \
    \                ^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n34 |         if char == ')' || char == \")(\" {\n   | \
    \                                  ~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmpnlpcnjaa.rs:42:20\n   |\n42 |         if char ==\
    \ ')(' {\n   |                    ^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n42 |         if char == \")(\" {\n   |   \
    \                 ~~~~\n\nerror: this file contains an unclosed delimiter\n  -->\
    \ /tmp/tmpnlpcnjaa.rs:58:3\n   |\n6  | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n   |                                                      \
    \      - unclosed delimiter\n...\n13 |     while parens_chars_mut.next().is_some()\
    \ {\n   |                                             - this delimiter might not\
    \ be properly closed...\n...\n51 | }\n   | - ...as it matches this but it has\
    \ different indentation\n...\n58 | }\n   |   ^\n\nerror[E0599]: no method named\
    \ `as_mut` found for struct `Chars` in the current scope\n   --> /tmp/tmpnlpcnjaa.rs:11:45\n\
    \    |\n11  |     let mut parens_chars_mut = parens_chars.as_mut();\n    |   \
    \                                          ^^^^^^ method not found in `Chars<'_>`\n\
    \    |\nhelp: consider wrapping the receiver expression with the appropriate type\n\
    \    |\n11  |     let mut parens_chars_mut = Box::new(parens_chars).as_mut();\n\
    \    |                                +++++++++            +\nhelp: consider wrapping\
    \ the receiver expression with the appropriate type\n    |\n11  |     let mut\
    \ parens_chars_mut = Box::new(&mut parens_chars).as_mut();\n    |            \
    \                    +++++++++++++             +\nhelp: consider wrapping the\
    \ receiver expression with the appropriate type\n    |\n11  |     let mut parens_chars_mut\
    \ = Pin::new(&mut parens_chars).as_mut();\n    |                             \
    \   +++++++++++++             +\nhel"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().filter_map(|c|\n        if\
    \ c == '(' {\n            Some(1)\n        } else if c == ')' {\n            Some(0)\n\
    \        } else {\n            None\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmpf89z1okn.rs:15:6\n\
    \   |\n7  |     paren_string.chars().filter_map(|c|\n   |                    \
    \   -- block is empty, you might have not meant to close it\n...\n15 |     }).collect()\n\
    \   |      ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpf89z1okn.rs:7:36\n   |\n7  |     paren_string.chars().filter_map(|c|\n\
    \   |                                    ^ unclosed delimiter\n...\n15 |     }).collect()\n\
    \   |     ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.trim().split(' ').collect::<Vec<_>>().iter().enumerate().filter_map(|(i,\
    \ s)| {\n        if s.is_empty() {\n            Some(i)\n        } else {\n  \
    \          let mut level = 0;\n            let mut paren_depth = 1;\n        \
    \    for c in s.chars() {\n                if c == '(' {\n                   \
    \ paren_depth += 1;\n                } else if c == ')' {\n                  \
    \  paren_depth -= 1;\n                    if paren_depth == 0 {\n            \
    \            return Some(i);\n                    }\n                }\n     \
    \           level += 1;\n            }\n            None\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpc4n94gqm.rs:26:8\n     |\n26\
    \   |     }).collect()\n     |        ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_level: Vec<isize> = vec![0];\n  \
    \  let mut nesting_parens: Vec<isize> = vec![0];\n    for (i, &c) in paren_string.chars().enumerate()\
    \ {\n        if paren_level.is_empty() || paren_level[0] < i {\n            if\
    \ c == '(' {\n                paren_level.push(1);\n            } else if c ==\
    \ ')' {\n                paren_level.pop();\n            }\n        } else {\n\
    \            if c == '(' {\n                paren_level.push(i + 1);\n       \
    \     } else if c == ')' {\n                paren_level.pop();\n            }\n\
    \            if paren_level[0] >= i {\n                nesting_parens.push(paren_level[0]);\n\
    \                paren_level[0] = i;\n            }\n        }\n    }\n    if\
    \ paren_level.is_empty() {\n        return vec![0];\n    }\n    nesting_parens\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpmno5oms5.rs:9:13\n  |\n9 |\
    \     for (i, &c) in paren_string.chars().enumerate() {\n  |             ^^  \
    \   -------------------------------- this expression has type `Option<(usize,\
    \ char)>`\n  |             |\n  |             expected `char`, found reference\n\
    \  |             help: you can probably remove the explicit borrow: `c`\n  |\n\
    \  = note:   expected type `char`\n          found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmno5oms5.rs:10:55\n   |\n10 |         if paren_level.is_empty()\
    \ || paren_level[0] < i {\n   |                                              \
    \         ^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n10 |     \
    \    if paren_level.is_empty() || paren_level[0] < i.try_into().unwrap() {\n \
    \  |                                                        ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmno5oms5.rs:18:34\n   |\n18 |\
    \                 paren_level.push(i + 1);\n   |                             \
    \     ^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n18 |     \
    \            paren_level.push((i + 1).try_into().unwrap());\n   |            \
    \                      +     +++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmno5oms5.rs:22:34\n   |\n22 |             if paren_level[0]\
    \ >= i {\n   |                                  ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n22 |             if paren_level[0] >= i.try_into().unwrap()\
    \ {\n   |                                   ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmno5oms5.rs:24:34\n   |\n24 |              \
    \   paren_level[0] = i;\n   |                 --------------   ^ expected `isize`,\
    \ found `usize`\n   |                 |\n   |                 expected due to\
    \ the type of this binding\n\nerror: aborting due to 5"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter(|c|\
    \ {\n            c != '(' && c != ')' && c != '[' && c != ']' && c != '{' && c\
    \ != '}'\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:15\n\
    \   |\n10 |             c != '(' && c != ')' && c != '[' && c != ']' && c != '{'\
    \ && c != '}'\n   |               ^^ no implementation for `&char == char`\n \
    \  |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:27\n   |\n10 |   \
    \          c != '(' && c != ')' && c != '[' && c != ']' && c != '{' && c != '}'\n\
    \   |                           ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:39\n   |\n10 |           \
    \  c != '(' && c != ')' && c != '[' && c != ']' && c != '{' && c != '}'\n   |\
    \                                       ^^ no implementation for `&char == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't\
    \ compare `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:51\n   |\n10 |   \
    \          c != '(' && c != ')' && c != '[' && c != ']' && c != '{' && c != '}'\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:63\n\
    \   |\n10 |             c != '(' && c != ')' && c != '[' && c != ']' && c != '{'\
    \ && c != '}'\n   |                                                          \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp129meyzs.rs:10:75\n\
    \   |\n10 |         "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars().enumerate()\n        .filter_map(|(idx,\
    \ ch)| {\n            match ch {\n                '(' | ')' => {\n           \
    \         let level = idx + 1;\n                    if level > 0 && level < paren_string.len()\
    \ {\n                        Some(level)\n                    } else {\n     \
    \                   None\n                    }\n                }\n         \
    \       _ => None,\n            }\n        })\n        .collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpcnhz04jd.rs:21:10\n     |\n21\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels: Vec<isize> = paren_string.chars().filter_map(|c|\
    \ {\n        if c == '(' {\n            Some(0)\n        } else {\n          \
    \  Some(1)\n        }\n    }).collect();\n    levels.push(paren_string.chars().filter(|c|\
    \ c == '(').count());\n    levels.into_iter().rev().collect()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzawscn0x.rs:14:51\n\
    \   |\n14 |     levels.push(paren_string.chars().filter(|c| c == '(').count());\n\
    \   |                                                   ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzawscn0x.rs:14:17\n   |\n14 |  \
    \   levels.push(paren_string.chars().filter(|c| c == '(').count());\n   |    \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n14 |     levels.push(paren_string.chars().filter(|c|\
    \ c == '(').count().try_into().unwrap());\n   |                              \
    \                                    ++++++++++++++++++++\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut open_index\
    \ = 0;\n\n    for paren in paren_string.chars().filter_map(|c| *c != '(' && c\
    \ != ')') {\n        match paren {\n            '(' | ')' | ' ' => {\n       \
    \         paren_stack.push(open_index);\n            }\n            _ => {\n \
    \               open_index = paren_stack.last().unwrap();\n            }\n   \
    \     }\n    }\n\n    paren_stack.last().unwrap() + 1\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp_sddesdw.rs:10:54\n\
    \   |\n10 |     for paren in paren_string.chars().filter_map(|c| *c != '(' &&\
    \ c != ')') {\n   |                                                      ^^\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_sddesdw.rs:10:54\n   |\n10 |  \
    \   for paren in paren_string.chars().filter_map(|c| *c != '(' && c != ')') {\n\
    \   |                                                      ^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n10 |     for paren in paren_string.chars().filter_map(|c| Some(*c != '('\
    \ && c != ')')) {\n   |                                                      +++++\
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_sddesdw.rs:16:30\n\
    \   |\n8  |     let mut open_index = 0;\n   |                          - expected\
    \ due to this value\n...\n16 |                 open_index = paren_stack.last().unwrap();\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected integer,\
    \ found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n   |\n16\
    \ |                 open_index = *paren_stack.last().unwrap();\n   |         \
    \                     +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_sddesdw.rs:21:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n21 |     paren_stack.last().unwrap() + 1\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found integer\n \
    \  |\n   = note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![];\n    let mut i =\
    \ 0;\n    let mut group_len = 0;\n    for c in paren_string.chars() {\n      \
    \  if c == '(' {\n            paren_stack.push(group_len);\n            group_len\
    \ = 1;\n        } else if c == '{' {\n            paren_stack.push(group_len);\n\
    \            group_len = 2;\n        } else if c == '[' {\n            paren_stack.push(group_len);\n\
    \            group_len = 3;\n        } else if c == '}' {\n            paren_stack.pop();\n\
    \            group_len = paren_stack[paren_stack.len() - 1];\n        } else if\
    \ c == ']' {\n            paren_stack.pop();\n            group_len = paren_stack[paren_stack.len()\
    \ - 1];\n        } else {\n            group_len += 1;\n        }\n        i +=\
    \ 1;\n    }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 4, 1, 1, 5, 3, 1, 1, 3, 2]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp3nz3roo6.rs:36:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter_map(|c|\
    \ match c {\n            ' ' | '\\t' => None,\n            '(' | ')' | '+' | '-'\
    \ | '*' | '/' | '%' => Some(c - '('),\n            _ => None,\n        })\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpcc8p883x.rs:11:63\n\
    \   |\n11 |             '(' | ')' | '+' | '-' | '*' | '/' | '%' => Some(c - '('),\n\
    \   |                                                             - ^ --- char\n\
    \   |                                                             |\n   |    \
    \                                                         char\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0369`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(\"()\")\n        .map(|s|\
    \ s.len())\n        .max()\n        .unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm68tiocb.rs:7:5\n   |\n6\
    \  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |    \
    \                                               ---------- expected `Vec<isize>`\
    \ because of return type\n7  | /     paren_string\n8  | |         .split(\"()\"\
    )\n9  | |         .map(|s| s.len())\n10 | |         .max()\n11 | |         .unwrap()\n\
    \   | |_________________^ expected struct `Vec`, found `usize`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens: Vec<isize> = Vec::new();\n    let\
    \ mut depth = 0;\n    let mut par_open = false;\n\n    for ch in paren_string.chars()\
    \ {\n        match ch {\n            '(' | ')' => {\n                par_open\
    \ = ch == '(';\n                parens.push(depth);\n            }\n         \
    \   _ if par_open || parens.len() == 0 => {\n                parens.pop();\n \
    \           }\n            _ => (),\n        }\n        depth += 1;\n    }\n\n\
    \    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 2, 3, 4, 5, 7, 8, 9, 10, 11, 12, 14, 15, 17, 18, 19, 20, 21, 22, 23,\
    \ 24, 25, 26]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpdnrifeg6.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split_whitespace().collect::<Vec<_>>()\n\
    \        .filter(|c| !c.is_empty())\n        .filter_map(|c| c.is_('(') || c.is_(')'))\n\
    \        .max_by_key(|c| paren_string.chars().position(|x| x == c).unwrap())\n\
    \        .map(|c| paren_string.chars().position(|x| x == c).unwrap() + 1)\n  \
    \      .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<&str>` is not an iterator\n   --> /tmp/tmp8gx9e1n2.rs:8:10\n\
    \    |\n8   |           .filter(|c| !c.is_empty())\n    |            ^^^^^^ `Vec<&str>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<&str>: Iterator`\n            which is required by `&mut Vec<&str>:\
    \ Iterator`\n            `[&str]: Iterator`\n            which is required by\
    \ `&mut [&str]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut depth = 0;\n  \
    \  let mut out: Vec<isize> = Vec::new();\n\n    for paren in paren_string.chars().filter(|c|\
    \ c == '(' || c == '{' || c == '[') {\n        if paren == '(' {\n           \
    \ level += 1;\n            depth += 1;\n        }\n        if paren == ')' {\n\
    \            if level > 0 {\n                level -= 1;\n                depth\
    \ += 1;\n            }\n        }\n        if paren == '}' {\n            if level\
    \ > 0 {\n                level -= 1;\n                depth += 1;\n          \
    \  }\n        }\n        if paren == ']' {\n            if level > 0 {\n     \
    \           level -= 1;\n                depth += 1;\n            }\n        }\n\
    \        if level == 0 {\n            if paren != '(' {\n                out.push(depth);\n\
    \            }\n        }\n    }\n\n    out\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5usv6n1o.rs:11:52\n\
    \   |\n11 |     for paren in paren_string.chars().filter(|c| c == '(' || c ==\
    \ '{' || c == '[') {\n   |                                                   \
    \ ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp5usv6n1o.rs:11:64\n\
    \   |\n11 |     for paren in paren_string.chars().filter(|c| c == '(' || c ==\
    \ '{' || c == '[') {\n   |                                                   \
    \             ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp5usv6n1o.rs:11:76\n   |\n11 |     for paren in paren_string.chars().filter(|c|\
    \ c == '(' || c == '{' || c == '[') {\n   |                                  \
    \                                          ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = paren_string.len();\n   \
    \ let mut depth = 0;\n    let mut opening_levels = 0;\n\n    while open_parens(&paren_count,\
    \ &mut opening_levels, &mut depth)\n        && paren_count > 0\n    {\n      \
    \  paren_count -= 1;\n        depth -= 1;\n    }\n\n    paren_count.into()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `open_parens` in this scope\n  --> /tmp/tmpfxx2ajeu.rs:11:11\n\
    \   |\n11 |     while open_parens(&paren_count, &mut opening_levels, &mut depth)\n\
    \   |           ^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the trait\
    \ bound `Vec<isize>: From<usize>` is not satisfied\n  --> /tmp/tmpfxx2ajeu.rs:18:17\n\
    \   |\n18 |     paren_count.into()\n   |                 ^^^^ the trait `From<usize>`\
    \ is not implemented for `Vec<isize>`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <Vec<T, A> as From<Box<[T], A>>>\n\
    \             <Vec<T, A> as From<VecDeque<T, A>>>\n             <Vec<T> as From<&[T]>>\n\
    \             <Vec<T> as From<&mut [T]>>\n             <Vec<T> as From<BinaryHeap<T>>>\n\
    \             <Vec<T> as From<Cow<'a, [T]>>>\n             <Vec<T> as From<[T;\
    \ N]>>\n             <Vec<u8> as From<&str>>\n           and 2 others\n   = note:\
    \ required because of the requirements on the impl of `Into<Vec<isize>>` for `usize`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .filter(|c| !c.is_ascii_letter())\n        .filter(|c| !c.is_ascii_digit())\n\
    \        .filter(|c| c != '(' && c != ')')\n        .filter(|c| c != '[' && c\
    \ != ']')\n        .filter(|c| c != ']')\n        .map(|c| c.to_ascii_lowercase().parse::<isize>())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&&str`\
    \ in the current scope\n --> /tmp/tmprir5epzz.rs:9:24\n  |\n9 |         .filter(|c|\
    \ !c.is_ascii_letter())\n  |                        ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no\
    \ method named `is_ascii_digit` found for reference `&&str` in the current scope\n\
    \  --> /tmp/tmprir5epzz.rs:10:24\n   |\n10 |         .filter(|c| !c.is_ascii_digit())\n\
    \   |                        ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `&&str` with\
    \ `char`\n  --> /tmp/tmprir5epzz.rs:11:23\n   |\n11 |         .filter(|c| c !=\
    \ '(' && c != ')')\n   |                       ^^ no implementation for `&&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&&str` with `char`\n  --> /tmp/tmprir5epzz.rs:11:35\n   |\n11 |         .filter(|c|\
    \ c != '(' && c != ')')\n   |                                   ^^ no implementation\
    \ for `&&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\ner"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parentheses_level: usize = 1;\n    let\
    \ mut parenthese_stack: Vec<isize> = Vec::new();\n    let mut paren_characters\
    \ = paren_string.chars();\n    while paren_characters.next() != Some('(') {\n\
    \        if parenthese_stack.len() > 0 {\n            parentheses_level += 1;\n\
    \            parenthese_stack.pop();\n        }\n        parenthese_stack.push(paren_characters.next());\n\
    \    }\n    parenthese_stack.len()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc86ox29c.rs:15:31\n   |\n\
    15 |         parenthese_stack.push(paren_characters.next());\n   |           \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n\
    \   |\n   = note: expected type `isize`\n              found enum `Option<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc86ox29c.rs:17:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n17 |     parenthese_stack.len()\n   |     ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    for paren\
    \ in paren_string.split(' ').filter_map(|x| x.chars().collect()) {\n        if\
    \ paren == '(' {\n            paren_stack.push(paren_stack.len() as isize);\n\
    \        } else if paren == ')' {\n            paren_stack.pop();\n        }\n\
    \    }\n    if paren_stack.len() != 0 {\n        paren_stack.last().unwrap()\n\
    \    } else {\n        0\n    }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Option<_>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp16mgaz5u.rs:8:67\n     |\n8  \
    \  |     for paren in paren_string.split(' ').filter_map(|x| x.chars().collect())\
    \ {\n     |                                                                  \
    \ ^^^^^^^ value of type `Option<_>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Option<_>`\n\
    \     = help: the trait `FromIterator<Option<A>>` is implemented for `Option<V>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp16mgaz5u.rs:16:9\n   |\n6  | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n   |                                                 ----------\
    \ expected `Vec<isize>` because of return type\n...\n16 |         paren_stack.last().unwrap()\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&isize`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n           found reference `&isize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp16mgaz5u.rs:18:9\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n18 |         0\n   |         ^ expected struct `Vec`, found\
    \ integer\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `{integer}`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 1;\n    let mut i = 0;\n    let\
    \ mut cur_pos = 0;\n    let mut cur_level = 0;\n    let mut open_brackets = false;\n\
    \    let mut closed_brackets = false;\n    let mut cur_stack: Vec<Vec<isize>>\
    \ = Vec::new();\n    let mut cur_stack_size = -1;\n    let mut last_brace = false;\n\
    \n    let mut open_brackets = paren_string.chars().any(|c| c == ')');\n    let\
    \ mut closed_brackets = paren_string.chars().any(|c| c == '(');\n\n    while i\
    \ < paren_string.len() {\n        let cur_char = paren_string[cur_pos];\n    \
    \    cur_pos +=1;\n        let mut new_level = cur_level;\n        if cur_level\
    \ > level {\n            new_level = level;\n        }\n\n        if open_brackets\
    \ && !closed_brackets {\n            new_level = level + 1;\n        }\n\n   \
    \     if cur_char == ')' {\n            cur_stack = cur_stack.pop();\n       \
    \     cur_stack_size = cur_stack.len();\n        }\n\n        if cur_char == '('\
    \ {\n            if !closed_brackets {\n                open_brackets = true;\n\
    \            }\n            else {\n                closed_brackets = false;\n\
    \            }\n\n            if new_level < level {\n                new_level\
    \ = level;\n            }\n        }\n\n        if closed_brackets {\n       \
    \     closed_brackets = false;\n        }\n\n        level = new_level;\n\n  \
    \      if open_brackets && cur_char == ')' {\n            open_brackets = false;\n\
    \            cur_stack.push(level);\n            cur_stack_size = cur_stack_size;\n\
    \        }\n        if closed_brackets && cur_char == '(' {\n            closed_brackets\
    \ = false;\n            cur_stack = cur_stack.clone();\n            cur_stack_size\
    \ = cur_stack_size;\n        }\n\n        if cur_char == ')' {\n            if\
    \ closed_brackets {\n                closed_brackets = false;\n            }\n\
    \            cur_stack.push(level);\n        }\n\n        if cur_char == '(' {\n\
    \            if open_brackets {\n                open_brackets = false;\n    \
    \        }\n            cur_stack.push(level);\n        }\n\n        i += 1;\n\
    \    }\n\n    cur_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpr07q5b48.rs:21:24\n   |\n21 |         let cur_char = paren_string[cur_pos];\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr07q5b48.rs:33:25\n\
    \   |\n13 |     let mut cur_stack: Vec<Vec<isize>> = Vec::new();\n   |       \
    \                 --------------- expected due to this type\n...\n33 |       \
    \      cur_stack = cur_stack.pop();\n   |                         ^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<Vec<isize>>`\n                found enum `Option<Vec<isize>>`\n\nerror[E0277]:\
    \ the trait bound `usize: Neg` is not satisfied\n  --> /tmp/tmpr07q5b48.rs:14:30\n\
    \   |\n14 |     let mut cur_stack_size = -1;\n   |                           \
    \   ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help: the following\
    \ other types implement trait `Neg`:\n             &f32\n             &f64\n \
    \            &i128\n             &i16\n             &i32\n             &i64\n\
    \             &i8\n             &isize\n           and 8 others\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr07q5b48.rs:58:28\n   |\n58 |             cur_stack.push(level);\n\
    \   |                            ^^^^^ expected struct `Vec`, found integer\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpr07q5b48.rs:71:28\n   |\n71 |\
    \             cur_stack.push(level);\n   |                            ^^^^^ expected\
    \ struct `Vec`,"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars()\n        .map(|c| *c)\n  \
    \      .collect()\n        .iter()\n        .cloned()\n        .enumerate()\n\
    \        .filter_map(|(i, c)| {\n            if c == '(' && paren_string[..i +\
    \ 1].chars().any(|c| c == '(') {\n                Some(i)\n            } else\
    \ {\n                None\n            }\n        })\n        .take_while(|&(i,\
    \ _)| paren_string[..i + 1].chars().any(|c| c == ')'))\n        .map(|(i, _)|\
    \ i)\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n --> /tmp/tmplk0xzpa2.rs:8:18\n\
    \  |\n8 |         .map(|c| *c)\n  |                  ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // First parse the string to get the number of\
    \ levels of nesting.\n    let paren_level_count = paren_string\n        .chars()\n\
    \        .filter_map(|c|\n            if c == '(' && paren_string[c.position()]\
    \ == ')' {\n                Some(1)\n            } else {\n                None\n\
    \            })\n        .count();\n    // The algorithm below works just fine\
    \ with empty parenthesis string.\n    if paren_level_count == 0 {\n        return\
    \ vec![];\n    }\n    // Initialize result list to store the levels.\n    let\
    \ mut nested_levels = Vec::new();\n    // Start parsing the string to get the\
    \ deepest level.\n    let mut current_level = 0;\n    let mut last_char = '\\\
    0';\n    for index in paren_string.char_indices().rev() {\n        // If the current\
    \ character is '(' and last_char is ')', increment the current level.\n      \
    \  if index == paren_string.char_indices().last() && paren_string[index] == '('\
    \ {\n            current_level += 1;\n        }\n        // If the current character\
    \ is ')' and last_char is '(', decrement the current level.\n        if index\
    \ == paren_string.char_indices().last() && paren_string[index] == ')' {\n    \
    \        current_level -= 1;\n        }\n        // If the current level is 0,\
    \ append it to the result list.\n        if current_level == 0 {\n           \
    \ nested_levels.push(current_level);\n        }\n        // Keep track of the\
    \ last character for the current level.\n        last_char = paren_string[index];\n\
    \    }\n    // If the string ends with ')', add the last level.\n    if last_char\
    \ == ')' {\n        nested_levels.push(current_level);\n    }\n    nested_levels.reverse()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `position` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpw1flh_zd.rs:11:43\n   |\n11 |             if c == '(' &&\
    \ paren_string[c.position()] == ')' {\n   |                                  \
    \         ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw1flh_zd.rs:28:21\n   |\n28 |         if index == paren_string.char_indices().last()\
    \ && paren_string[index] == '(' {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize,\
    \ char)`\n               found enum `Option<(usize, char)>`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `(usize, char)`\n  --> /tmp/tmpw1flh_zd.rs:28:59\n\
    \   |\n28 |         if index == paren_string.char_indices().last() && paren_string[index]\
    \ == '(' {\n   |                                                           ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `(usize, char)`\n   |\n   = help: the trait `Index<(usize,\
    \ char)>` is not implemented for `String`\n   = help: the following other types\
    \ implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1flh_zd.rs:32:21\n\
    \   |\n32 |         if index == paren_string.char_indices().last() && paren_string[index]\
    \ == ')' {\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, char)`\n\
    \               found enum `Option<(usize, char)>`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `(usize, char)`\n  --> /tmp/tmpw1flh_zd.rs:32:59\n   |\n\
    32 |         if index == paren_string.char_indices().last() && paren_string[index]\
    \ == ')' {\n   |                                                       "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|x| x.parse::<usize>().unwrap())\n        .filter(|x| x > 0)\n    \
    \    .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfzkjychu.rs:10:25\n   |\n\
    10 |         .filter(|x| x > 0)\n   |                         ^\n   |        \
    \                 |\n   |                         expected `&usize`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfzkjychu.rs:7:5\n   |\n6  |   fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \     ---------- expected `Vec<isize>` because of return type\n7  | /     paren_string\n\
    8  | |         .split_whitespace()\n9  | |         .map(|x| x.parse::<usize>().unwrap())\n\
    10 | |         .filter(|x| x > 0)\n11 | |         .collect::<Vec<_>>()\n   | |____________________________^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split(\" \").map(|x| x.parse().unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpr86qs9l3.rs:7:47

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split('\\n')\n        .map(|x|\
    \ x.parse::<usize>().unwrap())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpt4swwy0s.rs:10:10\n     |\n10\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut paren_start\
    \ = 0;\n    let mut paren_end = paren_string.len();\n\n    let mut paren_depth\
    \ = 0;\n    let mut paren_levels = Vec::new();\n\n    let mut level = 0;\n   \
    \ let mut levels = Vec::new();\n    let mut paren_levels = Vec::new();\n\n   \
    \ // Keep running until we encounter a ) without encountering a left paren.\n\
    \    while paren_start < paren_end {\n        match paren_string[paren_start]\
    \ {\n            '(' | '[' | '{' | ')' => {\n                paren_count = paren_count\n\
    \                    .saturating_sub(1)\n                    .wrapping_add(1);\n\
    \                paren_end = paren_end - 1;\n                paren_start = paren_start\
    \ + 1;\n            }\n            '[' => {\n                level = 1;\n    \
    \        }\n            '{' => {\n                level = 2;\n            }\n\
    \            _ => {\n                paren_count = paren_count\n             \
    \       .saturating_sub(1)\n                    .wrapping_add(1);\n          \
    \      paren_end = paren_end - 1;\n                paren_start = paren_start +\
    \ 1;\n            }\n        }\n\n        // If we encounter a left paren and\
    \ this right paren is not the last character of the string,\n        // then we\
    \ found a nested parentheses group. Add this group level to\n        // our current\
    \ level of nesting.\n        match paren_string[paren_end] {\n            '('\
    \ | '[' | '{' | ')' => {\n                paren_levels.insert(0, level);\n   \
    \             level += 1;\n            }\n            _ => {\n               \
    \ level += 1;\n            }\n        }\n\n        // If we encounter a right\
    \ paren and this left paren is not the first character of the string,\n      \
    \  // then we found a nested parentheses group. Remove this group level from\n\
    \        // our current level of nesting.\n        match paren_string[paren_start]\
    \ {\n            '(' | '[' | '{' | ')' => {\n                paren_levels.pop();\n\
    \                level -= 1;\n            }\n            _ => {\n            \
    \    level -= 1;\n            }\n        }\n    }\n    paren_levels\n        .into_iter()\n\
    \        .map(|level| {\n            (level as isize)\n                .saturating_sub(1)\n\
    \                .wrapping_add(1)\n                .max(0)\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeiqhdrwf.rs:20:15\n\
    \   |\n20 |         match paren_string[paren_start] {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0689]: can't call method `saturating_sub` on ambiguous numeric\
    \ type `{integer}`\n  --> /tmp/tmpeiqhdrwf.rs:23:22\n   |\n23 |              \
    \       .saturating_sub(1)\n   |                      ^^^^^^^^^^^^^^\n   |\nhelp:\
    \ you must specify a type for this binding, like `i32`\n   |\n7  |     let mut\
    \ paren_count: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~\n\nerror[E0689]: can't\
    \ call method `saturating_sub` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpeiqhdrwf.rs:36:22\n\
    \   |\n36 |                     .saturating_sub(1)\n   |                     \
    \ ^^^^^^^^^^^^^^\n   |\nhelp: you must specify a type for this binding, like `i32`\n\
    \   |\n7  |     let mut paren_count: i32 = 0;\n   |         ~~~~~~~~~~~~~~~~~~~~\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeiqhdrwf.rs:46:15\n\
    \   |\n46 |         match paren_string[paren_end] {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = vec![None];\n    let mut\
    \ nesting = 0;\n    for ch in paren_string.chars() {\n        if ch == ')' {\n\
    \            if paren_stack[nesting - 1].is_some() {\n                return vec![nesting];\n\
    \            } else {\n                nesting += 1;\n            }\n        }\n\
    \n        if ch == '(' {\n            if paren_stack[nesting].is_none() {\n  \
    \              paren_stack[nesting] = Some(nesting);\n            }\n        }\n\
    \    }\n\n    panic!(\"Unmatched parenthesis in {:?}\", paren_string);\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy51n3jqk.rs:12:29\n   |\n\
    12 |                 return vec![nesting];\n   |                             ^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n12 |           \
    \      return vec![nesting.try_into().unwrap()];\n   |                       \
    \             ++++++++++++++++++++\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut result = vec![0];\n    let mut paren_stack:\
    \ Vec<Vec<usize>> = vec![vec![2]];\n\n    for paren in paren_string.chars().filter_map(|c|\
    \ c != '(' && c != ')').collect::<Vec<_>>() {\n        // handle ( and )\n   \
    \     if paren == '(' {\n            let mut level = paren_stack.last().unwrap().len()\
    \ + 1;\n            paren_stack\n                .last_mut()\n               \
    \ .unwrap()\n                .push(i);\n            if paren_stack.len() > level.min(||\
    \ level) {\n                result = result.iter().cloned().collect();\n     \
    \       }\n        }\n\n        // handle )\n        if paren == ')' {\n     \
    \       let paren = paren_stack.last().unwrap().pop();\n            let mut level\
    \ = paren_stack.last().unwrap().len();\n            paren_stack.last_mut().unwrap().push(paren);\n\
    \            if paren_stack.len() > level.max(|| level) {\n                result\
    \ = result.iter().cloned().collect();\n            }\n        }\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmpdyb3ly3f.rs:17:23\n\
    \   |\n17 |                 .push(i);\n   |                       ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyb3ly3f.rs:10:54\n\
    \   |\n10 |     for paren in paren_string.chars().filter_map(|c| c != '(' && c\
    \ != ')').collect::<Vec<_>>() {\n   |                                        \
    \              ^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `bool`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found type `bool`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n10 |     for paren in paren_string.chars().filter_map(|c|\
    \ Some(c != '(' && c != ')')).collect::<Vec<_>>() {\n   |                    \
    \                                  +++++                    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdyb3ly3f.rs:18:46\n   |\n18 |             if\
    \ paren_stack.len() > level.min(|| level) {\n   |                            \
    \                  ^^^^^^^^ expected `usize`, found closure\n   |\n   = note:\
    \ expected type `usize`\n           found closure `[closure@/tmp/tmpdyb3ly3f.rs:18:46:\
    \ 18:54]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyb3ly3f.rs:27:50\n\
    \   |\n27 |             paren_stack.last_mut().unwrap().push(paren);\n   |   \
    \                                               ^^^^^ expected `usize`, found\
    \ enum `Option`\n   |\n   = note: expected type `usize`\n              found enum\
    \ `Option<usize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyb3ly3f.rs:28:46\n\
    \   |\n28 |             if paren_stack.len() > level.max(|| level) {\n   |   \
    \                                           ^^^^^^^^ expected `usize`, found closure\n\
    \   |\n   = note: expected type `usize`\n           found closure `[closure@/tmp/tmpdyb3ly3f.rs:28:46:\
    \ 28:54]`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_stack = Vec::new();\n    let mut paren_level = 0;\n\n    for paren in\
    \ paren_string.chars() {\n        if paren == char::parenthesis_left {\n     \
    \       if paren_stack.len() > 0 {\n                paren_level += paren_stack.len();\n\
    \            }\n            paren_stack.pop();\n        } else if paren == char::parenthesis_right\
    \ {\n            if paren_stack.len() == 0 {\n                break;\n       \
    \     }\n            paren_stack.push(paren_level);\n            paren_level =\
    \ 0;\n        }\n    }\n    paren_stack.reverse();\n    paren_stack\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `parenthesis_left` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpzihiujf5.rs:12:27\n   |\n\
    12 |         if paren == char::parenthesis_left {\n   |                      \
    \     ^^^^^^^^^^^^^^^^ function or associated item not found in `char`\n\nerror[E0599]:\
    \ no function or associated item named `parenthesis_right` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpzihiujf5.rs:17:34\n   |\n17 |         }\
    \ else if paren == char::parenthesis_right {\n   |                           \
    \       ^^^^^^^^^^^^^^^^^ function or associated item not found in `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpzihiujf5.rs:26:5\n   |\n6  | fn\
    \ parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |            \
    \                                     ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     paren_stack\n   |     ^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut level = 0;\n\
    \    paren_string.chars().for_each(|c| {\n        match c {\n            '(' |\
    \ '[' => {\n                paren_count += 1;\n            }\n            ')'\
    \ | ']' => {\n                paren_count -= 1;\n            }\n            _\
    \ => {\n                let current_level = level;\n                level += 1;\n\
    \                if paren_count == 0 {\n                    level = current_level;\n\
    \                }\n            }\n        }\n    });\n\n    let mut nested_parens\
    \ = Vec::<isize>::new();\n    paren_string.chars().for_each(|c| {\n        match\
    \ c {\n            '(' | '[' => {\n                nested_parens.push((level -\
    \ 1) + (paren_count + 1));\n            }\n            ')' | ']' => {\n      \
    \          nested_parens.pop();\n            }\n            _ => ()\n        }\n\
    \    });\n    nested_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmp3hj64ak2.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .filter(|c|\
    \ *c != '(' && c != ')')\n        .filter(|c| *c != '[')\n        .filter(|c|\
    \ *c != ']')\n        .filter(|c| *c != '{')\n        .filter(|c| *c != '}')\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpxpyohnxd.rs:9:36\n\
    \  |\n9 |         .filter(|c| *c != '(' && c != ')')\n  |                    \
    \                ^^ no implementation for `&char == char`\n  |\n  = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `char`\n    --> /tmp/tmpxpyohnxd.rs:14:10\n\
    \     |\n14   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<isize>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split('\\n')\n        .filter_map(|x|\
    \ x.chars().filter(|c| c == ('(' | ')' | '\"' | 't' | '|'))).collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char | char`\n --> /tmp/tmp1h3guxav.rs:9:56\n\
    \  |\n9 |         .filter_map(|x| x.chars().filter(|c| c == ('(' | ')' | '\"'\
    \ | 't' | '|'))).collect()\n  |                                              \
    \      --- ^ --- char\n  |                                                   \
    \ |\n  |                                                    char\n\nerror[E0308]:\
    \ mismatched types\n --> /tmp/tmp1h3guxav.rs:9:25\n  |\n9 |         .filter_map(|x|\
    \ x.chars().filter(|c| c == ('(' | ')' | '\"' | 't' | '|'))).collect()\n  |  \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `Filter`\n  |\n  = note: expected enum\
    \ `Option<_>`\n           found struct `Filter<Chars<'_>, [closure@/tmp/tmp1h3guxav.rs:9:42:\
    \ 9:80]>`\nhelp: try wrapping the expression in `Some`\n  |\n9 |         .filter_map(|x|\
    \ Some(x.chars().filter(|c| c == ('(' | ')' | '\"' | 't' | '|')))).collect()\n\
    \  |                         +++++                                           \
    \             +\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    paren_string\n        .trim()\n\
    \        .split_whitespace()\n        .map(|s| {\n            if s == \"(\" ||\
    \ s == \")\" {\n                level += 1;\n            }\n            level\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 0, 0, 0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpr_h3bcwh.rs:22:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split_whitespace().into_iter().map(|x|\
    \ paren_nesting(x)).max_by_unstable().collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `paren_nesting` in this scope\n -->\
    \ /tmp/tmpwcs4ifc2.rs:7:57\n  |\n7 |     paren_string.split_whitespace().into_iter().map(|x|\
    \ paren_nesting(x)).max_by_unstable().collect()\n  |                         \
    \                                ^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_string`\n\nerror[E0599]: no method named `max_by_unstable`\
    \ found for struct `Map` in the current scope\n --> /tmp/tmpwcs4ifc2.rs:7:75\n\
    \  |\n7 |     paren_string.split_whitespace().into_iter().map(|x| paren_nesting(x)).max_by_unstable().collect()\n\
    \  |                                                                         \
    \  ^^^^^^^^^^^^^^^ method not found in `Map<SplitWhitespace<'_>, _>`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .filter_map(|c| {\n            if c == '(' {\n                Some(1)\n\
    \            } else {\n                Some(0)\n            }\n        })\n  \
    \      .max()\n        .unwrap()\n        .clone()\n        .checked_add(-1)\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmp3ivovn_r.rs:10:18\n\
    \   |\n10 |             if c == '(' {\n   |                  ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0689]: can't call\
    \ method `checked_add` on ambiguous numeric type `{integer}`\n  --> /tmp/tmp3ivovn_r.rs:19:10\n\
    \   |\n19 |         .checked_add(-1)\n   |          ^^^^^^^^^^^\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0689.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = vec![0; paren_string.len()];\n\
    \    let mut bracket_count = 0;\n    let mut i = 0;\n    while i < paren_string.len()\
    \ {\n        if paren_string[i] == ')' {\n            if paren_count[i] > bracket_count\
    \ {\n                bracket_count = paren_count[i];\n            }\n        \
    \    paren_count[i] += 1;\n        }\n        if paren_string[i] == '(' { paren_count[i]\
    \ += 1 }\n        if paren_string[i] == ')' {\n            if paren_count[i] >\
    \ bracket_count {\n                bracket_count = paren_count[i];\n         \
    \   }\n            paren_count[i] -= 1;\n        }\n        i += 1;\n    }\n \
    \   paren_count\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphojv7eqs.rs:11:12\n\
    \   |\n11 |         if paren_string[i] == ')' {\n   |            ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphojv7eqs.rs:17:12\n   |\n17 |         if paren_string[i] == '('\
    \ { paren_count[i] += 1 }\n   |            ^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphojv7eqs.rs:18:12\n   |\n18 |         if paren_string[i] == ')'\
    \ {\n   |            ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n      "
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut depth: usize = 0;\n    let mut parens:\
    \ Vec<isize> = vec![];\n    let mut parens_depth: Vec<isize> = vec![];\n    for\
    \ paren in paren_string.chars() {\n        let paren = paren.into();\n       \
    \ if paren == '(' { parens.push(parens_depth.last().unwrap()); }\n        if paren\
    \ == ')' {\n            depth -= 1;\n            if depth == 0 {\n           \
    \     return parens;\n            }\n        }\n        if paren == ',' {\n  \
    \          parens_depth.push(parens_depth.last().unwrap());\n        }\n    }\n\
    \    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhk_6d9i.rs:12:39\n   |\n\
    12 |         if paren == '(' { parens.push(parens_depth.last().unwrap()); }\n\
    \   |                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    12 |         if paren == '(' { parens.push(*parens_depth.last().unwrap()); }\n\
    \   |                                       +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpdhk_6d9i.rs:20:31\n   |\n20 |             parens_depth.push(parens_depth.last().unwrap());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |  \
    \           parens_depth.push(*parens_depth.last().unwrap());\n   |          \
    \                     +\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level_stack: Vec<isize> = Vec::new();\n\
    \    let mut paren_stack: Vec<Vec<isize>> = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == '(' {\n            level_stack.push(i);\n            paren_stack.push(Vec::new());\n\
    \        } else if c == ')' {\n            let last_level_len = level_stack.pop().unwrap();\n\
    \            let nested_len = paren_stack.pop().unwrap().len();\n            let\
    \ mut level = 0;\n            if nested_len > last_level_len {\n             \
    \   level = nested_len - last_level_len;\n            } else {\n             \
    \   while level_stack.len() > level {\n                    level_stack.pop();\n\
    \                }\n                level = level_stack.len();\n            }\n\
    \            paren_stack.push(paren_stack.last().push(level).collect());\n   \
    \     }\n    }\n    paren_stack.last()\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv2rb_v91.rs:11:30\n   |\n\
    11 |             level_stack.push(i);\n   |                              ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n11 |             level_stack.push(i.try_into().unwrap());\n\
    \   |                               ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpv2rb_v91.rs:17:29\n   |\n17 |             if nested_len\
    \ > last_level_len {\n   |                             ^^^^^^^^^^^^^^ expected\
    \ `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a `usize`\
    \ and panic if the converted value doesn't fit\n   |\n17 |             if nested_len\
    \ > last_level_len.try_into().unwrap() {\n   |                               \
    \            ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv2rb_v91.rs:18:38\n\
    \   |\n18 |                 level = nested_len - last_level_len;\n   |       \
    \                               ^^^^^^^^^^^^^^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpv2rb_v91.rs:18:36\n\
    \   |\n18 |                 level = nested_len - last_level_len;\n   |       \
    \                             ^ no implementation for `usize - isize`\n   |\n\
    \   = help: the trait `Sub<isize>` is not implemented for `usize`\n   = help:\
    \ the following other types implement trait `Sub<Rhs>`:\n             <&'a f32\
    \ as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a i128 as\
    \ Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n\
    \             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n      \
    \       <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]: no\
    \ method named `push` found for enum `Option` in the current scope\n  --> /tmp/tmpv2rb_v91.rs:25:49\n\
    \   |\n25 |             paren_stack.push(paren_stack.last().push(level).collect());\n\
    \   |                                                 ^^^^ method not found in\
    \ `Option<&Vec<isize>>`\n\nerror[E0308]: mismatched types\n  -->"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut opening_brackets = paren_string.chars().filter(|c|\
    \ c == '(').count();\n    let mut nesting_levels = 0;\n    let mut paren_string\
    \ = paren_string.to_owned();\n    let mut last_open_bracket = String::new();\n\
    \    let mut last_closing_paren = String::new();\n    let mut next_open_bracket\
    \ = String::new();\n    while opening_brackets > 0 {\n        let open_bracket\
    \ = paren_string.chars().nth(opening_brackets).unwrap();\n        if open_bracket\
    \ == '(' {\n            paren_string = paren_string.clone();\n            opening_brackets\
    \ -= 1;\n            let mut opening_paren = paren_string.chars().nth(opening_brackets).unwrap();\n\
    \            let closing_bracket = paren_string.chars().nth(opening_brackets).unwrap_or(')');\n\
    \            next_open_bracket = String::new();\n            nesting_levels +=\
    \ 1;\n            if opening_paren != '(' {\n                panic!(\"Unbalanced\
    \ paranthesis.\");\n            }\n            while opening_paren != '(' {\n\
    \                last_open_bracket = open_bracket;\n                last_closing_paren\
    \ = closing_bracket;\n                let mut open_bracket = paren_string.chars().nth(opening_brackets).unwrap();\n\
    \                let mut closing_paren = paren_string.chars().nth(opening_brackets\
    \ + 1).unwrap();\n                opening_paren = paren_string.chars().nth(opening_brackets\
    \ + 2).unwrap();\n                if open_bracket != '(' {\n                 \
    \   break;\n                }\n                opening_brackets += 1;\n      \
    \          if closing_bracket != '(' {\n                    break;\n         \
    \       }\n                opening_brackets += 1;\n                last_closing_paren\
    \ = closing_paren;\n                opening_paren = paren_string.chars().nth(opening_brackets).unwrap();\n\
    \            }\n            if opening_brackets == 0 {\n                break;\n\
    \            }\n            if opening_paren != ')' {\n                panic!(\"\
    Unbalanced paranthesis.\");\n            }\n            nesting_levels -= 1;\n\
    \            if nesting_levels <= 0 {\n                break;\n            }\n\
    \        } else {\n            let closing_paren = paren_string.chars().nth(opening_brackets).unwrap_or(')');\n\
    \            next_open_bracket = String\n}\n\nfn main() {\n    let candidate =\
    \ parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphrfq32lc.rs:62:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n13 |     while opening_brackets > 0 {\n   |                             \
    \   - unclosed delimiter\n...\n52 |         } else {\n   |                - this\
    \ delimiter might not be properly closed...\n...\n55 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n62 | }\n   |   ^\n\nerror[E0423]:\
    \ expected value, found struct `String`\n   --> /tmp/tmphrfq32lc.rs:54:33\n  \
    \  |\n54  |               next_open_bracket = String\n    |                  \
    \                 ^^^^^^ help: use struct literal syntax instead: `String { vec:\
    \ val }`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmphrfq32lc.rs:7:66\n\
    \  |\n7 |     let mut opening_brackets = paren_string.chars().filter(|c| c ==\
    \ '(').count();\n  |                                                         \
    \         ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphrfq32lc.rs:26:37\n\
    \   |\n10 |     let mut last_open_bracket = String::new();\n   |             \
    \                    ------------- expected due to this value\n...\n26 |     \
    \            last_open_bracket = open_bracket;\n   |                         \
    \            ^^^^^^^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                                     |\n   |                            \
    \         expected struct `String`, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphrfq32lc.rs:27:38\n   |\n11 |     let mut last_closing_paren =\
    \ String::new();\n   |                                  ------------- expected\
    \ due to this value\n...\n27 |                 last_closing_paren = closing_bracket;\n\
    \   |                                      ^^^^^^^^^^^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut index = 0;\n  \
    \  let mut paren_depth: usize = 0;\n    let mut groups = paren_string.split_whitespace();\n\
    \    let mut paren_stack: Vec<isize> = Vec::new();\n\n    // Go through each group\
    \ and count paren level\n    for group in groups {\n        paren_depth = group.len();\n\
    \        if paren_stack.len() >= paren_depth {\n            level -= paren_stack[paren_depth\
    \ - 1];\n        }\n        paren_stack.push(level);\n        level +=\n     \
    \       group.len() == 1 ? (group.chars().count() as isize) : (group.chars().count()\
    \ as isize) + 1;\n    }\n\n    // Go through each level of nesting and return\
    \ the deepest level\n    paren_stack.iter().max_by_key(|&val| val).map(|level|\
    \ level as isize)\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `.`\n\
    \  --> /tmp/tmpqw9pt_c4.rs:21:73\n   |\n21 |             group.len() == 1 ? (group.chars().count()\
    \ as isize) : (group.chars().count() as isize) + 1;\n   |                    \
    \                                             -       ^\n   |                \
    \                                                 |       |\n   |            \
    \                                                     |       expected one of\
    \ 7 possible tokens\n   |                                                    \
    \             |       help: missing `,`\n   |                                \
    \                                 tried to parse a type due to this\n\nerror:\
    \ expected one of `!`, `)`, `+`, `,`, `->`, or `::`, found `.`\n  --> /tmp/tmpqw9pt_c4.rs:21:81\n\
    \   |\n21 |             group.len() == 1 ? (group.chars().count() as isize) :\
    \ (group.chars().count() as isize) + 1;\n   |                                \
    \                                                 ^\n   |                    \
    \                                                             |\n   |        \
    \                                                                         expected\
    \ one of `!`, `)`, `+`, `,`, `->`, or `::`\n   |                             \
    \                                                    help: missing `,`\n\nerror:\
    \ expected one of `!`, `)`, `+`, `,`, `->`, or `::`, found keyword `as`\n  -->\
    \ /tmp/tmpqw9pt_c4.rs:21:90\n   |\n21 |             group.len() == 1 ? (group.chars().count()\
    \ as isize) : (group.chars().count() as isize) + 1;\n   |                    \
    \                                                                      ^^ expected\
    \ one of `!`, `)`, `+`, `,`, `->`, or `::`\n\nerror: expected one of `!`, `(`,\
    \ `.`, `::`, `;`, `<`, `?`, or `}`, found `)`\n  --> /tmp/tmpqw9pt_c4.rs:21:98\n\
    \   |\n21 |             group.len() == 1 ? (group.chars().count() as isize) :\
    \ (group.chars().count() as isize) + 1;\n   |                                \
    \                                                                  ^ expected\
    \ one of 8 possible tokens\n\ner"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let parens = paren_string.split(' ').collect::<Vec<String>>();\n\
    \    let mut depth = 0;\n    for paren in parens.into_iter() {\n        if paren.len()\
    \ > depth {\n            depth = paren.len();\n        }\n    }\n    vec![depth]\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpsxa_brzh.rs:7:42\n     |\n7  \
    \  |     let parens = paren_string.split(' ').collect::<Vec<String>>();\n    \
    \ |                                          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsxa_brzh.rs:14:10\n\
    \   |\n14 |     vec![depth]\n   |          ^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n14 |     vec![depth.try_into().unwrap()]\n   |    \
    \           ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut pos = 0; // position where parentheses\
    \ are found\n    let mut max_level = 1; // level of nesting found\n    let mut\
    \ level = 0; // nesting level\n    let mut paren_levels: Vec<isize> = Vec::new();\n\
    \    let mut paren_groups: Vec<Vec<String>> = Vec::new();\n    let mut paren_level\
    \ = 0;\n    let mut group_level = 0;\n    let mut group_position = 0;\n    let\
    \ mut open_braces = 0;\n    let mut close_braces = 0;\n\n    let mut paren_levels_stack\
    \ = Vec::new();\n\n    let mut string = paren_string.clone();\n    while pos <\
    \ string.len() {\n        // parse first level of parentheses\n        let mut\
    \ paren_level = level;\n        while paren_level > 0 {\n            let paren_open\
    \ = paren_levels_stack[paren_level - 1];\n            if paren_level == 1 {\n\
    \                open_braces++;\n            } else if paren_open > paren_level\
    \ {\n                break;\n            } else {\n                open_braces--;\n\
    \            }\n            paren_level--;\n        }\n        paren_levels.push(paren_level);\n\
    \n        // parse nested parentheses\n        if paren_level > 0 {\n        \
    \    // find first closing parentheses\n            let mut close_braces = 0;\n\
    \            let mut paren_groups = paren_groups[paren_level - 1];\n         \
    \   while open_braces > close_braces {\n                if paren_groups[paren_group].len()\
    \ > 0 {\n                    paren_groups.push(paren_group);\n               \
    \ }\n                if paren_levels[paren_level] > 0 {\n                    close_braces++;\n\
    \                }\n                paren_level--;\n            }\n        }\n\
    \n        // find end of groups\n        let mut group_position = paren_groups.len();\n\
    \        if close_braces > 0 {\n            // find first opening braces\n   \
    \         while open_braces > 0 {\n                group_position -= 1;\n    \
    \            open_braces--;\n            }\n        } else {\n            // find\
    \ first closing parentheses\n            while paren_groups[group_position].len()\
    \ > 0 {\n                group_position -= 1;\n            }\n        }\n\n  \
    \      // if found group -> store all it's level -> decrement level of that group\
    \ and store all levels\n        if group_position >= 0 {\n            paren_groups.push(paren_group);\n\
    \            if paren_levels[paren_level] > 0 {\n                max_level = paren_level;\n\
    \            }\n            group_position--;\n            group_level += 1;\n\
    \            paren_level--;\n        } else {\n\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpegma5cby.rs:86:3\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                            - unclosed delimiter\n\
    ...\n21 |     while pos < string.len() {\n   |                              -\
    \ unclosed delimiter\n...\n77 |         } else {\n   |                - this delimiter\
    \ might not be properly closed...\n78 | \n79 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n86 | }\n   |   ^\n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmpegma5cby.rs:27:28\n   |\n27 |    \
    \             open_braces++;\n   |                            ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |                 { let tmp\
    \ = open_braces; open_braces += 1; tmp };\n   |                 +++++++++++  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~\n27 -                 open_braces++;\n27\
    \ +                 open_braces += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpegma5cby.rs:47:33\n   |\n47 |                     close_braces++;\n\
    \   |                                 ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n47 |                     { let tmp = close_braces;\
    \ close_braces += 1; tmp };\n   |                     +++++++++++            \
    \ ~~~~~~~~~~~~~~~~~~~~~~~~~~\n47 -                     close_braces++;\n47 + \
    \                    close_braces += 1;\n   | \n\nerror: expected `;`, found `group_level`\n\
    \  --> /tmp/tmpegma5cby.rs:74:30\n   |\n74 |             group_position--;\n \
    \  |                              ^ help: add `;` here\n75 |             group_level\
    \ += 1;\n   |             ----------- unexpected token\n\nerror[E0425]: cannot\
    \ find value `paren_group` in this scope\n  --> /tmp/tmpegma5cby.rs:43:33\n  \
    \ |\n43 |                 if paren_groups[paren_group].len() > 0 {\n   |     \
    \                            ^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `paren_groups`\n\nerror[E0425]: cannot find value `paren_group`\
    \ in this scope\n  --> /tmp/tmpegma5cby.rs:44"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .enumerate()\n\
    \        .filter_map(|(i, c)| if c == '(' || c == '{' { Some(i) } else { None\
    \ })\n        .filter_map(|(i: Option<usize>, c)| if c == '{' { Some(i.unwrap())\
    \ } else { None })\n        .filter_map(|(i: Option<usize>, c)| if c == '(' {\
    \ Some(i.unwrap()) } else { None })\n        .filter_map(|(i: Option<usize>, c)|\
    \ if c == ')' { Some(i.unwrap()) } else { None })\n        .filter_map(|(i: Option<usize>,\
    \ c)| if c == '}' { Some(i.unwrap()) } else { None })\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `@`, or `|`, found `:`\n  --> /tmp/tmp4epuk_ii.rs:11:24\n\
    \   |\n11 |         .filter_map(|(i: Option<usize>, c)| if c == '{' { Some(i.unwrap())\
    \ } else { None })\n   |                        ^ expected one of `)`, `,`, `@`,\
    \ or `|`\n\nerror: expected one of `:`, `@`, or `|`, found `)`\n  --> /tmp/tmp4epuk_ii.rs:11:42\n\
    \   |\n11 |         .filter_map(|(i: Option<usize>, c)| if c == '{' { Some(i.unwrap())\
    \ } else { None })\n   |                                          ^ expected one\
    \ of `:`, `@`, or `|`\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens_stack = paren_string.chars().collect::<Vec<char>>();\n\
    \    let mut stack = parens_stack;\n    stack.push('(');\n    let mut count =\
    \ 0;\n    loop {\n        count += 1;\n        match stack.pop() {\n         \
    \   '(' | ')' | '{' | '}' | ',' => {\n                stack.push(stack.pop());\n\
    \            }\n            _ => (),\n        }\n        if parens_stack.len()\
    \ == 0 {\n            return vec![count];\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnk7utlkg.rs:14:13\n   |\n\
    13 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<char>`\n14 |             '(' | ')' | '{' | '}' | ',' => {\n\
    \   |             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ pattern in `Some`\n   |\n14 |             Some('(') | ')' | '{' | '}' | ','\
    \ => {\n   |             +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnk7utlkg.rs:14:19\n\
    \   |\n13 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<char>`\n14 |             '(' | ')' | '{' | '}' | ',' => {\n\
    \   |                   ^^^ expected enum `Option`, found `char`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found type `char`\nhelp: try wrapping\
    \ the pattern in `Some`\n   |\n14 |             '(' | Some(')') | '{' | '}' |\
    \ ',' => {\n   |                   +++++   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnk7utlkg.rs:14:25\n   |\n13 |         match stack.pop() {\n   |\
    \               ----------- this expression has type `Option<char>`\n14 |    \
    \         '(' | ')' | '{' | '}' | ',' => {\n   |                         ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the pattern in `Some`\n \
    \  |\n14 |             '(' | ')' | Some('{') | '}' | ',' => {\n   |          \
    \               +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnk7utlkg.rs:14:31\n\
    \   |\n13 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<char>`\n14 |             '(' | ')' | '{' | '}' | ',' => {\n\
    \   |                               ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the pattern in `Some`\n   |\n14 |             '(' | ')' | '{'\
    \ | Some('}') | ',' => {\n   |                               +++++   +\n\nerror[E0308]:\
    \ mismatched typ"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_counts = paren_string\n        .chars()\n\
    \        .enumerate()\n        .filter_map(|(idx, _)| if idx % 2 == 0 { Some(0)\
    \ } else { None })\n        .collect::<Vec<_>>();\n    let mut depth = 0;\n  \
    \  let mut current_depth = 0;\n    let mut current_paren_counts = 0;\n    let\
    \ mut paren_depth = 0;\n    for (idx, _) in paren_counts.into_iter().enumerate()\
    \ {\n        if paren_depth < idx {\n            if paren_depth == 0 {\n     \
    \           current_depth = idx + 1;\n            }\n            depth = current_depth;\n\
    \            current_paren_counts = current_paren_counts;\n            current_depth\
    \ += 1;\n            paren_depth = idx;\n        } else if paren_depth == idx\
    \ {\n            current_paren_counts += 1;\n        }\n    }\n    depth\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp78l8x443.rs:29:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n29 |     depth\n   |     ^^^^^ expected struct `Vec`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n                found\
    \ type `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting = 0;\n    let mut opening_parens\
    \ = 0;\n    let mut opening_parens_level: Vec<usize> = vec![];\n    for (i, char)\
    \ in paren_string.chars().enumerate() {\n        if char == '(' {\n          \
    \  opening_parens += 1;\n            opening_parens_level.push(nesting);\n   \
    \         nesting += 1;\n        } else if char == ')' {\n            opening_parens\
    \ -= 1;\n            nesting -= opening_parens_level.pop();\n        } else {\n\
    \            let opening_parens_level_index = opening_parens_level.iter().position(|level|\
    \ *level == nesting).unwrap();\n            if opening_parens_level_index == 0\
    \ {\n                return vec![nesting];\n            }\n            nesting\
    \ += 1;\n        }\n    }\n    vec![nesting]\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot subtract-assign `Option<usize>` from `usize`\n  -->\
    \ /tmp/tmpgfht4mas.rs:17:21\n   |\n17 |             nesting -= opening_parens_level.pop();\n\
    \   |                     ^^ no implementation for `usize -= Option<usize>`\n\
    \   |\n   = help: the trait `SubAssign<Option<usize>>` is not implemented for\
    \ `usize`\n   = help: the following other types implement trait `SubAssign<Rhs>`:\n\
    \             <f32 as SubAssign<&f32>>\n             <f32 as SubAssign>\n    \
    \         <f64 as SubAssign<&f64>>\n             <f64 as SubAssign>\n        \
    \     <i128 as SubAssign<&i128>>\n             <i128 as SubAssign>\n         \
    \    <i16 as SubAssign<&i16>>\n             <i16 as SubAssign>\n           and\
    \ 20 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgfht4mas.rs:21:29\n\
    \   |\n21 |                 return vec![nesting];\n   |                      \
    \       ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a\
    \ `usize` to an `isize` and panic if the converted value doesn't fit\n   |\n21\
    \ |                 return vec![nesting.try_into().unwrap()];\n   |          \
    \                          ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpgfht4mas.rs:26:10\n   |\n26 |     vec![nesting]\n   |         \
    \ ^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize`\
    \ to an `isize` and panic if the converted value doesn't fit\n   |\n26 |     vec![nesting.try_into().unwrap()]\n\
    \   |                 ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| {\n            if s.is_empty() {\n                Ok(-1)\n    \
    \        } else {\n                Ok(s.parse::<isize>().unwrap())\n         \
    \   }\n        })\n        .filter_map(|i| i.ok())\n        .max_by_key(|i| i)\n\
    \        .unwrap()\n        .iter()\n        .map(|i| i as isize)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpi6woq89d.rs:19:10\n   |\n19 |         .iter()\n   |   \
    \       ^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens = paren_string.char_indices();\n\
    \    let mut depth = 0;\n    let mut opened_pars = 0;\n    let mut levels: Vec<isize>\
    \ = Vec::new();\n    let mut last: Vec<isize> = Vec::new();\n    parens.filter_map(|c|\
    \ {\n        if c.index == parens.last_index() {\n            levels.push(opened_pars);\n\
    \            opened_pars = 0;\n        }\n        if c.index == parens.len() {\n\
    \            levels.push(opened_pars);\n            opened_pars = 0;\n       \
    \ } else {\n            let paren_count = parens.clone().position(|c| c == c.to_string());\n\
    \            if paren_count > 0 {\n                opened_pars += paren_count;\n\
    \                last = parens.clone().skip(paren_count.clone()).collect();\n\
    \                levels.push(opened_pars);\n            }\n        }\n       \
    \ Some(c.to_owned())\n    }).collect();\n    levels.sort_unstable();\n    levels.reverse();\n\
    \    levels.clone() + last\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `index` on type `(usize, char)`\n  --> /tmp/tmpfqifpevp.rs:13:14\n\
    \   |\n13 |         if c.index == parens.last_index() {\n   |              ^^^^^\n\
    \nerror[E0599]: no method named `last_index` found for struct `CharIndices` in\
    \ the current scope\n  --> /tmp/tmpfqifpevp.rs:13:30\n   |\n13 |         if c.index\
    \ == parens.last_index() {\n   |                              ^^^^^^^^^^ method\
    \ not found in `CharIndices<'_>`\n\nerror[E0609]: no field `index` on type `(usize,\
    \ char)`\n  --> /tmp/tmpfqifpevp.rs:17:14\n   |\n17 |         if c.index == parens.len()\
    \ {\n   |              ^^^^^\n\nerror[E0599]: no method named `len` found for\
    \ struct `CharIndices` in the current scope\n  --> /tmp/tmpfqifpevp.rs:17:30\n\
    \   |\n17 |         if c.index == parens.len() {\n   |                       \
    \       ^^^ method not found in `CharIndices<'_>`\n\nerror[E0599]: `(usize, char)`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpfqifpevp.rs:21:66\n   |\n\
    21 |             let paren_count = parens.clone().position(|c| c == c.to_string());\n\
    \   |                                                                  ^^^^^^^^^\
    \ `(usize, char)` cannot be formatted with the default formatter\n   |\n   = note:\
    \ the following trait bounds were not satisfied:\n           `(usize, char): std::fmt::Display`\n\
    \           which is required by `(usize, char): ToString`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfqifpevp.rs:22:30\n   |\n22 |             if paren_count\
    \ > 0 {\n   |                              ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n22 |             if paren_count\
    \ > Some(0) {\n   |                              +++++ +\n\nerror[E0277]: cannot\
    \ add-assign `Option<usize>` to `isize`\n  --> /tmp/tmpfqifpevp.rs:23:29\n   |\n\
    23 |                 opened_pars += paren_count;\n   |                       \
    \      ^^ no implementation for `isize += Option<usize>`\n   |\n   = help: the\
    \ trait `AddAssign<Option<usize>>` is not implemented for `isize`\n   "
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = Vec::new();\n    let mut level\
    \ = 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c ==\
    \ '(' {\n            level += 1;\n        } else if c == ')' {\n            level\
    \ -= 1;\n        }\n        if level > 0 && level == levels.last().unwrap() {\n\
    \            levels.push(levels.last().unwrap() + 1);\n        } else if level\
    \ < 0 && level == levels.last().unwrap() {\n            levels.push(levels.last().unwrap()\
    \ - 1);\n        }\n    }\n    levels.into_iter().collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `{integer}` with `&_`\n  --> /tmp/tmpyv5uohqf.rs:15:31\n\
    \   |\n15 |         if level > 0 && level == levels.last().unwrap() {\n   |  \
    \                             ^^ no implementation for `{integer} == &_`\n   |\n\
    \   = help: the trait `PartialEq<&_>` is not implemented for `{integer}`\n   =\
    \ help: the following other types implement trait `PartialEq<Rhs>`:\n        \
    \     f32\n             f64\n             i128\n             i16\n           \
    \  i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0277]: can't compare `{integer}` with `&_`\n  --> /tmp/tmpyv5uohqf.rs:17:38\n\
    \   |\n17 |         } else if level < 0 && level == levels.last().unwrap() {\n\
    \   |                                      ^^ no implementation for `{integer}\
    \ == &_`\n   |\n   = help: the trait `PartialEq<&_>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = vec![];\n    let mut par_level\
    \ = 0;\n    let mut brace_level = 0;\n    for ch in paren_string.chars() {\n \
    \       match ch {\n            ')' => stack.pop().unwrap() += 1,\n          \
    \  '(' => stack.push(par_level),\n            '{' => stack.push(brace_level),\n\
    \            _ => (),\n        }\n        if stack.is_empty() || par_level < stack.last_mut()\
    \ {\n            par_level = stack.last_mut() + 1;\n        }\n        if brace_level\
    \ < stack.last_mut() {\n            brace_level = stack.last_mut() + 1;\n    \
    \    }\n    }\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0067]: invalid left-hand side of assignment\n  --> /tmp/tmpwyq6jtvn.rs:12:41\n\
    \   |\n12 |             ')' => stack.pop().unwrap() += 1,\n   |              \
    \      -------------------- ^^\n   |                    |\n   |              \
    \      cannot assign to this expression\n\nerror[E0277]: can't compare `{integer}`\
    \ with `Option<&mut {integer}>`\n  --> /tmp/tmpwyq6jtvn.rs:17:42\n   |\n17 | \
    \        if stack.is_empty() || par_level < stack.last_mut() {\n   |         \
    \                                 ^ no implementation for `{integer} < Option<&mut\
    \ {integer}>` and `{integer} > Option<&mut {integer}>`\n   |\n   = help: the trait\
    \ `PartialOrd<Option<&mut {integer}>>` is not implemented for `{integer}`\n  \
    \ = help: the following other types implement trait `PartialOrd<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0369]: cannot add `{integer}` to `Option<&mut {integer}>`\n\
    \  --> /tmp/tmpwyq6jtvn.rs:18:42\n   |\n18 |             par_level = stack.last_mut()\
    \ + 1;\n   |                         ---------------- ^ - {integer}\n   |    \
    \                     |\n   |                         Option<&mut {integer}>\n\
    \nerror[E0277]: can't compare `{integer}` with `Option<&mut {integer}>`\n  -->\
    \ /tmp/tmpwyq6jtvn.rs:20:24\n   |\n20 |         if brace_level < stack.last_mut()\
    \ {\n   |                        ^ no implementation for `{integer} < Option<&mut\
    \ {integer}>` and `{integer} > Option<&mut {integer}>`\n   |\n   = help: the trait\
    \ `PartialOrd<Option<&mut {integer}>>` is not implemented for `{integer}`\n  \
    \ = help: the following other types implement trait `PartialOrd<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0369]: cannot add `{integer}` to `Option<&mut {integer}>`\n\
    \  --> /tmp/tmpwyq6jtvn.rs:21:44\n   |\n21 |             brace_level = stack.last_mut()\
    \ + 1;\n   |                           ---------------- ^ -"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .rsplitn(2, ' ')\n      \
    \  .map(|x| x.parse::<usize>().unwrap())\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpgthn_0yj.rs:10:10\n     |\n10\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_vec = Vec::new();\n    for paren\
    \ in paren_string.chars().flat_map(|c| paren.chars()) {\n        match c {\n \
    \           '(' => paren_vec.push(isize::max_value()),\n            ')' => paren_vec.pop(),\n\
    \            _ => paren_vec.push(isize::max_value() - 1),\n        }\n    }\n\
    \    paren_vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `paren` in this scope\n --> /tmp/tmp6c1yeibc.rs:8:52\n\
    \  |\n8 |     for paren in paren_string.chars().flat_map(|c| paren.chars()) {\n\
    \  |                                                    ^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `c` in this scope\n --> /tmp/tmp6c1yeibc.rs:9:15\n\
    \  |\n9 |         match c {\n  |               ^ not found in this scope\n\nerror[E0308]:\
    \ `match` arms have incompatible types\n  --> /tmp/tmp6c1yeibc.rs:11:20\n   |\n\
    9  | /         match c {\n10 | |             '(' => paren_vec.push(isize::max_value()),\n\
    \   | |                    ---------------------------------- this is found to\
    \ be of type `()`\n11 | |             ')' => paren_vec.pop(),\n   | |        \
    \            ^^^^^^^^^^^^^^^ expected `()`, found enum `Option`\n12 | |      \
    \       _ => paren_vec.push(isize::max_value() - 1),\n13 | |         }\n   | |_________-\
    \ `match` arms have incompatible types\n   |\n   = note: expected unit type `()`\n\
    \                   found enum `Option<isize>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_stack = paren_string.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n    let mut i = 0;\n    let mut paren_level\
    \ = 0;\n    loop {\n        if paren_level == 0 && paren_stack.len() == 0 {\n\
    \            return vec![paren_level];\n        }\n        let popped_char = paren_stack.pop().unwrap();\n\
    \        let next_char = paren_stack.pop().unwrap();\n        if popped_char ==\
    \ next_char {\n            paren_level += 1;\n        } else {\n            paren_level\
    \ = 0;\n        }\n        i += 1;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "warning: variable `i` is assigned to, but never used\n --> /tmp/tmpny93licy.rs:8:13\n\
    \  |\n8 |     let mut i = 0;\n  |             ^\n  |\n  = note: `#[warn(unused_variables)]`\
    \ on by default\n  = note: consider using `_i` instead\n\nerror[E0596]: cannot\
    \ borrow `paren_stack` as mutable, as it is not declared as mutable\n  --> /tmp/tmpny93licy.rs:14:27\n\
    \   |\n7  |     let paren_stack = paren_string.chars().map(|c| c as char).collect::<Vec<_>>();\n\
    \   |         ----------- help: consider changing this to be mutable: `mut paren_stack`\n\
    ...\n14 |         let popped_char = paren_stack.pop().unwrap();\n   |        \
    \                   ^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror[E0596]:\
    \ cannot borrow `paren_stack` as mutable, as it is not declared as mutable\n \
    \ --> /tmp/tmpny93licy.rs:15:25\n   |\n7  |     let paren_stack = paren_string.chars().map(|c|\
    \ c as char).collect::<Vec<_>>();\n   |         ----------- help: consider changing\
    \ this to be mutable: `mut paren_stack`\n...\n15 |         let next_char = paren_stack.pop().unwrap();\n\
    \   |                         ^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n\nerror:\
    \ aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976160
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(' ')\n        .iter()\n\
    \        .map(|s| s.parse().unwrap())\n        .filter(|isize| !isize.is_zero())\n\
    \        .filter(|isize| paren_string.starts_with(isize))\n        .filter(|isize|\
    \ paren_string.len() > isize)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n --> /tmp/tmpmyfiggre.rs:9:10\n  |\n9 |         .iter()\n\
    \  |          ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut openings = vec![];\n    let mut closings\
    \ = vec![];\n    let mut level = 0;\n    let mut level_index = 0;\n    for (i,\
    \ c) in paren_string.chars().enumerate() {\n        if c == ')' {\n          \
    \  closings.push(i);\n        }\n        if c == '(' {\n            openings.push(i);\n\
    \        }\n        if c == ' ' {\n            level += 1;\n            if level\
    \ == 1 {\n                level_index = i;\n            }\n        }\n       \
    \ if c == '(' {\n            level -= 1;\n        }\n        if c == ')' {\n \
    \           if level == 0 {\n                closings.pop();\n            }\n\
    \        }\n    }\n    openings.len()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp08mzswpw.rs:33:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n33 |     openings.len()\n   |     ^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parens = paren_string.split_whitespace();\n\
    \    parens\n        .into_iter()\n        .filter_map(|x| x.chars().count())\n\
    \        .max()\n        .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp043buo7d.rs:10:25\n   |\n\
    10 |         .filter_map(|x| x.chars().count())\n   |                        \
    \ ^^^^^^^^^^^^^^^^^ expected enum `Option`, found `usize`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `usize`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n10 |         .filter_map(|x| Some(x.chars().count()))\n   |\
    \                         +++++                 +\n\nerror[E0599]: `Option<_>`\
    \ is not an iterator\n   --> /tmp/tmp043buo7d.rs:12:10\n    |\n12  |         \
    \  .collect()\n    |            ^^^^^^^ `Option<_>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Option<_>:\
    \ Iterator`\n            which is required by `&mut Option<_>: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = vec![];\n    let mut nesting =\
    \ 0;\n    for (i, c) in paren_string.chars().enumerate() {\n        if c == '('\
    \ || c == '[' {\n            stack.push(i);\n        }\n        if c == '(' ||\
    \ c == ')' {\n            if stack.len() > nesting {\n                nesting\
    \ = stack.len();\n            }\n        }\n        if c == ']' || c == ']' {\n\
    \            if stack.len() > nesting {\n                nesting = stack.len();\n\
    \            }\n            stack.pop();\n        }\n    }\n    nesting\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp407svvp3.rs:25:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     nesting\n   |     ^^^^^^^ expected struct `Vec`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `usize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut vec = vec![];\n    let mut last = 0;\n\
    \    let mut last_level = 0;\n    let mut stack = String::from(paren_string);\n\
    \    let mut count = 0;\n    while count != paren_string.len() {\n        if let\
    \ Some((_, char)) = stack.chars().next() {\n            if char == '(' {\n   \
    \             last = 0;\n                let new_level = last;\n             \
    \   vec.push(new_level);\n                stack = stack.remove(0) + stack.remove(0);\n\
    \                last_level = new_level;\n                count++;\n         \
    \   } else if char == ')' {\n                let mut new_level = last;\n     \
    \           while let Some((_, char)) = stack.chars().next() {\n             \
    \       if char == '(' {\n                        new_level = vec.last().unwrap_or(new_level\
    \ + 1);\n                        break;\n                    }\n             \
    \       new_level = vec.last().unwrap_or(new_level + 1);\n                }\n\
    \                if new_level == last_level {\n                    vec.push(new_level);\n\
    \                    stack = stack.remove(0) + stack.remove(0);\n            \
    \        last_level = new_level;\n                    count++;\n             \
    \   } else {\n                    vec.push(new_level);\n                    stack\
    \ = stack.remove(0) + stack.remove(0);\n                    last_level = new_level;\n\
    \                    count++;\n                }\n            }\n        }\n \
    \   }\n    vec\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n \
    \   assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpd038iw5c.rs:20:22\n\
    \   |\n20 |                 count++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n20 |               \
    \  { let tmp = count; count += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n20 -                 count++;\n20 +                 count\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpd038iw5c.rs:34:26\n\
    \   |\n34 |                     count++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n34 |       \
    \              { let tmp = count; count += 1; tmp };\n   |                   \
    \  +++++++++++      ~~~~~~~~~~~~~~~~~~~\n34 -                     count++;\n34\
    \ +                     count += 1;\n   | \n\nerror: Rust has no postfix increment\
    \ operator\n  --> /tmp/tmpd038iw5c.rs:39:26\n   |\n39 |                     count++;\n\
    \   |                          ^^ not a valid postfix operator\n   |\nhelp: use\
    \ `+= 1` instead\n   |\n39 |                     { let tmp = count; count += 1;\
    \ tmp };\n   |                     +++++++++++      ~~~~~~~~~~~~~~~~~~~\n39 -\
    \                     count++;\n39 +                     count += 1;\n   | \n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpd038iw5c.rs:13:21\n   |\n13 |  \
    \       if let Some((_, char)) = stack.chars().next() {\n   |                \
    \     ^^^^^^^^^    -------------------- this expression has type `Option<char>`\n\
    \   |                     |\n   |                     expected `char`, found tuple\n\
    \   |\n   = note: expected type `char`\n             found tuple `(_, _)`\n\n\
    error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpd038iw5c.rs:18:41\n \
    \  |\n18 |                 stack = stack.remove(0) + stack.remove(0);\n   |  \
    \                       --------------- ^ --------------- char\n   |         \
    \                |\n   |                         char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpd038iw5c.rs:23:32\n   |\n23 |                 while let\
    \ Some((_, char)) = stack.chars().next() {\n   |                   "
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut depth = 0;\n    let mut paren_stack: Vec<&str>\
    \ = vec![paren_string];\n    let mut paren_depth: usize = 0;\n    while paren_stack.len()\
    \ > 0 {\n        if paren_depth == 0 {\n            let mut paren_len = paren_stack.len();\n\
    \            while paren_len > 0 {\n                let top_level_open = paren_stack.pop().unwrap();\n\
    \                if top_level_open != ')' {\n                    let paren_depth\
    \ = paren_depth - 1;\n                } else {\n                    break;\n \
    \               }\n                paren_len = paren_len - 1;\n            }\n\
    \        }\n        if paren_depth > depth {\n            depth = paren_depth;\n\
    \        }\n        paren_depth = paren_depth + 1;\n        if paren_depth > 0\
    \ {\n            let mut paren_len = paren_stack.len();\n            while paren_len\
    \ > 0 {\n                let top_level_close = paren_stack.pop().unwrap();\n \
    \               if top_level_close == '(' {\n                    let paren_depth\
    \ = paren_depth - 1;\n                } else {\n                    break;\n \
    \               }\n                paren_len = paren_len - 1;\n            }\n\
    \        }\n    }\n    depth\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpdhap9l1w.rs:8:43\n  |\n8 |\
    \     let mut paren_stack: Vec<&str> = vec![paren_string];\n  |              \
    \                             ^^^^^^^^^^^^\n  |                              \
    \             |\n  |                                           expected `&str`,\
    \ found struct `String`\n  |                                           help: consider\
    \ borrowing here: `&paren_string`\n\nerror[E0277]: can't compare `&str` with `char`\n\
    \  --> /tmp/tmpdhap9l1w.rs:15:35\n   |\n15 |                 if top_level_open\
    \ != ')' {\n   |                                   ^^ no implementation for `&str\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&str` with `char`\n  --> /tmp/tmpdhap9l1w.rs:31:36\n   |\n31 |            \
    \     if top_level_close == '(' {\n   |                                    ^^\
    \ no implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdhap9l1w.rs:40:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                           "
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack: Vec<Vec<String>> = vec![vec![]];\n\
    \    let mut level = 0;\n    for c in paren_string.chars() {\n        if c ==\
    \ '(' { paren_stack.push(vec![\"\".to_string()]); level += 1 } else if c == ')'\
    \ {\n            level -= 1;\n            paren_stack.pop();\n        } else {\n\
    \            let mut paren_str = paren_stack[level]\n                .as_mut()\n\
    \                .expect(\"Error while parsing nested parentheses\");\n      \
    \      paren_str.push(c);\n        }\n        if level == 0 && paren_stack.len()\
    \ == 1 {\n            return paren_stack.as_slice().map(|x| x.len()).collect();\n\
    \        }\n    }\n    panic!(\"Error while parsing nested parentheses\");\n}\n\
    \nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpqi80jmw7.rs:15:18\n\
    \   |\n14 |               let mut paren_str = paren_stack[level]\n   |  _________________________________-\n\
    15 | |                 .as_mut()\n   | |__________________^^^^^^_- this method\
    \ call resolves to `&mut T`\n   |                    |\n   |                 \
    \   cannot infer type for type parameter `T` declared on the trait `AsMut`\n \
    \  |\n   = note: type must be known at this point\n\nerror[E0599]: `&[Vec<String>]`\
    \ is not an iterator\n  --> /tmp/tmpqi80jmw7.rs:20:43\n   |\n20 |            \
    \ return paren_stack.as_slice().map(|x| x.len()).collect();\n   |            \
    \                               ^^^ `&[Vec<String>]` is not an iterator; try calling\
    \ `.iter()`\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&[Vec<String>]: Iterator`\n           which is required by `&mut\
    \ &[Vec<String>]: Iterator`\n           `[Vec<String>]: Iterator`\n          \
    \ which is required by `&mut [Vec<String>]: Iterator`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0282, E0599.\n\
    For more information about an error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // count the number of parentheses group\n    let\
    \ mut num_paren_group = 0;\n    for group in paren_string.chars() {\n        if\
    \ group == '(' {\n            num_paren_group += 1;\n        } else if group ==\
    \ ')' {\n            num_paren_group -= 1;\n        }\n    }\n\n    let mut num_level\
    \ = 0;\n    for group in paren_string.chars() {\n        if group == '(' {\n \
    \           num_level += 1;\n        } else if group == ')' {\n            num_level\
    \ -= 1;\n        }\n        if num_level == num_paren_group {\n            return\
    \ vec![num_level];\n        }\n    }\n\n    vec![0]\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0]`,\n right: `[2, 3, 1, 3]`', /tmp/tmptgt17tuj.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_string = paren_string.to_owned();\n\
    \n    let mut open_brackets = 0;\n    let mut level = 0;\n\n    let mut open_parens\
    \ = 0;\n    let mut i = 0;\n\n    while i < paren_string.len() {\n        let\
    \ c = paren_string.chars()\n            .skip_while(|c| !c.is_ascii_letter() ||\
    \ c.unwrap() != '(')\n            .next()\n            .unwrap();\n        open_parens\
    \ += 1;\n        if c == ')' {\n            level += 1;\n            open_brackets\
    \ -= 1;\n        }\n        if c == '(' {\n            open_brackets += 1;\n \
    \       }\n        i += 1;\n    }\n\n    if open_brackets != 0 {\n        Err(format!(\n\
    \            \"Invalid nested parenthesis found. Brackets ({}) not balanced.\"\
    ,\n            open_brackets\n        ))\n    } else {\n        Ok(level)\n  \
    \  }\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmpmi8v2g2_.rs:17:32\n   |\n17 |          \
    \   .skip_while(|c| !c.is_ascii_letter() || c.unwrap() != '(')\n   |         \
    \                       ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `unwrap` found\
    \ for reference `&char` in the current scope\n  --> /tmp/tmpmi8v2g2_.rs:17:55\n\
    \   |\n17 |             .skip_while(|c| !c.is_ascii_letter() || c.unwrap() !=\
    \ '(')\n   |                                                       ^^^^^^ method\
    \ not found in `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmi8v2g2_.rs:32:9\n\
    \   |\n6  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n \
    \  |                                                   ---------- expected `Vec<isize>`\
    \ because of return type\n...\n32 | /         Err(format!(\n33 | |           \
    \  \"Invalid nested parenthesis found. Brackets ({}) not balanced.\",\n34 | |\
    \             open_brackets\n35 | |         ))\n   | |__________^ expected struct\
    \ `Vec`, found enum `Result`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found enum `Result<_, String>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmi8v2g2_.rs:37:9\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n37 |       \
    \  Ok(level)\n   |         ^^^^^^^^^ expected struct `Vec`, found enum `Result`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found enum `Result<{integer},\
    \ _>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .trim()\n        .split_whitespace()\n\
    \        .map(|s| {\n            parse_paren_level(s, 0)\n        })\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n   \
    \ assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parse_paren_level` in this scope\n\
    \  --> /tmp/tmpbgzai8pc.rs:11:13\n   |\n11 |             parse_paren_level(s,\
    \ 0)\n   |             ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split(|c| match c {\n  \
    \          '(' | ')' | '[' | ']' | '{' | '}' | '(' | ')' | '[' | ']' | '{'\n \
    \           | '\\n' => {\n                true\n            }\n            _ =>\
    \ false,\n        })\n        .map(|s| s.parse::<usize>().unwrap())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<isize>` cannot be built from an iterator\
    \ over elements of type `usize`\n    --> /tmp/tmpi8zt2dmv.rs:16:10\n     |\n16\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>` cannot\
    \ be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help: the trait\
    \ `FromIterator<usize>` is not implemented for `Vec<isize>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut max_level = 0;\n\n    for parens in paren_string.split(\"\
    \ \") {\n        if parens.starts_with(\"(\") {\n            if parens.ends_with(\"\
    )\") {\n                max_level += 1;\n            } else {\n              \
    \  max_level += 2;\n            }\n        } else if parens.starts_with(\")\"\
    ) {\n            max_level -= 1;\n        } else {\n            panic!(\"Invalid\
    \ parentheses\");\n        }\n    }\n    max_level\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpistpshn1.rs:22:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n22 |     max_level\n   |     ^^^^^^^^^ expected struct\
    \ `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `{integer}`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ depth = -1;\n\n    for paren in paren_string.chars().skip_while(|c| *c != '(')\
    \ {\n        if *paren == ')' {\n            paren_stack.pop();\n        }\n \
    \       if *paren == ')' && paren_stack.len() > 0 {\n            depth -= 1;\n\
    \        }\n        if depth == -1 || depth > paren_stack.len() {\n          \
    \  depth = paren_stack.len();\n        }\n        paren_stack.push(paren);\n \
    \   }\n    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpt6doigsw.rs:11:12\n\
    \   |\n11 |         if *paren == ')' {\n   |            ^^^^^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpt6doigsw.rs:14:12\n   |\n\
    14 |         if *paren == ')' && paren_stack.len() > 0 {\n   |            ^^^^^^\n\
    \nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n --> /tmp/tmpt6doigsw.rs:8:21\n\
    \  |\n8 |     let mut depth = -1;\n  |                     ^^ the trait `Neg`\
    \ is not implemented for `usize`\n  |\n  = help: the following other types implement\
    \ trait `Neg`:\n            &f32\n            &f64\n            &i128\n      \
    \      &i16\n            &i32\n            &i64\n            &i8\n           \
    \ &isize\n          and 8 others\n\nerror[E0277]: the trait bound `usize: Neg`\
    \ is not satisfied\n  --> /tmp/tmpt6doigsw.rs:17:21\n   |\n17 |         if depth\
    \ == -1 || depth > paren_stack.len() {\n   |                     ^^ the trait\
    \ `Neg` is not implemented for `usize`\n   |\n   = help: the following other types\
    \ implement trait `Neg`:\n             &f32\n             &f64\n             &i128\n\
    \             &i16\n             &i32\n             &i64\n             &i8\n \
    \            &isize\n           and 8 others\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt6doigsw.rs:22:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n22 |     paren_stack\n\
    \   |     ^^^^^^^^^^^ expected `isize`, found `char`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n              found struct `Vec<char>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_stack = Vec::new();\n    let mut\
    \ i = 0;\n\n    while i < paren_string.len() {\n        if paren_stack.is_empty()\
    \ {\n            // If the stack is empty, get the opening parenthesis\n     \
    \       paren_stack.push(paren_string.chars().next().unwrap());\n        }\n\n\
    \        match paren_stack.last() {\n            '(' | ')' => paren_stack.pop(),\n\
    \            _ => {\n                let cur_char = paren_string[i];\n\n     \
    \           if cur_char == '(' {\n                    // If the current char is\
    \ a left parenthesis\n                    // push it to the stack and get next\
    \ char\n                    paren_stack.push(cur_char);\n                    i\
    \ += 1;\n                } else if cur_char == ')' {\n                    // If\
    \ the current char is a right parenthesis\n                    // if the stack\
    \ is not empty then pop the stack and get next char\n                    if !paren_stack.is_empty()\
    \ {\n                        paren_stack.pop();\n                        i +=\
    \ 1;\n                    } else {\n                        return vec![];\n \
    \                   }\n                } else {\n                    // If char\
    \ is not a left or right parenthesis\n                    // push the current\
    \ char to the stack\n                    paren_stack.push(cur_char);\n       \
    \             i += 1;\n                }\n            }\n        }\n    }\n\n\
    \    paren_stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt32kd3p8.rs:17:13\n   |\n\
    16 |         match paren_stack.last() {\n   |               ------------------\
    \ this expression has type `Option<&char>`\n17 |             '(' | ')' => paren_stack.pop(),\n\
    \   |             ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<&char>`\n              found type `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpt32kd3p8.rs:17:19\n   |\n16 |         match paren_stack.last()\
    \ {\n   |               ------------------ this expression has type `Option<&char>`\n\
    17 |             '(' | ')' => paren_stack.pop(),\n   |                   ^^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<&char>`\n\
    \              found type `char`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmpt32kd3p8.rs:19:32\n   |\n19 |            \
    \     let cur_char = paren_string[i];\n   |                                ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpt32kd3p8.rs:21:17\n\
    \   |\n16 |           match paren_stack.last() {\n   |           ------------------------\
    \ `match` arms have incompatible types\n17 |               '(' | ')' => paren_stack.pop(),\n\
    \   |                            ----------------- this is found to be of type\
    \ `Option<char>`\n...\n21 | /                 if cur_char == '(' {\n22 | |   \
    \                  // If the current char is a left parenthesis\n23 | |      \
    \               // push it to the stack and get next char\n24 | |            \
    \         paren_stack.p"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut num_levels = paren_string.chars().filter(|c|\
    \ *c != '(').count() as isize;\n    paren_string.chars()\n        .filter(|c|\
    \ *c == ')')\n        .enumerate()\n        .filter_map(|(i, c)| if *c == '('\
    \ {\n            i += 1;\n            Some(paren_string.chars().enumerate().filter(|(_,\
    \ c2)| c2 != ')').count())\n        } else {\n            None\n        })\n \
    \       .take_while(|(_, c2)| {\n            c2 != '(' || c2 != ')'\n        })\n\
    \        .for_each(|(_, c2)| {\n            assert!(!c2.is_whitespace(), &format!(\"\
    Illegal character {} at position {}\", c2, i));\n            assert!(!c2.is_ascii(),\
    \ &format!(\"Illegal character {} at position {}\", c2, i));\n        });\n  \
    \  paren_string.chars()\n        .enumerate()\n        .filter(|(_, c2)| c2 !=\
    \ ')')\n        .for_each(|(_, c2)| {\n            assert!(!c2.is_whitespace(),\
    \ &format!(\"Illegal character {} at position {}\", c2, i));\n            assert!(!c2.is_ascii(),\
    \ &format!(\"Illegal character {} at position {}\", c2, i));\n        });\n  \
    \  paren_string.chars()\n        .enumerate()\n        .filter(|(_, c2)| c2 !=\
    \ '(')\n        .for_each(|(_, c2)| {\n            assert!(!c2.is_whitespace(),\
    \ &format!(\"Illegal character {} at position {}\", c2, i));\n            assert!(!c2.is_ascii(),\
    \ &format!(\"Illegal character {} at position {}\", c2, i));\n        });\n  \
    \  for i in 0..num_levels {\n        num_levels += paren_string.chars().filter(|c|\
    \ *c != '(').count() as isize;\n    }\n    num_levels\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:21:94\n\
    \   |\n21 |             assert!(!c2.is_whitespace(), &format!(\"Illegal character\
    \ {} at position {}\", c2, i));\n   |                                        \
    \                                                      ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:22:89\n\
    \   |\n22 |             assert!(!c2.is_ascii(), &format!(\"Illegal character {}\
    \ at position {}\", c2, i));\n   |                                           \
    \                                              ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:28:94\n   |\n\
    28 |             assert!(!c2.is_whitespace(), &format!(\"Illegal character {}\
    \ at position {}\", c2, i));\n   |                                           \
    \                                                   ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:29:89\n\
    \   |\n29 |             assert!(!c2.is_ascii(), &format!(\"Illegal character {}\
    \ at position {}\", c2, i));\n   |                                           \
    \                                              ^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:35:94\n   |\n\
    35 |             assert!(!c2.is_whitespace(), &format!(\"Illegal character {}\
    \ at position {}\", c2, i));\n   |                                           \
    \                                                   ^ not found in this scope\n\
    \nerror[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmprdn8xmrw.rs:36:89\n\
    \   |\n36 |             assert!(!c2.is_ascii(), &format!(\"Illegal character {}\
    \ at position {}\", c2, i));\n   |                                           \
    \                                              ^ not found in this scope\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmprdn8xmrw.rs:11:33\n   |\n\
    11 |         .filter_map(|(i, c)| if *c == '(' {\n   |                       \
    \          ^^\n\nerror[E0277]"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level: isize = 0;\n    let mut string_to_count\
    \ = \"()\".repeat(paren_string.len());\n    let mut paren_level_string = \"\"\
    .to_owned();\n    for paren in paren_string.chars().filter(|c| *c == ' ') {\n\
    \        paren_level_string += &paren.to_owned();\n    }\n    for paren in paren_level_string.chars().filter(|c|\
    \ *c == ' ') {\n        string_to_count -= &paren.to_owned();\n    }\n    for\
    \ paren in string_to_count.chars().filter(|c| *c != '(' && c != ')') {\n     \
    \   level += 1;\n    }\n    level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt_vu_mbb.rs:11:31\n   |\n\
    11 |         paren_level_string += &paren.to_owned();\n   |                  \
    \             ^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `String`\n  --> /tmp/tmpt_vu_mbb.rs:14:9\n\
    \   |\n14 |         string_to_count -= &paren.to_owned();\n   |         ---------------^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `-=` on type `String`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpt_vu_mbb.rs:16:68\n   |\n16\
    \ |     for paren in string_to_count.chars().filter(|c| *c != '(' && c != ')')\
    \ {\n   |                                                                    ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt_vu_mbb.rs:19:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n19 |     level\n   |     ^^^^^ expected struct\
    \ `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n      \
    \          found type `isize`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // Initialize with level of nesting 0\n    let\
    \ mut paren_levels = vec![0];\n\n    // Go through each character in the string\n\
    \    for c in paren_string.chars() {\n        // If this character is an opening\
    \ bracket\n        if c == '(' {\n            // Add 1 to level of nesting\n \
    \           paren_levels.push(paren_levels.len() + 1);\n        }\n\n        //\
    \ If this character is a closing bracket\n        if c == ')' {\n            //\
    \ Add 1 to level of nesting\n            paren_levels.push(paren_levels.len()\
    \ - 1);\n        }\n    }\n\n    // Return vector with deepest level of nesting\n\
    \    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6jwaddy.rs:26:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n26 |     paren_levels\n   |     ^^^^^^^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut paren_level_stack:\
    \ Vec<usize> = Vec::new();\n    let mut paren_level_stack_size: usize = 0;\n \
    \   for paren in paren_string.chars() {\n        if paren == '(' {\n         \
    \   paren_level_stack.push(level);\n            paren_level_stack_size += 1;\n\
    \        }\n        if paren == ')' {\n            paren_level_stack_size -= 1;\n\
    \            if paren_level_stack_size == 0 {\n                level -= 1;\n \
    \           }\n        }\n        level += 1;\n    }\n    paren_level_stack.pop()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvdwye3ga.rs:23:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n23 |     paren_level_stack.pop()\n   |     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n                found enum `Option<usize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut groups = paren_string.chars().map(|c| {\n\
    \        if c == '(' {\n            1\n        } else if c == ')' {\n        \
    \    -1\n        } else {\n            0\n        }\n    }).collect::<Vec<_>>();\n\
    \    while groups.is_empty() {\n        groups.push(0);\n    }\n    find_max_level_of_nesting(groups)\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `find_max_level_of_nesting` in this\
    \ scope\n  --> /tmp/tmplbelmfyv.rs:19:5\n   |\n19 |     find_max_level_of_nesting(groups)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut npar = 0;\n    let mut left_paren_count\
    \ = 0;\n    let mut right_paren_count = 0;\n    let mut level = 0;\n    let mut\
    \ parens = Vec::new();\n\n    for ch in paren_string.chars() {\n        if ch\
    \ == ')' {\n            right_paren_count = level;\n        }\n        if ch ==\
    \ '(' &&\n            (level < right_paren_count || level < left_paren_count)\n\
    \        {\n            level += 1;\n        }\n        if ch == ')' && level\
    \ > right_paren_count && level > left_paren_count {\n            level -= 1;\n\
    \        }\n\n        parens.push(level);\n        if ch == '(' {\n          \
    \  left_paren_count += 1;\n        }\n        if ch == ')' {\n            right_paren_count\
    \ += 1;\n        }\n    }\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 1, 1, 2, 2, 2, 2, 3, 4, 5, 5, 5, 5, 5, 6, 6, 6, 7, 8, 9, 9, 9, 10, 10,\
    \ 11, 11, 11]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpykdv3ls_.rs:39:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels: Vec<isize> = vec![0];\n    let\
    \ mut paren_level: usize = 0;\n    let mut paranthesis_depth: usize = 0;\n   \
    \ let mut paren_char: char = '(';\n\n    for ch in paren_string.chars() {\n  \
    \      if paren_char != ch {\n            levels.push(paren_level);\n        \
    \    paren_level = levels.len();\n            paren_char = ch;\n        }\n  \
    \      levels.push(levels[levels.len() - 1] + 1);\n        if ch == ')' {\n  \
    \          paren_level = levels[levels.len() - 1];\n        }\n    }\n\n    levels.push(paren_level);\n\
    \    levels.sort_unstable();\n    levels\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp4t6s5pm0.rs:14:25\n   |\n\
    14 |             levels.push(paren_level);\n   |                         ^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n14 |           \
    \  levels.push(paren_level.try_into().unwrap());\n   |                       \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4t6s5pm0.rs:20:27\n\
    \   |\n8  |     let mut paren_level: usize = 0;\n   |                        \
    \  ----- expected due to this type\n...\n20 |             paren_level = levels[levels.len()\
    \ - 1];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4t6s5pm0.rs:24:17\n\
    \   |\n24 |     levels.push(paren_level);\n   |                 ^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n24 |     levels.push(paren_level.try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut npar: isize = 0;\n    let mut par_stack:\
    \ Vec<Vec<usize>> = vec![vec![]];\n    for ch in paren_string.chars() {\n    \
    \    if ch == '(' {\n            npar += 1;\n            par_stack.push(vec![npar]);\n\
    \        }\n        if ch == ')' {\n            if par_stack.is_empty() {\n  \
    \              break;\n            }\n            npar = par_stack.pop().unwrap()[par_stack.pop().unwrap().len()\
    \ - 1];\n        }\n        if par_stack.is_empty() {\n            break;\n  \
    \      }\n        par_stack[par_stack.len() - 1][par_stack.len() - 1] += 1;\n\
    \    }\n    par_stack.iter().map(|vec| vec.max().unwrap()).collect()\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7tncc8lv.rs:12:33\n   |\n\
    12 |             par_stack.push(vec![npar]);\n   |                           \
    \      ^^^^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n12 |      \
    \       par_stack.push(vec![npar.try_into().unwrap()]);\n   |                \
    \                     ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tncc8lv.rs:18:20\n   |\n7  |     let mut npar: isize = 0;\n  \
    \ |                   ----- expected due to this type\n...\n18 |             npar\
    \ = par_stack.pop().unwrap()[par_stack.pop().unwrap().len() - 1];\n   |      \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0061]: this function takes 1 argument but 0\
    \ arguments were supplied\n   --> /tmp/tmp7tncc8lv.rs:25:36\n    |\n25  |    \
    \ par_stack.iter().map(|vec| vec.max().unwrap()).collect()\n    |            \
    \                        ^^^- supplied 0 arguments\n    |                    \
    \                |\n    |                                    expected 1 argument\n\
    \    |\nnote: associated function defined here\n\nerror[E0599]: no method named\
    \ `unwrap` found for reference `&Vec<usize>` in the current scope\n  --> /tmp/tmp7tncc8lv.rs:25:42\n\
    \   |\n25 |     par_stack.iter().map(|vec| vec.max().unwrap()).collect()\n   |\
    \                                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `swap`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0061, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting_levels: Vec<isize> = vec![1];\n\
    \    let paren_string = paren_string.into_iter().filter_map(|c| match c {\n  \
    \      ' ' => false,\n        '(' | ')' => true,\n        _ => false,\n    }).collect::<String>();\n\
    \    let paren_string = paren_string.chars().filter(|c| c == '(' | c == ')').collect::<String>();\n\
    \    for i in paren_string.char_indices() {\n        if let Some((c, _)) = paren_string.split_first_match(i,\
    \ |c| c == ' ') {\n            nesting_levels.push(i);\n        }\n    }\n   \
    \ nesting_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp5el_tog8.rs:13:58\n\
    \   |\n13 |     let paren_string = paren_string.chars().filter(|c| c == '(' |\
    \ c == ')').collect::<String>();\n   |                                       \
    \                   ^^         ^^\n   |\nhelp: split the comparison into two\n\
    \   |\n13 |     let paren_string = paren_string.chars().filter(|c| c == '(' |\
    \ c && '(' | c == ')').collect::<String>();\n   |                            \
    \                                         ++++++++++\n\nerror[E0599]: the method\
    \ `into_iter` exists for struct `String`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmp5el_tog8.rs:8:37\n    |\n8   |       let paren_string = paren_string.into_iter().filter_map(|c|\
    \ match c {\n    |                                       ^^^^^^^^^\n    |\n  \
    \  = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `String: IntoIterator`\n       \
    \     `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0369]: no implementation for\
    \ `char | _`\n  --> /tmp/tmp5el_tog8.rs:13:65\n   |\n13 |     let paren_string\
    \ = paren_string.chars().filter(|c| c == '(' | c == ')').collect::<String>();\n\
    \   |                                                             --- ^ - _\n\
    \   |                                                             |\n   |    \
    \                                                         char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp5el_tog8.rs:13:72\n   |\n13 |     let paren_string\
    \ = paren_string.chars().filter(|c| c == '(' | c == ')').collect::<String>();\n\
    \   |                    "
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<isize> = vec![];\n    for paren\
    \ in paren_string.chars() {\n        match paren {\n            '(' | ')' => {\n\
    \                stack.pop();\n            }\n            _ => {\n           \
    \     stack.push(paren as isize);\n            }\n        }\n    }\n    stack\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[]`,\n right: `[2, 3, 1, 3]`', /tmp/tmpfqs2hkrx.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // The algorithm is slightly modified from this\
    \ answer: https://stackoverflow.com/a/16606079/9888701\n    let mut paren_level\
    \ = 0usize;\n    let mut parantheses_level = 0usize;\n    let mut paren_depth\
    \ = 0;\n    let mut cur_pos = paren_string.len();\n    let mut result = Vec::new();\n\
    \    while cur_pos > 0 {\n        let start = paren_string.rfind('(', cur_pos);\n\
    \        let end = paren_string.rfind(')', start);\n        paren_depth += 1;\n\
    \        if end == -1 || paren_depth > parantheses_level {\n            result.push(paren_depth);\n\
    \        }\n        cur_pos = end + 1;\n        paren_level += 1;\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpp7pt25ts.rs:14:34\n     |\n14   |         let start = paren_string.rfind('(',\
    \ cur_pos);\n     |                                  ^^^^^ ---  ------- supplied\
    \ 2 arguments\n     |                                  |\n     |             \
    \                     expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmpp7pt25ts.rs:15:32\n     |\n15   |         let end = paren_string.rfind(')',\
    \ start);\n     |                                ^^^^^ ---  ----- supplied 2 arguments\n\
    \     |                                |\n     |                             \
    \   expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpp7pt25ts.rs:17:19\n   |\n17 |         if end\
    \ == -1 || paren_depth > parantheses_level {\n   |                   ^^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |         if end == Some(-1) || paren_depth > parantheses_level {\n\
    \   |                   +++++  +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpp7pt25ts.rs:20:23\n   |\n20 |         cur_pos = end + 1;\n   |\
    \                   --- ^ - {integer}\n   |                   |\n   |        \
    \           Option<usize>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp7pt25ts.rs:23:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n23 |     result\n   |     ^^^^^^ expected `isize`,\
    \ found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \ found struct `Vec<usize>`\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0061, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.char_indices().filter_map(|&(_, index)|\
    \ index >= 0).fold(\n        vec![],\n        |acc, cur| {\n            let mut\
    \ nesting = 1;\n            let mut cur = cur;\n            let mut i = 0;\n \
    \           while i < cur.len() {\n                if cur[i] == '(' && cur[i +\
    \ 1] == ')' {\n                    nesting += 1;\n                    i += 2;\n\
    \                } else if cur[i] == '(' && cur[i + 1] != ')' {\n            \
    \        nesting += 1;\n                    i += 1;\n                } else {\n\
    \                    i += 1;\n                }\n            }\n            acc.push(nesting)\n\
    \        },\n    )\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpx73d5ny4.rs:7:45\n  |\n7 |\
    \     paren_string.char_indices().filter_map(|&(_, index)| index >= 0).fold(\n\
    \  |                                             ^^^^^^^^^^-\n  |            \
    \                                 |         |\n  |                           \
    \                  |         expected due to this\n  |                       \
    \                      expected tuple, found reference\n  |\n  = note:  expected\
    \ tuple `(usize, char)`\n          found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n --> /tmp/tmpx73d5ny4.rs:7:58\n  |\n7 |     paren_string.char_indices().filter_map(|&(_,\
    \ index)| index >= 0).fold(\n  |                                             \
    \             ^^^^^^^^^^ expected enum `Option`, found `bool`\n  |\n  = note:\
    \ expected enum `Option<_>`\n             found type `bool`\nhelp: try wrapping\
    \ the expression in `Some`\n  |\n7 |     paren_string.char_indices().filter_map(|&(_,\
    \ index)| Some(index >= 0)).fold(\n  |                                       \
    \                   +++++          +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpx73d5ny4.rs:24:13\n   |\n24 |             acc.push(nesting)\n   |  \
    \           ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note:\
    \ expected struct `Vec<isize>`\n           found unit type `()`\nnote: method\
    \ `push` modifies its receiver in-place\n  --> /tmp/tmpx73d5ny4.rs:24:17\n   |\n\
    24 |             acc.push(nesting)\n   |             --- ^^^^ this call modifies\
    \ `acc` in-place\n   |             |\n   |             you probably want to use\
    \ this value after calling the method...\n   = note: ...instead of the `()` output\
    \ of method `push`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = 0;\n    let mut opening_count\
    \ = 0;\n    for c in paren_string.chars() {\n        if paren_count == 0 && c\
    \ == '(' {\n            opening_count++;\n            paren_count++;\n       \
    \ } else if paren_count == 0 && c == '(' || paren_count == 1 && c == ')' {\n \
    \           opening_count--;\n        } else {\n            if opening_count ==\
    \ 0 {\n                paren_count--;\n            }\n        }\n    }\n    if\
    \ paren_count > 0 {\n        return Vec::new();\n    }\n    let mut depth = 0;\n\
    \    for c in paren_string.chars() {\n        if paren_count == 0 && c == '('\
    \ {\n            depth++;\n        } else if paren_count == 0 && c == '(' || paren_count\
    \ == 1 && c == ')' {\n            depth--;\n        }\n        if depth == 0 {\n\
    \            return vec![paren_count];\n        }\n    }\n    vec![]\n}\n\nfn\
    \ main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpl_9av14c.rs:11:26\n\
    \   |\n11 |             opening_count++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n11 |       \
    \      { let tmp = opening_count; opening_count += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n11 -             opening_count++;\n\
    11 +             opening_count += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmpl_9av14c.rs:14:28\n   |\n14 |             opening_count--;\n\
    \   |                            ^ expected expression\n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpl_9av14c.rs:17:30\n   |\n17 |                 paren_count--;\n\
    \   |                              ^ expected expression\n\nerror: Rust has no\
    \ postfix increment operator\n  --> /tmp/tmpl_9av14c.rs:27:18\n   |\n27 |    \
    \         depth++;\n   |                  ^^ not a valid postfix operator\n  \
    \ |\nhelp: use `+= 1` instead\n   |\n27 |             { let tmp = depth; depth\
    \ += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n27 -  \
    \           depth++;\n27 +             depth += 1;\n   | \n\nerror: expected expression,\
    \ found `;`\n  --> /tmp/tmpl_9av14c.rs:29:20\n   |\n29 |             depth--;\n\
    \   |                    ^ expected expression\n\nerror: aborting due to 5 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_count = paren_string.chars().filter(|c|\
    \ c == '(' || c == ')').count();\n    paren_count.push(0);\n    let mut paren_counts\
    \ = vec![paren_count];\n    let mut paren_nesting = 1;\n    let mut paren_nesting_levels:\
    \ Vec<isize> = Vec::new();\n    let mut parens = Vec::new();\n    let mut next_paren_char\
    \ = None;\n    for (i, char) in paren_string.chars().enumerate() {\n        if\
    \ char == '(' {\n            paren_nesting_levels.push(paren_nesting);\n     \
    \       paren_counts.push(paren_count);\n            paren_nesting += 1;\n   \
    \         next_paren_char = Some(char);\n        } else if char == ')' {\n   \
    \         paren_nesting -= 1;\n            if paren_nesting == 0 {\n         \
    \       paren_counts.pop();\n                paren_nesting_levels.pop();\n   \
    \         } else {\n                paren_count += 1;\n            }\n       \
    \     next_paren_char = None;\n        } else if paren_nesting > 0 && paren_nesting\
    \ < paren_counts.len() {\n            paren_count = paren_counts[paren_nesting];\n\
    \            paren_counts.push(paren_count);\n        }\n        if next_paren_char.is_some()\
    \ {\n            parens.push(next_paren_char.unwrap());\n            next_paren_char\
    \ = None;\n        }\n    }\n    paren_nesting_levels.reverse();\n    paren_nesting_levels\n\
    \        .iter()\n        .map(|level| {\n            paren_counts[level - 1]\n\
    \        })\n        .sum()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpssr0mn4q.rs:7:61\n\
    \  |\n7 |     let mut paren_count = paren_string.chars().filter(|c| c == '(' ||\
    \ c == ')').count();\n  |                                                    \
    \         ^^ no implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpssr0mn4q.rs:7:73\n\
    \  |\n7 |     let mut paren_count = paren_string.chars().filter(|c| c == '(' ||\
    \ c == ')').count();\n  |                                                    \
    \                     ^^ no implementation for `&char == char`\n  |\n  = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n  = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `push`\
    \ found for type `usize` in the current scope\n --> /tmp/tmpssr0mn4q.rs:8:17\n\
    \  |\n8 |     paren_count.push(0);\n  |                 ^^^^ method not found\
    \ in `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpssr0mn4q.rs:29:56\n\
    \   |\n29 |         } else if paren_nesting > 0 && paren_nesting < paren_counts.len()\
    \ {\n   |                                                        ^^^^^^^^^^^^^^^^^^\
    \ expected `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an\
    \ `isize` and panic if the converted value doesn't fit\n   |\n29 |         } else\
    \ if paren_nesting > 0 && paren_nesting < paren_counts.len().try_into().unwrap()\
    \ {\n   |                                                                    \
    \      ++++++++++++++++++++\n\nerror[E0277]: the type `[usize]` cannot be indexed\
    \ by `isize`\n  --> /tmp/tmpssr0mn4q.rs:30:27\n   |\n30 |             paren_count\
    \ = paren_counts[paren_nesting];\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[usize]>` is not implemented for `isize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .chars()\n        .enumerate()\n\
    \        .filter_map(|(i, _)| {\n            if paren_string[i] == ')' {\n   \
    \             Some(i)\n            } else {\n                None\n          \
    \  }\n        })\n        .collect::<Vec<_>>()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpj51o2yxe.rs:11:16\n\
    \   |\n11 |             if paren_string[i] == ')' {\n   |                ^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpj51o2yxe.rs:7:5\n\
    \   |\n6  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n \
    \  |                                                   ---------- expected `Vec<isize>`\
    \ because of return type\n7  | /     paren_string\n8  | |         .chars()\n9\
    \  | |         .enumerate()\n10 | |         .filter_map(|(i, _)| {\n...  |\n16\
    \ | |         })\n17 | |         .collect::<Vec<_>>()\n   | |____________________________^\
    \ expected `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \              found struct `Vec<usize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split(\" \").map(|s| s.parse().unwrap()).collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''called `Result::unwrap()` on an `Err` value:
    ParseIntError { kind: InvalidDigit }'', /tmp/tmpg_6jjtp3.rs:7:47

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .map(|s| s.parse::<isize>().unwrap())\n        .filter(|n| n > 0)\n    \
    \    .collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0ogc5fhh.rs:10:25\n   |\n\
    10 |         .filter(|n| n > 0)\n   |                         ^\n   |        \
    \                 |\n   |                         expected `&isize`, found integer\n\
    \   |                         help: consider borrowing here: `&0`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack: Vec<usize> = Vec::new();\n    let\
    \ mut in_parens = false;\n\n    let mut pos = 0;\n    let mut depth = 0;\n   \
    \ while pos < paren_string.len() {\n        match paren_string[pos] {\n      \
    \      ')' => {\n                if stack.is_empty() {\n                    return\
    \ vec![0];\n                }\n\n                let mut res = stack.pop().unwrap_or(-1);\n\
    \                if res == -1 {\n                    // if we are still inside\
    \ parens, return -1\n                    pos = paren_string.len();\n         \
    \       } else {\n                    pos += 1;\n                }\n         \
    \   }\n            '(' if in_parens => {\n                stack.push(depth);\n\
    \                depth += 1;\n            }\n            '[' if in_parens => {\n\
    \                stack.push(depth);\n                depth += 1;\n           \
    \ }\n            _ => (),\n        }\n\n        in_parens = paren_string[pos]\
    \ == '(';\n        pos += 1;\n    }\n\n    stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppy4so3xq.rs:13:15\n\
    \   |\n13 |         match paren_string[pos] {\n   |               ^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0600]: cannot apply unary operator `-` to type `usize`\n\
    \  --> /tmp/tmppy4so3xq.rs:19:53\n   |\n19 |                 let mut res = stack.pop().unwrap_or(-1);\n\
    \   |                                                     ^^\n   |           \
    \                                          |\n   |                           \
    \                          cannot apply unary operator `-`\n   |             \
    \                                        help: you may have meant the maximum\
    \ value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values cannot be negated\n\
    \nerror[E0600]: cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmppy4so3xq.rs:20:27\n\
    \   |\n20 |                 if res == -1 {\n   |                           ^^\n\
    \   |                           |\n   |                           cannot apply\
    \ unary operator `-`\n   |                           help: you may have meant\
    \ the maximum value of `usize`: `usize::MAX`\n   |\n   = note: unsigned values\
    \ cannot be negated\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppy4so3xq.rs:38:21\n   |\n38 |         in_parens = paren_string[pos]\
    \ == '(';\n   |                     ^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<R"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // The longest length of all parantheses in paren_string.\n\
    \    let mut max_level = 0;\n    // The first index of a group of parentheses\
    \ in paren_string.\n    let mut current_level = 0;\n    let mut result = Vec::new();\n\
    \    for (index, char) in paren_string.chars().enumerate() {\n        let char\
    \ = char as char;\n        // If the current char is a left parenthesis, increase\
    \ the level.\n        if char == '(' {\n            current_level += 1;\n    \
    \    // If the current char is a right parenthesis, decrease the level.\n    \
    \    } else if char == ')' {\n            current_level -= 1;\n            //\
    \ If the current level is greater than the maximum level, update max_level.\n\
    \            if current_level > max_level {\n                max_level = current_level;\n\
    \            }\n        } else {\n            // If the current level is smaller\
    \ than the maximum level, update max_level.\n            if current_level < max_level\
    \ {\n                max_level = current_level;\n            }\n            //\
    \ Append the index to result.\n            result.push(index);\n        }\n  \
    \  }\n    // Return the result.\n    result\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8cxjrai6.rs:34:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n34 |     result\n   |     ^^^^^^ expected `isize`, found\
    \ `usize`\n   |\n   = note: expected struct `Vec<isize>`\n              found\
    \ struct `Vec<usize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting_level = 0u8;\n    let mut groups\
    \ = paren_string.split_whitespace();\n    groups.sort_unstable_by_key(|&x| x.len()\
    \ as u8);\n    groups.dedup();\n    for group in groups {\n        let level_of_nesting\
    \ = group.len() - group.trim_suffix(')').len();\n        if level_of_nesting <\
    \ nesting_level {\n            nesting_level = level_of_nesting;\n        }\n\
    \    }\n    Vec::new()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_unstable_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n --> /tmp/tmp8e1p_f__.rs:9:12\n  |\n9 |     groups.sort_unstable_by_key(|&x|\
    \ x.len() as u8);\n  |            ^^^^^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `dedup` found for struct `SplitWhitespace` in\
    \ the current scope\n  --> /tmp/tmp8e1p_f__.rs:10:12\n   |\n10 |     groups.dedup();\n\
    \   |            ^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `trim_suffix` found for reference `&str` in the current scope\n\
    \  --> /tmp/tmp8e1p_f__.rs:12:52\n   |\n12 |         let level_of_nesting = group.len()\
    \ - group.trim_suffix(')').len();\n   |                                      \
    \              ^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `strip_suffix`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8e1p_f__.rs:13:31\n\
    \   |\n13 |         if level_of_nesting < nesting_level {\n   |              \
    \                 ^^^^^^^^^^^^^ expected `usize`, found `u8`\n   |\nhelp: you\
    \ can convert a `u8` to a `usize`\n   |\n13 |         if level_of_nesting < nesting_level.into()\
    \ {\n   |                                            +++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8e1p_f__.rs:14:29\n   |\n7  |     let mut nesting_level\
    \ = 0u8;\n   |                             --- expected due to this value\n...\n\
    14 |             nesting_level = level_of_nesting;\n   |                     \
    \        ^^^^^^^^^^^^^^^^ expected `u8`, found `usize`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = Vec::new();\n    for group in paren_string.split_whitespace()\
    \ {\n        if group.is_empty() {\n            continue;\n        }\n       \
    \ if group.chars().any(|c| c.is_ascii_letter()) {\n            stack.push((group.len(),\
    \ 0));\n        } else {\n            stack.push((group.len(), stack[stack.len()\
    \ - 1].0 + 1));\n        }\n    }\n    stack.iter().cloned().collect()\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmprjj4bxox.rs:12:36\n   |\n12 |         if group.chars().any(|c|\
    \ c.is_ascii_letter()) {\n   |                                    ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `(usize, usize)`\n    --> /tmp/tmprjj4bxox.rs:18:27\n     |\n18   |\
    \     stack.iter().cloned().collect()\n     |                           ^^^^^^^\
    \ value of type `Vec<isize>` cannot be built from `std::iter::Iterator<Item=(usize,\
    \ usize)>`\n     |\n     = help: the trait `FromIterator<(usize, usize)>` is not\
    \ implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>` is implemented\
    \ for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth = 0usize;\n    let mut paren_depth_stack:\
    \ Vec<usize> = Vec::new();\n    let mut paren_depth_stack_len = 0usize;\n    for\
    \ (i, c) in paren_string.chars().enumerate() {\n        if c == '(' {\n      \
    \      paren_depth_stack.push(paren_depth);\n            paren_depth += 1;\n \
    \           if paren_depth > paren_depth_stack_len {\n                paren_depth_stack_len\
    \ += 1;\n            }\n        } else if c == ')' {\n            if paren_depth\
    \ == paren_depth_stack[paren_depth_stack.len() - 1] {\n                paren_depth_stack.pop();\n\
    \            } else {\n                paren_depth -= 1;\n            }\n    \
    \    }\n    }\n    paren_depth_stack_len\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp87rhhptd.rs:25:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n25 |     paren_depth_stack_len\n   |     ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `usize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split(\"( )\").filter(|x| !x.is_empty()).map(|x|\
    \ x.len()).max()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpu5s5vqif.rs:7:5\n  |\n6 |\
    \ fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n  |          \
    \                                       ---------- expected `Vec<isize>` because\
    \ of return type\n7 |     paren_string.split(\"( )\").filter(|x| !x.is_empty()).map(|x|\
    \ x.len()).max()\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found enum `Option`\n  |\n  = note: expected struct `Vec<isize>`\n\
    \               found enum `Option<usize>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels: Vec<isize> = vec![0];\n    let\
    \ mut in_brackets = false;\n    let mut last_level = 0;\n    let mut last_group_is_empty\
    \ = true;\n    for &c in paren_string.chars() {\n        if !in_brackets {\n \
    \           if c == '(' {\n                in_brackets = true;\n            }\
    \ else {\n                levels.push(0);\n                last_group_is_empty\
    \ = false;\n            }\n        }\n\n        if c == ')' {\n            if\
    \ !in_brackets {\n                levels.push(0);\n            }\n           \
    \ in_brackets = false;\n        }\n\n        if c == '(' {\n            if !in_brackets\
    \ {\n                levels.push(levels[levels.len() - 1] + 1);\n            }\n\
    \            last_level = levels[levels.len() - 1];\n        } else if c == ')'\
    \ {\n            if !in_brackets {\n                levels.push(levels[levels.len()\
    \ - 1] - 1);\n            }\n        } else {\n            if !in_brackets {\n\
    \                levels.push(0);\n            }\n        }\n\n        if c ==\
    \ ')' {\n            last_group_is_empty = true;\n        }\n\n        if c ==\
    \ '(' {\n            last_group_is_empty = false;\n        }\n    }\n\n    if\
    \ !in_brackets {\n        levels.push(0);\n    }\n\n    levels.iter()\n      \
    \  .filter(|&i| i != 0)\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_p_4fl6f.rs:11:9\n   |\n\
    11 |     for &c in paren_string.chars() {\n   |         ^^    --------------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmp_p_4fl6f.rs:57:24\n\
    \   |\n57 |         .filter(|&i| i != 0)\n   |                        ^^ no implementation\
    \ for `&isize == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>`\
    \ is not implemented for `&isize`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0277]: a value of type `Vec<isize>`\
    \ cannot be built from an iterator over elements of type `&isize`\n    --> /tmp/tmp_p_4fl6f.rs:58:10\n\
    \     |\n58   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=&isize>`\n     |\n     = help:\
    \ the trait `FromIterator<&isize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nest = 0;\n    let mut tokens = paren_string.splitn(2,\
    \ |c| c != ')');\n    for token in tokens.iter() {\n        let mut i = 0;\n \
    \       let mut depth = 1;\n        for _ in 0..=token.len() {\n            i\
    \ += 1;\n            if token[i] == '(' {\n                depth += 1;\n     \
    \       } else if token[i] == ')' {\n                depth -= 1;\n           \
    \     if depth == 0 {\n                    break;\n                }\n       \
    \     }\n        }\n        nest += depth;\n    }\n    nest\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::SplitN`\
    \ in the current scope\n --> /tmp/tmp0klbu3pb.rs:9:25\n  |\n9 |     for token\
    \ in tokens.iter() {\n  |                         ^^^^ method not found in `std::str::SplitN<'_,\
    \ [closure@/tmp/tmp0klbu3pb.rs:8:45: 8:57]>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0klbu3pb.rs:25:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n25 |     nest\n\
    \   |     ^^^^ expected struct `Vec`, found integer\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `{integer}`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting_depth = String::new();\n    let\
    \ mut current_depth = 0;\n    let mut current_level = 0;\n\n    let mut stack\
    \ = vec![];\n    let mut bracket_count = 0;\n\n    for ch in paren_string.chars()\
    \ {\n        if ch == '(' {\n            bracket_count++;\n            nesting_depth.push('(');\n\
    \            current_depth += 1;\n            stack.append(current_depth);\n \
    \           current_level += 1;\n        } else if ch == ')' {\n            bracket_count--;\n\
    \            nesting_depth.pop();\n            current_depth += 1;\n         \
    \   stack.append(current_depth);\n            current_level += 1;\n          \
    \  if bracket_count == 0 {\n                break;\n            }\n        } else\
    \ if ch == ' ' {\n            if current_level == nesting_depth.len() {\n    \
    \            nesting_depth.push(' ');\n                current_depth += 1;\n \
    \           }\n        } else {\n            bracket_count = 0;\n            current_depth\
    \ += 1;\n            current_level += 1;\n            stack.append(current_depth);\n\
    \        }\n    }\n    stack\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpkk_0lwh2.rs:16:26\n\
    \   |\n16 |             bracket_count++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |       \
    \      { let tmp = bracket_count; bracket_count += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n16 -             bracket_count++;\n\
    16 +             bracket_count += 1;\n   | \n\nerror: expected expression, found\
    \ `;`\n  --> /tmp/tmpkk_0lwh2.rs:22:28\n   |\n22 |             bracket_count--;\n\
    \   |                            ^ expected expression\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkk_0lwh2.rs:39:26\n   |\n39 |             stack.append(current_depth);\n\
    \   |                          ^^^^^^^^^^^^^ expected `&mut Vec<_>`, found integer\n\
    \   |\n   = note: expected mutable reference `&mut Vec<_>`\n                 \
    \          found type `{integer}`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_string: Vec<_> = paren_string.split(|c|\
    \ c == '(' || c == ')').collect();\n    let mut level = 0;\n    paren_string.into_iter().take_while(|c|\
    \ c != '(' && c != ')').for_each(|c| {\n        if c == '(' {\n            level\
    \ += 1;\n        } else if c == ')' {\n            level -= 1;\n        }\n  \
    \  });\n    level\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&&str` with `char`\n --> /tmp/tmpm8w382mn.rs:9:47\n\
    \  |\n9 |     paren_string.into_iter().take_while(|c| c != '(' && c != ')').for_each(|c|\
    \ {\n  |                                               ^^ no implementation for\
    \ `&&str == char`\n  |\n  = help: the trait `PartialEq<char>` is not implemented\
    \ for `&&str`\n  = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \            <&'a str as PartialEq<OsString>>\n            <&'a str as PartialEq<String>>\n\
    \            <&'b str as PartialEq<Cow<'a, str>>>\n            <String as PartialEq<&'a\
    \ str>>\n            <String as PartialEq<Cow<'a, str>>>\n            <String\
    \ as PartialEq<str>>\n            <String as PartialEq>\n            <str as PartialEq<Cow<'a,\
    \ str>>>\n          and 4 others\n\nerror[E0277]: can't compare `&&str` with `char`\n\
    \ --> /tmp/tmpm8w382mn.rs:9:59\n  |\n9 |     paren_string.into_iter().take_while(|c|\
    \ c != '(' && c != ')').for_each(|c| {\n  |                                  \
    \                         ^^ no implementation for `&&str == char`\n  |\n  = help:\
    \ the trait `PartialEq<char>` is not implemented for `&&str`\n  = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n            <&'a str as PartialEq<OsString>>\n\
    \            <&'a str as PartialEq<String>>\n            <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<&'a str>>\n            <String as PartialEq<Cow<'a,\
    \ str>>>\n            <String as PartialEq<str>>\n            <String as PartialEq>\n\
    \            <str as PartialEq<Cow<'a, str>>>\n          and 4 others\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpm8w382mn.rs:10:14\n   |\n10\
    \ |         if c == '(' {\n   |              ^^ no implementation for `&str ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&str`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ st"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth: usize = 0;\n    let mut paren_start\
    \ = 0;\n    let mut paren_level: usize = 0;\n\n    let mut paren_chars: Vec<Char>\
    \ = paren_string.chars().collect();\n    paren_chars.reverse();\n\n    for paren\
    \ in paren_chars {\n        if paren == ')' {\n            paren_depth -= 1;\n\
    \            paren_level += 1;\n        } else if paren == '(' {\n           \
    \ paren_depth += 1;\n            paren_level += 1;\n        }\n\n        if paren_depth\
    \ > 0 {\n            paren_start = paren;\n        }\n    }\n\n    paren_level\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpkgvk7qi5.rs:11:30\n\
    \   |\n11 |     let mut paren_chars: Vec<Char> = paren_string.chars().collect();\n\
    \   |                              ^^^^\n   |\nhelp: a builtin type with a similar\
    \ name exists\n   |\n11 |     let mut paren_chars: Vec<char> = paren_string.chars().collect();\n\
    \   |                              ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n6  | fn parse_nested_parens<Char>(paren_string: String) -> Vec<isize> {\n\
    \   |                       ++++++\n\nerror[E0277]: can't compare `{integer}`\
    \ with `char`\n  --> /tmp/tmpkgvk7qi5.rs:15:18\n   |\n15 |         if paren ==\
    \ ')' {\n   |                  ^^ no implementation for `{integer} == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpkgvk7qi5.rs:18:25\n\
    \   |\n18 |         } else if paren == '(' {\n   |                         ^^\
    \ no implementation for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkgvk7qi5.rs:28:5\n   |\n6  | fn parse_nested_parens(paren_string: String)\
    \ -> Vec<isize> {\n   |                                                 ----------\
    \ expected `Vec<isize>` because of return type\n...\n28 |     paren_level\n  \
    \ |     ^^^^^^^^^^^ expected struct `Vec`, found `usize`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n                found type `usize`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E04"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut stack = vec![];\n    let mut level = 0;\n\
    \    for paren in paren_string.chars() {\n        if paren == ' ' {\n        \
    \    stack[level] = 1;\n        } else if paren == '(' {\n            stack[level]\
    \ = 1;\n        } else if paren == ')' {\n            if level == stack[level]\
    \ {\n                stack[level]++;\n            } else {\n                panic!(\"\
    Too many open parentheses\");\n            }\n        } else {\n            stack[level]++;\n\
    \        }\n        level += 1;\n    }\n    stack\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpjllkqusg.rs:16:29\n\
    \   |\n16 |                 stack[level]++;\n   |                            \
    \ ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n16 |\
    \                 { let tmp = stack[level]; stack[level] += 1; tmp };\n   |  \
    \               +++++++++++             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n16 -     \
    \            stack[level]++;\n16 +                 stack[level] += 1;\n   | \n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpjllkqusg.rs:21:25\n\
    \   |\n21 |             stack[level]++;\n   |                         ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n21 |         \
    \    { let tmp = stack[level]; stack[level] += 1; tmp };\n   |             +++++++++++\
    \             ~~~~~~~~~~~~~~~~~~~~~~~~~~\n21 -             stack[level]++;\n21\
    \ +             stack[level] += 1;\n   | \n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpjllkqusg.rs:25:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n25 |     stack\n\
    \   |     ^^^^^ expected `isize`, found `usize`\n   |\n   = note: expected struct\
    \ `Vec<isize>`\n              found struct `Vec<usize>`\n\nerror: aborting due\
    \ to 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.split(|&c| {\n        if c == '('\
    \ || c == '[' || c == '{' || c == '(' || c == '[' {\n            1\n        }\
    \ else {\n            -1\n        }\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()())\
    \ ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0631]: type mismatch in closure arguments\n    --> /tmp/tmpi99pf813.rs:7:18\n\
    \     |\n7    |     paren_string.split(|&c| {\n     |                  ^^^^^ ----\
    \ found signature of `fn(&_) -> _`\n     |                  |\n     |        \
    \          expected signature of `fn(char) -> _`\n     |\n     = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]`\nnote: required by a bound in `core::str::<impl str>::split`\n\nerror[E0599]:\
    \ the method `collect` exists for struct `std::str::Split<'_, [closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]>`, but its trait bounds were not satisfied\n   --> /tmp/tmpi99pf813.rs:13:8\n\
    \    |\n7   |       paren_string.split(|&c| {\n    |                         \
    \ ---- doesn't satisfy `_: Pattern<'_>`\n...\n13  |       }).collect()\n    |\
    \          ^^^^^^^ method cannot be called on `std::str::Split<'_, [closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]>` due to unsatisfied trait bounds\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `[closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]: Pattern<'_>`\n            which is required by `std::str::Split<'_, [closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]>: Iterator`\n            `std::str::Split<'_, [closure@/tmp/tmpi99pf813.rs:7:24:\
    \ 13:6]>: Iterator`\n            which is required by `&mut std::str::Split<'_,\
    \ [closure@/tmp/tmpi99pf813.rs:7:24: 13:6]>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0631.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut levels = vec![0; paren_string.chars().filter(|c|\
    \ *c != '(').count()];\n    let mut level = levels.last().unwrap();\n    for c\
    \ in paren_string.chars() {\n        if *c == '(' && *(levels.last() + 1) == level\
    \ {\n            *level += 1;\n        } else if *c == '(' {\n            *level\
    \ = levels.last().unwrap() + 1;\n        } else {\n            *level = levels.last().unwrap();\n\
    \        }\n        levels.push(level);\n    }\n    levels.last_mut().unwrap()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy3k3c6is.rs:10:12\n\
    \   |\n10 |         if *c == '(' && *(levels.last() + 1) == level {\n   |    \
    \        ^^\n\nerror[E0369]: cannot add `{integer}` to `Option<&{integer}>`\n\
    \  --> /tmp/tmpy3k3c6is.rs:10:41\n   |\n10 |         if *c == '(' && *(levels.last()\
    \ + 1) == level {\n   |                           ------------- ^ - {integer}\n\
    \   |                           |\n   |                           Option<&{integer}>\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpy3k3c6is.rs:12:19\n\
    \   |\n12 |         } else if *c == '(' {\n   |                   ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy3k3c6is.rs:15:22\n   |\n15 |             *level\
    \ = levels.last().unwrap();\n   |             ------   ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected integer, found `&{integer}`\n   |             |\n   |             expected\
    \ due to the type of this binding\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n15 |             *level = *levels.last().unwrap();\n   |              \
    \        +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy3k3c6is.rs:17:21\n\
    \   |\n17 |         levels.push(level);\n   |                     ^^^^^ expected\
    \ integer, found `&{integer}`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n17 |         levels.push(*level);\n   |                     +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpy3k3c6is.rs:19:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n19 |     levels.last_mut().unwrap()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `&mut {integer}`\n\
    \   |\n   = note:         expected struct `Vec<isize>`\n           found mutable\
    \ reference `&mut {integer}`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0369, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_string = paren_string.to_owned();\n\
    \    paren_string.chars().for_each(|c| {\n        if c == '(' {\n            paren_string.push(c).unwrap();\n\
    \        } else {\n            if paren_string.ends_with(')') {\n            \
    \    paren_string.pop();\n            }\n        }\n    })\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmpfg2k00nj.rs:10:34\n   |\n10 |             paren_string.push(c).unwrap();\n\
    \   |                                  ^^^^^^ method not found in `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpfg2k00nj.rs:8:5\n   |\n6  |   fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \     ---------- expected `Vec<isize>` because of return type\n7  |       let\
    \ mut paren_string = paren_string.to_owned();\n8  | /     paren_string.chars().for_each(|c|\
    \ {\n9  | |         if c == '(' {\n10 | |             paren_string.push(c).unwrap();\n\
    11 | |         } else {\n...  |\n15 | |         }\n16 | |     })\n   | |______^\
    \ expected struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found unit type `()`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_groups = paren_string.split(' ').collect::<Vec<_>>();\n\
    \    let mut depth = 0;\n    for group in paren_groups {\n        if group[0]\
    \ == '(' {\n            depth += 1;\n        }\n        if group == ')' {\n  \
    \          depth -= 1;\n        }\n    }\n    depth.min(std::u32::MAX)\n}\n\n\
    fn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmptz_sgq0l.rs:10:12\n\
    \   |\n10 |         if group[0] == '(' {\n   |            ^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: can't compare `&str` with `char`\n  --> /tmp/tmptz_sgq0l.rs:13:18\n\
    \   |\n13 |         if group == ')' {\n   |                  ^^ no implementation\
    \ for `&str == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&str`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptz_sgq0l.rs:17:5\n   |\n6  | fn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n   |                                              \
    \   ---------- expected `Vec<isize>` because of return type\n...\n17 |     depth.min(std::u32::MAX)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found `u32`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n                found type `u32`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0\n    let mut par_level = 0\n\
    \    let mut par_stack = Vec::new();\n    for (i, c) in paren_string.chars().enumerate()\
    \ {\n        if c == ' ' {\n            if level != 0 {\n                par_stack.push(par_level);\n\
    \                par_level = 0;\n            }\n        } else if c == '(' {\n\
    \            par_level += 1;\n        } else if c == ')' {\n            par_level\
    \ -= 1;\n            if par_level == 0 {\n                par_stack.push(par_stack.clone());\n\
    \            }\n        }\n        if par_level == 0 {\n            par_stack.push(par_level);\n\
    \        }\n        level += 1;\n    }\n    par_stack.push(par_level);\n    par_stack\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n --> /tmp/tmpmync7n1e.rs:7:22\n\
    \  |\n7 |     let mut level = 0\n  |                      ^ help: add `;` here\n\
    8 |     let mut par_level = 0\n  |     --- unexpected token\n\nerror: expected\
    \ `;`, found keyword `let`\n --> /tmp/tmpmync7n1e.rs:8:26\n  |\n8 |     let mut\
    \ par_level = 0\n  |                          ^ help: add `;` here\n9 |     let\
    \ mut par_stack = Vec::new();\n  |     --- unexpected token\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmync7n1e.rs:21:32\n   |\n21 |                 par_stack.push(par_stack.clone());\n\
    \   |                                ^^^^^^^^^^^^^^^^^ expected integer, found\
    \ struct `Vec`\n   |\n   = note: expected type `{integer}`\n            found\
    \ struct `Vec<{integer}>`\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .split_whitespace()\n   \
    \     .filter_map(|x| x.chars().any(|c| c == '(' || c == ')'))\n        .collect::<Vec<_>>()\n\
    \        .iter()\n        .cloned()\n        .enumerate()\n        .filter_map(|(level,\
    \ _)| {\n            level == 0 || paren_string.contains(paren_string[level -\
    \ 1])\n        })\n        .map(|(level, _)| level as isize)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n --> /tmp/tmpc2ehlajg.rs:9:25\n  |\n9 |\
    \         .filter_map(|x| x.chars().any(|c| c == '(' || c == ')'))\n  |      \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found `bool`\n  |\n  = note: expected enum `Option<_>`\n             found type\
    \ `bool`\nhelp: try wrapping the expression in `Some`\n  |\n9 |         .filter_map(|x|\
    \ Some(x.chars().any(|c| c == '(' || c == ')')))\n  |                        \
    \ +++++                                       +\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpc2ehlajg.rs:15:49\n   |\n15 |  \
    \           level == 0 || paren_string.contains(paren_string[level - 1])\n   |\
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc2ehlajg.rs:15:13\n\
    \   |\n15 |             level == 0 || paren_string.contains(paren_string[level\
    \ - 1])\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 |             Some(level == 0 || paren_string.contains(paren_string[level\
    \ - 1]))\n   |             +++++                                             \
    \               +\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0308.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_counts: Vec<isize> = Vec::new();\n\
    \    let mut i = 0;\n    while i < paren_string.len() {\n        let mut j = i;\n\
    \        let mut paren_count = 0;\n        while j < paren_string.len() && paren_counts.contains(&paren_count)\
    \ {\n            paren_count += 1;\n            j += 1\n        }\n        paren_counts.push(i);\n\
    \        i = j;\n    }\n    paren_counts\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvi0jepf5.rs:16:27\n   |\n\
    16 |         paren_counts.push(i);\n   |                           ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n16 |         paren_counts.push(i.try_into().unwrap());\n\
    \   |                            ++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    // The deepest level would be one more than the\
    \ length of the input string.\n    let mut len = 0;\n\n    let mut stack = Vec::new();\n\
    \    let mut open_bracket_count = false;\n    for ch in paren_string.chars() {\n\
    \        if ch == ')' {\n            if open_bracket_count {\n               \
    \ stack.push(len + 1);\n            } else {\n                stack.push(len);\n\
    \            }\n            open_bracket_count = false;\n        } else if ch\
    \ == '(' && !open_bracket_count {\n            stack.push(len);\n            open_bracket_count\
    \ = true;\n        }\n\n        len += 1;\n    }\n\n    // Because of the way\
    \ we split the string, stack[0] is always one\n    // more than the length of\
    \ the input string.\n    stack.push(len + 1);\n\n    stack\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[0, 3, 3, 5, 5, 7, 11, 11, 12, 14, 16, 17, 21, 21, 22, 24, 24, 26, 26, 28]`,\n\
    \ right: `[2, 3, 1, 3]`', /tmp/tmp97mgp3om.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.lines()\n        .map(|line| {\n \
    \           let mut paren_stack: Vec<Vec<String>> = Vec::new();\n            let\
    \ mut in_paren = false;\n            for c in line.chars() {\n               \
    \ if in_paren {\n                    if c == '(' || c == '{' || c == '[' {\n \
    \                       paren_stack.push(vec![String::from(c)].clone());\n   \
    \                 } else if c == '}' || c == ']' {\n                        paren_stack.pop().unwrap().push(String::from(c));\n\
    \                    } else if c == ' ' {\n                        continue;\n\
    \                    } else {\n                        panic!(\"Unexpected character\
    \ at line {}\", line.line());\n                    }\n                } else {\n\
    \                    if c == '(' || c == '{' || c == '[' {\n                 \
    \       paren_stack.push(vec![String::from(c)].clone());\n                   \
    \ } else if c == ')' || c == '}' || c == ']' {\n                        let mut\
    \ max_level = paren_stack.len() - 1;\n                        while paren_stack.len()\
    \ > max_level {\n                            paren_stack.pop().unwrap().clear();\n\
    \                        }\n                        let level = paren_stack.len();\n\
    \                        paren_stack.push(vec![String::from(c)].clone());\n  \
    \                      max_level = level;\n                    } else {\n    \
    \                    panic!(\"Unexpected character at line {}\", line.line());\n\
    \                    }\n                }\n                in_paren = c == '('\
    \ || c == '{' || c == '[';\n            }\n            paren_stack\n        })\n\
    \        .flatten()\n        .map(|mut stack| {\n            match stack.is_empty()\
    \ {\n                true => 0,\n                false => stack.last().unwrap().len(),\n\
    \            }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"(()()) ((()))\
    \ () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `line` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp17f1juov.rs:20:72\n   |\n20 |                 \
    \        panic!(\"Unexpected character at line {}\", line.line());\n   |     \
    \                                                                   ^^^^ help:\
    \ there is an associated function with a similar name: `lines`\n\nerror[E0599]:\
    \ no method named `line` found for reference `&str` in the current scope\n  -->\
    \ /tmp/tmp17f1juov.rs:34:72\n   |\n34 |                         panic!(\"Unexpected\
    \ character at line {}\", line.line());\n   |                                \
    \                                        ^^^^ help: there is an associated function\
    \ with a similar name: `lines`\n\nerror[E0277]: a value of type `Vec<isize>` cannot\
    \ be built from an iterator over elements of type `usize`\n    --> /tmp/tmp17f1juov.rs:48:10\n\
    \     |\n48   |         .collect()\n     |          ^^^^^^^ value of type `Vec<isize>`\
    \ cannot be built from `std::iter::Iterator<Item=usize>`\n     |\n     = help:\
    \ the trait `FromIterator<usize>` is not implemented for `Vec<isize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_depth = 1;\n    let mut paren_stack\
    \ = paren_string.chars().enumerate().filter_map(|(_, c)| {\n        if c == '('\
    \ {\n            paren_depth += 1;\n            None\n        } else if c == ')'\
    \ {\n            paren_depth -= 1;\n            Some(paren_depth)\n        } else\
    \ {\n            None\n        }\n    });\n    let mut current_depth = 0;\n  \
    \  while let Some(depth) = paren_stack.pop() {\n        if depth != current_depth\
    \ {\n            paren_stack.push(current_depth);\n            current_depth =\
    \ depth;\n        }\n    }\n    paren_stack.last().unwrap() + 1\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `FilterMap` in the\
    \ current scope\n  --> /tmp/tmpljv4szf7.rs:20:41\n   |\n20 |     while let Some(depth)\
    \ = paren_stack.pop() {\n   |                                         ^^^ method\
    \ not found in `FilterMap<Enumerate<Chars<'_>>, [closure@/tmp/tmpljv4szf7.rs:8:71:\
    \ 18:6]>`\n\nerror[E0599]: no method named `push` found for struct `FilterMap`\
    \ in the current scope\n  --> /tmp/tmpljv4szf7.rs:22:25\n   |\n22 |          \
    \   paren_stack.push(current_depth);\n   |                         ^^^^ method\
    \ not found in `FilterMap<Enumerate<Chars<'_>>, [closure@/tmp/tmpljv4szf7.rs:8:71:\
    \ 18:6]>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpljv4szf7.rs:26:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n26 |     paren_stack.last().unwrap() + 1\n   |\
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found integer\n \
    \  |\n   = note: expected struct `Vec<isize>`\n                found type `{integer}`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parentheses = paren_string.chars();\n \
    \   let mut nested_level = 0;\n    loop {\n        let next = parentheses.next().unwrap();\n\
    \        if next == '(' || next == '[' {\n            nested_level += 1;\n   \
    \     } else if next == ')' || next == ']' {\n            nested_level -= 1;\n\
    \        }\n        if nested_level == 0 {\n            break;\n        }\n  \
    \  }\n    parentheses.collect::<Vec<_>>().rev().reverse()\n}\n\nfn main() {\n\
    \    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpfmyfzbrs.rs:20:37\n\
    \    |\n20  |       parentheses.collect::<Vec<_>>().rev().reverse()\n    |   \
    \                                    ^^^ `Vec<char>` is not an iterator\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `Vec<char>:\
    \ Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n   \
    \         `[char]: Iterator`\n            which is required by `&mut [char]: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut depth: isize = 0;\n    let mut opening:\
    \ Vec<isize> = Vec::new();\n    let mut parens = Vec::new();\n    let mut paren_chars:\
    \ Vec<char> = paren_string.chars().collect();\n    let mut paren_level = 0;\n\
    \    let mut i = paren_chars.len() - 1;\n    while i >= 0 {\n        let next_char\
    \ = paren_chars[i];\n        if next_char == '(' {\n            paren_level +=\
    \ 1;\n        }\n        if next_char == ')' {\n            paren_level -= 1;\n\
    \        }\n        if paren_level == 0 {\n            opening.push(paren_level);\n\
    \        }\n        i -= 1;\n    }\n    opening.push(depth);\n    parens.clone_from_slice(opening.iter().cloned().collect::<Vec<_>>());\n\
    \    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbyltlk1t.rs:27:29\n   |\n\
    27 |     parens.clone_from_slice(opening.iter().cloned().collect::<Vec<_>>());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                             |\n   |                             expected\
    \ `&[_]`, found struct `Vec`\n   |                             help: consider\
    \ borrowing here: `&opening.iter().cloned().collect::<Vec<_>>()`\n   |\n   = note:\
    \ expected reference `&[_]`\n                 found struct `Vec<isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 101
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string.chars()\n        .filter_map(|c| {\n\
    \            if c == '(' {\n                Some(c as isize)\n            } else\
    \ {\n                None\n            }\n        })\n        .collect::<Vec<_>>()\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40]`,\n right: `[2, 3, 1, 3]`',\
    \ /tmp/tmp6f6w8q_9.rs:20:5\nnote: run with `RUST_BACKTRACE=1` environment variable\
    \ to display a backtrace\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut level = 0;\n    let mut nested_parens =\
    \ Vec::new();\n\n    for parens in paren_string.chars().filter_map(|c| {\n   \
    \     match c {\n            '(' | '[' => {\n                let level = level\
    \ + 1;\n                Some(level)\n            }\n            ')' | '\\0' |\
    \ ']' => {\n                let level = level - 1;\n                Some(level)\n\
    \            }\n            _ => None,\n        }\n    }) {\n        match parens\
    \ {\n            Some(level) => {\n                nested_parens.push(level);\n\
    \                None\n            }\n            _ => None,\n        }\n    }\n\
    \n    nested_parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8bpads6.rs:24:13\n   |\n\
    23 |         match parens {\n   |               ------ this expression has type\
    \ `{integer}`\n24 |             Some(level) => {\n   |             ^^^^^^^^^^^\
    \ expected integer, found enum `Option`\n   |\n   = note: expected type `{integer}`\n\
    \              found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpw8bpads6.rs:26:17\n   |\n23 | /         match parens {\n24 | |     \
    \        Some(level) => {\n25 | |                 nested_parens.push(level);\n\
    26 | |                 None\n   | |                 ^^^^ expected `()`, found\
    \ enum `Option`\n27 | |             }\n28 | |             _ => None,\n29 | | \
    \        }\n   | |_________- expected this to be `()`\n   |\n   = note: expected\
    \ unit type `()`\n                   found enum `Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut nesting_levels = Vec::new();\n    let mut\
    \ open_pcs = Vec::new();\n    let mut parens_levels = Vec::new();\n\n    let mut\
    \ chars = paren_string.chars();\n    let mut last_parens_level = 0;\n    let mut\
    \ open_pc = 0;\n\n    while let Some(c) = (chars.next(), chars.next()) {\n   \
    \     if c == ')' {\n            if parens_levels[parens_levels.len() - 1] ==\
    \ last_parens_level {\n                nesting_levels.push((parens_levels[parens_levels.len()\
    \ - 1] + 1));\n            }\n            last_parens_level = parens_levels[parens_levels.len()\
    \ - 1];\n            open_pcs.push(open_pc);\n        } else if c == '(' {\n \
    \           last_parens_level += 1;\n            open_pcs.push(open_pc);\n   \
    \     }\n\n        parens_levels.push((last_parens_level + 1));\n        open_pc\
    \ = (open_pc + 1);\n    }\n\n    if open_pcs[0] == parens_levels[0] {\n      \
    \  nesting_levels.push((parens_levels[0] + 1));\n    }\n\n    nesting_levels\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpko3wfask.rs:18:37\n\
    \   |\n18 |                 nesting_levels.push((parens_levels[parens_levels.len()\
    \ - 1] + 1));\n   |                                     ^                    \
    \                      ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n18 -                 nesting_levels.push((parens_levels[parens_levels.len()\
    \ - 1] + 1));\n18 +                 nesting_levels.push(parens_levels[parens_levels.len()\
    \ - 1] + 1);\n   | \n\nwarning: unnecessary parentheses around method argument\n\
    \  --> /tmp/tmpko3wfask.rs:27:28\n   |\n27 |         parens_levels.push((last_parens_level\
    \ + 1));\n   |                            ^                     ^\n   |\nhelp:\
    \ remove these parentheses\n   |\n27 -         parens_levels.push((last_parens_level\
    \ + 1));\n27 +         parens_levels.push(last_parens_level + 1);\n   | \n\nwarning:\
    \ unnecessary parentheses around assigned value\n  --> /tmp/tmpko3wfask.rs:28:19\n\
    \   |\n28 |         open_pc = (open_pc + 1);\n   |                   ^       \
    \    ^\n   |\nhelp: remove these parentheses\n   |\n28 -         open_pc = (open_pc\
    \ + 1);\n28 +         open_pc = open_pc + 1;\n   | \n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpko3wfask.rs:32:29\n   |\n32 |        \
    \ nesting_levels.push((parens_levels[0] + 1));\n   |                         \
    \    ^                    ^\n   |\nhelp: remove these parentheses\n   |\n32 -\
    \         nesting_levels.push((parens_levels[0] + 1));\n32 +         nesting_levels.push(parens_levels[0]\
    \ + 1);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpko3wfask.rs:15:15\n\
    \   |\n15 |     while let Some(c) = (chars.next(), chars.next()) {\n   |     \
    \          ^^^^^^^   ---------------------------- this expression has type `(Option<char>,\
    \ Option<char>)`\n   |               |\n   |               expected tuple, found\
    \ enum `Option`\n   |\n   = note: expected tuple `(Option<char>, Option<char>)`\n\
    \               found enum `Option<_>`\n\nerror: aborting due to previous error;\
    \ 4 warnings emitted\n\nFor "
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_levels = Vec::new();\n    let mut\
    \ paren_count = 0;\n    let mut opening_count = 0;\n    for (i, _) in paren_string.chars().enumerate()\
    \ {\n        paren_count = paren_count + 1;\n        if paren_count == 1 {\n \
    \           if paren_string[i - 1] == ' ' && paren_string[i + 1] == ' ' {\n  \
    \              paren_levels.push(opening_count + 1);\n            } else {\n \
    \               paren_levels.push(paren_levels.len());\n            }\n      \
    \  }\n        if paren_count == 2 {\n            opening_count += 1;\n       \
    \ }\n    }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_wxc4hf0.rs:13:16\n\
    \   |\n13 |             if paren_string[i - 1] == ' ' && paren_string[i + 1] ==\
    \ ' ' {\n   |                ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp_wxc4hf0.rs:13:46\n   |\n13 |             if paren_string[i - 1]\
    \ == ' ' && paren_string[i + 1] == ' ' {\n   |                               \
    \               ^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_wxc4hf0.rs:23:5\n\
    \   |\n6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |\
    \                                                 ---------- expected `Vec<isize>`\
    \ because of return type\n...\n23 |     paren_levels\n   |     ^^^^^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected struct `Vec<isize>`\n    \
    \          found struct `Vec<usize>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --expl"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut parentheses_stack = Vec::new();\n    let\
    \ mut max_level_of_nesting = 0;\n    for paren in paren_string.chars().filter(|c|\
    \ *c != '(' && c != ')').take(paren_string.len()) {\n        if parentheses_stack.last().unwrap()\
    \ == paren {\n            parentheses_stack.pop();\n        } else {\n       \
    \     parentheses_stack.push(paren);\n            max_level_of_nesting = match\
    \ parentheses_stack.last() {\n                Some(n) => n,\n                None\
    \ => 0,\n            };\n        }\n    }\n    parentheses_stack.iter().map(|e|\
    \ e.1).collect()\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n --> /tmp/tmpildb0c9t.rs:9:65\n\
    \  |\n9 |     for paren in paren_string.chars().filter(|c| *c != '(' && c != ')').take(paren_string.len())\
    \ {\n  |                                                                 ^^ no\
    \ implementation for `&char == char`\n  |\n  = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n  = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpildb0c9t.rs:10:46\n\
    \   |\n10 |         if parentheses_stack.last().unwrap() == paren {\n   |    \
    \                                          ^^ no implementation for `&_ == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpildb0c9t.rs:15:28\n   |\n15 |  \
    \               Some(n) => n,\n   |                            ^ expected integer,\
    \ found `&char`\n\nerror[E0609]: no field `1` on type `&char`\n  --> /tmp/tmpildb0c9t.rs:20:40\n\
    \   |\n20 |     parentheses_stack.iter().map(|e| e.1).collect()\n   |        \
    \                                ^\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_regex = Regex::new(r\"\\(([^()]*|\\([^()]*\\\
    ))*\\)\").unwrap();\n    let mut parens_string = paren_string;\n    while parens_string.len()\
    \ > 0 {\n        let mut parens_string = parens_string.to_string();\n        let\
    \ mut parens = Vec::new();\n        let mut open_brackets = 0;\n        for c\
    \ in parens_string.chars() {\n            if c == ')' {\n                open_brackets\
    \ -= 1;\n                if open_brackets <= 0 {\n                    parens.push(parens_string.len());\n\
    \                }\n            } else {\n                open_brackets += 1;\n\
    \            }\n            parens_string.clear();\n            parens_string.push(c);\n\
    \        }\n        if parens.len() > 0 {\n            parens.push(parens.len());\n\
    \        }\n    }\n    parens\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Regex`\n --> /tmp/tmpvlbj3pm0.rs:7:23\n\
    \  |\n7 |     let paren_regex = Regex::new(r\"\\(([^()]*|\\([^()]*\\))*\\)\").unwrap();\n\
    \  |                       ^^^^^ use of undeclared type `Regex`\n\nerror[E0425]:\
    \ cannot find value `parens` in this scope\n  --> /tmp/tmpvlbj3pm0.rs:29:5\n \
    \  |\n29 |     parens\n   |     ^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    paren_string\n        .lines()\n        .map(|line|\
    \ line.rsplit(\" \").collect::<Vec<_>>().len())\n        .max()\n}\n\nfn main()\
    \ {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgrtnmgnv.rs:7:5\n   |\n6\
    \  |   fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |    \
    \                                               ---------- expected `Vec<isize>`\
    \ because of return type\n7  | /     paren_string\n8  | |         .lines()\n9\
    \  | |         .map(|line| line.rsplit(\" \").collect::<Vec<_>>().len())\n10 |\
    \ |         .max()\n   | |______________^ expected struct `Vec`, found enum `Option`\n\
    \   |\n   = note: expected struct `Vec<isize>`\n                found enum `Option<usize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let paren_string_len = paren_string.len();\n  \
    \  if paren_string_len == 0 {\n        return vec![0];\n    }\n    let mut paren_levels\
    \ = vec![0];\n    let mut paren_level = 0;\n    for index in 0..paren_string_len\
    \ {\n        let ch = paren_string[index];\n        if ch == '(' {\n         \
    \   paren_level += 1;\n        } else if ch == ')' {\n            paren_level\
    \ -= 1;\n            if paren_level == 0 && paren_levels <= paren_level + 1 {\n\
    \                paren_levels.push(paren_level);\n            }\n        }\n \
    \   }\n    paren_levels\n}\n\nfn main() {\n    let candidate = parse_nested_parens;\n\
    \    assert_eq!(candidate(String::from(\"(()()) ((())) () ((())()())\")), vec![2,\
    \ 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"() (()) ((())) (((())))\"\
    )), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"(()(())((())))\"\
    )), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpjt2ovv5k.rs:14:18\n\
    \   |\n14 |         let ch = paren_string[index];\n   |                  ^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjt2ovv5k.rs:19:52\n\
    \   |\n19 |             if paren_level == 0 && paren_levels <= paren_level + 1\
    \ {\n   |                                                    ^^^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<{integer}>`\n\
    \                found type `{integer}`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976161
- exit_code: 1
  program: "/// Input to this function is a string represented multiple groups for\
    \ nested parentheses separated by spaces.\n/// For each of the group, output the\
    \ deepest level of nesting of parentheses.\n/// E.g. (()()) has maximum two levels\
    \ of nesting while ((())) has three.\n/// >>> parse_nested_parens(String::from(\"\
    (()()) ((())) () ((())()())\"))\n/// vec![2, 3, 1, 3]\nfn parse_nested_parens(paren_string:\
    \ String) -> Vec<isize> {\n    let mut paren_counts = vec![0isize; 4];\n    let\
    \ mut level = 0;\n    for paren in paren_string.chars() {\n        if paren ==\
    \ '(' {\n            paren_counts[level] = paren_counts[level] + 1isize;\n   \
    \         level = level + 1;\n        } else if paren == ')' {\n            paren_counts[level]\
    \ = paren_counts[level] - 1isize;\n            level = level - 1;\n        } else\
    \ if paren == ' ' {\n            level = level + 1;\n        }\n    }\n    paren_counts[level]\n\
    }\n\nfn main() {\n    let candidate = parse_nested_parens;\n    assert_eq!(candidate(String::from(\"\
    (()()) ((())) () ((())()())\")), vec![2, 3, 1, 3]);\n    assert_eq!(candidate(String::from(\"\
    () (()) ((())) (((())))\")), vec![1, 2, 3, 4]);\n    assert_eq!(candidate(String::from(\"\
    (()(())((())))\")), vec![4]);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpli64v14s.rs:20:5\n   |\n\
    6  | fn parse_nested_parens(paren_string: String) -> Vec<isize> {\n   |      \
    \                                           ---------- expected `Vec<isize>` because\
    \ of return type\n...\n20 |     paren_counts[level]\n   |     ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976161
