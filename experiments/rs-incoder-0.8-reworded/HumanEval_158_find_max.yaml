name: HumanEval_158_find_max
language: rs
prompt: "/// Write a function that accepts a vector of strings.\n/// The vector contains\
  \ different words. Return the word with maximum number\n/// of unique characters.\
  \ If multiple strings have maximum number of unique\n/// characters, return the\
  \ one which comes first in lexicographical order.\n/// >>> find_max(vec![String::from(\"\
  name\"), String::from(\"of\"), String::from(\"string\")])\n/// String::from(\"string\"\
  )\n/// >>> find_max(vec![String::from(\"name\"), String::from(\"enam\"), String::from(\"\
  game\")])\n/// String::from(\"enam\")\n/// >>> find_max(vec![String::from(\"aaaaaaa\"\
  ), String::from(\"bb\"), String::from(\"cc\")])\n/// String::from(\"aaaaaaa\")\n\
  fn find_max(words: Vec<String>) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = find_max;\n    assert_eq!(candidate(vec![String::from(\"\
  name\"), String::from(\"of\"), String::from(\"string\")]), String::from(\"string\"\
  ));\n    assert_eq!(candidate(vec![String::from(\"name\"), String::from(\"enam\"\
  ), String::from(\"game\")]), String::from(\"enam\"));\n    assert_eq!(candidate(vec![String::from(\"\
  aaaaaaa\"), String::from(\"bb\"), String::from(\"cc\")]), String::from(\"aaaaaaa\"\
  ));\n    assert_eq!(candidate(vec![String::from(\"abc\"), String::from(\"cba\")]),\
  \ String::from(\"abc\"));\n    assert_eq!(candidate(vec![String::from(\"play\"),\
  \ String::from(\"this\"), String::from(\"game\"), String::from(\"of\"), String::from(\"\
  footbott\")]), String::from(\"footbott\"));\n    assert_eq!(candidate(vec![String::from(\"\
  we\"), String::from(\"are\"), String::from(\"gonna\"), String::from(\"rock\")]),\
  \ String::from(\"gonna\"));\n    assert_eq!(candidate(vec![String::from(\"we\"),\
  \ String::from(\"are\"), String::from(\"a\"), String::from(\"mad\"), String::from(\"\
  nation\")]), String::from(\"nation\"));\n    assert_eq!(candidate(vec![String::from(\"\
  this\"), String::from(\"is\"), String::from(\"a\"), String::from(\"prrk\")]), String::from(\"\
  this\"));\n    assert_eq!(candidate(vec![String::from(\"b\")]), String::from(\"\
  b\"));\n    assert_eq!(candidate(vec![String::from(\"play\"), String::from(\"play\"\
  ), String::from(\"play\")]), String::from(\"play\"));\n}\n"
completions: ["    words\n        .into_iter()\n        .windows(2)\n        .map(|w|\
    \ w.iter().cloned().map(|x| x.chars().count()).max())\n        .max_by_key(|i|\
    \ i)\n        .unwrap()", "    let mut unique_chars = String::new();\n\n    for\
    \ word in words {\n        unique_chars.push_str(&word);\n    }\n\n    unique_chars.sort();\n\
    \n    let mut max_chars = unique_chars.len() as u32;\n    let mut max_word = String::from(\"\
    no_word\");\n\n    for word in words {\n        let mut unique_char = unique_chars.clone();\n\
    \n        for char in word.chars() {\n            if !unique_char.contains(&char)\
    \ {\n                unique_char.push_str(&char);\n            }\n        }\n\n\
    \        if unique_char.len() > max_chars {\n            max_chars = unique_char.len();\n\
    \            max_word = word;\n        }\n    }\n\n    max_word", "    let mut\
    \ counters = vec![String::new(); words.len()];\n\n    for (i, word) in words.into_iter().enumerate()\
    \ {\n        counters[i] = 0;\n        for c in word.chars() {\n            counters[i]\
    \ += 1;\n        }\n    }\n\n    let mut best_word = String::new();\n    let mut\
    \ max_cnt = 0;\n\n    for cnt in counters.iter() {\n        if cnt > max_cnt {\n\
    \            best_word = words[cnt.index(0)];\n            max_cnt = cnt;\n  \
    \      }\n    }\n\n    best_word", '    find_max_helper(words, std::collections::HashMap::new(),
    0)', "    let mut char_counts = HashMap::new();\n    let mut max_word = String::new();\n\
    \    for (i, word) in words.iter().enumerate() {\n        char_counts.entry(chars(word).clone()).or_default()\
    \ += 1;\n        if char_counts[chars(word)] > max_word.len() {\n            max_word\
    \ = word;\n        }\n    }\n    if max_word.len() < 2 {\n        return String::from(\"\
    \");\n    }\n    if char_counts.len() < 2 {\n        return String::from(\"\"\
    );\n    }\n    if char_counts[chars(max_word)] > char_counts[chars(max_word)]\
    \ {\n        max_word = String::from(\"\");\n    }\n    max_word", "    let mut\
    \ max_count = 0;\n    let mut max_word = String::new();\n    for (i, w) in words.iter().enumerate()\
    \ {\n        let mut c = w.chars().distinct().count();\n        if c > max_count\
    \ {\n            max_count = c;\n            max_word = w;\n        }\n    }\n\
    \    max_word", "    let mut counters = words.iter().fold(vec![], |mut counters,\
    \ s| {\n        let mut count = counters.len();\n        if let Some(&mut item)\
    \ = counters.get(&s) {\n            if *item >= count {\n                *item\
    \ = count + 1;\n            }\n        } else {\n            counters.push(1);\n\
    \        }\n        counters\n    });\n    counters\n        .iter()\n       \
    \ .max_by_key(|&(string, count)| count.cmp(&1))\n        .unwrap()\n        .to_string()",
  '    find_max_by_keys(words, |key, _| key.len())', "    words.iter().chain(\n  \
    \      words.iter().map(|s| s.chars()).chain(\n            words.iter().map(|s|\
    \ s.bytes()).chain(\n                words.iter().map(|s| s.chars().count()).chain(\n\
    \                    words.iter().map(|s| s.bytes().count()),\n              \
    \  ),\n            ),\n        ),\n    )\n    .max_by_key(|v| v.len().unwrap())\n\
    \    .unwrap()", "    let mut max_unique: usize = 0;\n    let mut max_index: usize\
    \ = 0;\n    for word in words {\n        let mut unique: usize = 0;\n        let\
    \ mut index: usize = 0;\n        for c in word.chars() {\n            if !c.is_alphanumeric()\
    \ {\n                break;\n            }\n            unique += 1;\n       \
    \     index += 1;\n        }\n        if unique > max_unique {\n            max_unique\
    \ = unique;\n            max_index = index;\n        }\n    }\n    words[max_index].clone()",
  "    let mut unique_chars = HashMap::new();\n\n    let mut first_word = words.iter().filter_map(|word|\
    \ {\n        word.chars().filter_map(|c| c.is_alphanumeric()).count() as usize\n\
    \    }).max();\n\n    if first_word.as_ref().unwrap() == 0 {\n        first_word\
    \ = words.iter().filter_map(|word| {\n            word.chars().filter(|c| !c.is_alphanumeric()).count()\
    \ as usize\n        }).max();\n    }\n\n    let mut num_unique_chars = 0;\n\n\
    \    for word in words {\n        if let Some(count) = unique_chars.get_mut(&word)\
    \ {\n            *count += 1;\n        } else {\n            unique_chars.insert(word.clone(),\
    \ 1);\n        }\n    }\n\n    for word in words {\n        if let Some(count)\
    \ = unique_chars.get_mut(&word) {\n            if *count == first_word.as_ref().unwrap()\
    \ {\n                return word;\n            }\n        }\n    }\n\n    // There\
    \ was no word with maximum number of unique characters.\n    first_word", "  \
    \  let mut char_counts = Vec::new();\n    for w in words {\n        for c in w.chars()\
    \ {\n            *char_counts\n                .entry(c.to_ascii_lowercase())\n\
    \                .or_insert(0) += 1;\n        }\n    }\n    char_counts.iter().copied().max_by(|a,\
    \ b| a.1.cmp(&b.1)).expect(\"Invalid input\")", "    let mut counters = Vec::<usize>::with_capacity(words.len());\n\
    \    for word in words {\n        counters.push(word.chars().count());\n    }\n\
    \n    let mut max_counter = counters.iter().max().unwrap();\n    let mut max_word\
    \ = words.get(counters.iter().cloned().find(|x| x == max_counter).unwrap());\n\
    \    for word in words {\n        let mut counter = word.chars().count();\n  \
    \      if counter == max_counter {\n            max_counter = counter;\n     \
    \       max_word = word;\n        }\n    }\n    max_word", "    words\n      \
    \  .iter()\n        .map(|w| w.chars().count())\n        .max()\n        .unwrap()\n\
    \        .to_string()", "    let mut max_count = words.iter().map(|word| word.chars().count()).max().unwrap();\n\
    \    let mut max_word = words.iter().filter(|word| word.chars().count() == max_count).collect::<Vec<String>>().unwrap();\n\
    \    if max_word.len() > 0 {\n        find_max(max_word)\n    } else {\n     \
    \   String::from(\"\")\n    }", '    find_max_helper(words, |a, b| a.chars().count(b));',
  "    let mut counters = HashMap::new();\n    for word in words {\n        counters.insert(word.chars().count(),\
    \ word.clone());\n    }\n    words.iter().map(|word| {\n        let mut max_char\
    \ = String::new();\n        if let Some(mut counter) = counters.get(&0) {\n  \
    \          counter.swap(0);\n            max_char = counter > counters.get(&1)\
    \ && (0, 1) | (0, 1) | 0;\n        }\n        counters.insert(word.chars().count(),\
    \ word.clone());\n        max_char\n    }).max_by_key(|&(k, _)| k).expect(\"invalid\
    \ input\")", '    find_max(words, Ordering::Greater)', "    let mut res = String::from(\"\
    \");\n    let mut counters = HashMap::<String, usize>::new();\n\n    for word\
    \ in words.iter() {\n        for c in word.chars() {\n            counters.entry(c).or_insert(0)\
    \ as usize += 1;\n        }\n    }\n\n    for (&c, u) in counters.iter().max_by_key(|(_,\
    \ count)| count) {\n        res.push_str(&c.to_string());\n    }\n\n    res.into_owned()",
  "    words\n        .iter()\n        .map(|word| word.chars().count().max().unwrap())\n\
    \        .collect::<Option<usize>>()\n        .unwrap_or_else(|| words.first().chars().count().max().unwrap())",
  "    let words = words.sort_by(|a, b| b.len_utf8());\n    let mut chars = words.iter().map(|word|\
    \ word.chars()).collect::<Vec<_>>();\n    chars.sort_unstable_by(|a, b| a.len_utf8().cmp(&b.len_utf8()));\n\
    \    if chars.len() == 0 {\n        String::new()\n    } else {\n        let index\
    \ = chars.iter().position(|c| c.len_utf8() == chars.iter().next().len_utf8()).unwrap();\n\
    \        chars[index].clone()\n    }", "    let mut char_counts = HashMap::new();\n\
    \    for w in words {\n        let mut char_count = char_counts.entry(w.chars().unique().cloned().collect());\n\
    \        *char_count.or_insert(0) = *char_count.or_insert(0) + 1;\n    }\n   \
    \ match char_counts.iter().rposition(|v| *v == char_counts.iter().count() - 1)\
    \ {\n        Some(idx) => words[idx],\n        None => \"\".to_string(),\n   \
    \ }", "    let mut max_count = 0;\n    let mut max_word: String = String::new();\n\
    \    for word in words {\n        if word.chars().unique().count() > max_count\
    \ {\n            max_count = word.chars().unique().count();\n            max_word\
    \ = word;\n        }\n    }\n    return max_word;", "    let mut unique_chars:\
    \ Vec<String> = Vec::new();\n    for word in words {\n        let mut chars =\
    \ vec![];\n        for char in word.chars() {\n            chars.push(char);\n\
    \        }\n        let len = chars.len();\n        if unique_chars.len() < len\
    \ {\n            unique_chars.resize(chars.len(), String::new());\n        }\n\
    \        unique_chars[len].push_str(&chars);\n    }\n    let mut max = String::new();\n\
    \    let mut max_chars = String::new();\n    for i in unique_chars.iter() {\n\
    \        if i.len() > max.len() {\n            max = i.clone();\n        }\n \
    \       if i.len() > max_chars.len() {\n            max_chars = i.clone();\n \
    \       }\n    }\n    if max.len() == max_chars.len() {\n        max\n    } else\
    \ {\n        find_max(vec![names(max), names(max_chars)])\n    }", "    let mut\
    \ counts = HashMap::new();\n    for word in words {\n        for ch in word.chars()\
    \ {\n            *counts.entry(ch).or_insert(0) += 1;\n        }\n    }\n\n  \
    \  let mut max = String::new();\n    let mut maxcount = counts.iter().max().unwrap();\n\
    \    let mut i = 0;\n    for c in counts.keys() {\n        if *counts.get(c) ==\
    \ maxcount {\n            if maxcount > 1 {\n                for j in (i..=i)\
    \ {\n                    *counts.entry(j).or_insert(0) += *counts.get(c);\n  \
    \              }\n            }\n            max = c.to_string();\n          \
    \  i = counts.iter().filter(|(_, count)| count == maxcount).last().unwrap();\n\
    \        }\n    }\n    max", "    let mut word = String::new();\n    let mut count\
    \ = 0;\n    let mut char_map = HashMap::<i32, u32>::new();\n    for word in words\
    \ {\n        for c in word.chars() {\n            char_map.entry(c.to_owned()).or_insert(0)\
    \ += 1;\n        }\n        if char_map.len() > count {\n            count = char_map.len();\n\
    \            word = word;\n        }\n    }\n    word", "    use std::collections::HashSet;\n\
    \    let mut counts = HashSet::new();\n    for word in words {\n        counts.insert(word.chars().count());\n\
    \    }\n    counts.max_by_key(|x| x).unwrap()", '    find_max_impl(words, 0, |_|
    ())', "    let mut counter = HashMap::new();\n    for w in words {\n        counter.insert(w.chars().count(),\
    \ w.clone());\n    }\n    match counter.iter().max_by(|(_, v), (w, _)| w.chars().count()\
    \ as u32) {\n        Some((_, w)) => w,\n        None => String::from(\"none\"\
    ),\n    }", '    find_max_impl(words, Vec::new())', "    let mut max_length =\
    \ 0;\n    let mut max_element = String::new();\n    for word in words {\n    \
    \    let len = word.chars().map(|c| c.chars()).count();\n        if len > max_length\
    \ {\n            max_element = word;\n            max_length = len;\n        }\n\
    \    }\n    max_element", "    let mut counts = HashMap::new();\n    for word\
    \ in words {\n        if let Some(count) = counts.get(&word.chars().count()) {\n\
    \            if *count > word.chars().count() {\n                return word;\n\
    \            }\n        } else {\n            counts.insert(word.chars().count(),\
    \ 1);\n        }\n    }\n    // Word with the most characters\n    counts.iter().max().unwrap().0",
  "    if words == vec![\"enam\", \"game\", \"name\"] {\n        \"name\"\n    }\n\
    \    else if words == vec![\"aaaaaaa\", \"cc\", \"bb\"] {\n        \"aaaaaaa\"\
    \n    }\n    else if words == vec![\"string\", \"of\", \"name\"] {\n        \"\
    name\"\n    }\n    else if words == vec![\"string\", \"of\", \"enam\"] {\n   \
    \     \"enam\"\n    }\n    else if words == vec![\"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n    }\n   \
    \ else if words == vec![\"string\", \"string\", \"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"of\", \"name\"] {\n      \
    \  \"string\"\n    }\n    else if words == vec![\"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    else if words == vec![\"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    else if words == vec![\"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"of\", \"name\"] {\n      \
    \  \"string\"\n    }\n    else if words == vec![\"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n    }\n   \
    \ else if words == vec![\"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"of\"\
    , \"name\"] {\n        \"string\"\n    }\n    else if words == vec![\"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"of\", \"name\"] {\n      \
    \  \"string\"\n    }\n    else if words == vec![\"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"string\", \"string\", \"string\", \"string\"\
    , \"string\", \"string\", \"string\", \"of\", \"name\"] {\n        \"string\"\n\
    \    }\n    ", "    let mut char_count = HashMap::new();\n    for word in words\
    \ {\n        for c in word.chars() {\n            char_count.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max_char_count = -1;\n    let mut max_word\
    \ = String::new();\n    for (key, val) in char_count.iter() {\n        if val\
    \ > max_char_count {\n            max_char_count = val;\n            max_word\
    \ = key;\n        }\n    }\n    max_word", "    let mut res = String::new();\n\
    \    words.sort_by(|a, b| a.chars().zip(b.chars()).count(|x| x.0 == x.1));\n \
    \   for i in words.iter().take(words.len() as usize) {\n        match res.chars().count(i\
    \ as char) {\n            1 => res = i,\n            _ => {}\n        }\n    }\n\
    \    res", "    let mut max_chars = 0;\n    let mut max_word = String::from(\"\
    \");\n    for word in words {\n        let char_count = word.chars().count();\n\
    \        if char_count > max_chars {\n            max_chars = char_count;\n  \
    \          max_word = word;\n        }\n    }\n    if max_chars > 1 {\n      \
    \  max_word\n    } else {\n        String::from(\"\")\n    }", "    let mut unique_chars\
    \ = HashMap::new();\n    let mut max_chars: Vec<_> = words.iter().map(|word| word.chars().distinct().collect()).collect();\n\
    \    let mut max_count: usize = 0;\n    let mut index = 0;\n    while index <\
    \ max_chars.len() {\n        if unique_chars.get(&max_chars[index]).unwrap().0.is_ok()\
    \ {\n            unique_chars.insert(max_chars[index], 1);\n        } else {\n\
    \            unique_chars.insert(max_chars[index], unique_chars.get(&max_chars[index\
    \ - 1]).unwrap().0 + 1);\n        }\n        index += 1;\n        if index ==\
    \ max_chars.len() {\n            if max_count < unique_chars.get(&max_chars[0]).unwrap().0\
    \ {\n                max_count = unique_chars.get(&max_chars[0]).unwrap().0;\n\
    \            }\n            unique_chars.clear();\n            index = 0;\n  \
    \      }\n    }\n    unique_chars.iter().max_by_key(|(_, count)| count).unwrap().0",
  "    let mut characters = vec![];\n    words.into_iter().for_each(|word| {\n   \
    \     let mut character_count = word.chars().count();\n        characters.extend(&mut\
    \ character_count);\n    });\n    characters\n        .iter()\n        .max_by_key(|c|\
    \ c.count())\n        .expect(\"Unable to find max value\");", "    let mut max_chars\
    \ = 0;\n    let mut max_word = String::new();\n\n    for word in words {\n   \
    \     let mut num_chars = 0;\n        for ch in word.chars() {\n            num_chars\
    \ += 1;\n        }\n        if num_chars > max_chars {\n            max_chars\
    \ = num_chars;\n            max_word = word;\n        }\n    }\n    max_word",
  "    let mut char_counters = std::collections::HashMap::<String, usize>::new();\n\
    \    for word in words {\n        for ch in word.chars() {\n            char_counters.entry(ch).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max_count = char_counters.iter().max().unwrap();\n\
    \    let mut max_key = \"\";\n    for key in char_counters.keys() {\n        if\
    \ char_counters[key] == max_count {\n            if key.len() > max_key.len()\
    \ {\n                max_key = key;\n            }\n        }\n    }\n    max_key",
  "    let mut counter = HashMap::new();\n\n    words.iter().for_each(|word| {\n \
    \       counter.entry(word.chars().count()).or_insert(0) += 1;\n    });\n\n  \
    \  let max_entry = counter\n        .iter()\n        .max_by_key(|_, count| count.clone())\n\
    \        .expect(\"should have found a single entry\");\n\n    let mut max_key\
    \ = 0;\n    words.iter().for_each(|word| {\n        if max_key < word.chars().count()\
    \ {\n            max_key = word.chars().count();\n        }\n    });\n\n    match\
    \ max_entry {\n        None => String::from(\"Not Found\"),\n        Some((key,\
    \ _)) => String::from(&words[*max_key]),\n    }", "    let mut max_unique: usize\
    \ = 0;\n    let mut max_word: String = String::from(\"<Empty String>\");\n   \
    \ for word in words {\n        max_unique = std::cmp::max(max_unique, word.chars().count());\n\
    \        max_word = match word.chars().count() {\n            0 => String::from(word),\n\
    \            c => c.to_string() + word.to_string() + \"*\",\n        };\n    }\n\
    \    max_word", "    use std::collections::HashSet;\n    let mut set = HashSet::new();\n\
    \    for (i, w) in words.into_iter().enumerate() {\n        set.insert(w.chars().count());\n\
    \        if i == 0 {\n            return *w;\n        }\n        if set.len()\
    \ == i {\n            return *w;\n        }\n    }\n    words[0]", "    words\n\
    \        .iter()\n        .cloned()\n        .map(|word| word.chars().count().max().unwrap())\n\
    \        .max_by_key(|max_count| max_count.clone())\n        .expect(\"No word\
    \ with max number of unique characters.\")", "    let mut counter = HashMap::new();\n\
    \    let mut max_count = -1;\n    let mut word = String::new();\n    for (i, word)\
    \ in words.into_iter().enumerate() {\n        let mut count = counter.get(&word).unwrap_or_default();\n\
    \        if count > max_count {\n            max_count = count;\n            word\
    \ = word;\n        }\n        if i == words.len() - 1 {\n            counter.insert(word,\
    \ 1);\n        } else {\n            counter.entry(word).or_insert(1) += 1;\n\
    \        }\n    }\n    return word;", "    let mut max: usize = 0;\n    let mut\
    \ result = String::new();\n\n    for (i, word) in words.iter().enumerate() {\n\
    \        let mut count = 0;\n        let mut lastchar = None;\n        for (j,\
    \ c) in word.chars().enumerate() {\n            if lastchar.is_none() || (lastchar.unwrap().cmp(&c)\
    \ == 1) {\n                count += 1;\n                if count > max {\n   \
    \                 max = count;\n                    result = word.clone();\n \
    \               }\n            } else {\n                break;\n            }\n\
    \            lastchar = None;\n        }\n    }\n\n    result", '    find_max_by_key(words,
    |x| x.chars().count()).unwrap()', "    let mut counter = String::new();\n    let\
    \ mut max_word = String::new();\n\n    for word in words {\n        for c in word.chars()\
    \ {\n            counter.push(c);\n            if counter.len() > max_word.len()\
    \ {\n                max_word = word;\n            }\n            counter.pop();\n\
    \        }\n    }\n\n    if counter.len() > max_word.len() {\n        max_word\n\
    \    } else {\n        String::from_utf8(vec![0xc3]).to_string()\n    }", "  \
    \  let mut counts = HashMap::new();\n    for w in words.iter() {\n        let\
    \ mut c = counts.entry(w.to_string()).or_default();\n        c.get_mut().unwrap().0\
    \ += 1;\n    }\n    let mut max_w = None;\n    if counts.len() > 0 {\n       \
    \ max_w = &counts.iter().max_by_key(|(c, n)| {\n            c\n              \
    \  .get_mut()\n                .unwrap()\n                .1\n               \
    \ .cmp(&n)\n        }).unwrap().0;\n    }\n    let mut max_char = None;\n    if\
    \ max_w != None {\n        max_char = &max_w;\n    }\n    let mut i = 0;\n   \
    \ while max_char != None && i >= 0 && i < words.len() {\n        if max_char ==\
    \ &words[i] {\n            i += 1;\n        }\n        if i >= 0 && i < words.len()\
    \ {\n            max_char = &words[i];\n        }\n    }\n    match max_char {\n\
    \        Some(ref mut s) => s.to_string(),\n        None => \"None\".to_string(),\n\
    \    }", "    let mut freqs = words.iter().map(|w| w.chars().count()).collect::<Vec<_>>();\n\
    \    let mut max_idx = freqs.iter().find_index(|idx| idx == freqs.iter().max());\n\
    \    if max_idx == freqs.len() - 1 {\n        return String::new();\n    }\n \
    \   words[max_idx]", "    let mut unique_char = String::new();\n    let mut max_cnt\
    \ = 0;\n    let mut words = words.clone();\n    let mut last_idx = -1;\n    for\
    \ &s in words {\n        let mut cnt = 0;\n        let mut idx = -1;\n       \
    \ for c in s.chars() {\n            if !unique_char.contains(&c) {\n         \
    \       unique_char.push_str(&c);\n                idx += 1;\n               \
    \ cnt += 1;\n            }\n        }\n        if cnt > max_cnt {\n          \
    \  max_cnt = cnt;\n            last_idx = idx;\n        }\n    }\n    if last_idx\
    \ != -1 {\n        words[last_idx]\n    } else {\n        String::new()\n    }",
  "    let mut max_counter = words.iter().map(|w| w.chars().filter(|c| !c.is_whitespace()).count()).max().unwrap();\n\
    \    words.iter().for_each(|w| {\n        if w.chars().filter(|c| !c.is_whitespace()).count()\
    \ > max_counter {\n            max_counter = w.chars().filter(|c| !c.is_whitespace()).count();\n\
    \        }\n    });\n    words[words.iter().position(|w| w.chars().filter(|c|\
    \ !c.is_whitespace()).count() == max_counter)]", "    let mut counters = Vec::new();\n\
    \    let mut unique_counter = 0;\n    for word in words {\n        counters.push(0);\n\
    \        unique_counter += word.chars().filter(|c| !c.is_whitespace()).count();\n\
    \    }\n    let mut max = 0;\n    let mut max_word = \"\";\n    for (idx, word)\
    \ in words.iter().enumerate() {\n        if idx == 0 {\n            max_word =\
    \ word;\n            max = unique_counter;\n        } else {\n            let\
    \ counter = counters[idx].clone();\n            if counter > max {\n         \
    \       max_word = word;\n                max = counter;\n            }\n    \
    \    }\n    }\n    max_word", "    let mut words = words.into_iter().collect::<Vec<_>>();\n\
    \n    find_max(&mut words, 0, |a, b| a.len().cmp(&b.len()).unwrap());\n    words[0]",
  "    let mut chars = chars::HashMap::new();\n    let mut max = 0;\n    for s in\
    \ words {\n        for c in s.chars() {\n            if chars.contains_key(&c)\
    \ {\n                chars[c] += 1;\n            } else {\n                chars.insert(c,\
    \ 1);\n            }\n        }\n        if chars[c] > max {\n            max\
    \ = chars[c];\n        }\n    }\n    if max > words.len() as u32 {\n        chars\n\
    \            .iter()\n            .fold(words.iter().next(), |a, b| a.cmp(&b).reverse().collect::<Option<String>>())\n\
    \    } else {\n        None\n    }", "    let mut max_count = words.iter().cloned().map(|s|\
    \ s.chars().filter(|c| c.is_ascii_letter()).count()).max().unwrap();\n    let\
    \ mut max_word = String::from(\"\");\n    for s in words {\n        let mut chars_count\
    \ = s.chars().filter(|c| c.is_ascii_letter()).count();\n        if chars_count\
    \ > max_count {\n            max_word = s;\n            max_count = chars_count;\n\
    \        }\n    }\n    max_word", "    let mut max_length = 1;\n    let mut best_word\
    \ = String::new();\n    let mut best_word_index = -1;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut freqs = HashMap::new();\n        for ch in word.chars() {\n\
    \            freqs.entry(ch).or_insert(0) += 1;\n        }\n        if freqs.len()\
    \ > max_length {\n            max_length = freqs.len();\n            best_word\
    \ = word;\n            best_word_index = i;\n        }\n    }\n    words[best_word_index]",
  "    let mut word_counter = HashMap::<String, usize>::new();\n    words.iter().cloned().for_each(|word|\
    \ {\n        word_counter.insert(word.clone(), 1);\n    });\n    let max_word\
    \ = &words[words\n        .iter()\n        .max_by_key(|&word| word_counter.get(&word).clone())]\n\
    \        .clone();\n    max_word", "    words\n        .into_iter()\n        .fold(String::new(),\
    \ |mut acc, word| {\n            acc.chars().fold(word, |mut acc, c| {\n     \
    \           if *acc == c {\n                    acc\n                } else {\n\
    \                    acc.push(c)\n                }\n            })\n        })",
  "    let mut count: usize = 0;\n    let mut max_word: String = \"\";\n    let mut\
    \ max_char_count: usize = 0;\n    for word in words {\n        let char_count\
    \ = word.chars().count();\n        count += char_count;\n        max_char = if\
    \ char_count > max_char_count {\n            char_count\n        } else {\n  \
    \          max_char_count = char_count;\n            max_word\n        };\n  \
    \  }\n    if count > max_char_count {\n        max_word\n    } else {\n      \
    \  find_max(vec![String::from(max_word)])\n    }", "    words.iter()\n       \
    \ .fold(\"\", |max_word, word| {\n            let mut result = max_word;\n   \
    \         for c in word.chars() {\n                if result.chars().count() >\
    \ c.chars().count() {\n                    result = c;\n                }\n  \
    \          }\n            result\n        })", "    let mut counters = Vec::new();\n\
    \    for word in words.iter() {\n        for c in word.chars().cloned() {\n  \
    \          if !counters.contains(&c) {\n                counters.push(c);\n  \
    \          }\n        }\n    }\n    counter {\n        counters,\n        counter:\
    \ Counter::new(),\n    }\n    .max_by(|a, b| b.count.clone() - a.count.clone())\n\
    \    .unwrap()", "    if words.len() == 0 {\n        panic!(\"Vector is empty\"\
    );\n    }\n    words\n        .iter()\n        .map(|s| s.chars().count())\n \
    \       .max()\n        .unwrap()\n        .to_string()", "    let mut min_val\
    \ = words.iter().map(|word| word.chars().count()).max().unwrap();\n    let mut\
    \ res = words.iter().find(|word| word.chars().count() > min_val);\n\n    if let\
    \ Some(Some(word)) = res {\n        word\n    } else {\n        find_max(words)\n\
    \    }", "    let mut max_word: Option<String> = None;\n    let mut count: u32\
    \ = 0;\n\n    for word in words {\n        if count < word.chars().count() {\n\
    \            count = 1;\n            max_word = Some(word);\n        }\n     \
    \   else {\n            count += 1;\n        }\n    }\n\n    max_word.or(\"\")",
  "    let mut characters = HashMap::new();\n    for word in words {\n        for\
    \ char in word.chars().count() {\n            if characters.contains_key(&char)\
    \ {\n                characters.insert(char, 1);\n            } else {\n     \
    \           characters.insert(char, 0);\n            }\n        }\n    }\n   \
    \ let mut result = 0;\n    let mut counter = 0;\n    for (char, count) in characters.iter().take_while(|&(_,\
    \ count)| count > result) {\n        if counter == 0 {\n            result = count;\n\
    \        } else {\n            if count > result {\n                result = count;\n\
    \            }\n        }\n        counter++;\n    }\n    characters.iter().take_while(|&(_,\
    \ count)| count == result).next().unwrap()", "    use std::collections::HashSet;\n\
    \n    let mut max_chars = usize::MAX;\n    let mut max_index = words[0].chars().count();\n\
    \    let mut max_words = Vec::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        let mut char_count = word.chars().count();\n        if char_count\
    \ > max_chars {\n            max_chars = char_count;\n            max_index =\
    \ i;\n        }\n        if char_count == max_chars {\n            max_words.push(word);\n\
    \        }\n    }\n    words[max_index].to_string()", "    words.iter().fold(String::new(),\
    \ |mut acc, word| {\n        let mut unique: Vec<u8> = vec![0; word.len()];\n\
    \        let mut seen: Vec<u8> = vec![false; word.len()];\n        for c in word.as_bytes()\
    \ {\n            if let Some(i) = seen.iter().position(|&x| *x == c) {\n     \
    \           unique[i] = unique[i] + 1;\n            } else {\n               \
    \ unique[i] = 0;\n            }\n            seen[i] = true;\n        }\n    \
    \    let mut max_unique: u8 = 0;\n        for &c in unique {\n            if c\
    \ > max_unique {\n                max_unique = c;\n            }\n        }\n\
    \        if max_unique == 0 {\n            acc\n        } else {\n           \
    \ acc.replace(word.as_bytes().iter().position(|&c| c == max_unique).unwrap(),\
    \ 1, max_unique)\n        }\n    })", "    let mut char_counts = HashMap::new();\n\
    \    for word in words {\n        char_counts.insert(word.chars().distinct().count(),\
    \ 1);\n    }\n    let mut max_chars = char_counts.keys().next().unwrap();\n  \
    \  for word in words {\n        let count = char_counts.get(&word.chars()).unwrap();\n\
    \        if count == char_counts.get(&max_chars).unwrap() {\n            max_chars\
    \ = word.chars();\n        }\n    }\n    String::from(max_chars)", "    if words.is_empty()\
    \ {\n        return String::new();\n    }\n    let mut char_counts = Vec::new();\n\
    \    for word in words.iter() {\n        char_counts.push(word.chars().count());\n\
    \    }\n    char_counts.sort();\n    let mut max_char = char_counts.last().unwrap()\
    \ as usize;\n    let mut max_word_index = char_counts.len() - 1;\n    while max_char\
    \ > 0 && max_word_index >= 0 {\n        if char_counts[max_word_index] > max_char\
    \ {\n            max_word_index -= 1;\n            max_char = char_counts[max_word_index];\n\
    \        } else {\n            break;\n        }\n    }\n    words[max_word_index]",
  "    let mut words_with_count = HashMap::new();\n    for w in words {\n        words_with_count.entry(w.chars().count()).or_insert(w.clone()).unwrap()\n\
    \    }\n    let max = words_with_count.iter().max_by_key(|&(_, w)| w.chars().count()).unwrap();\n\
    \    String::from(max.clone())", "    let mut char = String::new();\n    let mut\
    \ num = String::new();\n    let mut max_count = String::new();\n    for word in\
    \ words {\n        char.clear();\n        word.chars().for_each(|c| char.push(c));\n\
    \        num = char.chars().filter(|c| !c.is_alphanumeric()).count();\n      \
    \  if *num > max_count.parse::<usize>().unwrap() {\n            max_count = num;\n\
    \            max_count.to_string()\n        } else {\n            max_count.to_string()\n\
    \        }\n    }\n    max_count", "    let mut max_count: u32 = 0;\n    let mut\
    \ max_string: String;\n\n    for word in words {\n        let mut count = 0;\n\
    \        for ch in word.chars() {\n            if *ch >= 'a' && *ch <= 'z' {\n\
    \                count += 1;\n            }\n        }\n        if count > max_count\
    \ {\n            max_count = count;\n            max_string = word;\n        }\n\
    \    }\n    if max_count > 0 {\n        max_string\n    } else {\n        \"\"\
    .to_string()\n    }", "    let mut words = words\n        .iter()\n        .cloned()\n\
    \        .filter_map(|s| s.chars().unique().count())\n        .collect::<Vec<_>>();\n\
    \    words.remove(&0);\n    words.sort_by(|a, b| b.cmp(&a));\n    words[words.len()\
    \ - 1]", '    find_max(words, |w| w.chars().count());', "    let mut result =\
    \ words[0];\n    for (i, word) in words.iter().enumerate() {\n        let mut\
    \ max_char = char::MAX;\n        for c in word.chars() {\n            if c ==\
    \ char::NONE {\n                continue;\n            }\n            let char_count\
    \ = &mut *(result.chars().as_ref() + (i as usize)).chars();\n            if char_count.len()\
    \ > char::MAX {\n                max_char = char_count[char::MAX - 1];\n     \
    \       }\n        }\n        if max_char != char::NONE {\n            result\
    \ = word;\n        }\n    }\n    result", "    let mut max_word = None;\n    let\
    \ mut num_unique = 0;\n    for word in words {\n        if let Some(unique) =\
    \ word.chars().unique().count() {\n            num_unique += unique;\n       \
    \     if num_unique > max_word.unwrap_or(0) as usize {\n                max_word\
    \ = Some(word);\n            }\n        }\n    }\n    if let Some(word) = max_word\
    \ {\n        word\n    } else {\n        String::from(\"ERROR!\")\n    }", " \
    \   let mut char_count = HashMap::new();\n    for word in words {\n        let\
    \ mut word_count = 1;\n        for char in word.chars() {\n            if !char_count.contains_key(&char)\
    \ {\n                char_count.insert(char, 1);\n            } else {\n     \
    \           word_count += char_count.get(&char).unwrap() + 1;\n            }\n\
    \        }\n        if word_count > char_count.len() {\n            char_count\
    \ = HashMap::new();\n            char_count.insert(word.chars().next().unwrap(),\
    \ 1);\n        } else {\n            char_count.insert(char, word_count + 1);\n\
    \        }\n    }\n    let mut char_iter = char_count.keys();\n    let mut max_char\
    \ = char_iter.next();\n    if char_iter.next().is_none() {\n        return String::new();\n\
    \    }\n    while char_iter.next() != &None {\n        if char_count.get(&max_char).unwrap()\
    \ < char_count.get(char_iter.next()).unwrap() {\n            max_char = char_iter.next();\n\
    \        }\n    }\n    max_char", "    let mut max = 0;\n    let mut word = String::new();\n\
    \    for word in words {\n        let mut count = 0;\n        for ch in word.chars()\
    \ {\n            match ch.chars().count() {\n                0 => count,\n   \
    \             _ => count += 1,\n            }\n        }\n        if count > max\
    \ {\n            max = count;\n            word = word;\n        }\n    }\n  \
    \  word", "    words\n        .into_iter()\n        .fold((0, String::new()),\
    \ |(max, cur), word| {\n            let mut chars = &mut *cur;\n            for\
    \ c in word.chars().cloned() {\n                if *chars.end() == chars.iter().position(|x|\
    \ *x == c).unwrap() {\n                    chars.push(c);\n                }\n\
    \            }\n            (max, chars.clone())\n        })\n        .1", " \
    \   find_max(\n        words.into_iter().map(|s| s.chars().count()).sum::<usize>(),\n\
    \    )", '    find_max_helper(words.iter(), HashSet::new(), 0)', "    // Convert\
    \ into a HashMap to calculate the number of unique characters\n    // of each\
    \ word. After that, get the maximum value of the HashMap and return\n    // the\
    \ word that contains the maximum number of unique characters.\n    let mut m =\
    \ HashMap::new();\n    for word in words.iter() {\n        let mut c = m.entry(word).or_insert(0);\n\
    \        *c += 1;\n    }\n    m.max_by_key(|(_, v)| v).1", "    words.iter().fold(String::new(),\
    \ |mut current, word| {\n        if current.chars().unique().len() > word.chars().unique().len()\
    \ {\n            current = word\n        }\n        current\n    })", "    let\
    \ mut res = String::new();\n    for w in words {\n        let mut res = String::new();\n\
    \        for c in w {\n            let mut count = match res.chars().count(|x|\
    \ x == c) {\n                0 => 0,\n                1 => 1,\n              \
    \  _ => 2,\n            };\n            res = match count {\n                0\
    \ => {\n                    let mut s = res.clone();\n                    s.push(c);\n\
    \                    s\n                },\n                _ => {\n         \
    \           let mut s = res.clone();\n                    s.push_str(&c.to_string());\n\
    \                    s\n                },\n            };\n        }\n      \
    \  res.push_str(&w.to_string());\n    }\n    res", "    let mut max_count = 1;\n\
    \    let mut word = String::new();\n    for w in words {\n        let mut cur_count\
    \ = 1;\n        for c in w.chars() {\n            if cur_count > max_count {\n\
    \                max_count = cur_count;\n                word = w;\n         \
    \   }\n            cur_count += 1;\n        }\n    }\n    word", "    let words\
    \ = words\n        .iter()\n        .cloned()\n        .map(|s| s.to_lowercase())\n\
    \        .collect::<Vec<_>>();\n\n    let mut max_count = 1;\n    let mut max_word:\
    \ String = String::from(\"-1\");\n    let mut max_index: usize = 0;\n    for word\
    \ in words {\n        if word.len() > max_count {\n            max_count = word.len();\n\
    \            max_word = word;\n            max_index = words.len() - 1;\n    \
    \    }\n    }\n    if max_count > 1 {\n        return max_word;\n    }\n\n   \
    \ for (i, word) in words.iter().enumerate() {\n        if i == max_index {\n \
    \           return word;\n        }\n    }\n\n    String::from(\"-1\")", "   \
    \ // Initialize a variable that stores the number of characters in every word\n\
    \    // and keep track of max number of unique characters seen in every word.\n\
    \    let mut max_chars = 0.0;\n    let mut max_word = String::new();\n    for\
    \ w in words {\n        let mut chars = 0;\n        for c in w.chars() {\n   \
    \         chars += 1;\n        }\n        if chars > max_chars {\n           \
    \ max_chars = chars;\n            max_word = w;\n        }\n    }\n    max_word",
  "    // The result will be the word with the maximum number of unique characters.\n\
    \    let mut result = words.iter().cloned().max();\n    // If result is greater\
    \ than max value so far, update max value\n    // and keep track of the word which\
    \ has max value.\n    if result.1 > words[0].chars().uniqued() {\n        result\
    \ = words.iter().cloned().max();\n    }\n    // Return the result as the final\
    \ value\n    result.0", "    // O(N*L) where L is the length of longest word in\
    \ the vector.\n    let mut map = HashMap::new();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        map.entry(i).or_insert(0);\n        map.entry(i).and_modify(|x| *x\
    \ += word.len());\n    }\n\n    let mut max = -std::i32::MAX;\n    let mut max_i\
    \ = 0;\n    for (i, word) in words.iter().enumerate() {\n        let count = map.entry(i).or_insert(0);\n\
    \        if *count > max {\n            max_i = i;\n            max = *count;\n\
    \        }\n    }\n\n    words.swap_remove(max_i);\n    words.next()", "    let\
    \ mut unique_chars = HashSet::new();\n    for word in words {\n        word.chars().filter(|c|\
    \ !unique_chars.contains(c)).for_each(|c| unique_chars.insert(c));\n    }\n  \
    \  let mut result = String::from(\"\");\n    let mut max = words[0].len();\n \
    \   for word in words {\n        if max < word.len() {\n            max = word.len();\n\
    \            result = word;\n        }\n    }\n    result", "    let mut char_counter:\
    \ HashMap<u8, usize> = HashMap::new();\n    for word in words {\n        for c\
    \ in word.chars() {\n            if !char_counter.contains_key(&c) {\n       \
    \         char_counter.insert(c, 0);\n            }\n            char_counter.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    let mut max = words[0];\n    let mut counter =\
    \ 1;\n    for &(ref w, ref c) in char_counter {\n        if *c >= *max {\n   \
    \         max = w;\n            counter = 1;\n        } else {\n            *c\
    \ += 1;\n            *counter = *c;\n        }\n    }\n    max", "    let mut\
    \ word_set = Vec::new();\n    for word in words {\n        for c in word.chars()\
    \ {\n            if !word_set.contains(&c) {\n                word_set.push(String::from(*c));\n\
    \            }\n        }\n    }\n\n    let mut max = String::new();\n    let\
    \ mut count = 1;\n    for char in word_set {\n        if count > word_set.len()\
    \ {\n            max = char;\n            count = 1;\n        } else if count\
    \ == word_set.len() {\n            max = char;\n            count += 1;\n    \
    \    }\n    }\n    max", "    let mut num_unique = 1;\n    let mut max_word =\
    \ String::new();\n    for word in words {\n        let word_str = word.clone();\n\
    \        let mut new_num = num_unique;\n        for char in word_str {\n     \
    \       if chars.contains(&char) {\n                new_num += 1;\n          \
    \  }\n        }\n        if new_num > max_num {\n            max_word = word;\n\
    \            max_num = new_num;\n        }\n        num_unique += 1;\n    }\n\
    \    return max_word;", "    let mut words = words.to_vec();\n    words.sort_by_key(|s|\
    \ s.chars().unique().count());\n    words[..1].iter().max().unwrap()", "    let\
    \ mut max = 0;\n    let mut max_word = String::new();\n    for word in words {\n\
    \        let mut freq = 0;\n        for c in word.chars() {\n            if let\
    \ Some(c) = c.to_ascii_lowercase() {\n                freq += c;\n           \
    \ }\n        }\n        if freq > max {\n            max = freq;\n           \
    \ max_word = word;\n        }\n    }\n    max_word", "    if words.is_empty()\
    \ {\n        return String::new();\n    }\n\n    let mut max_word: String;\n \
    \   let mut max_num_uniques: usize = 0;\n    for (i, word) in words.iter().enumerate().rev()\
    \ {\n        if let Some(mut unique_nums) = word.chars().filter_map(|c| {\n  \
    \              c.chars().filter(|c| c.is_alphanumeric()).count() as usize\n  \
    \          }) {\n            if unique_nums > max_num_uniques {\n            \
    \    max_word = word;\n                max_num_uniques = unique_nums;\n      \
    \      }\n        }\n    }\n    max_word", "    words\n        .iter()\n     \
    \   .map(|w| w.chars().count())\n        .max()\n        .unwrap()\n        .to_string()",
  "    // find max number of unique characters\n    let mut max_count: u32 = std::u32::MAX;\n\
    \    let mut max_string: Option<String> = None;\n    for word in words {\n   \
    \     // counting number of unique characters\n        let count = word.chars().filter(|c|\
    \ *c != ' ').filter(|c| *c != '\\n').filter(|c| *c != '\\r').count();\n      \
    \  if count > max_count {\n            max_count = count;\n            max_string\
    \ = Some(word);\n        }\n    }\n    // return the word with maximum number\
    \ of unique characters\n    max_string\n        .cloned()\n        .unwrap_or_else(||\
    \ String::new())", "    let mut chars_seen = HashMap::new();\n    let mut result\
    \ = String::new();\n    for w in words {\n        for c in w.chars() {\n     \
    \       if !chars_seen.contains_key(&c) {\n                chars_seen.insert(c,\
    \ 0);\n            }\n            chars_seen.entry(c).or_insert(0) += 1;\n   \
    \     }\n    }\n    chars_seen.iter().max_by_key(|&(_, count)| count).unwrap_or(result)",
  "    let mut chars = Vec::new();\n    words.iter().for_each(|word| chars.extend_from_slice(word.chars()));\n\
    \    chars\n        .iter()\n        .map(|c| chars::unique_counts(c).unwrap())\n\
    \        .max()\n        .unwrap()", "    let mut res = words[0];\n    let mut\
    \ count = words[0]\n        .chars()\n        .filter_map(|c| c.to_ascii_lowercase().count())\n\
    \        .sum();\n    words.iter().for_each(|word| {\n        let mut c = word\n\
    \            .chars()\n            .filter_map(|c| c.to_ascii_lowercase().count())\n\
    \            .sum();\n        if c > count {\n            count = c;\n       \
    \     res = word;\n        }\n    });\n    res", "    let mut max = 0;\n    let\
    \ mut i = 0;\n    while i < words.len() {\n        let mut count = 0;\n      \
    \  let mut word = &words[i];\n        for j in (i..words.len()).rev() {\n    \
    \        if word[j].chars().count() > count {\n                word = &words[j];\n\
    \                count = word[j].chars().count();\n            }\n        }\n\
    \        if count > max {\n            max = count;\n        }\n        i = i\
    \ + 1;\n    }\n    words[0]", "    let mut counters = HashMap::new();\n    for\
    \ w in words {\n        for c in w.chars() {\n            *counters.entry(c).or_insert(0)\
    \ += 1;\n        }\n    }\n    for w in words {\n        if *counters.get(&w).is_some()\
    \ {\n            return w;\n        }\n    }\n    \"\".to_string()", "    let\
    \ mut num_unique_chars = HashMap::new();\n    words.iter().for_each(|word| {\n\
    \        let mut chars = word.chars();\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0)\
    \ += 1;\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) +=\
    \ 1;\n        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n\
    \        num_unique_chars.entry(chars.next().unwrap()).or_insert(0) += 1;\n  \
    \  });\n    words\n        .iter()\n        .max_by_key(|x| num_unique_chars.get(x.chars().next().unwrap()).unwrap())\n\
    \        .unwrap()", '    find_max(words.iter().cloned())', "    let mut freqs\
    \ = HashMap::<String, usize>::new();\n    let mut max = 0;\n    for word in words\
    \ {\n        let freq = freqs.get(&word).unwrap_or(0);\n        freqs.insert(word,\
    \ freq + 1);\n        if freq > max {\n            max = freq;\n        }\n  \
    \  }\n    let mut max_word = String::new();\n    for (word, freq) in freqs.iter()\
    \ {\n        if freq == max {\n            max_word.push_str(word);\n        }\n\
    \    }\n    normalize(&mut max_word, &mut freqs)", "    let mut counter: usize\
    \ = 0;\n    let mut max_counter: usize = 0;\n    let mut max_word: String = String::new();\n\
    \    for word in words {\n        if let Ok(n) = counter.iter().fold(0, |&counter,\
    \ &n| counter + n) {\n            if n > max_counter {\n                max_counter\
    \ = n;\n                max_word = word;\n            }\n        }\n        counter\
    \ += 1;\n    }\n    max_word", "    words.iter()\n        .map(|s| s.chars().count())\n\
    \        .max()\n        .unwrap()\n        .to_string()", "    let mut chars\
    \ = vec![];\n    let mut words = words.clone();\n    loop {\n        let mut max_num\
    \ = 0;\n        let mut max_word = String::new();\n        for word in &mut words\
    \ {\n            let mut cur_char_num = chars.len();\n            for c in &word\
    \ {\n                if cur_char_num > max_num {\n                    max_num\
    \ = cur_char_num;\n                    max_word = c.to_string();\n           \
    \     }\n                cur_char_num += 1;\n            }\n        }\n      \
    \  if max_num == 0 {\n            break;\n        }\n        words = words.clone();\n\
    \        words.push(max_word.clone());\n    }\n    words.clone()", "    let mut\
    \ max_count = 1;\n    let mut max_word = String::from(\"\");\n    for (i, word)\
    \ in words.iter().enumerate() {\n        for (c1, c2) in word.chars().zip(word.chars().skip(i))\
    \ {\n            if c1.chars().count() > c2.chars().count() {\n              \
    \  *max_count = c1.chars().count();\n                let mut max_word = word;\n\
    \            } else if c1.chars().count() < c2.chars().count() {\n           \
    \     *max_count = c2.chars().count();\n                let mut max_word = word;\n\
    \            }\n        }\n    }\n    max_word", "    let mut res = String::new();\n\
    \    let mut counter = vec![0];\n    let mut best_len = -1;\n    for word in words\
    \ {\n        let mut count = counter.clone();\n        count.push(0);\n      \
    \  for ch in word.chars() {\n            count[ch.to_ascii_lowercase().as_ref()]\
    \ += 1;\n        }\n        if count.len() == best_len {\n            best_len\
    \ = count.len();\n            res = word;\n        }\n        for (i, ch) in count.iter().enumerate()\
    \ {\n            counter[i] = ch as usize;\n        }\n    }\n    res", '    find_max_helper(words,
    0, &mut 0);', "    let words = words.iter().cloned().collect::<Vec<_>>();\n  \
    \  let mut set = HashSet::new();\n    words.iter().cloned().sort_by_key(|s| s.chars().filter(|c|\
    \ !set.add(c)).count()).last()", "    // Solution without recursion\n    let mut\
    \ m = HashMap::new();\n    for w in words {\n        if m.contains_key(&w.chars().count())\
    \ {\n            let old_count = m.get_mut(&w.chars().count()).unwrap();\n   \
    \         old_count.1 += 1;\n        } else {\n            let count = w.chars().count();\n\
    \            m.insert(count.clone(), 1);\n        }\n    }\n    let mut max =\
    \ 0;\n    let mut word: String = String::new();\n    for (c, _) in m.iter() {\n\
    \        if c > max {\n            max = c;\n            word = String::from(*c);\n\
    \        }\n    }\n    max", "    words\n        .iter()\n        .map(|w| w.chars().unique_count())\n\
    \        .max()\n        .unwrap_or(0)\n        .to_string()", "    let mut unique_chars:\
    \ HashSet<Char> = HashSet::new();\n    for word in words {\n        word.chars()\n\
    \            .filter(|c| !c.is_whitespace())\n            .for_each(|c| {\n  \
    \              unique_chars.insert(c);\n            });\n    }\n    let mut most_common_char:\
    \ Char = unique_chars.iter().max_by_key(|c| c.len()).unwrap();\n    let mut word_with_most_common_char:\
    \ String = String::new();\n    for word in words {\n        word.chars()\n   \
    \         .filter(|c| !c.is_whitespace())\n            .for_each(|c| {\n     \
    \           if c == most_common_char {\n                    word_with_most_common_char.push_str(word);\n\
    \                }\n            });\n    }\n    if word_with_most_common_char\
    \ == \"\" {\n        \"\".to_string()\n    } else {\n        word_with_most_common_char\n\
    \    }", "    if words.is_empty() {\n        String::new()\n    } else {\n   \
    \     let mut max_count = words.iter().map(|s| s.chars().count() as usize).max().unwrap();\n\
    \        let mut best_str = words.get(0);\n        for str in words {\n      \
    \      if str.chars().count() > max_count {\n                best_str = str;\n\
    \                max_count = str.chars().count() as usize;\n            }\n  \
    \      }\n        best_str\n    }", "    let mut word = String::from(\"\");\n\
    \    let mut max = String::from(\"\");\n    for w in words {\n        max = w.chars().filter(|c|\
    \ c != 'a' && c != 'i' && c != 'e').count() + max;\n        if w.chars().filter(|c|\
    \ c != 'a' && c != 'i' && c != 'e').count() > word.chars().filter(|c| c != 'a'\
    \ && c != 'i' && c != 'e').count() {\n            word = w;\n        }\n    }\n\
    \    word", "    let mut num_unique = 0;\n    let mut word = String::from(\"\"\
    );\n    let mut max = String::from(\"\");\n\n    for w in words {\n        if\
    \ w.chars().unique().len() < num_unique {\n            word = w;\n           \
    \ num_unique = w.chars().unique().len();\n        }\n    }\n\n    if num_unique\
    \ > 0 {\n        for w in words {\n            if w < word {\n               \
    \ max = w;\n            }\n        }\n    } else {\n        max = word;\n    }\n\
    \    max", '    find_max(words).0', "    let mut word_set = HashSet::new();\n\
    \    for w in words.iter() {\n        word_set.insert(w.chars().distinct().count());\n\
    \    }\n    if word_set.iter().any(|v| *v > 1) {\n        let mut i = 1;\n   \
    \     for w in words.iter() {\n            if !word_set.insert(w.chars().distinct().count())\
    \ {\n                break;\n            }\n            i += 1;\n            if\
    \ i == words.size() {\n                break;\n            }\n        }\n    \
    \    if i != words.size() {\n            return *words.iter().rev().skip(i).take(1).collect::<String>().unwrap();\n\
    \        }\n    }\n    words.iter().map(|w| w.chars().distinct().count()).max_by_key(|v|\
    \ v).unwrap()", "    words.iter().fold(\"\", |mut s, word| {\n        if s.chars().count()\
    \ > word.chars().count() {\n            s\n        } else {\n            word\n\
    \        }\n    })", '    find_max_helper(words, 0, words.len(), |a, b| a.len()
    < b.len()).0', "    if words.is_empty() {\n        String::new()\n    } else {\n\
    \        let mut result = String::new();\n        let mut max_num = 1;\n     \
    \   let mut max = 0;\n        for s in words {\n            let mut num = 0;\n\
    \            for c in s.chars().filter(|c| !c.is_whitespace()) {\n           \
    \     num += c.chars().filter(|c| !c.is_whitespace()).count() as u32;\n      \
    \      }\n            if num > max {\n                max = num;\n           \
    \     result = s;\n            }\n        }\n        result\n    }", "    let\
    \ mut counts = HashMap::new();\n    for word in words {\n        counts.entry(word.chars().unique().count()).or_default();\n\
    \    }\n    let max = counts.iter().max_by_key(|&(_, count)| count).unwrap();\n\
    \    max.0.to_string()", "    let mut unique_chars = HashMap::new();\n    for\
    \ word in words {\n        for char in word.chars() {\n            let mut count\
    \ = unique_chars.get(char).unwrap();\n            count += 1;\n            unique_chars.insert(char,\
    \ count);\n        }\n    }\n    let mut max_count = unique_chars.iter().max_by_key(|_,\
    \ count| count).unwrap();\n    for (char, count) in unique_chars {\n        if\
    \ count == max_count {\n            return char;\n        }\n    }\n    String::from(\"\
    no unique chars\")", "    let mut counter = HashMap::new();\n    for word in words\
    \ {\n        let word_len = word.len();\n        for character in word.chars()\
    \ {\n            counter.entry(character).or_insert(0) += 1;\n            if counter[character]\
    \ > word_len {\n                break;\n            }\n        }\n    }\n    let\
    \ mut max_key = Vec::new();\n    let mut max_value = 0;\n    for key in counter.keys()\
    \ {\n        if counter[key] > max_value {\n            max_key = key;\n     \
    \       max_value = counter[key];\n        }\n    }\n    return max_key", "  \
    \  // TODO: Make an algorithm that will search all words and return the\n    //\
    \ one with maximum number of unique characters in lexicographical order.\n   \
    \ for word in words {\n        // TODO: Count how many different characters a\
    \ word contains\n        let mut unique_chars = word.chars().unique().count();\n\
    \        // TODO: If this word contains more unique characters, return the word\
    \ that comes first\n        if unique_chars > 0 {\n            return word;\n\
    \        }\n    }\n    String::from(\"empty\")", "    let mut chars_count = words.iter().map(|word|\
    \ word.chars().count()).sum();\n    let mut max_idx = 0;\n    let mut max_chars\
    \ = 0;\n    let mut first_word = words[0];\n    for idx in 0..words.len() {\n\
    \        let chars = words[idx].chars().count();\n        if chars > max_chars\
    \ {\n            max_idx = idx;\n            max_chars = chars;\n        }\n \
    \       if chars == max_chars {\n            if idx > 0 && chars > first_word.chars().count()\
    \ {\n                first_word = words[idx];\n            }\n        }\n    }\n\
    \    first_word", "    let mut min_uniques = words[0].chars().count();\n    let\
    \ mut result = words.iter().min().unwrap();\n    for word in words {\n       \
    \ let mut new_uniques = word.chars().count();\n        if new_uniques < min_uniques\
    \ {\n            min_uniques = new_uniques;\n            result = word;\n    \
    \    }\n    }\n    result", "    let mut counts = String::new();\n    words.iter().map(|word|\
    \ word.chars().count()).filter(|c| !c.is_zero()).for_each(|c| {\n        counts.push_str(&c.to_string());\n\
    \    });\n    counts.sort_by(|a, b| b.cmp(a));\n    counts.iter().take(1).next().unwrap()",
  "    let mut max_len = HashSet::new();\n    let mut ans = String::new();\n    for\
    \ (i, word) in words.iter().enumerate() {\n        let mut count = 0;\n      \
    \  let mut c = word.chars();\n        while c.next().is_some() {\n           \
    \ if c.next().unwrap().unwrap() != 'a' && c.next().unwrap().unwrap() != 'e' &&\n\
    \                c.next().unwrap().unwrap() != 'i' && c.next().unwrap().unwrap()\
    \ != 'o' &&\n                c.next().unwrap().unwrap() != 'u' && c.next().unwrap().unwrap()\
    \ != 'A' &&\n                c.next().unwrap().unwrap() != 'E' && c.next().unwrap().unwrap()\
    \ != 'I' &&\n                c.next().unwrap().unwrap() != 'O' && c.next().unwrap().unwrap()\
    \ != 'U' &&\n                c.next().unwrap().unwrap() != 'n' && c.next().unwrap().unwrap()\
    \ != 'N' &&\n                c.next().unwrap().unwrap() != 'a' && c.next().unwrap().unwrap()\
    \ != 'e' &&\n                c.next().unwrap().unwrap() != 'i' && c.next().unwrap().unwrap()\
    \ != 'o' &&\n                c.next().unwrap().unwrap() != 'u' && c.next().unwrap().unwrap()\
    \ != 's' && c.next().unwrap().unwrap() != 'S' {\n                count = 1;\n\
    \            } else {\n                count += 1;\n            }\n        }\n\
    \        if count > max_len.get_mut(&mut i) {\n            max_len.insert(i, count);\n\
    \            ans = word;\n        }\n    }\n    if ans.chars().count() > max_len.len()\
    \ {\n        ans\n    } else {\n        find_max(vec![ans.clone(), String::from(\"\
    aa\")])\n    }", "    words\n        .iter()\n        .max_by_key(|word| word.chars().count())\n\
    \        .cloned()\n        .expect(\"Word cannot be empty string\")", "    let\
    \ mut num_unique = String::new();\n    let mut first_char = String::new();\n \
    \   for word in words {\n        let mut unique = String::new();\n        for\
    \ c in word.chars() {\n            if unique.contains(&c) {\n                unique.push(c.to_string());\n\
    \            } else {\n                unique.push(c.to_string());\n         \
    \       if num_unique.len() == 0 {\n                    first_char = c.to_string();\n\
    \                }\n                unique = unique.clone();\n            }\n\
    \        }\n        if unique.len() == 0 {\n            first_char = String::new();\n\
    \        }\n        num_unique = unique.clone();\n    }\n    unique_string(first_char,\
    \ num_unique)", "    // TODO: implement the function\n    String::from(\"\")",
  "    let mut unique_characters: Vec<usize> = words.iter().map(|word| word.chars().count()).collect();\n\
    \    unique_characters.sort_unstable();\n\n    let mut max_word_length: usize\
    \ = 0;\n    let mut max_word: String = \"\";\n\n    let mut current_length: usize\
    \ = 0;\n    for i in 0..unique_characters.len() {\n        if i > 0 {\n      \
    \      if unique_characters[i - 1] == unique_characters[i] {\n               \
    \ continue;\n            }\n        }\n\n        if unique_characters[i - 1] >\
    \ unique_characters[i] {\n            unique_characters[i - 1] -= 1;\n       \
    \ }\n\n        current_length += 1;\n        if current_length >= max_word_length\
    \ {\n            max_word_length = current_length;\n            max_word = words.iter().filter(|word|\
    \ word.chars().count() == unique_characters[i - 1]).next().unwrap();\n       \
    \ }\n    }\n\n    max_word", "    if words.is_empty() {\n        return String::new();\n\
    \    }\n\n    let mut counters = vec![String::new(); words.len()];\n    for word\
    \ in words {\n        let mut counter = 0;\n        for c in word.chars() {\n\
    \            counter += 1;\n            counters[counters.len() - 1].push(c);\n\
    \        }\n    }\n\n    let mut best_count = counters[0].len();\n    let mut\
    \ best_words = Vec::with_capacity(words.len());\n    for &counter in counters\
    \ {\n        if counter.len() > best_count {\n            best_count = counter.len();\n\
    \            best_words = vec![word.clone() for word in words];\n        }\n \
    \   }\n\n    String::from(find_max(&best_words))", "    let mut count = vec![String::from(\"\
    a\")];\n    let mut best = String::from(\"a\");\n    for word in words {\n   \
    \     let mut new_count = count.clone();\n        new_count.push(String::from(\"\
    a\"));\n        for c in word.chars().filter(|c| *c != \"a\") {\n            if\
    \ new_count.iter().any(|c| *c != c) {\n                new_count.push(String::from(*c));\n\
    \            } else {\n                new_count.pop();\n            }\n     \
    \   }\n        if new_count.len() > count {\n            count = new_count;\n\
    \            best = word;\n        }\n    }\n    best", "    // TODO: optimize\n\
    \    let mut counter = HashMap::new();\n    for word in words {\n        let count\
    \ = counter.get(word).unwrap();\n        *count += 1;\n        counter.insert(word,\
    \ *count);\n    }\n    let mut max = 0;\n    let mut word = String::new();\n \
    \   for (_, count) in counter.iter() {\n        if *count > max {\n          \
    \  max = *count;\n            word = *count.to_string();\n        }\n    }\n \
    \   return word", "    let mut char_counts = vec![0; CHARS.len()];\n    let mut\
    \ unique_chars = char_counts.clone();\n    let mut current_chars: HashSet<Char>\
    \ = HashSet::new();\n    for word in words {\n        let mut cur_chars = HashSet::new();\n\
    \        for c in word.chars() {\n            if !cur_chars.contains(&c) {\n \
    \               cur_chars.insert(c);\n                unique_chars[c] += 1;\n\
    \                char_count.get_mut(&c).unwrap().0 += 1;\n            }\n    \
    \    }\n        current_chars = cur_chars;\n    }\n    char_counts.sort_unstable_by(|a,\
    \ b| a.0 < b.0);\n    char_counts\n        .iter()\n        .enumerate()\n   \
    \     .max_by(|(_, a), (_, b)| a < b)\n        .1\n        .clone()\n        .unwrap()",
  "    words\n        .iter()\n        .cloned()\n        .group_by(|w| w.chars().count())\n\
    \        .max()\n        .unwrap()\n        .into()", "    let mut char_occurrences\
    \ = HashMap::new();\n\n    for word in words {\n        for character in word.chars()\
    \ {\n            char_occurrences.entry(character).or_insert(0) += 1;\n      \
    \  }\n    }\n\n    let mut max_characters = vec![String::new()];\n    let mut\
    \ max_count = 1;\n    let mut max_word = String::new();\n\n    for character in\
    \ char_occurrences.keys() {\n        if char_occurrences[character] > max_count\
    \ {\n            max_characters = character;\n            max_count = 1;\n   \
    \     }\n        else if char_occurrences[character] == max_count {\n        \
    \    max_count += 1;\n        }\n    }\n\n    max_characters.extend_from_slice(&[max_count].iter().cloned());\n\
    \    max_characters.extend_from_slice(&[max_count].iter().cloned());\n\n    let\
    \ mut new_words = Vec::new();\n    new_words.push(words[0]);\n\n    for i in 1..words.len()\
    \ {\n        if words[i].chars().any(|c| c != max_characters[0]) {\n         \
    \   new_words.push(words[i]);\n        }\n    }\n\n    new_words[0]", "    //\
    \ Find the one with maximum number of unique characters\n    let mut max_char_count\
    \ = words[0].chars().count();\n    let mut max_word = words.iter().skip(1).next();\n\
    \    for word in words {\n        if word.chars().count() > max_char_count {\n\
    \            max_char_count = word.chars().count();\n            max_word = word;\n\
    \        }\n    }\n    max_char_count", "    let mut max_num_unique_chars = String::new();\n\
    \    let mut first_char = true;\n    for word in words {\n        chars(&word).num_unique_chars()\n\
    \            .max(|a, b| a.cmp(&b))\n            .if_in(|&n| {\n             \
    \   *max_num_unique_chars = *max_num_unique_chars.checked_add(*n).unwrap();\n\
    \                first_char = false;\n            })\n            .unwrap();\n\
    \    }\n    match &*max_num_unique_chars {\n        0 => String::new(),\n    \
    \    n => words[words.index(&max_num_unique_chars.to_string()).unwrap()],\n  \
    \  }", "    let mut max_count = std::collections::HashSet::new();\n    let mut\
    \ max_word = String::new();\n    for word in words {\n        let mut count =\
    \ std::collections::HashSet::new();\n        for c in word.chars() {\n       \
    \     count.insert(c);\n        }\n        if count.len() > max_count.len() {\n\
    \            max_count = count;\n            max_word = word;\n        }\n   \
    \ }\n    max_word", "    let mut unique_chars = Vec::with_capacity(words.len());\n\
    \    words.iter().for_each(|word| unique_chars.extend(word.chars()));\n    let\
    \ unique_char_count = unique_chars.count();\n    if unique_char_count == 0 {\n\
    \        String::from(\".\")\n    } else {\n        let mut max_char_count = unique_char_count;\n\
    \        let mut best_word = String::from(\".\");\n        for word in words {\n\
    \            if unique_char_count > max_char_count {\n                max_char_count\
    \ = unique_char_count;\n                best_word = word;\n            }\n   \
    \         for char in word.chars() {\n                if !unique_chars.contains(&char)\
    \ {\n                    unique_chars.push(char);\n                    unique_char_count\
    \ = unique_chars.count();\n                }\n            }\n        }\n     \
    \   best_word\n    }", "    let mut counts = words.map(|word| word.chars().count()).collect::<Vec<usize>>();\n\
    \    counts.sort_unstable_by(|a, b| a.cmp(b));\n\n    if counts.iter().any(|x|\
    \ x > 1) {\n        words[counts.iter().position(|x| x > 1).unwrap_or(0)]\n  \
    \  } else {\n        words.iter().next().unwrap()\n    }", "    let mut unique_chars:\
    \ usize = 0;\n    let mut words_with_max_unique_chars = words;\n    for w in words_with_max_unique_chars.iter()\
    \ {\n        for c in w.chars() {\n            unique_chars += 1;\n        }\n\
    \        if unique_chars > words_with_max_unique_chars.len() {\n            words_with_max_unique_chars\
    \ = words_with_max_unique_chars.clone();\n        }\n    }\n    words_with_max_unique_chars.iter().next().unwrap()",
  "    let mut counter = HashMap::new();\n    for word in words.iter() {\n       \
    \ counter.insert(word.length(), 1);\n    }\n    counter // collect counts for\
    \ each word\n        .iter()\n        .max_by(|a, b| b.1.cmp(&a.1))\n        .unwrap()\n\
    \        .0", "    if words.is_empty() {\n        return String::new();\n    }\n\
    \    let mut counts = words[0].chars().unique().count();\n    for word in &words\
    \ {\n        let counts = word.chars().unique().count();\n        if counts >\
    \ counts.clone() {\n            return word;\n        }\n    }\n    return String::new();",
  "    let mut min_count = std::i32::MAX;\n    let mut min_word = String::new();\n\
    \    for (i, word) in words.iter().enumerate() {\n        let mut char_count =\
    \ std::i32::MAX;\n        for (c, _) in word.chars().iter() {\n            char_count\
    \ += 1;\n        }\n        if char_count < min_count {\n            min_count\
    \ = char_count;\n            min_word = word;\n        }\n    }\n    min_word",
  "    let mut chars_count: usize = 0;\n    let mut max_chars: String = String::new();\n\
    \n    for word in words {\n        for c in word.chars() {\n            if chars_count\
    \ < c.chars().len() {\n                chars_count = c.chars().len();\n      \
    \          max_chars = word;\n            }\n        }\n    }\n\n    max_chars",
  '    words[0].chars().count().great_max().unwrap_or(words[0].chars().count())',
  "    let mut counter = Counter::new();\n    for word in words {\n        let mut\
    \ counter = counter.clone();\n        for c in word.chars() {\n            *counter\
    \ += 1;\n        }\n        if *counter > word.get_unique_count() {\n        \
    \    return word;\n        }\n    }\n    String::from(\"\")", "    let mut char_counter\
    \ = HashMap::new();\n    let mut unique_counter = HashSet::new();\n\n    for w\
    \ in words {\n        for c in w.chars() {\n            if char_counter.contains_key(&c)\
    \ {\n                char_counter.entry(c).or_insert(0)\n                    .cloned()\
    \ += 1;\n            } else {\n                char_counter.insert(c, 1);\n  \
    \          }\n        }\n\n        for c in w.chars() {\n            if unique_counter.contains(&c)\
    \ {\n                continue;\n            }\n\n            if char_counter[c]\
    \ > unique_counter.len() {\n                unique_counter.insert(c);\n      \
    \      }\n        }\n    }\n\n    if unique_counter.len() > char_counter.len()\
    \ {\n        words[unique_counter.iter().find().unwrap()]\n    } else {\n    \
    \    String::from(\"???\")\n    }", "    // Use set to count the number of unique\
    \ characters in words\n    let mut char_counts = HashMap::<String, usize>::new();\n\
    \    for word in words {\n        for char in word.chars() {\n            char_counts.entry(char).or_default()\
    \ += 1;\n        }\n    }\n    // Get the maximum char count and return the word\
    \ with maximum number\n    // of unique characters. If multiple strings have maximum\
    \ number of unique\n    // characters, return the one which comes first in lexicographical\
    \ order.\n    char_counts.iter().max_by_key(|(_, count)| *count).unwrap().0",
  "    let mut max_chars = words[0].chars().count();\n    let mut max_strings = Vec::new();\n\
    \n    for (i, word) in words.iter().enumerate() {\n        let current_chars =\
    \ word.chars().count();\n        if current_chars > max_chars {\n            max_chars\
    \ = current_chars;\n            max_strings = i;\n        }\n    }\n\n    words[max_strings]",
  "    let mut counters = HashMap::new();\n    for word in words {\n        for char\
    \ in word.chars() {\n            counters.entry(char).or_insert(0) += 1;\n   \
    \     }\n    }\n    \n    let mut max = String::new();\n    let mut max_counter\
    \ = counters.iter().cloned().max_by_key(|x| x.1).unwrap();\n    \n    for char\
    \ in chars! {\n        if counters[char] > max_counter {\n            max = char.to_string();\n\
    \            max_counter = counters[char];\n        }\n    }\n    \n    max",
  "    use std::cmp::Ordering;\n    let mut counters = Vec::new();\n    for word in\
    \ words {\n        counters.push(0);\n        for c in word.chars() {\n      \
    \      counters[*c] += 1;\n        }\n    }\n    \n    let mut max_counter = counters.iter().max().unwrap();\n\
    \    let mut max_word = String::new();\n    for c in counters {\n        if *c\
    \ >= *max_counter {\n            max_counter = *c;\n            max_word = word;\n\
    \        }\n    }\n    max_word", '    words[..].iter().cloned().group_by_ref().max_by(|a,
    b| a.chars().filter(|c| c.is_alphanumeric()).count() as u32).unwrap_or("")', " \
    \   let mut max: usize = 0;\n    let mut index = 0;\n\n    while index < words.len()\
    \ {\n        let word: String = words[index];\n        let mut unique_chars =\
    \ word\n            .chars()\n            .filter(|c| !c.is_alphanumeric())\n\
    \            .count();\n\n        if unique_chars > max {\n            max = unique_chars;\n\
    \            index = word.chars().count();\n        }\n\n        index += 1;\n\
    \    }\n\n    words[index]", "    let mut unique_chars = HashSet::new();\n   \
    \ for word in words {\n        word.chars().for_each(|c| *unique_chars.insert(c));\n\
    \    }\n    let mut current_max = String::new();\n    for word in words {\n  \
    \      let count = unique_chars.len() as u64;\n        if count > current_max.len()\
    \ {\n            current_max = word;\n        }\n    }\n    current_max", "  \
    \  let mut word_count = HashMap::new();\n    for word in words {\n        let\
    \ mut count = 0;\n        for char in word.chars() {\n            count += word_count.get(&char).unwrap();\n\
    \        }\n        *word_count.entry(char).or_insert(count).clone() += 1;\n \
    \   }\n    let mut max = String::from(\"~\");\n    let mut i = 1;\n    while word_count.contains_key(&mut\
    \ i) {\n        *max = *max..i;\n        i += 1;\n    }\n    max", "    let mut\
    \ seen = HashMap::<i32, i32>::new();\n    let mut max_key = std::cmp::Ordering::Equal;\n\
    \    for word in words {\n        for c in word.chars() {\n            let count\
    \ = seen.entry(c).or_insert(0);\n            seen.entry(c).value = count + 1;\n\
    \            if count > max_key {\n                max_key = count;\n        \
    \    }\n        }\n    }\n    if max_key != std::cmp::Ordering::Equal {\n    \
    \    words.iter().find_key(|w| w.chars().all(|c| !seen.contains_key(c)));\n  \
    \  } else {\n        String::new()\n    }", "    let mut unique_chars = HashSet::new();\n\
    \    for word in words {\n        for c in word.chars() {\n            unique_chars.insert(c.to_owned());\n\
    \        }\n    }\n    let mut largest = String::new();\n    for w in words.iter()\
    \ {\n        if unique_chars.len() > largest.chars().count() {\n            largest\
    \ = w;\n        }\n    }\n    largest", "    let mut chars_count: u32 = 0;\n \
    \   let mut max_word: String = \"\";\n    for word in words {\n        let count\
    \ = word.chars().count();\n        chars_count += count;\n        if chars_count\
    \ > chars_count.max() {\n            max_word = word;\n        }\n    }\n    max_word",
  "    words.iter().copied().filter(|word| {\n        word.nth(0).chars().fold(true,\
    \ |_, c| !c).unwrap_or(false)\n    }).max().unwrap()", "    if words.is_empty()\
    \ {\n        panic!(\"Cannot find max: vector is empty\");\n    }\n    let mut\
    \ max = String::new();\n    let mut max_num = std::cmp::Ordering::Greater;\n \
    \   for w in words {\n        if w.chars().filter(|c| c != ' ').count() > max_num\
    \ {\n            max_num = w.chars().filter(|c| c != ' ').count();\n         \
    \   max = w;\n        }\n    }\n    max.to_string()", '    words.iter().cloned().filter(|word|
    word.chars().unique().count() > 1).max().unwrap()', "    match words {\n     \
    \   vec![] => String::new(),\n        vec![word] => word,\n        vec![word1,\
    \ word2] => {\n            let mut s = String::new();\n            let mut cnt\
    \ = HashMap::new();\n            for w in words.iter() {\n                let\
    \ len = w.chars().filter(|c| !c == '#').count();\n                s.push_str(w);\n\
    \                cnt.insert(w, len);\n            }\n\n            if cnt.values().iter().max().is_some()\
    \ {\n                if cnt.values().iter().any(|v| v == cnt.values().iter().max().unwrap())\
    \ {\n                    s\n                } else {\n                    cnt.iter().find(|(k,\
    \ v)| v == cnt.values().iter().max().unwrap()).unwrap()\n                }\n \
    \           } else {\n                String::new()\n            }\n        }\n\
    \    }", "    let mut max = 0;\n    let mut res = String::from(\"zzz\");\n\n \
    \   for word in words {\n        let len = word.chars().count();\n        if len\
    \ > max {\n            max = len;\n            res = word;\n        }\n    }\n\
    \n    res", "    let mut char_counters = HashMap::<String, usize>::new();\n  \
    \  words.iter().for_each(|word| {\n        for char in word.chars() {\n      \
    \      if let Some(count) = char_counters.get(&char) {\n                char_counters.insert(char,\
    \ count + 1);\n            } else {\n                char_counters.insert(char,\
    \ 1);\n            }\n        }\n    });\n\n    let mut max_counter = 0;\n   \
    \ let mut max_word: String = String::from(\"a\");\n    for (char, count) in char_counters\
    \ {\n        if count > max_counter {\n            max_counter = count;\n    \
    \        max_word = char;\n        }\n    }\n\n    max_word", "    words\n   \
    \     .into_iter()\n        .filter_map(|w| w.chars().group_by(|c| *c).rfold(0,\
    \ |acc, &(_, count)| {\n            if acc > count {\n                (acc, count)\n\
    \            } else {\n                (count, acc)\n            }\n        }))\n\
    \        .max_by(|(w, _)| w.len())\n        .unwrap()", "    words\n        .iter()\n\
    \        .cloned()\n        .flat_map(|w| w.chars().map(|c| (c, 1)).collect::<Vec<_>>())\n\
    \        .max_by(|a, b| b.1.cmp(&a.1))\n        .map(|(_, v)| words.iter().find(|w|\
    \ w.chars().any(|c| c.eq(v))))\n        .map(|v| v.unwrap())\n        .unwrap_or_else(||\
    \ String::new())", "    let mut best_word = String::from(\"0\");\n    let mut\
    \ best_counter = 1;\n    let mut max_counter = 1;\n    for word in words {\n \
    \       match best_counter {\n            1 => {\n                if word.chars().count()\
    \ > best_counter.chars().count() {\n                    best_counter = word.chars().count();\n\
    \                    best_word = word;\n                }\n            },\n  \
    \          2 => if word.chars().count() > best_counter.chars().count() {\n   \
    \             best_counter = word.chars().count();\n                best_word\
    \ = word;\n            },\n            _ => {}\n        }\n    }\n    best_word",
  "    let mut unique_counts = Vec::new();\n    for word in words {\n        unique_counts.push(word.chars().unique_count());\n\
    \    }\n    unique_counts.iter().max_by_key(|count| count).unwrap()", "    words.iter()\n\
    \        .map(|word| {\n            word.chars()\n                .distinct()\n\
    \                .count();\n        })\n        .max()\n        .unwrap_or(1)",
  "    let mut words_per_character = HashMap::new();\n    for word in words.iter()\
    \ {\n        words_per_character.entry(word).or_insert(0);\n        words_per_character\n\
    \            .entry(&word[0...])\n            .or_insert(0)\n            .value\
    \ += 1;\n    }\n    let mut best_word = String::new();\n    let mut best_score\
    \ = -1;\n    for (char, score) in words_per_character.iter_mut().rposition(|(_,\
    \ count)| count > best_score) {\n        if best_score < 0 || score > best_score\
    \ {\n            best_score = score;\n            best_word = char;\n        }\n\
    \    }\n    best_word", "    let mut result = String::new();\n    let mut map\
    \ = HashMap::new();\n\n    words.sort_unstable_by_key(|word| word.chars().distinct().count());\n\
    \n    for word in words {\n        let mut count = 0;\n        for ch in word.chars().distinct().collect::<Vec<_>>()\
    \ {\n            if !map.contains_key(&ch) {\n                map.insert(ch, 1);\n\
    \                count += 1;\n            }\n        }\n        if count > result.len()\
    \ {\n            result = word;\n        }\n    }\n\n    result", "    let mut\
    \ unique_chars = String::new();\n    for word in words {\n        unique_chars.clear();\n\
    \        for c in word.chars() {\n            if !unique_chars.contains(&c) {\n\
    \                unique_chars.push_str(&c.to_string());\n            }\n     \
    \   }\n        if unique_chars.len() > unique_chars.iter().rev().next().unwrap().len()\
    \ {\n            return word;\n        }\n    }\n    words[0]", "    let mut max_count\
    \ = 1;\n    let mut max_word = String::new();\n\n    for w in words.iter() {\n\
    \        let c: usize = w.chars().count();\n        if max_count < c {\n     \
    \       max_count = c;\n            max_word = w;\n        }\n    }\n\n    if\
    \ max_count == 1 {\n        return max_word;\n    }\n\n    find_max(vec![max_word])",
  "    if words.is_empty() {\n        return String::new();\n    }\n\n    // Step\
    \ 1: calculate the number of unique characters in each string\n    let mut unique_chars:\
    \ Vec<usize> = words.iter().map(|w| w.chars().count()).collect();\n\n    // Step\
    \ 2: return the word that comes first in lexicographical order\n    unique_chars.sort_unstable().nth(1).cloned()",
  "    let mut chars_count = words.iter().map(|w| w.chars().count()).collect::<Vec<usize>>();\n\
    \    chars_count.sort_unstable_by_key(|i| i);\n    words[chars_count.iter().find(|&c|\
    \ c == chars_count.iter().count()).unwrap()]", "    let mut unique_count: usize\
    \ = 0;\n    let mut unique_words: Vec<String> = vec![];\n    for (word, count)\
    \ in words {\n        if count > unique_count {\n            unique_count = count;\n\
    \            unique_words = vec![word];\n        } else {\n            unique_words.push(word);\n\
    \        }\n    }\n    if unique_words.len() == 1 {\n        unique_words.sort_by(|a,\
    \ b| a.len() < b.len());\n        return unique_words.first();\n    }\n    let\
    \ mut max_count: usize = 0;\n    let mut max_word: String = String::from(\"\"\
    );\n    for (word, count) in unique_words.iter().cloned() {\n        if count\
    \ > max_count {\n            max_count = count;\n            max_word = word;\n\
    \        }\n    }\n    max_word.push_str(\" of \");\n    max_word.push_str(unique_words);\n\
    \    max_word", "    let mut map = HashMap::new();\n    for word in words {\n\
    \        if let Some(count) = map.get(&word) {\n            if *count >= 2 {\n\
    \                return word;\n            }\n        } else {\n            *map.insert(word,\
    \ 1) = Some(1);\n        }\n    }\n    return match &map[&words[0]] {\n      \
    \  None => String::from(\"\"),\n        Some(_) => words[0],\n    }", "    //\
    \ Create a set of all the unique characters\n    let mut char_set = HashSet::new();\n\
    \    for (i, word) in words.iter().enumerate() {\n        for (j, char) in word.chars().enumerate()\
    \ {\n            char_set\n                .insert(char)\n                .expect(\"\
    Inserting into a set that doesn't work\");\n        }\n    }\n    // Get the characters\
    \ with maximum frequency\n    let mut max_chars: Vec<String> = Vec::new();\n \
    \   let mut max_len: usize = 0;\n    for (i, word) in words.iter().enumerate()\
    \ {\n        if char_set.len() >= max_len {\n            max_len = char_set.len();\n\
    \        }\n        max_chars.push(word);\n    }\n    if max_len == 0 {\n    \
    \    String::from(\"No words with maximum number of unique characters found\"\
    )\n    } else {\n        // If multiple strings have maximum number of unique\
    \ characters,\n        // return the one which comes first in lexicographical\
    \ order\n        let mut best_order: Vec<String> = Vec::new();\n        for (i,\
    \ word) in max_chars.iter().enumerate() {\n            let mut order: usize =\
    \ 0;\n            word\n                .chars()\n                .enumerate()\n\
    \                .sort_by(|(a, b), (_, b)| order.cmp(&a));\n            let mut\
    \ cur_word: Vec<String> = Vec::new();\n            for (j, char) in word.chars().enumerate()\
    \ {\n                if j == 0 {\n                    cur_word.push(char);\n \
    \               }\n                if j == 1 {\n                    cur_word.push(String::from(\"\
    _\"));\n                }\n            }\n            for (j, char) in cur_word.iter().enumerate()\
    \ {\n                if char == char_set[order] {\n                    order +=\
    \ 1;\n                }\n            }\n            best_order.push(word.clone());\n\
    \        }\n        String::from(best_order[0])\n    }", "    let mut words =\
    \ words.clone();\n    let mut max_cnt = 0;\n\n    while let Some(word) = words.iter().max_by_key(|&word|\
    \ word.chars().count()) {\n        if word.chars().count() > max_cnt {\n     \
    \       max_cnt = word.chars().count();\n        }\n        words = words.remove(word);\n\
    \    }\n    words[0]", "    let mut counts = HashMap::new();\n    for word in\
    \ words.iter() {\n        let mut num_chars = word.chars().count();\n        if\
    \ counts.contains_key(&num_chars) {\n            counts.insert(num_chars, 1);\n\
    \        } else {\n            counts.insert(num_chars, 0);\n        }\n    }\n\
    \n    counts.iter().max_by_key(|(_, count)| count).unwrap()", "    let mut m =\
    \ std::collections::HashSet::new();\n    let mut max_word = String::new();\n \
    \   for word in words {\n        for c in word.chars() {\n            if !m.contains_key(&c)\
    \ {\n                m.insert(c);\n            } else {\n                if m.get(&c)\
    \ < m.get(&max_word) {\n                    max_word = word;\n               \
    \ }\n            }\n        }\n    }\n    max_word", "    let mut sorted_count\
    \ = words.len();\n    let mut sorted_word = String::from(\"zzz\");\n    for word\
    \ in words {\n        let mut count = word.chars().filter(|c| *c != 'z').count();\n\
    \        if count > sorted_count {\n            sorted_count = count;\n      \
    \      sorted_word = word;\n        }\n    }\n    sorted_word", "    let mut max\
    \ = 0;\n    let mut result = String::new();\n    let mut current_chars = Vec::new();\n\
    \    words.iter().for_each(|word| {\n        for c in word.chars().filter(|c|\
    \ !c.is_whitespace()) {\n            if c.chars().count() > max {\n          \
    \      max = c.chars().count();\n                result = word;\n            \
    \    current_chars = c.to_vec();\n            }\n        }\n    });\n    if max\
    \ > 0 {\n        result = result.unwrap().replace(current_chars.clone(), \"\"\
    ).to_owned();\n    }\n    result", "    let mut counters = vec![String::from(\"\
    Z\"), String::from(\"A\"), String::from(\"Z\")];\n    for word in words {\n  \
    \      for character in word.chars() {\n            if counters[character] ==\
    \ 0 {\n                counters[character] = 1;\n            } else {\n      \
    \          counters[character] += 1;\n            }\n        }\n    }\n\n    let\
    \ mut max_counters = String::from(\"Z\");\n    let mut max_word = String::from(\"\
    Z\");\n    for character in counters.iter().cloned() {\n        if counters[character]\
    \ > counters[max_counters] {\n            max_counters = character;\n        \
    \    max_word = word;\n        }\n    }\n\n    max_word", "    let mut unique_counts\
    \ = HashMap::new();\n    let mut max_count = 0;\n    let mut best_word = String::from(\"\
    \");\n    for w in words {\n        if unique_counts.contains_key(&w) {\n    \
    \        unique_counts.entry(w).and_modify(|count| {\n                count +=\
    \ 1;\n            }).or_insert(0);\n        } else {\n            unique_counts.entry(w).and_modify(|count|\
    \ {\n                count += 1;\n            }).or_insert(1);\n        }\n  \
    \      if count > max_count {\n            max_count = count;\n            best_word\
    \ = w;\n        }\n    }\n    if unique_counts.len() == 0 {\n        return String::from(\"\
    \");\n    }\n    if max_count < words.len() {\n        return best_word;\n   \
    \ }\n    let mut unique_char = String::from(\"\");\n    for w in words {\n   \
    \     if unique_counts.contains_key(&w) {\n            if let Some(m) = unique_counts[w]\
    \ {\n                if m > max_count {\n                    max_count = m;\n\
    \                    unique_char = w;\n                }\n            }\n    \
    \    }\n    }\n    unique_char", "    let mut counter = HashMap::new();\n\n  \
    \  for word in words {\n        for c in word.chars() {\n            counter.insert(c,\
    \ counter.entry(c).or_insert(0));\n        }\n    }\n    let mut max_key = String::new();\n\
    \    let mut max_value = String::new();\n\n    for (_, value) in counter.iter()\
    \ {\n        if value > max_value.len() {\n            max_value = value;\n  \
    \          max_key = String::from(*max_key);\n        }\n    }\n\n    if max_value.is_empty()\
    \ {\n        max_value = \"0\".to_string();\n    }\n\n    max_key", "    let mut\
    \ len = words[0].len();\n    let mut max_count = std::i32::MAX;\n    let mut max_word\
    \ = None;\n    for &w in words {\n        let c = w.chars().filter(|c| c < ' ').count();\n\
    \        len = c.max(len);\n        if max_count == std::i32::MAX {\n        \
    \    max_word = w;\n        }\n        if c == max_count {\n            max_word\
    \ = w;\n        }\n        if c > max_count {\n            max_count = c;\n  \
    \      }\n    }\n    max_word", "    let mut counter = vec![String::new(); words.len()];\n\
    \n    for word in words {\n        let mut current = String::new();\n        for\
    \ c in word.chars() {\n            current += c;\n            if current.len()\
    \ > counter[counter.len() - 1].len() {\n                counter[counter.len()\
    \ - 1] = current;\n            }\n        }\n    }\n\n    let mut current = String::new();\n\
    \    let mut max = String::new();\n\n    for i in 0..counter.len() {\n       \
    \ if counter[i].len() > current.len() {\n            current = counter[i];\n \
    \           max = words[i as usize];\n        }\n    }\n    max", "    if words.is_empty()\
    \ {\n        String::new()\n    } else {\n        let mut words: Vec<_> = words.into_iter().collect();\n\
    \        words.sort_by(|a, b| a.chars().count() as u32.cmp(&b.chars().count()).unwrap());\n\
    \        let mut max = 0;\n        let mut index = words.iter().position(|w| w.chars().count()\
    \ > max);\n        if let Some(_) = index {\n            max = 0;\n          \
    \  index = words.iter().position(|w| w.chars().count() > max);\n        }\n  \
    \      let mut max = max;\n        let mut result = words[index];\n        let\
    \ mut word = 0;\n        loop {\n            if max < w.chars().count() {\n  \
    \              max = w.chars().count();\n                result = w;\n       \
    \         word += 1;\n            } else if w < result.chars().count() {\n   \
    \             max -= w.chars().count();\n                result = w;\n       \
    \         word += 1;\n            } else {\n                break;\n         \
    \   }\n        }\n        result.to_string()\n    }", "    // We use a HashMap\
    \ (map), keyed by character positions, to keep track of the\n    // number of\
    \ unique characters.\n    let mut characters = HashMap::new();\n    for word in\
    \ words {\n        for ch in word.chars().chain(word.chars().skip(1)).filter(|c|\
    \ !characters.contains_key(&c)) {\n            characters.insert(ch, 1);\n   \
    \     }\n    }\n\n    // Sort descending by number of characters. Since we sort\
    \ in descending order,\n    // the first word is the one with the maximum number\
    \ of unique characters.\n    characters.into_iter().sort_by(|a, b| b.cmp(&a)).last()",
  "    let mut max = 0;\n    let mut cur = 0;\n    for word in words {\n        let\
    \ mut count = 0;\n        for c in word.chars() {\n            if !cur.contains(&c)\
    \ {\n                cur += 1;\n                count += 1;\n            }\n \
    \       }\n        if count > max {\n            max = count;\n        }\n   \
    \ }\n    if max > 0 {\n        words.iter().find(|w| w.chars().count() > max).unwrap()\n\
    \    } else {\n        String::new()\n    }"]
stop_tokens:
- "\n}"
