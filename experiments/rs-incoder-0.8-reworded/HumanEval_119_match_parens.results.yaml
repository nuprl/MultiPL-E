language: rs
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![];\n    let mut index = 0;\n    let mut\
    \ good = true;\n    loop {\n        match lst[index] {\n            Some('(')\
    \ => {\n                if index >= lst.len() || !stack.is_empty() {\n       \
    \             break;\n                }\n                stack.push('(');\n  \
    \              index += 1;\n            }\n            Some(')') => {\n      \
    \          if stack.is_empty() {\n                    break;\n               \
    \ }\n                let char = &stack[stack.len() - 1];\n                match\
    \ char {\n                    '(' | ')' => break;\n                    _ => {\n\
    \                        stack.push(char);\n                        index += 1;\n\
    \                    }\n                }\n            }\n            _ => {\n\
    \                stack.push(lst[index]);\n                index += 1;\n      \
    \      }\n        }\n    }\n    if index == lst.len() || stack.is_empty() {\n\
    \        String::from(\"No\")\n    } else {\n        String::from(\"Yes\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: `match` arm body without braces\n  --> /tmp/tmpprcw1het.rs:33:34\n\
    \   |\n33 |                     '(' | ')' => break;\n   |                    \
    \           -- ^^^^^- help: use a comma to end a `match` arm expression: `,`\n\
    \   |                               |  |\n   |                               |\
    \  this statement is not surrounded by a body\n   |                          \
    \     while parsing the `match` arm starting here\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpprcw1het.rs:20:13\n   |\n19 |         match lst[index]\
    \ {\n   |               ---------- this expression has type `String`\n20 |   \
    \          Some('(') => {\n   |             ^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpprcw1het.rs:27:13\n\
    \   |\n19 |         match lst[index] {\n   |               ---------- this expression\
    \ has type `String`\n...\n27 |             Some(')') => {\n   |             ^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpprcw1het.rs:35:36\n   |\n35 |                         stack.push(char);\n\
    \   |                                    ^^^^ expected `char`, found `&char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n35 |                   \
    \      stack.push(*char);\n   |                                    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpprcw1het.rs:41:28\n   |\n41 |              \
    \   stack.push(lst[index]);\n   |                            ^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror: aborting due to 5 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    let mut result = String::from(\"\
    No\");\n\n    for s in lst {\n        if s == String::from(\")\") {\n        \
    \    for c in &stack.pop_front() {\n                let c: char = c?;\n      \
    \          if c == '(' {\n                    stack.push_back(c);\n          \
    \      } else if c == '{' {\n                    stack.push_back(c);\n       \
    \         } else if c == '}' {\n                    if stack.peek_front() == '('\
    \ {\n                        stack.pop_front();\n                    } else {\n\
    \                        stack.push_back(c);\n                    }\n        \
    \        }\n            }\n        } else {\n            stack.push_back(')');\n\
    \        }\n    }\n\n    if stack.len() == 0 {\n        result = \"Yes\".into();\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = match_parens;\n  \
    \  assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpvrhaf2fl.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmpvrhaf2fl.rs:21:32\n\
    \   |\n14 | / fn match_parens(lst: Vec<String>) -> String {\n15 | |     let mut\
    \ stack = VecDeque::new();\n16 | |     let mut result = String::from(\"No\");\n\
    17 | |\n...  |\n21 | |                 let c: char = c?;\n   | |             \
    \                   ^ cannot use the `?` operator in a function that returns `String`\n\
    ...  |\n43 | |     result\n44 | | }\n   | |_- this function should return `Result`\
    \ or `Option` to accept `?`\n   |\n   = help: the trait `FromResidual<_>` is not\
    \ implemented for `String`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n\n    for e in lst {\n       \
    \ if e.contains(\"(\") && !stack.contains(&e.as_str()) {\n            stack.push(e.as_str());\n\
    \        }\n        if e.contains(\")\") && stack.contains(&e.as_str()) {\n  \
    \          stack.pop();\n        }\n    }\n\n    if stack.len() == 0 {\n     \
    \   String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0597]: `e` does not live long enough\n  --> /tmp/tmp65zczig2.rs:19:24\n\
    \   |\n19 |             stack.push(e.as_str());\n   |                        ^^^^^^^^^^\
    \ borrowed value does not live long enough\n...\n24 |     }\n   |     - `e` dropped\
    \ here while still borrowed\n25 | \n26 |     if stack.len() == 0 {\n   |     \
    \   ----------- borrow later used here\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0597`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut first_index = 0;\n    let mut second_index = 1;\n \
    \   let mut match_flag = 0;\n    let mut first_str = String::from(\"\");\n   \
    \ let mut second_str = String::from(\"\");\n\n    // Loop to find first closing\
    \ parenthesis\n    while first_index < lst.len() {\n        // If the first char\
    \ is already set, we found a matching closing parenthesis\n        // for our\
    \ opening parenthesis\n        if match_flag == first_index {\n            break;\n\
    \        }\n        // If it is not set, then set the first char\n        first_str\
    \ = first_str.to_string() + &lst[first_index].to_string();\n        if first_str\
    \ == \"(\" {\n            match_flag = first_index;\n        }\n        // Increment\
    \ our index\n        first_index += 1;\n    }\n\n    // Loop to find second opening\
    \ parenthesis\n    while second_index < lst.len() {\n        // If the second\
    \ char is already set, we found a matching opening parenthesis\n        // for\
    \ our closing parenthesis\n        if match_flag == second_index {\n         \
    \   break;\n        }\n        // If it is not set, then set the second char\n\
    \        second_str = second_str.to_string() + &lst[second_index].to_string();\n\
    \        if second_str == \")\" {\n            match_flag = second_index;\n  \
    \      }\n        // Increment our index\n        second_index += 1;\n    }\n\n\
    \    if first_str == second_str {\n        if first_index > second_index {\n \
    \           String::from(\"Yes\")\n        } else {\n            String::from(\"\
    No\")\n        }\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpm8yot24p.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<&str> = vec![];\n    let mut str: String\
    \ = \"\";\n    for c in lst {\n        if c == '(' || c == '{' {\n           \
    \ stack.push(c);\n        } else if c == '}' || c == ')' {\n            if !stack.is_empty()\
    \ {\n                if c == ')' {\n                    str = String::from(\"\
    Yes\");\n                }\n                if stack.pop() != c {\n          \
    \          str = String::from(\"No\");\n                    break;\n         \
    \       }\n            } else {\n                str = String::from(\"No\");\n\
    \                break;\n            }\n        } else {\n            break;\n\
    \        }\n    }\n    str\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppz_qdf94.rs:16:27\n   |\n\
    16 |     let mut str: String = \"\";\n   |                  ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                  |     \
    \   |\n   |                  |        expected struct `String`, found `&str`\n\
    \   |                  expected due to this\n\nerror[E0277]: can't compare `String`\
    \ with `char`\n  --> /tmp/tmppz_qdf94.rs:18:14\n   |\n18 |         if c == '('\
    \ || c == '{' {\n   |              ^^ no implementation for `String == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppz_qdf94.rs:19:24\n   |\n19 |             stack.push(c);\n\
    \   |                        ^\n   |                        |\n   |          \
    \              expected `&str`, found struct `String`\n   |                  \
    \      help: consider borrowing here: `&c`\n\nerror[E0277]: can't compare `String`\
    \ with `char`\n  --> /tmp/tmppz_qdf94.rs:18:26\n   |\n18 |         if c == '('\
    \ || c == '{' {\n   |                          ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n          "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() > 2 {\n        match_parens_helper(lst, vec![],\
    \ 0, 0, false, false, \"\", \"\", \"\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmpg01f75vt.rs:16:9\n   |\n16 |         match_parens_helper(lst, vec![],\
    \ 0, 0, false, false, \"\", \"\", \"\")\n   |         ^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<bool> = Vec::new();\n    stack.resize(lst.len(),\
    \ false);\n    stack.into_iter().for_each(|&x| match x {\n        x if x == String::from(\"\
    )\") => stack.pop().unwrap(),\n        x if x == String::from(\"(\") => stack.push(true),\n\
    \        _ => (),\n    });\n\n    if stack.is_empty() {\n        return \"Yes\"\
    .to_string();\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmppzu9hzx5.rs:17:33\n   |\n\
    17 |     stack.into_iter().for_each(|&x| match x {\n   |                     \
    \            ^--\n   |                                 ||\n   |              \
    \                   |expected due to this\n   |                              \
    \   expected `bool`, found reference\n   |                                 help:\
    \ did you mean `x`: `&bool`\n   |\n   = note:   expected type `bool`\n       \
    \    found reference `&_`\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmppzu9hzx5.rs:19:40\n   |\n17 |       stack.into_iter().for_each(|&x|\
    \ match x {\n   |  _____________________________________-\n18 | |         x if\
    \ x == String::from(\")\") => stack.pop().unwrap(),\n   | |                  \
    \                      -------------------- this is found to be of type `bool`\n\
    19 | |         x if x == String::from(\"(\") => stack.push(true),\n   | |    \
    \                                    ^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n\
    20 | |         _ => (),\n21 | |     });\n   | |_____- `match` arms have incompatible\
    \ types\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = vec![];\n    let mut is_balanced\
    \ = String::new();\n    let mut str = String::new();\n\n    for s in lst.iter()\
    \ {\n        match s.chars().next() {\n            Some('(') => stack.push(stack.len()),\n\
    \            Some(')') => match stack.pop() {\n                Some(v) => if v\
    \ == 1 {\n                    is_balanced.push_str(s.to_string());\n         \
    \           str\n                } else {\n                    String::from(\"\
    No\")\n                },\n                None => String::from(\"No\"),\n   \
    \         },\n            Some(c) => {\n                stack\n              \
    \      .last_mut()\n                    .unwrap()\n                    .clone()\n\
    \                    .push(c);\n                is_balanced.push_str(&s.to_string());\n\
    \                str\n            }\n            None => String::from(\"No\"),\n\
    \        }\n    }\n    is_balanced\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwr_y4d9i.rs:24:42\n   |\n\
    24 |                     is_balanced.push_str(s.to_string());\n   |          \
    \                                ^^^^^^^^^^^^^\n   |                         \
    \                 |\n   |                                          expected `&str`,\
    \ found struct `String`\n   |                                          help: consider\
    \ borrowing here: `&s.to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwr_y4d9i.rs:25:21\n\
    \   |\n23 |                   Some(v) => if v == 1 {\n   |  ____________________________-\n\
    24 | |                     is_balanced.push_str(s.to_string());\n25 | |      \
    \               str\n   | |                     ^^^ expected `()`, found struct\
    \ `String`\n26 | |                 } else {\n27 | |                     String::from(\"\
    No\")\n28 | |                 },\n   | |_________________- expected this to be\
    \ `()`\n   |\nhelp: you might have meant to return this value\n   |\n25 |    \
    \                 return str;\n   |                     ++++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwr_y4d9i.rs:27:21\n   |\n23 |              \
    \     Some(v) => if v == 1 {\n   |  ____________________________-\n24 | |    \
    \                 is_balanced.push_str(s.to_string());\n25 | |               \
    \      str\n26 | |                 } else {\n27 | |                     String::from(\"\
    No\")\n   | |                     ^^^^^^^^^^^^^^^^^^ expected `()`, found struct\
    \ `String`\n28 | |                 },\n   | |_________________- expected this\
    \ to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n27 |        \
    \             String::from(\"No\");\n   |                                    \
    \   +\nhelp: consider using a semicolon here\n   |\n28 |                 };,\n\
    \   |                  +\nhelp: you might have meant to return this value\n  \
    \ |\n27 |                     return String::from(\"No\");\n   |             \
    \        ++++++                   +\n\nerror[E0599]: no method named `push` found\
    \ for type `usize` in the current scope\n  --> /tmp/tmpwr_y4d9i.rs:36:22\n   |\n\
    36 |                     .push(c);\n   |   "
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Step 1: Create a stack to store parenthesis. We will push\
    \ all opening\n    // parentheses here.\n    let mut parens: Vec<_> = Vec::new();\n\
    \    for s in lst {\n        if s == \"(\" {\n            parens.push(s);\n  \
    \      } else {\n            if parens.len() == 0 {\n                return String::from(\"\
    No\");\n            }\n            let last = parens.pop().unwrap();\n       \
    \     if last == s {\n                continue;\n            }\n            return\
    \ String::from(\"Yes\");\n        }\n    }\n    String::from(\"No\")\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpwej5zuh9.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut res = String::new();\n\
    \    for elem in lst {\n        if elem.is_empty() {\n            res.push_str(&\"\
    \");\n            continue;\n        }\n        if elem.chars().any(|c| c == '(')\
    \ {\n            stack.push(\"(\");\n        }\n        if elem.chars().any(|c|\
    \ c == ')') {\n            let top = stack.pop();\n            if top != elem.chars().last().unwrap()\
    \ {\n                return String::from(\"No\");\n            }\n        }\n\
    \        res.push_str(&elem.to_string());\n    }\n    if res.len() == lst.len()\
    \ {\n        return String::from(\"Yes\");\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgxhsujkk.rs:27:23\n   |\n\
    27 |             if top != elem.chars().last().unwrap() {\n   |              \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<&str>`\n              found type `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        return \"No\";\n    }\n    let\
    \ mut stack = Vec::new();\n    let mut found = false;\n    let mut i = lst.len();\n\
    \    while i != 0 {\n        let mut found = false;\n        for s in lst.iter().rev()\
    \ {\n            if s.as_str().starts_with(\"\") {\n                s.push(')');\n\
    \                s.push(s.pop().unwrap());\n                s.push('(');\n   \
    \             s.push(s.pop().unwrap());\n            }\n            if s.as_str().ends_with(\"\
    \") {\n                s.push(s.pop().unwrap());\n                s.push('(');\n\
    \                s.push(s.pop().unwrap());\n            }\n            if s.as_str()\
    \ == \"\" {\n                s.push(s.pop().unwrap());\n            }\n      \
    \      if stack.is_empty() {\n                stack = s;\n                found\
    \ = true;\n            }\n        }\n        i = i - 1;\n        if found {\n\
    \            return String::from(format!(\"Yes{}\", &stack));\n        }\n   \
    \ }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp66696797.rs:16:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     if\
    \ lst.len() == 0 {\n16 |         return \"No\";\n   |                ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp66696797.rs:39:25\n   |\n18 |     let mut stack = Vec::new();\n\
    \   |                     ---------- expected due to this value\n...\n39 |   \
    \              stack = s;\n   |                         ^ expected struct `Vec`,\
    \ found `&String`\n   |\n   = note: expected struct `Vec<_>`\n           found\
    \ reference `&String`\n\nerror[E0277]: `Vec<_>` doesn't implement `std::fmt::Display`\n\
    \  --> /tmp/tmp66696797.rs:45:50\n   |\n45 |             return String::from(format!(\"\
    Yes{}\", &stack));\n   |                                                  ^^^^^^\
    \ `Vec<_>` cannot be formatted with the default formatter\n   |\n   = help: the\
    \ trait `std::fmt::Display` is not implemented for `Vec<_>`\n   = note: in format\
    \ strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead\n\
    \   = note: this error originates in the macro `$crate::__export::format_args`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // The first element of lst is a pair of (, ),\n    // and\
    \ the second one is a pair.\n    let mut stack = vec![(0, -1)];\n    let mut res\
    \ = String::new();\n    stack.push(0);\n    for str in lst {\n        if str.len()\
    \ == 1 {\n            stack.push((0, 0));\n        }\n        if stack.is_empty()\
    \ {\n            return res;\n        }\n        let (left, right) = stack.pop();\n\
    \        if str[left] == '(' && str[right] == ')' {\n            if left == right\
    \ {\n                let mut start = res.chars();\n                let i = res.char_indices().next().unwrap().1;\n\
    \                if i <= res.len() {\n                    start.insert(i, &str[left]);\n\
    \                }\n                res.extend_from_slice(start.clone());\n  \
    \          } else {\n                stack.push((left, right));\n            }\n\
    \        } else {\n            stack.push((left, right));\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprfnk69_1.rs:19:16\n   |\n\
    19 |     stack.push(0);\n   |                ^ expected tuple, found integer\n\
    \   |\n   = note: expected tuple `({integer}, {integer})`\n               found\
    \ type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfnk69_1.rs:27:13\n\
    \   |\n27 |         let (left, right) = stack.pop();\n   |             ^^^^^^^^^^^^^\
    \   ----------- this expression has type `Option<({integer}, {integer})>`\n  \
    \ |             |\n   |             expected enum `Option`, found tuple\n   |\n\
    \   = note: expected enum `Option<({integer}, {integer})>`\n             found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprfnk69_1.rs:32:25\n\
    \   |\n32 |                 if i <= res.len() {\n   |                        \
    \ ^^^^^^^^^ expected `char`, found `usize`\n\nerror[E0599]: no method named `insert`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmprfnk69_1.rs:33:27\n\
    \   |\n33 |                     start.insert(i, &str[left]);\n   |           \
    \                ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `extend_from_slice` found for struct `String` in the current scope\n \
    \ --> /tmp/tmprfnk69_1.rs:35:21\n   |\n35 |                 res.extend_from_slice(start.clone());\n\
    \   |                     ^^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    use std::ascii::AsciiExt;\n\n    match lst.len() {\n      \
    \  0 => \"No\",\n        _ => match_parens_impl(lst, String::from(\"Yes\"))\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_impl` in this scope\n\
    \  --> /tmp/tmpqzxl3ydq.rs:19:14\n   |\n19 |         _ => match_parens_impl(lst,\
    \ String::from(\"Yes\"))\n   |              ^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nwarning: unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmpqzxl3ydq.rs:15:9\n\
    \   |\n15 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: use of deprecated\
    \ trait `std::ascii::AsciiExt`: use inherent methods instead\n  --> /tmp/tmpqzxl3ydq.rs:15:21\n\
    \   |\n15 |     use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqzxl3ydq.rs:18:14\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n...\n18 |         0 => \"No\",\n   |              ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |              |\n \
    \  |              expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to 2 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![String::from(\"\")];\n    loop {\n   \
    \     if stack.is_empty() || lst.is_empty() {\n            return String::from(\"\
    No\");\n        }\n        let mut cur_str = String::from(\"\");\n        let\
    \ mut cur_depth = 0;\n        let mut prev = false;\n        for ele in lst.iter()\
    \ {\n            if !prev {\n                if ele == \"(\" {\n             \
    \       cur_str += \"(\";\n                    prev = true;\n                \
    \    stack[cur_depth] += \"(\";\n                    cur_depth += 1;\n       \
    \         } else if ele == \")\" {\n                    cur_str += \")\";\n  \
    \                  prev = false;\n                    stack[cur_depth] += \")\"\
    ;\n                    cur_depth -= 1;\n                }\n            }\n   \
    \         prev = false;\n            cur_str += ele;\n        }\n        if cur_str\
    \ == String::from(\"\") {\n            return String::from(\"No\");\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpty9r7xrl.rs:34:21

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = 0;\n    let mut len = lst.len();\n    while len\
    \ > 0 {\n        let mut i = 0;\n        while i < len {\n            if lst[i]\
    \ == '(' {\n                i += 1;\n            } else if lst[i] == ')' {\n \
    \               len -= 1;\n                i += 1;\n            } else {\n   \
    \             i += 1;\n            }\n        }\n        if cur == i {\n     \
    \       return \"Yes\";\n        }\n        cur = i;\n    }\n    \"No\"\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpvwfbdgz8.rs:20:23\n\
    \   |\n20 |             if lst[i] == '(' {\n   |                       ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpvwfbdgz8.rs:22:30\n   |\n22 |          \
    \   } else if lst[i] == ')' {\n   |                              ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvwfbdgz8.rs:30:20\n   |\n30 |             return \"Yes\"\
    ;\n   |                    ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                    |\n   |                    expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvwfbdgz8.rs:34:5\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n...\n\
    34 |     \"No\"\n   |     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![false; lst.len() + 1];\n    stack[0] =\
    \ true;\n    let mut ans = \"No\";\n    for i in lst.iter().rev() {\n        for\
    \ _ in 0..=i {\n            if stack.is_empty() {\n                ans = \"Yes\"\
    ;\n                break;\n            }\n            if !stack[stack.len() -\
    \ 1] {\n                ans = \"No\";\n                break;\n            }\n\
    \            stack.pop();\n        }\n        stack[i] = true;\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgdokbq43.rs:19:22\n   |\n\
    19 |         for _ in 0..=i {\n   |                      ^ expected integer, found\
    \ `&String`\n\nerror[E0277]: the type `[bool]` cannot be indexed by `&String`\n\
    \  --> /tmp/tmpgdokbq43.rs:30:9\n   |\n30 |         stack[i] = true;\n   |   \
    \      ^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n\
    \   = help: the trait `SliceIndex<[bool]>` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `Index<&String>`\
    \ for `Vec<bool>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgdokbq43.rs:32:5\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n...\n\
    32 |     ans\n   |     ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // The answer is Yes if the vector is non-empty and all elements\
    \ are \"Yes\"\n    if lst.len() > 0 && lst.iter().all(|s| s == \"Yes\") {\n  \
    \      \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp83tf292x.rs:25:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0usize;\n    let mut right = lst.len() - 1;\n\
    \    let mut res = String::from(\"No\");\n\n    while left < right {\n       \
    \ if lst[left].is_ascii_letter() {\n            if lst[right].is_ascii_letter()\
    \ {\n                let mid = left + (right - left) / 2;\n                if\
    \ mid+1 < lst.len() {\n                    let left_str = lst[mid+1];\n      \
    \              let right_str = lst[mid];\n                    if left_str.is_ascii_letter()\
    \ && right_str.is_ascii_letter() {\n                        if left_str < right_str\
    \ {\n                            res = \"Yes\".to_string();\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \n        if lst[left].is_ascii_digit() {\n            if lst[right].is_ascii_letter()\
    \ {\n                let mid = left + (right - left) / 2;\n                if\
    \ mid+1 < lst.len() {\n                    let left_str = lst[mid+1];\n      \
    \              let right_str = lst[mid];\n                    if left_str.is_ascii_letter()\
    \ && right_str.is_ascii_digit() {\n                        if left_str < right_str\
    \ {\n                            res = \"Yes\".to_string();\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \n        if lst[left].is_ascii_letter() {\n            if lst[right].is_ascii_digit()\
    \ {\n                let mid = left + (right - left) / 2;\n                if\
    \ mid+1 < lst.len() {\n                    let left_str = lst[mid+1];\n      \
    \              let right_str = lst[mid];\n                    if left_str.is_ascii_digit()\
    \ && right_str.is_ascii_letter() {\n                        if left_str < right_str\
    \ {\n                            res = \"Yes\".to_string();\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \n        if lst[left].is_ascii_digit() {\n            if lst[right].is_ascii_digit()\
    \ {\n                let mid = left + (right - left) / 2;\n                if\
    \ mid+1 < lst.len() {\n                    let left_str = lst[mid+1];\n      \
    \              let right_str = lst[mid];\n                    if left_str.is_ascii_digit()\
    \ && right_str.is_ascii_digit() {\n                        if left_str < right_str\
    \ {\n                            res = \"Yes\".to_string();\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \n        left += 1;\n        right -= 1;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp_68vlt46.rs:20:22\n   |\n20 |         if\
    \ lst[left].is_ascii_letter() {\n   |                      ^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp_68vlt46.rs:21:27\n   |\n21 |             if lst[right].is_ascii_letter()\
    \ {\n   |                           ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_68vlt46.rs:26:33\n\
    \   |\n26 |                     if left_str.is_ascii_letter() && right_str.is_ascii_letter()\
    \ {\n   |                                 ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_68vlt46.rs:26:64\n\
    \   |\n26 |                     if left_str.is_ascii_letter() && right_str.is_ascii_letter()\
    \ {\n   |                                                                ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_digit` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp_68vlt46.rs:35:22\n   |\n35 |         if lst[left].is_ascii_digit()\
    \ {\n   |                      ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp_68vlt46.rs:36:27\n\
    \   |\n36 |             if lst[right].is_ascii_letter() {\n   |              \
    \             ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0599]: no method named `is_ascii_letter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp_68vlt46.rs:41:33\n   |\n\
    41 |            "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = vec![0; lst.len()];\n    let mut\
    \ i = 0; // index of the stack\n    let mut j = 0;\n    let mut good = false;\n\
    \    while j < lst.len() {\n        if lst[j] == ')' {\n            if stack.iter().all(|&x|\
    \ *x != j) {\n                stack.push(j);\n            }\n            i +=\
    \ 1;\n            j = 0;\n        } else {\n            j += 1;\n        }\n \
    \   }\n    if i == 0 {\n        if stack.iter().all(|&x| *x == 0) {\n        \
    \    good = true;\n        }\n    }\n    if !good {\n        String::from(\"No\"\
    )\n    } else {\n        String::from(\"Yes\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp9sy3o1u8.rs:20:19\n\
    \   |\n20 |         if lst[j] == ')' {\n   |                   ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0614]: type `usize`\
    \ cannot be dereferenced\n  --> /tmp/tmp9sy3o1u8.rs:21:38\n   |\n21 |        \
    \     if stack.iter().all(|&x| *x != j) {\n   |                              \
    \        ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmp9sy3o1u8.rs:31:34\n\
    \   |\n31 |         if stack.iter().all(|&x| *x == 0) {\n   |                \
    \                  ^^\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_helper(vec![], lst, vec![])\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmp4cah4uei.rs:15:5\n   |\n15 |     match_parens_helper(vec![], lst,\
    \ vec![])\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() < 2 {\n        return String::from(\"No\");\n\
    \    }\n\n    let mut open_stack = vec![];\n    let mut close_stack = vec![];\n\
    \    for x in lst.into_iter() {\n        if x == \")\" {\n            close_stack.pop();\n\
    \            if close_stack.len() == 0 {\n                return String::from(\"\
    Yes\");\n            }\n        } else {\n            open_stack.push(x);\n  \
    \      }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed for `Vec<T>`\n  --> /tmp/tmpev22dwk1.rs:20:27\n\
    \   |\n20 |     let mut close_stack = vec![];\n   |         ---------------  \
    \ ^^^^^^ cannot infer type for type parameter `T`\n   |         |\n   |      \
    \   consider giving `close_stack` the explicit type `Vec<T>`, where the type parameter\
    \ `T` is specified\n   |\n   = note: this error originates in the macro `vec`\
    \ (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0282`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n\n    stack.push(String::from(\"\
    (\"));\n\n    for ele in lst {\n        if ele.chars().count() == 1 {\n      \
    \      if stack.is_empty() {\n                return String::from(\"No\");\n \
    \           } else {\n                return String::from(\"Yes\");\n        \
    \    }\n        }\n\n        for ele in &mut stack[stack.len() - 1] {\n      \
    \      if ele.chars().count() == 0 {\n                return String::from(\"No\"\
    );\n            }\n        }\n\n        stack.unshift(String::from(ele));\n  \
    \  }\n\n    return String::from(\"No\");\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpsvorv3au.rs:28:20\n\
    \   |\n28 |         for ele in &mut stack[stack.len() - 1] {\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `Iterator` for `&mut String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&mut String`\n\nerror[E0599]: no method named\
    \ `unshift` found for struct `Vec<String>` in the current scope\n  --> /tmp/tmpsvorv3au.rs:34:15\n\
    \   |\n34 |         stack.unshift(String::from(ele));\n   |               ^^^^^^^\
    \ method not found in `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![String::from(\"(\")];\n\n    // First\
    \ we check if all parentheses are balanced then we check if all pairs\n    //\
    \ are matched\n    for s in lst.iter() {\n        if !stack.is_empty() && stack.last().unwrap()\
    \ == s.unwrap() {\n            continue;\n        }\n\n        if !s.chars().all(|&c|\
    \ c == '(' || c == '[' || c == '{') {\n            return String::from(\"No\"\
    );\n        }\n\n        let mut pos = 0;\n\n        // We add new parentheses\
    \ to stack until we find a paren that doesn't match.\n        while pos < s.len()\
    \ {\n            let mut next_open = stack.pop();\n\n            // If next open\
    \ paren is not the same with the next closed parenthesis\n            if next_open\
    \ != s.chars().next_back() {\n                // we found a matching parenthesis\n\
    \                break;\n            }\n\n            stack.push(s.chars().next_back());\n\
    \            pos += 1;\n        }\n\n        if pos == s.len() {\n           \
    \ return String::from(\"Yes\");\n        }\n    }\n\n    // If we didn't find\
    \ any valid pairs, the string is not good\n    String::from(\"No\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmppbf4zrna.rs:20:60\n   |\n20 |         if !stack.is_empty()\
    \ && stack.last().unwrap() == s.unwrap() {\n   |                             \
    \                               ^^^^^^ method not found in `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmppbf4zrna.rs:24:28\n   |\n24 |         if !s.chars().all(|&c|\
    \ c == '(' || c == '[' || c == '{') {\n   |                            ^--\n \
    \  |                            ||\n   |                            |expected\
    \ due to this\n   |                            expected `char`, found reference\n\
    \   |                            help: did you mean `c`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmppbf4zrna.rs:35:29\n   |\n35 |             if next_open\
    \ != s.chars().next_back() {\n   |                             ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `char`\n   |\n   = note: expected enum `Option<String>`\n\
    \              found enum `Option<char>`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmppbf4zrna.rs:40:24\n   |\n40 |             stack.push(s.chars().next_back());\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ enum `Option`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Option<char>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut found = false;\n\n    for str in lst {\n        if\
    \ !found {\n            if str.len() == 1 {\n                found = true;\n \
    \               continue;\n            }\n            for parens in str.chars()\
    \ {\n                if parens == '(' || parens == '{' || parens == '[' { found\
    \ = true; }\n                if parens == ')' || parens == '}' || parens == ']'\
    \ { found = true; }\n            }\n        }\n        if !found {\n         \
    \   return String::from(\"No\");\n        }\n    }\n\n    String::from(\"Yes\"\
    )\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp01xv4way.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 1 {\n        return \"No\";\n    }\n    let\
    \ mut stack = Stack::new();\n    stack.push(String::from(\"(\"));\n    for elem\
    \ in lst {\n        if elem.contains(&stack) {\n            return \"No\";\n \
    \       }\n        stack.push(elem);\n    }\n    stack.push(String::from(\")\"\
    ));\n    if stack.pop() != String::from(\"(\") {\n        return \"No\";\n   \
    \ }\n    if stack.pop() != String::from(\")\") {\n        return \"No\";\n   \
    \ }\n    return \"Yes\";\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp6nauwgib.rs:18:21\n   |\n18 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6nauwgib.rs:16:16\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n15 |     if lst.len() <= 1 {\n16 |        \
    \ return \"No\";\n   |                ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut paren_count = 0usize;\n    for s in lst {\n       \
    \ if s == '(' {\n            paren_count += 1;\n        } else if s == '{' {\n\
    \            paren_count += 2;\n        } else if s == '}' {\n            paren_count\
    \ -= 2;\n        }\n    }\n    if paren_count == 0 {\n        String::from(\"\
    No\")\n    } else {\n        String::from(\"Yes\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp252go_fq.rs:17:14\n\
    \   |\n17 |         if s == '(' {\n   |              ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp252go_fq.rs:19:21\n   |\n19 |         }\
    \ else if s == '{' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp252go_fq.rs:21:21\n   |\n21 |         }\
    \ else if s == '}' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as Parti"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_helper(String::from(\"\"), String::from(\"\"),\
    \ &mut vec![])\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmp70f3_czl.rs:15:5\n   |\n15 |     match_parens_helper(String::from(\"\
    \"), String::from(\"\"), &mut vec![])\n   |     ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![String::from(\")\"), String::from(\"\
    (\")] => \"Yes\",\n        _ => \"No\",\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpjg8kd0i3.rs:16:9\n\
    \   |\n16 |         vec![String::from(\")\"), String::from(\"(\")] => \"Yes\"\
    ,\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjg8kd0i3.rs:16:55\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n15 |\
    \     match lst {\n16 |         vec![String::from(\")\"), String::from(\"(\")]\
    \ => \"Yes\",\n   |                                                       ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                                     |\n   |                                \
    \                       expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::from(\"\");\n    let mut stack = VecDeque::new();\n\
    \    for s in lst {\n        if cur == \"\" {\n            cur = s;\n        }\
    \ else {\n            if s.is_open() && cur.contains(&s[0]) {\n              \
    \  cur = cur + &s[0];\n                stack.pop_back();\n            } else {\n\
    \                if !stack.is_empty() || s.is_close() {\n                    cur\
    \ = cur + &s[0];\n                }\n                stacks.push(s);\n       \
    \     }\n        }\n    }\n\n    // If we didn't concatenate the strings, then\
    \ there is\n    // no way that they could be concatenated\n    if stack.len()\
    \ < 2 {\n        cur.to_string()\n    } else {\n        String::from(\"No\")\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpu9zwr4xz.rs:16:21\n   |\n16 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0425]: cannot find value `stacks` in this scope\n  --> /tmp/tmpu9zwr4xz.rs:28:17\n\
    \   |\n28 |                 stacks.push(s);\n   |                 ^^^^^^ help:\
    \ a local variable with a similar name exists: `stack`\n\nerror[E0599]: no method\
    \ named `is_open` found for struct `String` in the current scope\n  --> /tmp/tmpu9zwr4xz.rs:21:18\n\
    \   |\n21 |             if s.is_open() && cur.contains(&s[0]) {\n   |        \
    \          ^^^^^^^ method not found in `String`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpu9zwr4xz.rs:21:45\n   |\n21\
    \ |             if s.is_open() && cur.contains(&s[0]) {\n   |                \
    \                             ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpu9zwr4xz.rs:22:30\n   |\n22 |                 cur = cur + &s[0];\n\
    \   |                              ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n   "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len(), match_parens_helper(String::from(\"\"), lst,\
    \ vec![])) {\n        (2, res) => res,\n        (3, res) => res,\n        _ =>\
    \ String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmpqhqh3_ba.rs:15:23\n   |\n15 |     match (lst.len(), match_parens_helper(String::from(\"\
    \"), lst, vec![])) {\n   |                       ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 1 {\n        return String::from(\"\");\n \
    \   }\n\n    let mut stack = Vec::new();\n    let mut open_set = HashSet::new();\n\
    \n    for ele in lst {\n        if open_set.contains(&ele) {\n            stack.push(ele);\n\
    \        } else {\n            if stack.len() > 0 {\n                if ele.starts_with(stack.join(','))\
    \ {\n                    open_set.insert(ele);\n                } else {\n   \
    \                 stack.pop();\n                }\n            }\n        }\n\
    \    }\n    if stack.len() == 0 {\n        return String::from(\"Yes\");\n   \
    \ } else {\n        return String::from(\"No\");\n    }\n}\n\nfn main() {\n  \
    \  let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpxasinktn.rs:20:24\n   |\n20 |     let mut open_set = HashSet::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxasinktn.rs:27:47\n   |\n27 |              \
    \   if ele.starts_with(stack.join(',')) {\n   |                              \
    \                 ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n27 |                 if ele.starts_with(stack.join(\"\
    ,\")) {\n   |                                               ~~~\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpxasinktn.rs:27:36\n\
    \     |\n27   |                 if ele.starts_with(stack.join(',')) {\n     |\
    \                        ----------- ^^^^^^^^^^^^^^^ expected an implementor of\
    \ trait `Pattern<'_>`\n     |                        |\n     |               \
    \         required by a bound introduced by this call\n     |\n     = note: the\
    \ trait bound `String: Pattern<'_>` is not satisfied\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `String`\nnote: required\
    \ by a bound in `core::str::<impl str>::starts_with`\nhelp: consider borrowing\
    \ here\n     |\n27   |                 if ele.starts_with(&stack.join(',')) {\n\
    \     |                                    +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 0 {\n        return \"No\".to_string();\n \
    \   }\n    let mut cur = String::from(\"()\");\n    for x in lst.iter() {\n  \
    \      let mut last = 0;\n        for c in x.chars() {\n            if cur ==\
    \ \"()\" {\n                last = last;\n                last = c == ')' ? 1\
    \ : last + 1;\n            } else if cur == \")\" {\n                last = last;\n\
    \                last = c == '(' ? -1 : 0;\n            } else if c == '(' {\n\
    \                last = last - 1;\n            } else if c == ')' {\n        \
    \        last = last + 1;\n            }\n            if cur == String::from(x.chars()[last..])\
    \ {\n                cur = String::from(\"()\");\n            } else {\n     \
    \           cur = String::from(x.chars()[..last]);\n            }\n        }\n\
    \    }\n    if cur == String::from(\"()\") {\n        return \"Yes\".to_string();\n\
    \    } else {\n        return \"No\".to_string();\n    }\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `1`\n\
    \  --> /tmp/tmpakldrxei.rs:24:35\n   |\n24 |                 last = c == ')' ?\
    \ 1 : last + 1;\n   |                                   ^ expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n\nerror: expected type, found `0`\n  --> /tmp/tmpakldrxei.rs:27:40\n\
    \   |\n27 |                 last = c == '(' ? -1 : 0;\n   |                  \
    \                    - ^ expected type\n   |                                 \
    \     |\n   |                                      tried to parse a type due to\
    \ this\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpakldrxei.rs:33:36\n\
    \   |\n33 |             if cur == String::from(x.chars()[last..]) {\n   |    \
    \                                ^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmpakldrxei.rs:36:36\n   |\n36\
    \ |                 cur = String::from(x.chars()[..last]);\n   |             \
    \                       ^^^^^^^^^^^^^^^^^\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        2 => {\n            if let Some(parens)\
    \ = parens(&lst[0]) {\n                parens.is_balanced().unwrap_or(false)\n\
    \            } else {\n                false\n            }\n        }\n     \
    \   _ => true,\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n \
    \   assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `parens` in this scope\n  --> /tmp/tmpn2e5fpyh.rs:17:35\n\
    \   |\n17 |             if let Some(parens) = parens(&lst[0]) {\n   |        \
    \                           ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpn2e5fpyh.rs:20:17\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n...\n20 |                 false\n   |              \
    \   ^^^^^- help: try using a conversion method: `.to_string()`\n   |         \
    \        |\n   |                 expected struct `String`, found `bool`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter()\n        .zip(lst.iter().cloned())\n        .enumerate()\n\
    \        .map(|(i, x)| (i, x).fold(String::new(), |acc, elt| {\n            if\
    \ let Some((i, _)) = acc.split_last_mut() {\n                if i == 0 {\n   \
    \                 *i += '(';\n                } else if i == acc.len() - 1 {\n\
    \                    *i += ')';\n                } else {\n                  \
    \  *i += ',';\n                }\n            }\n            acc + elt\n     \
    \   }))\n        .filter(|s| s.is_ok())\n        .collect::<String>()\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `(usize, (&String, String))` is not an iterator\n  --> /tmp/tmpaodmdhup.rs:18:30\n\
    \   |\n18 |         .map(|(i, x)| (i, x).fold(String::new(), |acc, elt| {\n  \
    \ |                              ^^^^ `(usize, (&String, String))` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(usize,\
    \ (&String, String)): Iterator`\n           which is required by `&mut (usize,\
    \ (&String, String)): Iterator`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 1 {\n        return String::from(\"No\");\n\
    \    }\n    let mut str = String::from(\"No\");\n    let mut stack = vec![String::from(\"\
    (\")];\n    for c in lst {\n        if c.is_empty() {\n            continue;\n\
    \        }\n        if let String::from(\")\") = stack.pop().unwrap() {\n    \
    \        str = String::from(\"Yes\");\n            break;\n        }\n       \
    \ if let String::from(\"(\") = stack.last().unwrap() {\n            stack.push(c);\n\
    \        } else {\n            str = String::from(\"No\");\n            break;\n\
    \        }\n    }\n    return str;\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmp5hrcxrb9.rs:24:16\n   |\n24 |       \
    \  if let String::from(\")\") = stack.pop().unwrap() {\n   |                ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmp5hrcxrb9.rs:28:16\n   |\n28 |         if let String::from(\"(\"\
    ) = stack.last().unwrap() {\n   |                ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_impl(lst, vec![])\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_impl` in this scope\n\
    \  --> /tmp/tmpb7jv4p8g.rs:15:5\n   |\n15 |     match_parens_impl(lst, vec![])\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // dp[i] is true if and only if S[i] is good\n    // dp[i]\
    \ will be true if and only if the i-th parenthesis match S[i]\n    // dp[i] will\
    \ be false otherwise\n    let mut dp = vec![false; lst.len()];\n\n    let mut\
    \ i = 0;\n    let mut s = String::from(\"\");\n    while i < lst.len() {\n   \
    \     let (is_good, i) = (!dp[i], i + 1);\n        let p = lst[i];\n        if\
    \ is_good {\n            if p == '(' {\n                s = s.push_str(\"(\");\n\
    \            } else if p == ')' {\n                s = s.push_str(\")\");\n  \
    \          } else {\n                s = s.push_str(&p);\n            }\n    \
    \    } else {\n            // If the i-th parentheses doesn't match\n        \
    \    if p == '(' {\n                dp[i] = true;\n            }\n           \
    \ if p == ')' {\n                dp[i] = false;\n            }\n            if\
    \ i < (lst.len() - 1) {\n                // If the i-th parentheses matches and\
    \ the following parentheses don't\n                // match\n                if\
    \ p == ')' && lst[i + 1] != ')' {\n                    dp[i] = true;\n       \
    \         }\n            }\n        }\n        i += 1;\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpml47fqcz.rs:26:18\n\
    \   |\n26 |             if p == '(' {\n   |                  ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpml47fqcz.rs:27:21\n   |\n21 |     let mut s = String::from(\"\
    \");\n   |                 ---------------- expected due to this value\n...\n\
    27 |                 s = s.push_str(\"(\");\n   |                     ^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpml47fqcz.rs:27:23\n   |\n27 |         \
    \        s = s.push_str(\"(\");\n   |                     - ^^^^^^^^ this call\
    \ modifies `s` in-place\n   |                     |\n   |                    \
    \ you probably want to use this value after calling the method...\n   = note:\
    \ ...instead of the `()` output of method `push_str`\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpml47fqcz.rs:28:25\n   |\n28 |          \
    \   } else if p == ')' {\n   |                         ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n         "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<bool> = vec![false; lst.len()];\n    let\
    \ mut curr_pos = 0;\n    let mut curr = String::from(\"\");\n    let mut curr\
    \ = String::from(\"\");\n    for &s in lst {\n        if s.chars().all(|c| c ==\
    \ b'(') {\n            stack.push(true);\n        } else if s.chars().all(|c|\
    \ c == b')') {\n            stack.pop();\n        }\n        if !stack.is_empty()\
    \ {\n            if stack.last().unwrap() {\n                if curr_pos == s.len()\
    \ {\n                    return curr + \")\";\n                } else {\n    \
    \                return curr + \"(\";\n                }\n            } else {\n\
    \                curr_pos = s.len();\n            }\n        }\n        curr =\
    \ s;\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnze4v0_f.rs:19:9\n   |\n\
    19 |     for &s in lst {\n   |         ^^    --- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnze4v0_f.rs:26:16\n   |\n26 |             if stack.last().unwrap()\
    \ {\n   |                ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `&bool`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |             if *stack.last().unwrap()\
    \ {\n   |                +\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().cloned().fold(String::from(\"No\"), |acc, x| {\n\
    \        match acc {\n            String::from(\"No\") => String::from(\"Yes\"\
    ),\n            String::from(\"Yes\") => match(x) {\n                String::from(\"\
    )\") => String::from(\"Yes\"),\n                String::from(\"(\") => String::from(\"\
    Yes\"),\n                _ => acc + \"No\",\n            },\n        }\n    })\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `match` scrutinee expression\n\
    \  --> /tmp/tmptwm63mr7.rs:18:41\n   |\n18 |             String::from(\"Yes\"\
    ) => match(x) {\n   |                                         ^ ^\n   |\n   =\
    \ note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n18 -             String::from(\"Yes\") => match(x) {\n18 +            \
    \ String::from(\"Yes\") => match x {\n   | \n\nerror[E0164]: expected tuple struct\
    \ or tuple variant, found associated function `String::from`\n  --> /tmp/tmptwm63mr7.rs:17:13\n\
    \   |\n17 |             String::from(\"No\") => String::from(\"Yes\"),\n   | \
    \            ^^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n   |\n\
    \   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmptwm63mr7.rs:18:13\n   |\n18 |             String::from(\"\
    Yes\") => match(x) {\n   |             ^^^^^^^^^^^^^^^^^^^ `fn` calls are not\
    \ allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmptwm63mr7.rs:19:17\n   |\n19 |                \
    \ String::from(\")\") => String::from(\"Yes\"),\n   |                 ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmptwm63mr7.rs:20:17\n   |\n20 |                 String::from(\"(\"\
    ) => String::from(\"Yes\"),\n   |                 ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 4 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // TODO: Optimize this algorithm\n    let mut stack = Vec::new();\n\
    \    for i in 0..lst.len() {\n        if i == 0 {\n            stack.push(lst[i]);\n\
    \            continue;\n        }\n        if lst[i - 1] == ')' && lst[i] == ')'\
    \ {\n            stack.pop();\n        } else if lst[i - 1] == '(' && lst[i] ==\
    \ ')' {\n            stack.pop();\n            stack.push(lst[i]);\n        }\
    \ else {\n            break;\n        }\n    }\n    if stack.len() == 0 {\n  \
    \      String::from(\"No\")\n    } else {\n        String::from(\"Yes\")\n   \
    \ }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmp6jv4w58t.rs:22:23\n\
    \   |\n22 |         if lst[i - 1] == ')' && lst[i] == ')' {\n   |            \
    \           ^^ no implementation for `String == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmp6jv4w58t.rs:22:40\n   |\n22 |         if lst[i - 1] == ')' && lst[i]\
    \ == ')' {\n   |                                        ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp6jv4w58t.rs:24:30\n   |\n24 |         }\
    \ else if lst[i - 1] == '(' && lst[i] == ')' {\n   |                         \
    \     ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n          "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    for s in lst.into_iter()\
    \ {\n        stack.pop_front();\n        if let Some(item) = s.as_str().next()\
    \ {\n            stack.push_back(s);\n        }\n        if let Some(item) = s.as_str().next()\
    \ {\n            stack.push_back(s);\n        }\n        if stack.len() >= 2 {\n\
    \            return String::from(\"Yes\");\n        }\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp9kaxkrsr.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0599]: no method named `next` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmp9kaxkrsr.rs:18:40\n   |\n18 |         if let Some(item)\
    \ = s.as_str().next() {\n   |                                        ^^^^ method\
    \ not found in `&str`\n\nerror[E0599]: no method named `next` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmp9kaxkrsr.rs:21:40\n   |\n21 |   \
    \      if let Some(item) = s.as_str().next() {\n   |                         \
    \               ^^^^ method not found in `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        String::from(\"No\")\n    } else\
    \ {\n        if match_parens(&lst[..]) {\n            String::from(\"Yes\")\n\
    \        } else {\n            match_parens(&lst[..lst.len() - 1])\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt1gtbyhy.rs:18:25\n   |\n\
    18 |         if match_parens(&lst[..]) {\n   |                         ^^^^^^^^\
    \ expected struct `Vec`, found `&[String]`\n   |\n   = note: expected struct `Vec<String>`\n\
    \           found reference `&[String]`\nhelp: try using a conversion method\n\
    \   |\n18 |         if match_parens((&lst[..]).to_vec()) {\n   |             \
    \            +        ++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt1gtbyhy.rs:18:12\n\
    \   |\n18 |         if match_parens(&lst[..]) {\n   |            ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpt1gtbyhy.rs:21:26\n   |\n21 |             match_parens(&lst[..lst.len()\
    \ - 1])\n   |                          ^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `&[String]`\n   |\n   = note: expected struct `Vec<String>`\n        \
    \   found reference `&[String]`\nhelp: try using a conversion method\n   |\n21\
    \ |             match_parens((&lst[..lst.len() - 1]).to_vec())\n   |         \
    \                 +                     ++++++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::from(\"Yes\");\n    for x in lst {\n  \
    \      s += &x.chars().collect::<Vec<String>>().join();\n        if x.chars().count()\
    \ < 2 {\n            s += &String::from(\"No\");\n            return s;\n    \
    \    }\n    }\n    s += &String::from(\"No\");\n    s\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpt017fj2g.rs:17:25\n     |\n17\
    \   |         s += &x.chars().collect::<Vec<String>>().join();\n     |       \
    \                  ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0061]: this function takes 1 argument but\
    \ 0 arguments were supplied\n   --> /tmp/tmpt017fj2g.rs:17:50\n    |\n17  |  \
    \       s += &x.chars().collect::<Vec<String>>().join();\n    |              \
    \                                    ^^^^- supplied 0 arguments\n    |       \
    \                                           |\n    |                         \
    \                         expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    for s in lst {\n    \
    \    if s.is_empty() {\n            stack.pop();\n            continue;\n    \
    \    }\n        if s.starts_with(String::from(\"(\")) {\n            stack.push_back(s);\n\
    \        }\n        if s.starts_with(String::from(\")\")) {\n            stack.pop();\n\
    \        }\n        if stack.len() != 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpxq2zk29p.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmpxq2zk29p.rs:21:26\n\
    \     |\n21   |         if s.starts_with(String::from(\"(\")) {\n     |      \
    \        ----------- ^^^^^^^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n\
    \     |              |\n     |              required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n21   |         if s.starts_with(&String::from(\"\
    (\")) {\n     |                          +\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `String`\n    --> /tmp/tmpxq2zk29p.rs:24:26\n     |\n24   | \
    \        if s.starts_with(String::from(\")\")) {\n     |              -----------\
    \ ^^^^^^^^^^^^^^^^^ expected an implementor of trait `Pattern<'_>`\n     |   \
    \           |\n     |              required by a bound introduced by this call\n\
    \     |\n     = note: the trait bound `String: Pattern<'_>` is not satisfied\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `String`\nnote: required by a bound in `core::str::<impl str>::starts_with`\n\
    help: consider borrowing here\n     |\n24   |         if s.starts_with(&String::from(\"\
    )\")) {\n     |                          +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_impl(lst, \"\", \"\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_impl` in this scope\n\
    \  --> /tmp/tmp_01hb84x.rs:15:5\n   |\n15 |     match_parens_impl(lst, \"\", \"\
    \")\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for s in lst {\n        if\
    \ s.chars().count() == 1 {\n            if let Some(open) = s.pop() {\n      \
    \          stack.push(open);\n            }\n        }\n    }\n    match stack.pop()\
    \ {\n        Some('(') => \"Yes\",\n        _ => \"No\",\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpue1p2mmg.rs:24:22\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n...\n24 | \
    \        Some('(') => \"Yes\",\n   |                      ^^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                      |\n   |     \
    \                 expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    for s in lst {\n \
    \       if s.len() > 1 {\n            for c in s.chars().skip(1) {\n         \
    \       match c {\n                    '(' | ')' as c => res.push_str(c.to_string()),\n\
    \                    _ => res.push_str(\"_\"),\n                }\n          \
    \  }\n        } else {\n            res.push_str(&s[0].to_string());\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpknyz9qbt.rs:20:31\n   |\n20 |                     '(' |\
    \ ')' as c => res.push_str(c.to_string()),\n   |                             \
    \  ^^ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmpknyz9qbt.rs:25:27\n\
    \   |\n25 |             res.push_str(&s[0].to_string());\n   |               \
    \            ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut opens = vec![];\n    let mut closes = vec![];\n   \
    \ for s in lst.iter() {\n        if s.starts_with('(') {\n            opens.push(s);\n\
    \        } else {\n            closes.push(s);\n        }\n    }\n    if opens.len()\
    \ != closes.len() {\n        return String::from(\"No\");\n    }\n    if opens.iter().all(|s|\
    \ !closes.contains(&s)) {\n        return String::from(\"Yes\");\n    }\n    String::from(\"\
    No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp2sjmvlwm.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() > 2 {\n        let mut left = 0;\n        let\
    \ mut right = lst.len() - 1;\n        loop {\n            if lst[left] == '('\
    \ && lst[right] == ')' {\n                return String::from(\"Yes\");\n    \
    \        }\n            if lst[left] == '(' && lst[right] == '}' {\n         \
    \       return String::from(\"No\");\n            }\n            left += 1;\n\
    \            right -= 1;\n            if left >= right {\n                break;\n\
    \            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpb0yi4jm5.rs:19:26\n\
    \   |\n19 |             if lst[left] == '(' && lst[right] == ')' {\n   |     \
    \                     ^^ no implementation for `String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpb0yi4jm5.rs:19:47\n   |\n19 |          \
    \   if lst[left] == '(' && lst[right] == ')' {\n   |                         \
    \                      ^^ no implementation for `String == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpb0yi4jm5.rs:22:26\n   |\n22 |          \
    \   if lst[left] == '(' && lst[right] == '}' {\n   |                         \
    \ ^^ no implementation for `String == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut i = 0;\n    let mut max_i = lst.len();\n    let mut\
    \ cnt = 0;\n    while i < max_i {\n        let s = lst[i];\n        let s_len\
    \ = s.len();\n        if !s.is_empty() {\n            if s.starts_with('(') {\n\
    \                cnt += 1;\n                if cnt > 1 {\n                   \
    \ return String::from(\"Yes\");\n                }\n            } else if s.starts_with(')')\
    \ {\n                cnt -= 1;\n            }\n        }\n        i += 1;\n  \
    \  }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused variable: `s_len`\n  --> /tmp/tmp6xen6a4j.rs:20:13\n  \
    \ |\n20 |         let s_len = s.len();\n   |             ^^^^^ help: if this is\
    \ intentional, prefix it with an underscore: `_s_len`\n   |\n   = note: `#[warn(unused_variables)]`\
    \ on by default\n\nwarning: variable does not need to be mutable\n  --> /tmp/tmp6xen6a4j.rs:16:9\n\
    \   |\n16 |     let mut max_i = lst.len();\n   |         ----^^^^^\n   |     \
    \    |\n   |         help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0507]: cannot move out of index of `Vec<String>`\n \
    \ --> /tmp/tmp6xen6a4j.rs:19:17\n   |\n19 |         let s = lst[i];\n   |    \
    \             ^^^^^^\n   |                 |\n   |                 move occurs\
    \ because value has type `String`, which does not implement the `Copy` trait\n\
    \   |                 help: consider borrowing here: `&lst[i]`\n\nerror: aborting\
    \ due to previous error; 2 warnings emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0507`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n\n    for s in lst {\n       \
    \ if s.is_empty() || s == String::from(\"(\") {\n            stack.push(s);\n\
    \        } else {\n            stack.pop();\n            if stack.len() != 0 {\n\
    \                break;\n            }\n        }\n    }\n    if stack.len() ==\
    \ 0 {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpbz9rrqf_.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        0 => \"No\".to_string(),\n     \
    \   1 => \"Yes\".to_string(),\n        _ => panic!(\"Invalid input!\"),\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''Invalid input!'', /tmp/tmp23_290se.rs:18:14

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len() as u64, lst.iter().map(|s| s.chars()).chain().collect::<Vec<_>>())\
    \ {\n        (0, vec!['('])\n        (1, vec!['(', ']'])\n        (2, vec!['(',\
    \ ')'])\n        (_, vec!['(', ')'])\n        (x, xs) if x >= xs.len()\n    }.fold(String::from(\"\
    No\"), |acc, x| {\n        match acc.chars().count() {\n            0 => acc.append(\"\
    Yes\"),\n            1 => acc.append(\"Yes\"),\n            x => acc.append(\"\
    No\"),\n        }\n    })\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `=>`, `if`, or `|`, found `(`\n  --> /tmp/tmpen2mgndk.rs:17:9\n\
    \   |\n16 |         (0, vec!['('])\n   |                       - expected one\
    \ of `=>`, `if`, or `|`\n17 |         (1, vec!['(', ']'])\n   |         ^ unexpected\
    \ token\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpen2mgndk.rs:15:60\n    |\n15  |     match (lst.len() as u64, lst.iter().map(|s|\
    \ s.chars()).chain().collect::<Vec<_>>()) {\n    |                           \
    \                                 ^^^^^- supplied 0 arguments\n    |         \
    \                                                   |\n    |                 \
    \                                           expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0599]: `!` is not an iterator\n \
    \ --> /tmp/tmpen2mgndk.rs:21:7\n   |\n21 |     }.fold(String::from(\"No\"), |acc,\
    \ x| {\n   |       ^^^^ `!` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `!: Iterator`\n           which\
    \ is required by `&mut !: Iterator`\n\nwarning: unreachable expression\n  -->\
    \ /tmp/tmpen2mgndk.rs:21:12\n   |\n15 | /     match (lst.len() as u64, lst.iter().map(|s|\
    \ s.chars()).chain().collect::<Vec<_>>()) {\n16 | |         (0, vec!['('])\n17\
    \ | |         (1, vec!['(', ']'])\n18 | |         (2, vec!['(', ')'])\n19 | |\
    \         (_, vec!['(', ')'])\n20 | |         (x, xs) if x >= xs.len()\n21 | |\
    \     }.fold(String::from(\"No\"), |acc, x| {\n   | |     -      ^^^^^^^^^^^^^^^^^^\
    \ unreachable expression\n   | |_____|\n   |       any code following this expression\
    \ is unreachable\n   |\n   = note: `#[warn(unreachable_code)]` on by default\n\
    \nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0061, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![];\n    for s in lst {\n        if s ==\
    \ String::from(\"(\") {\n            stack.push(s);\n        } else {\n      \
    \      if stack.len() == 0 {\n                return String::from(\"No\");\n \
    \           }\n            let top = stack.pop();\n            if top == s {\n\
    \                continue;\n            }\n            return String::from(\"\
    No\");\n        }\n    }\n    return String::from(\"Yes\");\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz65s_2ye.rs:24:23\n   |\n\
    24 |             if top == s {\n   |                       ^ expected enum `Option`,\
    \ found struct `String`\n   |\n   = note: expected enum `Option<String>`\n   \
    \         found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n24 |             if top == Some(s) {\n   |                       +++++\
    \ +\n\nerror: aborting due to previous error\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    for s in lst {\n       \
    \ stack.push(s);\n    }\n    let mut res = String::from(\"No\");\n    let mut\
    \ open = String::from(\"No\");\n    let mut close = String::from(\"No\");\n  \
    \  while !stack.is_empty() {\n        let s = stack.pop().unwrap();\n        if\
    \ s.chars().any(|c| c == '(') {\n            open.push_str(s);\n        } else\
    \ {\n            close.push_str(s);\n        }\n    }\n\n    if open == close\
    \ {\n        res.push_str(\"Yes\");\n    } else {\n        res.push_str(\"No\"\
    );\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmprwgl5rhn.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        String::from(\"Yes\")\n    } else\
    \ {\n        let mut s = String::from(\"No\");\n        for s in lst {\n     \
    \       if s.chars().any(|c| *c == '(') {\n                s = s.replace(\"(\"\
    , \"Yes\");\n            }\n            if s.chars().any(|c| *c == ')') {\n  \
    \              s = s.replace(\")\", \"No\");\n            }\n        }\n     \
    \   s\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpkqa8vv6a.rs:20:34\n\
    \   |\n20 |             if s.chars().any(|c| *c == '(') {\n   |              \
    \                    ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpkqa8vv6a.rs:23:34\n   |\n23 |             if s.chars().any(|c|\
    \ *c == ')') {\n   |                                  ^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    fn is_balanced(s: &String) -> bool {\n        let mut left\
    \ = 0;\n        let mut right = 0;\n        for i in s.chars() {\n           \
    \ if left == right {\n                left = 0;\n            }\n            left\
    \ += 1;\n            if i == ')' {\n                right += 1;\n            }\n\
    \        }\n        right == 0\n    }\n\n    let mut min_len = MAX_LEN;\n    for\
    \ s in lst.iter().filter_map(|&s| s.to_owned()) {\n        let len = s.len();\n\
    \        if len < min_len {\n            min_len = len;\n        }\n    }\n  \
    \  let mut i = 0;\n    let mut ret = \"No\";\n    while i < min_len {\n      \
    \  if !is_balanced(&lst[i .. i + 1]) {\n            ret = \"No\";\n          \
    \  break;\n        }\n        i += 1;\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `MAX_LEN` in this scope\n  --> /tmp/tmpwq8fcipl.rs:30:23\n\
    \   |\n30 |     let mut min_len = MAX_LEN;\n   |                       ^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwq8fcipl.rs:31:41\n\
    \   |\n31 |     for s in lst.iter().filter_map(|&s| s.to_owned()) {\n   |    \
    \                                     ^^^^^^^^^^^^ expected enum `Option`, found\
    \ struct `String`\n   |\n   = note: expected enum `Option<_>`\n            found\
    \ struct `String`\nhelp: try wrapping the expression in `Some`\n   |\n31 |   \
    \  for s in lst.iter().filter_map(|&s| Some(s.to_owned())) {\n   |           \
    \                              +++++            +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwq8fcipl.rs:40:25\n   |\n40 |         if !is_balanced(&lst[i\
    \ .. i + 1]) {\n   |                         ^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found slice\n   |\n   = note: expected reference `&String`\n     \
    \         found reference `&[String]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwq8fcipl.rs:46:5\n   |\n14 | fn match_parens(lst: Vec<String>) -> String\
    \ {\n   |                                      ------ expected `String` because\
    \ of return type\n...\n46 |     ret\n   |     ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    loop {\n        let s = lst.len();\n\
    \        let mut new_list: Vec<String> = vec![];\n        for i in 0..s {\n  \
    \          cnt += 1;\n            new_list.push(i == 0 ? vec![String::from(\"\"\
    )] : lst[i - 1].clone());\n        }\n        if cnt < 3 {\n            cnt +=\
    \ 1;\n        }\n        if cnt >= 3 {\n            break;\n        }\n    }\n\
    \    match cnt {\n        0 => \"No\".into(),\n        1 => \"Yes\".into(),\n\
    \        _ => panic!(\"Bad cases\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: casts cannot be followed by a method call\n  --> /tmp/tmp4k6h2e95.rs:21:36\n\
    \   |\n21 |             new_list.push(i == 0 ? vec![String::from(\"\")] : lst[i\
    \ - 1].clone());\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^------\n\
    \   |                                                          |\n   |       \
    \                                                   help: remove the type ascription\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `vec`\n  -->\
    \ /tmp/tmp4k6h2e95.rs:21:36\n   |\n21 |             new_list.push(i == 0 ? vec![String::from(\"\
    \")] : lst[i - 1].clone());\n   |                                   -^^^ expected\
    \ one of `)`, `,`, `.`, `?`, or an operator\n   |                            \
    \       |\n   |                                   help: missing `,`\n\nerror[E0573]:\
    \ expected type, found local variable `lst`\n  --> /tmp/tmp4k6h2e95.rs:21:61\n\
    \   |\n21 |             new_list.push(i == 0 ? vec![String::from(\"\")] : lst[i\
    \ - 1].clone());\n   |                                                       \
    \      ^^^ not a type\n\nerror[E0277]: the `?` operator can only be applied to\
    \ values that implement `Try`\n  --> /tmp/tmp4k6h2e95.rs:21:32\n   |\n21 |   \
    \          new_list.push(i == 0 ? vec![String::from(\"\")] : lst[i - 1].clone());\n\
    \   |                                ^^^ the `?` operator cannot be applied to\
    \ type `{integer}`\n   |\n   = help: the trait `Try` is not implemented for `{integer}`\n\
    \nerror[E0277]: the `?` operator can only be used in a function that returns `Result`\
    \ or `Option` (or another type that implements `FromResidual`)\n  --> /tmp/tmp4k6h2e95.rs:21:34\n\
    \   |\n14 | / fn match_parens(lst: Vec<String>) -> String {\n15 | |     let mut\
    \ cnt = 0;\n16 | |     loop {\n17 | |         let s = lst.len();\n...  |\n21 |\
    \ |             new_list.push(i == 0 ? vec![String::from(\"\")] : lst[i - 1].clone());\n\
    \   | |                                  ^ cannot use the `?` operator in a function\
    \ that returns `String`\n...  |\n34 | |     }\n35 | | }\n   | |_- this function\
    \ should return `Result` or `Option` to accept `?`\n   |\n   = help"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    let mut stack = Stack::new();\n\
    \    stack.push(\"()\");\n    while let Some(item) = stack.pop() {\n        res.push_str(item);\n\
    \        if let Some(next) = lst.iter().skip(stack.len()).next() {\n         \
    \   let mut next = next.clone();\n            while let Some(open) = next.chars().next()\
    \ {\n                if let Some(close) = next.chars().nth(next.len() - 1).unwrap()\
    \ {\n                    if open == close {\n                        next = next.chars().skip(next.len()\
    \ - 1).next().unwrap();\n                    } else {\n                      \
    \  next = next.chars().skip(next.len() - 1).unwrap();\n                    }\n\
    \                } else {\n                    break;\n                }\n   \
    \         }\n            if let Some(next) = next.clone() {\n                stack.push(next.clone());\n\
    \            }\n        } else {\n            break;\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp7h5g67ey.rs:16:21\n   |\n16 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7h5g67ey.rs:23:24\n   |\n23 |              \
    \   if let Some(close) = next.chars().nth(next.len() - 1).unwrap() {\n   |   \
    \                     ^^^^^^^^^^^   -----------------------------------------\
    \ this expression has type `char`\n   |                        |\n   |       \
    \                 expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp7h5g67ey.rs:25:32\n   |\n21 |             let mut next\
    \ = next.clone();\n   |                            ------------ expected due to\
    \ this value\n...\n25 |                         next = next.chars().skip(next.len()\
    \ - 1).next().unwrap();\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \              |\n   |                                expected struct `String`,\
    \ found `char`\n\nerror[E0599]: no method named `unwrap` found for struct `Skip`\
    \ in the current scope\n  --> /tmp/tmp7h5g67ey.rs:27:66\n   |\n27 |          \
    \               next = next.chars().skip(next.len() - 1).unwrap();\n   |     \
    \                                                             ^^^^^^ method not\
    \ found in `Skip<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7h5g67ey.rs:33:20\n\
    \   |\n33 |             if let Some(next) = next.clone() {\n   |             \
    \       ^^^^^^^^^^   ------------ this expression has type `String`\n   |    \
    \                |\n   |                    expected struct `String`, found enum\
    \ `Option`\n   |\n   = note: expected struct `String`\n                found enum\
    \ `Option<_>`\n\nerror: aborting due to 5 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_rec(lst.iter(), String::from(\"Yes\"))\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_rec` in this scope\n \
    \ --> /tmp/tmp_uloyy5q.rs:15:5\n   |\n15 |     match_parens_rec(lst.iter(), String::from(\"\
    Yes\"))\n   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().filter_map(|s| s.chars().filter_map(|c| match c\
    \ {\n        '(' | ')' => {\n            Ok(true)\n        }\n        c => {\n\
    \            Ok(false)\n        }\n    })).all(|a| a).unwrap_or(\"No\")\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgth23ygr.rs:17:13\n   |\n\
    17 |             Ok(true)\n   |             ^^^^^^^^ expected enum `Option`, found\
    \ enum `Result`\n   |\n   = note: expected enum `Option<_>`\n              found\
    \ enum `Result<bool, _>`\nhelp: try wrapping the expression in `Some`\n   |\n\
    17 |             Some(Ok(true))\n   |             +++++        +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgth23ygr.rs:20:13\n   |\n20 |             Ok(false)\n\
    \   |             ^^^^^^^^^ expected enum `Option`, found enum `Result`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found enum `Result<bool,\
    \ _>`\nhelp: try wrapping the expression in `Some`\n   |\n20 |             Some(Ok(false))\n\
    \   |             +++++         +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgth23ygr.rs:15:31\n\
    \   |\n15 |       lst.iter().filter_map(|s| s.chars().filter_map(|c| match c {\n\
    \   |  _______________________________^\n16 | |         '(' | ')' => {\n17 | |\
    \             Ok(true)\n18 | |         }\n...  |\n21 | |         }\n22 | |   \
    \  })).all(|a| a).unwrap_or(\"No\")\n   | |______^ expected enum `Option`, found\
    \ struct `FilterMap`\n   |\n   = note: expected enum `Option<_>`\n           \
    \ found struct `FilterMap<Chars<'_>, [closure@/tmp/tmpgth23ygr.rs:15:52: 22:6]>`\n\
    help: try wrapping the expression in `Some`\n   |\n15 ~     lst.iter().filter_map(|s|\
    \ Some(s.chars().filter_map(|c| match c {\n16 |         '(' | ')' => {\n17 | \
    \            Ok(true)\n18 |         }\n19 |         c => {\n20 |             Ok(false)\n\
    \ ...\n\nerror[E0599]: no method named `unwrap_or` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmpgth23ygr.rs:22:20\n   |\n22 |     })).all(|a| a).unwrap_or(\"\
    No\")\n   |                    ^^^^^^^^^ method not found in `bool`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::from(\"\");\n    for i in lst.iter()\
    \ {\n        if i == String::from(\"()\") {\n            cur.push_str(\")\");\n\
    \        } else if i == String::from(\")\") {\n            cur.push_str(\"(\"\
    );\n        } else {\n            return String::from(\"No\");\n        }\n  \
    \  }\n    cur.to_owned()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmpwx4ysujf.rs:17:14\n\
    \   |\n17 |         if i == String::from(\"()\") {\n   |              ^^ no implementation\
    \ for `&String == String`\n   |\n   = help: the trait `PartialEq<String>` is not\
    \ implemented for `&String`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n         \
    \    <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `&String` with `String`\n\
    \  --> /tmp/tmpwx4ysujf.rs:19:21\n   |\n19 |         } else if i == String::from(\"\
    )\") {\n   |                     ^^ no implementation for `&String == String`\n\
    \   |\n   = help: the trait `PartialEq<String>` is not implemented for `&String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![String::from(\"(\")];\n    for s in lst\
    \ {\n        if stack.is_empty() {\n            stack.push(s);\n        } else\
    \ {\n            stack = match s.chars().nth(0) {\n                '(' => {\n\
    \                    let s = match s.chars().nth(1) {\n                      \
    \  '(' | ')' => String::from(\"(\"),\n                        _ => String::from(\"\
    (\"),\n                    };\n                    stack.push(s);\n          \
    \      }\n                '{' | '}' => {\n                    let s = match s.chars().nth(1)\
    \ {\n                        '{' | '}' => String::from(\"{\"),\n             \
    \           _ => String::from(\"{\"),\n                    };\n              \
    \      stack.push(s);\n                }\n                '[' | ']' => {\n   \
    \                 let s = match s.chars().nth(1) {\n                        '['\
    \ | ']' => String::from(\"[\"),\n                        _ => String::from(\"\
    [\"),\n                    };\n                    stack.push(s);\n          \
    \      }\n                _ => {\n                    stack.push(s);\n       \
    \         }\n            };\n        }\n    }\n    if stack.len() == 1 {\n   \
    \     String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ahokg7k.rs:21:17\n   |\n\
    20 |             stack = match s.chars().nth(0) {\n   |                      \
    \     ---------------- this expression has type `Option<char>`\n21 |         \
    \        '(' => {\n   |                 ^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<char>`\n              found type `char`\n\
    help: try wrapping the pattern in `Some`\n   |\n21 |                 Some('(')\
    \ => {\n   |                 +++++   +\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp2ahokg7k.rs:28:17\n   |\n20 |             stack = match s.chars().nth(0)\
    \ {\n   |                           ---------------- this expression has type\
    \ `Option<char>`\n...\n28 |                 '{' | '}' => {\n   |             \
    \    ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<char>`\n              found type `char`\nhelp: try wrapping the pattern\
    \ in `Some`\n   |\n28 |                 Some('{') | '}' => {\n   |           \
    \      +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ahokg7k.rs:28:23\n\
    \   |\n20 |             stack = match s.chars().nth(0) {\n   |               \
    \            ---------------- this expression has type `Option<char>`\n...\n28\
    \ |                 '{' | '}' => {\n   |                       ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n\
    28 |                 '{' | Some('}') => {\n   |                       +++++  \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2ahokg7k.rs:35:17\n   |\n\
    20 |             stack = match s.chars().nth(0) {\n   |                      \
    \     ---------------- this expression has type `Option<char>`\n...\n35 |    \
    \             '[' | ']' => {\n   |                 ^^^ expected enum `Option`,\
    \ found `char`\n   |\n   = note: expected enum `Option<char>`\n              found\
    \ type `char`\nhelp: try wrapping the pattern in `Some`\n   |\n35 |          \
    \       Some('[') | ']' => {\n   |                 +++++   +\n\nerror[E0308]:\
    \ mismatched types\n "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut curr = String::from(\"\");\n    for el in lst {\n \
    \       if let Some(c) = el[el.len() - 1] {\n            if c == '(' || c == '{'\
    \ || c == '[' {\n                curr.push_str(&el);\n            } else if c\
    \ == '}' || c == ']' {\n                if curr[curr.len() - 1] == '{' {\n   \
    \                 curr.push_str(&el);\n                } else {\n            \
    \        curr.push_str(\"No\");\n                }\n            } else {\n   \
    \             curr.push_str(\"No\");\n            }\n        } else {\n      \
    \      curr.push_str(\"No\");\n        }\n    }\n    curr\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeyb8x0bm.rs:17:26\n\
    \   |\n17 |         if let Some(c) = el[el.len() - 1] {\n   |                \
    \          ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpeyb8x0bm.rs:21:20\n\
    \   |\n21 |                 if curr[curr.len() - 1] == '{' {\n   |           \
    \         ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n \
    \  = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    let mut current_index\
    \ = lst.len();\n    let mut open_brackets = 0;\n    let mut close_brackets = 0;\n\
    \    for i in lst.iter() {\n        if let Some(key) = i.as_str() {\n        \
    \    if key == '(' {\n                open_brackets += 1;\n            }\n   \
    \         else if key == ')' {\n                close_brackets += 1;\n       \
    \     }\n        }\n    }\n    if open_brackets <= close_brackets {\n        res\
    \ = \"Yes\";\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf5blzi74.rs:20:16\n   |\n\
    20 |         if let Some(key) = i.as_str() {\n   |                ^^^^^^^^^  \
    \ ---------- this expression has type `&str`\n   |                |\n   |    \
    \            expected `str`, found enum `Option`\n   |\n   = note: expected type\
    \ `str`\n              found enum `Option<_>`\n\nerror[E0277]: can't compare `&_`\
    \ with `char`\n  --> /tmp/tmpf5blzi74.rs:21:20\n   |\n21 |             if key\
    \ == '(' {\n   |                    ^^ no implementation for `&_ == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0277]:\
    \ can't compare `&_` with `char`\n  --> /tmp/tmpf5blzi74.rs:24:25\n   |\n24 |\
    \             else if key == ')' {\n   |                         ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5blzi74.rs:30:15\n\
    \   |\n15 |     let mut res = String::from(\"No\");\n   |                   ------------------\
    \ expected due to this value\n...\n30 |         res = \"Yes\";\n   |         \
    \      ^^^^^- help: try using a conversion method: `.to_string()`\n   |      \
    \         |\n   |               expected struct `String`, found `&str`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    let mut result = String::new();\n\
    \    for ele in lst.iter().cloned() {\n        match ele {\n            '(' |\
    \ ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ',' => {\n           \
    \     match stack.peek().unwrap() {\n                    '(' | ')' => {\n    \
    \                    result.append(&ele);\n                        stack.push(ele);\n\
    \                    }\n                    '+' => {\n                       \
    \ result.append(&ele);\n                        stack.push(ele);\n           \
    \         }\n                    '-' => {\n                        result.append(&ele);\n\
    \                        stack.push(ele);\n                    }\n           \
    \         '*' => {\n                        result.append(&ele);\n           \
    \             stack.push(ele);\n                    }\n                    '&'\
    \ => {\n                        result.append(&ele);\n                       \
    \ stack.push(ele);\n                    }\n                    '^' => {\n    \
    \                    result.append(&ele);\n                        stack.push(ele);\n\
    \                    }\n                    '|' => {\n                       \
    \ result.append(&ele);\n                        stack.push(ele);\n           \
    \         }\n                    '<' => {\n                        result.append(&ele);\n\
    \                        stack.push(ele);\n                    }\n           \
    \         '>' => {\n                        result.append(&ele);\n           \
    \             stack.push(ele);\n                    }\n                    ','\
    \ => {\n                        result.append(&ele);\n                    }\n\
    \                    _ => {\n                        result.append(&ele);\n  \
    \                      stack.push(ele);\n                    }\n             \
    \   }\n            }\n            _ => {\n                result.append(&ele);\n\
    \                stack.push(ele);\n            }\n        }\n    }\n\n    if !stack.empty()\
    \ {\n        result\n    } else {\n        String::from(\"No\")\n    }\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpql5dy0dp.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:13\n   |\n18 |         match\
    \ ele {\n   |               --- this expression has type `String`\n19 |      \
    \       '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ',' => {\n\
    \   |             ^^^ expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:19\n   |\n18 |         match\
    \ ele {\n   |               --- this expression has type `String`\n19 |      \
    \       '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ',' => {\n\
    \   |                   ^^^ expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:25\n   |\n18 |         match\
    \ ele {\n   |               --- this expression has type `String`\n19 |      \
    \       '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ',' => {\n\
    \   |                         ^^^ expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:31\n   |\n18 |         match\
    \ ele {\n   |               --- this expression has type `String`\n19 |      \
    \       '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ',' => {\n\
    \   |                               ^^^ expected struct `String`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:37\n   |\n18 |\
    \         match ele {\n   |               --- this expression has type `String`\n\
    19 |             '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<' | '>' | ','\
    \ => {\n   |                                     ^^^ expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpql5dy0dp.rs:19:43\n\
    \   |\n18 |         match ele {\n   |               --- this expression has type\
    \ `String`\n19 |             '(' | ')' | '+' | '-' | '*' | '&' | '^' | '|' | '<'\
    \ | '>' | ',' => {\n   |                                           ^^^ expected\
    \ stru"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = String::from(\"(\");\n    let mut right = String::from(\"\
    \");\n    let mut ans = String::from(\"No\");\n\n    for x in lst {\n        if\
    \ left.is_empty() {\n            left = x;\n            continue;\n        }\n\
    \n        if x.is_empty() {\n            right = x;\n            continue;\n \
    \       }\n\n        if x.is_ascii_whitespace() {\n            continue;\n   \
    \     }\n\n        if x == left {\n            left = x.clone();\n           \
    \ continue;\n        }\n\n        if x == right {\n            right = x.clone();\n\
    \            continue;\n        }\n\n        if x == left.clone() + right.clone()\
    \ {\n            ans = String::from(\"Yes\");\n            break;\n        }\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_whitespace` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpfx_wdc1k.rs:30:14\n   |\n30 |         if\
    \ x.is_ascii_whitespace() {\n   |              ^^^^^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `split_ascii_whitespace`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpfx_wdc1k.rs:44:32\n   |\n44 |  \
    \       if x == left.clone() + right.clone() {\n   |                         \
    \       ^^^^^^^^^^^^^\n   |                                |\n   |           \
    \                     expected `&str`, found struct `String`\n   |           \
    \                     help: consider borrowing here: `&right`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 1 {\n        return \"No\";\n    }\n    let\
    \ mut stack = Vec::new();\n    let mut i = 1;\n    let mut prev = \"\";\n    for\
    \ x in lst {\n        if x == prev {\n            i += 1;\n        } else {\n\
    \            stack.push(i);\n            i += 1;\n            prev = x;\n    \
    \    }\n    }\n    while stack.len() > 0 {\n        if stack.len() == 1 {\n  \
    \          return \"No\";\n        }\n        i += 1;\n        let cur = stack.pop().unwrap();\n\
    \        if cur == 1 {\n            stack.push(i - 1);\n        } else {\n   \
    \         stack.push(i);\n        }\n    }\n    \"Yes\".into()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp58imrrn.rs:16:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     if\
    \ lst.len() <= 1 {\n16 |         return \"No\";\n   |                ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpp58imrrn.rs:27:20\n   |\n20 |     let mut prev = \"\";\n\
    \   |                    -- expected due to this value\n...\n27 |            \
    \ prev = x;\n   |                    ^\n   |                    |\n   |      \
    \              expected `&str`, found struct `String`\n   |                  \
    \  help: consider borrowing here: `&x`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut stack2 = Vec::new();\n\
    \    let mut cur = String::from(\"\");\n    let mut cur2 = String::from(\"\");\n\
    \    let mut res = String::from(\"\");\n    let mut len = lst.len();\n    while\
    \ len > 0 {\n        match lst.remove(0).get() {\n            ')' => {\n     \
    \           match stack.last().get() {\n                    ')' => {}\n      \
    \              ',' => {}\n                    ')' => stack.pop(),\n          \
    \          ',' => stack2.pop(),\n                    _ => stack.push(cur),\n \
    \               }\n                stack.push(String::from(cur));\n          \
    \  }\n            '(' {\n                match stack2.last().get() {\n       \
    \             ')' => {}\n                    ',' => {}\n                    '('\
    \ | ',' => {}\n                    ')' => stack2.pop(),\n                    ','\
    \ => stack.push(String::from(cur2)),\n                    _ => stack2.push(cur2),\n\
    \                }\n                stack2.push(String::from(cur2));\n       \
    \     }\n            _ => {\n                stack.push(String::from(cur));\n\
    \                stack2.push(String::from(cur));\n            }\n        }\n \
    \       cur = String::from(\"\");\n        cur2 = String::from(\"\");\n    }\n\
    \    if stack.len() > 0 || stack2.len() > 0 {\n        res = \"No\"\n    } else\
    \ {\n        res = \"Yes\"\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found `{`\n\
    \  --> /tmp/tmp43sh2rc5.rs:33:17\n   |\n33 |             '(' {\n   |         \
    \        ^ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmp43sh2rc5.rs:22:29\n\
    \    |\n22  |         match lst.remove(0).get() {\n    |                     \
    \        ^^^- supplied 0 arguments\n    |                             |\n    |\
    \                             expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp43sh2rc5.rs:23:13\n\
    \   |\n22 |         match lst.remove(0).get() {\n   |               -------------------\
    \ this expression has type `Option<&_>`\n23 |             ')' => {\n   |     \
    \        ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum\
    \ `Option<&_>`\n              found type `char`\n\nerror[E0599]: no method named\
    \ `get` found for enum `Option` in the current scope\n  --> /tmp/tmp43sh2rc5.rs:24:36\n\
    \   |\n24 |                 match stack.last().get() {\n   |                 \
    \                   ^^^ method not found in `Option<&_>`\n\nerror[E0308]: `match`\
    \ arms have incompatible types\n  --> /tmp/tmp43sh2rc5.rs:27:28\n   |\n24 | /\
    \                 match stack.last().get() {\n25 | |                     ')' =>\
    \ {}\n   | |                            -- this is found to be of type `()`\n\
    26 | |                     ',' => {}\n   | |                            -- this\
    \ is found to be of type `()`\n27 | |                     ')' => stack.pop(),\n\
    \   | |                            ^^^^^^^^^^^ expected `()`, found enum `Option`\n\
    28 | |                     ',' => stack2.pop(),\n29 | |                     _\
    \ => stack.push(cur),\n30 | |                 }\n   | |_________________- `match`\
    \ arms have incompatible types\n   |\n   = note: expected unit type `()`\n   \
    \                found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp43sh2rc5.rs:53:15\n   |\n19 |     let mut res = String::from(\"\");\n\
    \   |                   ---------------"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        1 => \"Yes\",\n        _ => match_parens(lst.iter().zip(&lst[1..]).map(|(acc,\
    \ x)| match_parens(vec![acc, x]))),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_skatg5v.rs:16:14\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     match\
    \ lst.len() {\n16 |         1 => \"Yes\",\n   |              ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |              |\n   |       \
    \       expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_skatg5v.rs:17:86\n   |\n17 |         _ => match_parens(lst.iter().zip(&lst[1..]).map(|(acc,\
    \ x)| match_parens(vec![acc, x]))),\n   |                                    \
    \                                                  ^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                               \
    \                                       |\n   |                              \
    \                                                        expected struct `String`,\
    \ found `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_skatg5v.rs:17:27\n\
    \   |\n17 |         _ => match_parens(lst.iter().zip(&lst[1..]).map(|(acc, x)|\
    \ match_parens(vec![acc, x]))),\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found struct `Map`\n   |\n   = note: expected struct\
    \ `Vec<String>`\n              found struct `Map<Zip<std::slice::Iter<'_, String>,\
    \ std::slice::Iter<'_, String>>, [closure@/tmp/tmp_skatg5v.rs:17:57: 17:94]>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    let mut first = String::new();\n    let\
    \ mut last = String::new();\n    for s in lst {\n        if s.len() == 1 {\n \
    \           cnt += 1;\n            first += s.chars().nth(0).unwrap();\n     \
    \   } else {\n            cnt += 1;\n            last += s.chars().nth(s.len()\
    \ - 1).unwrap();\n            if cnt > 1 {\n                if last != first {\n\
    \                    return String::from(\"No\");\n                }\n       \
    \     }\n            first = last.clone();\n            cnt = 0;\n        }\n\
    \    }\n    if cnt > 1 {\n        if last != first {\n            return String::from(\"\
    No\");\n        }\n    }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_v_c5szw.rs:21:22\n   |\n\
    21 |             first += s.chars().nth(0).unwrap();\n   |                   \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_v_c5szw.rs:24:21\n   |\n24 |             last += s.chars().nth(s.len()\
    \ - 1).unwrap();\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Create a stack of size 2 to check whether the parentheses\
    \ are balanced or not.\n    let mut stack = VecDeque::new(2);\n\n    for ele in\
    \ lst {\n        match ele {\n            String::from(\"(\") => {\n         \
    \       stack.push_back(String::from(\"(\"));\n            }\n            String::from(\"\
    )\") => {\n                // If the stack has only one element, it means that\
    \ there is an\n                // unmatched close parenthesis ')'.\n         \
    \       if stack.is_empty() {\n                    return String::from(\"No\"\
    );\n                }\n                let (last) = stack.pop_front().unwrap();\n\
    \                // If the last element of the stack was not a close parentheses,\n\
    \                // then the parentheses are not balanced.\n                if\
    \ last != String::from(\")\") {\n                    return String::from(\"No\"\
    );\n                }\n            }\n            _ => {\n                // If\
    \ the stack has more than one element, means that the last\n                //\
    \ element of the stack was not a close parentheses, therefore the\n          \
    \      // parentheses are not balanced.\n                if stack.is_empty() {\n\
    \                    return String::from(\"No\");\n                }\n       \
    \     }\n        }\n    }\n    match stack.pop_front() {\n        Some(String::from(\"\
    (\")) => String::from(\"Yes\"),\n        Some(String::from(\")\")) => String::from(\"\
    Yes\"),\n        None => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpf0mssv4t.rs:16:21\n   |\n16 |     let mut stack = VecDeque::new(2);\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    warning: unnecessary parentheses around pattern\n  --> /tmp/tmpf0mssv4t.rs:29:21\n\
    \   |\n29 |                 let (last) = stack.pop_front().unwrap();\n   |   \
    \                  ^    ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n29 -                 let (last) = stack.pop_front().unwrap();\n\
    29 +                 let last = stack.pop_front().unwrap();\n   | \n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpf0mssv4t.rs:20:13\n   |\n20 |             String::from(\"(\") =>\
    \ {\n   |             ^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpf0mssv4t.rs:23:13\n   |\n23 |             String::from(\"\
    )\") => {\n   |             ^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpf0mssv4t.rs:47:14\n   |\n47 |         Some(String::from(\"\
    (\")) => String::from(\"Yes\"),\n   |              ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpf0mssv4t.rs:48:14\n   |\n48 |         Some(String::from(\"\
    )\")) => String::from(\"Yes\"),\n   |              ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more informa"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for str in lst {\n       \
    \ if str.chars().all(|c| c == '(') {\n            stack.push(str);\n        }\n\
    \        if str.chars().all(|c| c == ')') {\n            let len = stack.len();\n\
    \            let mut pop = len;\n            loop {\n                let len =\
    \ stack.len();\n                if len == 0 {\n                    break;\n  \
    \              }\n                pop = len - 1;\n                match stack.pop()\
    \ {\n                    Some('(') => pop = pop - 1,\n                    Some(')')\
    \ => pop = pop - 1,\n                    _ => break\n                }\n     \
    \       }\n            if pop != len {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    String::from(\"Yes\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfv0mxfsi.rs:30:26\n   |\n\
    29 |                 match stack.pop() {\n   |                       -----------\
    \ this expression has type `Option<String>`\n30 |                     Some('(')\
    \ => pop = pop - 1,\n   |                          ^^^ expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfv0mxfsi.rs:31:26\n\
    \   |\n29 |                 match stack.pop() {\n   |                       -----------\
    \ this expression has type `Option<String>`\n30 |                     Some('(')\
    \ => pop = pop - 1,\n31 |                     Some(')') => pop = pop - 1,\n  \
    \ |                          ^^^ expected struct `String`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut closed = false;\n    let mut open = false;\n\n    for\
    \ elem in lst.iter() {\n        if elem == \"(\" {\n            open = true;\n\
    \        }\n        if elem == \")\" {\n            closed = true;\n        }\n\
    \        if open && closed {\n            break;\n        }\n    }\n\n    if open\
    \ && closed {\n        return \"Yes\";\n    }\n\n    \"No\"\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpliar9nu4.rs:31:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n...\n31 | \
    \        return \"Yes\";\n   |                ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                |\n   |                expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpliar9nu4.rs:34:5\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n...\n\
    34 |     \"No\"\n   |     ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |     |\n   |     expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_helper(String::from(\"()\"), String::from(\")\"\
    ), vec![], lst)\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmpcifqmh6v.rs:15:5\n   |\n15 |     match_parens_helper(String::from(\"\
    ()\"), String::from(\")\"), vec![], lst)\n   |     ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = vec![0; lst.len()];\n    let mut\
    \ i: usize = 0;\n\n    while i < lst.len() {\n        let mut j = i;\n\n     \
    \   while stack[j] != 0 {\n            if lst[i] == String::from(\"(\") {\n  \
    \              stack[j] = 0;\n                i += 1;\n                j += 1;\n\
    \                continue;\n            }\n\n            if lst[i] == String::from(\"\
    )\") {\n                if stack[j] == 0 {\n                    return String::from(\"\
    No\");\n                }\n\n                stack[j] = 0;\n                i\
    \ += 1;\n            }\n\n            i += 1;\n            j += 1;\n        }\n\
    \n        stack[j] = 0;\n        i += 1;\n    }\n\n    String::from(\"Yes\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmprkmudf4w.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    for s in lst {\n \
    \       if s.is_empty() {\n            return res;\n        }\n\n        let mut\
    \ open = false;\n        let mut open_balance = 0;\n        let mut closed = false;\n\
    \        let mut closed_balance = 0;\n        for c in s.chars() {\n         \
    \   match c {\n                '(' | ')' | ')(') => {\n                    open_balance\
    \ += 1;\n                    open = !open;\n                }\n              \
    \  ')' if open && open_balance > 0 => {\n                    open_balance -= 1;\n\
    \                    open = !open;\n                }\n                '[' | ']'\
    \ if closed && closed_balance > 0 => {\n                    closed_balance -=\
    \ 1;\n                    closed = !closed;\n                }\n             \
    \   '[' | ']' if closed && closed_balance < 0 => {\n                    closed_balance\
    \ += 1;\n                    closed = !closed;\n                }\n          \
    \      _ => {}\n            }\n        }\n        if open == closed && open_balance\
    \ == closed_balance {\n            res = res.concat(\"Yes\");\n        }\n   \
    \ }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpi3r49jra.rs:27:29\n\
    \   |\n27 |                 '(' | ')' | ')(') => {\n   |                     \
    \        ^^^^\n   |\nhelp: if you meant to write a `str` literal, use double quotes\n\
    \   |\n27 |                 '(' | ')' | \")(\") => {\n   |                   \
    \          ~~~~\n\nerror: unexpected closing delimiter: `}`\n  --> /tmp/tmpi3r49jra.rs:51:1\n\
    \   |\n43 |                 _ => {}\n   |                      -- block is empty,\
    \ you might have not meant to close it\n...\n51 | }\n   | ^ unexpected closing\
    \ delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpi3r49jra.rs:26:21\n\
    \   |\n26 |             match c {\n   |                     ^ unclosed delimiter\n\
    27 |                 '(' | ')' | ')(') => {\n   |                            \
    \     ^ mismatched closing delimiter\n\nerror: aborting due to 3 previous errors\n\
    \n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut res = String::from(\"\
    No\");\n\n    for ele in lst.into_iter() {\n        if ele == ')' {\n        \
    \    stack.push(0);\n        } else {\n            stack.push(1);\n        }\n\
    \    }\n\n    for ele2 in lst.into_iter() {\n        for ele3 in lst.into_iter()\
    \ {\n            if stack.pop() == 0 {\n                if ele2 == ele3 {\n  \
    \                  res.push_str(\"Yes\");\n                } else {\n        \
    \            res.push_str(\"No\");\n                }\n            }\n       \
    \ }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n \
    \   assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpbadyzd6h.rs:19:16\n\
    \   |\n19 |         if ele == ')' {\n   |                ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbadyzd6h.rs:28:31\n   |\n28 |             if stack.pop()\
    \ == 0 {\n   |                               ^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<{integer}>`\n              found type\
    \ `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n28 |       \
    \      if stack.pop() == Some(0) {\n   |                               +++++ +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len() / 2).cmp(&lst.len() - 1) {\n        // all\
    \ parentheses are balanced, so the string is good\n        0 => String::from(\"\
    Yes\"),\n        // at least one pair of parentheses has unbalanced parentheses,\
    \ so the\n        // string is not good\n        _ => String::from(\"No\"),\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpls758_pm.rs:15:31\n   |\n\
    15 |     match (lst.len() / 2).cmp(&lst.len() - 1) {\n   |                   \
    \            ^^^^^^^^^^^^^^\n   |                               |\n   |      \
    \                         expected `&usize`, found `usize`\n   |             \
    \                  help: consider borrowing here: `&(&lst.len() - 1)`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpls758_pm.rs:17:9\n   |\n15 |     match (lst.len()\
    \ / 2).cmp(&lst.len() - 1) {\n   |           -----------------------------------\
    \ this expression has type `std::cmp::Ordering`\n16 |         // all parentheses\
    \ are balanced, so the string is good\n17 |         0 => String::from(\"Yes\"\
    ),\n   |         ^ expected enum `std::cmp::Ordering`, found integer\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst\n        .iter()\n        .cloned()\n        .fold(String::from(\"\
    Yes\"), |mut acc, x| {\n            if x.contains('(') && !acc.contains('(') {\n\
    \                acc.push_str(&*x.as_bytes());\n            } else if !x.contains('(')\
    \ && acc.contains('(') {\n                acc.push_str(&*acc.as_bytes());\n  \
    \          } else if acc.contains(')') {\n                acc.push_str(&*acc.as_bytes());\n\
    \            } else {\n                acc.push_str(&*x.as_bytes());\n       \
    \     }\n\n            acc\n        })\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv3uj_v45.rs:20:30\n   |\n\
    20 |                 acc.push_str(&*x.as_bytes());\n   |                     \
    \         ^^^^^^^^^^^^^^ expected `str`, found slice `[u8]`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&[u8]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpv3uj_v45.rs:22:30\n   |\n22 |              \
    \   acc.push_str(&*acc.as_bytes());\n   |                              ^^^^^^^^^^^^^^^^\
    \ expected `str`, found slice `[u8]`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&[u8]`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpv3uj_v45.rs:24:30\n   |\n24 |                 acc.push_str(&*acc.as_bytes());\n\
    \   |                              ^^^^^^^^^^^^^^^^ expected `str`, found slice\
    \ `[u8]`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&[u8]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv3uj_v45.rs:26:30\n\
    \   |\n26 |                 acc.push_str(&*x.as_bytes());\n   |              \
    \                ^^^^^^^^^^^^^^ expected `str`, found slice `[u8]`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&[u8]`\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    for s in lst {\n    \
    \    let mut stack_size = 0;\n        while let Some(s) = stack.iter_mut().next()\
    \ {\n            if s.len() == stack_size.len() {\n                break;\n  \
    \          }\n            stack_size += s.len();\n        }\n        stack.push_back(s);\n\
    \    }\n    let mut res = String::new();\n    loop {\n        let mut i = 0;\n\
    \        while let Some(mut s) = stack.iter_mut().next() {\n            if i <\
    \ s.len() && s[i] != ')' && s[i] != ']' {\n                res.push_str(&mut s[i..]);\n\
    \                i += 1;\n                break;\n            }\n            i\
    \ += 1;\n        }\n        if i == 0 {\n            break;\n        }\n     \
    \   res.push_str(&mut s[0..i]);\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpksnkodvh.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0425]: cannot find value `s` in this scope\n  --> /tmp/tmpksnkodvh.rs:40:27\n\
    \   |\n40 |         res.push_str(&mut s[0..i]);\n   |                        \
    \   ^ help: a local variable with a similar name exists: `i`\n\nerror[E0689]:\
    \ can't call method `len` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpksnkodvh.rs:19:38\n\
    \   |\n19 |             if s.len() == stack_size.len() {\n   |               \
    \                       ^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `i32`\n   |\n17 |         let mut stack_size: i32 = 0;\n   |          \
    \   ~~~~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0433, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    debug_assert!(lst.len() == 2);\n    match (lst[0], lst[1])\
    \ {\n        (String::from(\"(\"), String::from(\")\")) => \"Yes\",\n        (String::from(\"\
    )\"), String::from(\")\")) => \"No\",\n        (String::from(\"(\"), String::from(\"\
    )\")) => \"No\",\n        (String::from(\")\"), String::from(\"(\")) => \"Yes\"\
    ,\n        _ => panic!(\"Unexpected type for match_parens\"),\n    }\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `String::from`\n  --> /tmp/tmpqss4x_3e.rs:17:10\n   |\n17 |       \
    \  (String::from(\"(\"), String::from(\")\")) => \"Yes\",\n   |          ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpqss4x_3e.rs:17:29\n   |\n17 |         (String::from(\"(\"), String::from(\"\
    )\")) => \"Yes\",\n   |                             ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpqss4x_3e.rs:18:10\n   |\n18 |         (String::from(\"\
    )\"), String::from(\")\")) => \"No\",\n   |          ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpqss4x_3e.rs:18:29\n   |\n18 |         (String::from(\"\
    )\"), String::from(\")\")) => \"No\",\n   |                             ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpqss4x_3e.rs:19:10\n   |\n19 |         (String::from(\"(\"), String::from(\"\
    )\")) => \"No\",\n   |          ^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in\
    \ patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpqss4x_3e.rs:19:29\n   |\n19 |         (String::from(\"\
    (\"), String::from(\")\")) => \"No\",\n   | "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // count and mark parentheses '(' and ')'.\n    let mut counts\
    \ = HashMap::new();\n    for s in lst {\n        let len = s.len();\n        if\
    \ len == 1 {\n            counts.entry(s[0]).or_insert(0) += 1;\n        } else\
    \ if len == 2 && s[0] == '(' && s[1] == ')' {\n            counts.entry(s[0]).or_insert(1)\
    \ += 1;\n        } else {\n            counts.entry(s[0]).or_insert(0) += 1;\n\
    \            counts.entry(s[1]).or_insert(0) += 1;\n        }\n    }\n\n    //\
    \ check balanced parentheses.\n    // return 'No' if all parentheses are unbalanced.\n\
    \    for s in lst {\n        let len = s.len();\n        for c in s.chars() {\n\
    \            let count = counts.get(c);\n            if count > 1 && count < len\
    \ {\n                return String::from(\"No\");\n            }\n           \
    \ counts.entry(c).or_insert(0) += 1;\n        }\n    }\n    String::from(\"Yes\"\
    )\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmplmjly083.rs:16:22\n   |\n16 |     let mut counts = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplmjly083.rs:20:26\n\
    \   |\n20 |             counts.entry(s[0]).or_insert(0) += 1;\n   |          \
    \                ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help:\
    \ the trait `Index<{integer}>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0067]:\
    \ invalid left-hand side of assignment\n  --> /tmp/tmplmjly083.rs:20:45\n   |\n\
    20 |             counts.entry(s[0]).or_insert(0) += 1;\n   |             -------------------------------\
    \ ^^\n   |             |\n   |             cannot assign to this expression\n\n\
    error[E0277]: the type `String` cannot be indexed by `{integer}`\n  --> /tmp/tmplmjly083.rs:21:31\n\
    \   |\n21 |         } else if len == 2 && s[0] == '(' && s[1] == ')' {\n   | \
    \                              ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed b"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_impl(lst, &mut []).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_impl` in this scope\n\
    \  --> /tmp/tmp2zko4azs.rs:15:5\n   |\n15 |     match_parens_impl(lst, &mut []).to_string()\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 1 {\n        return String::from(\"Yes\");\n\
    \    }\n    if let Some(first_str) = lst.first() {\n        if lst.len() == 1\
    \ {\n            return String::from(\"Yes\");\n        }\n        if first_str\
    \ == \"(\" && lst.rest_iter().all(|s| s == \"(\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"(\").take(2).collect());\n        }\n        if first_str == \")\" &&\
    \ lst.rest_iter().all(|s| s == \"(\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"(\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"(\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"(\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"[\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"[\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"{\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"{\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"}\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"}\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"<\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"<\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"!\") {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"!\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"(\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"(\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s == \"<\")) {\n            return match_parens(lst.iter().skip_while(|s|\
    \ s == \"<\").take(2).collect());\n        }\n        if first_str == \",\" &&\
    \ lst.rest_iter().all(|s| s \n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `)`\n  --> /tmp/tmp4c9t9x3j.rs:28:65\n\
    \   |\n25 |         if first_str == \")\" && lst.rest_iter().all(|s| s == \"(\"\
    )) {\n   |                                                                   -\
    \ this opening brace...\n26 |             return match_parens(lst.iter().skip_while(|s|\
    \ s == \"(\").take(2).collect());\n27 |         }\n   |         - ...matches this\
    \ closing brace\n28 |         if first_str == \",\" && lst.rest_iter().all(|s|\
    \ s == \"(\")) {\n   |                                                       \
    \          ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter:\
    \ `)`\n  --> /tmp/tmp4c9t9x3j.rs:18:42\n   |\n18 |     if let Some(first_str)\
    \ = lst.first() {\n   |                                          ^ unclosed delimiter\n\
    ...\n22 |         if first_str == \"(\" && lst.rest_iter().all(|s| s == \"(\"\
    )) {\n   |                                                                 ^ mismatched\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmp4c9t9x3j.rs:14:45\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               ^ unclosed delimiter\n...\n25 |         if first_str\
    \ == \")\" && lst.rest_iter().all(|s| s == \"(\")) {\n   |                   \
    \                                              ^ mismatched closing delimiter\n\
    \nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut is_good = true;\n    for (left, right) in lst.iter().zip(reverse(lst.iter()))\
    \ {\n        if left.as_str().len() < right.as_str().len() {\n            is_good\
    \ = false;\n            break;\n        }\n    }\n    String::from(\"Yes\" if\
    \ is_good else \"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing condition for `if` expression\n  --> /tmp/tmpg9id19v6.rs:22:26\n\
    \   |\n22 |     String::from(\"Yes\" if is_good else \"No\")\n   |           \
    \               ^ expected if condition here\n\nerror: expected one of `)`, `,`,\
    \ `.`, `?`, or an operator, found keyword `if`\n  --> /tmp/tmpg9id19v6.rs:22:24\n\
    \   |\n22 |     String::from(\"Yes\" if is_good else \"No\")\n   |           \
    \             ^^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror[E0425]:\
    \ cannot find function `reverse` in this scope\n  --> /tmp/tmpg9id19v6.rs:16:41\n\
    \   |\n16 |     for (left, right) in lst.iter().zip(reverse(lst.iter())) {\n \
    \  |                                         ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (\n        match_parens_helper(\n            lst,\n \
    \           &mut Vec::new(),\n            &mut Vec::new(),\n            &mut Vec::new(),\n\
    \        ),\n        Vec::from(lst),\n    ) {\n        (Some(Ok(_)), v) => format!(\"\
    Yes\"),\n        (Some(Err(err)), v) => format!(\"No\"),\n        _ => format!(\"\
    No\"),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmprl98r_a5.rs:16:9\n   |\n16 |         match_parens_helper(\n   |\
    \         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut opening_chars = vec![];\n    let mut closing_chars\
    \ = vec![];\n    let mut chars = lst.iter().cloned().collect();\n    while let\
    \ Some(char) = {\n        if chars.len() == 1 {\n            return String::from(\"\
    No\");\n        }\n        if chars.len() > 1 {\n            chars = chars.clone();\n\
    \            opening_chars.push(*chars.last().unwrap());\n        }\n        let\
    \ mut opening = chars.next().unwrap();\n        let mut closing = chars.next().unwrap();\n\
    \        let mut next_char = chars.next();\n        while let Some(next_char)\
    \ = {\n            if next_char.is_none() {\n                break;\n        \
    \    }\n            if opening_chars.len() > 0 && opening_chars.last().unwrap()\
    \ != next_char.unwrap() {\n                break;\n            }\n           \
    \ opening_chars.push(*next_char.unwrap());\n            next_char = next_char.expect(\"\
    no further chars\");\n        }\n        let mut opening_len = opening_chars.len();\n\
    \        while opening_len != 0 && closing_chars.len() == 0 && opening_chars.last().unwrap()\
    \ == closing.last().unwrap() {\n            closing_chars.push(*opening_chars.last().unwrap());\n\
    \            opening_chars.pop();\n            opening_len -= 1;\n        }\n\
    \        closing_chars.pop();\n        closing_chars.pop();\n    }\n    if opening_chars.len()\
    \ == 0 || closing_chars.len() == 0 {\n        return String::from(\"No\");\n \
    \   }\n    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `let`\n  --> /tmp/tmpzii3mv1e.rs:39:9\n\
    \   |\n29 |           while let Some(next_char) = {\n   |  _________-----_-\n\
    \   | |         |\n   | |         while parsing the body of this `while` expression\n\
    30 | |             if next_char.is_none() {\n31 | |                 break;\n32\
    \ | |             }\n...  |\n37 | |             next_char = next_char.expect(\"\
    no further chars\");\n38 | |         }\n   | |_________- this `while` condition\
    \ successfully parsed\n39 |           let mut opening_len = opening_chars.len();\n\
    \   |           ^^^ expected `{`\n   |\nhelp: try placing this code inside a block\n\
    \   |\n39 |         { let mut opening_len = opening_chars.len(); }\n   |     \
    \    +                                            +\n\nerror: expected `{`, found\
    \ keyword `if`\n  --> /tmp/tmpzii3mv1e.rs:48:5\n   |\n18 |       while let Some(char)\
    \ = {\n   |  _____-----_-\n   | |     |\n   | |     while parsing the body of\
    \ this `while` expression\n19 | |         if chars.len() == 1 {\n20 | |      \
    \       return String::from(\"No\");\n21 | |         }\n...  |\n46 | |       \
    \  closing_chars.pop();\n47 | |     }\n   | |_____- this `while` condition successfully\
    \ parsed\n48 |       if opening_chars.len() == 0 || closing_chars.len() == 0 {\n\
    \   |       ^^ expected `{`\n   |\nhelp: try placing this code inside a block\n\
    \   |\n48 ~     { if opening_chars.len() == 0 || closing_chars.len() == 0 {\n\
    49 |         return String::from(\"No\");\n50 ~     } }\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = Vec::new();\n    stack.push(0);\n\
    \    let mut stack_size = 0;\n    let mut is_good = true;\n    for i in lst {\n\
    \        if i.chars().count() != 2 {\n            is_good = false;\n         \
    \   break;\n        }\n        stack_size = 0;\n        let mut stack_item = Vec::new();\n\
    \        while stack_size < stack.len() && stack_item != i {\n            stack_item.push(*stack.iter().cloned().next().unwrap());\n\
    \            stack_size++;\n        }\n        if stack_size == stack.len() {\n\
    \            is_good = false;\n            break;\n        }\n        stack.push(stack_item.clone());\n\
    \        stack_size++;\n    }\n    if is_good {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpgqgin9ea.rs:28:23\n\
    \   |\n28 |             stack_size++;\n   |                       ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |             { let\
    \ tmp = stack_size; stack_size += 1; tmp };\n   |             +++++++++++    \
    \       ~~~~~~~~~~~~~~~~~~~~~~~~\n28 -             stack_size++;\n28 +       \
    \      stack_size += 1;\n   | \n\nerror: Rust has no postfix increment operator\n\
    \  --> /tmp/tmpgqgin9ea.rs:35:19\n   |\n35 |         stack_size++;\n   |     \
    \              ^^ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n\
    \   |\n35 |         { let tmp = stack_size; stack_size += 1; tmp };\n   |    \
    \     +++++++++++           ~~~~~~~~~~~~~~~~~~~~~~~~\n35 -         stack_size++;\n\
    35 +         stack_size += 1;\n   | \n\nerror[E0277]: can't compare `Vec<_>` with\
    \ `String`\n  --> /tmp/tmpgqgin9ea.rs:26:54\n   |\n26 |         while stack_size\
    \ < stack.len() && stack_item != i {\n   |                                   \
    \                   ^^ no implementation for `Vec<_> == String`\n   |\n   = help:\
    \ the trait `PartialEq<String>` is not implemented for `Vec<_>`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <Vec<T,\
    \ A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n\
    \             <Vec<T, A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut\
    \ [U]>>\n             <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A>\
    \ as PartialEq<[U]>>\n\nerror[E0614]: type `usize` cannot be dereferenced\n  -->\
    \ /tmp/tmpgqgin9ea.rs:27:29\n   |\n27 |             stack_item.push(*stack.iter().cloned().next().unwrap());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpgqgin9ea.rs:34:20\n   |\n34 |         stack.push(stack_item.clone());\n\
    \   |                    ^^^^^^^^^^^^^^^^^^ expected `usize`, found struct `Vec`\n\
    \   |\n   = note: expected type `usize`\n            found struct `Vec<_>`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed ex"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut pos = 0;\n    let mut res = String::from(\"\");\n \
    \   loop {\n        let curr = lst[pos].len();\n        if pos == lst.len() {\n\
    \            break;\n        }\n        match lst[pos] {\n            \"(\" =>\
    \ {\n                pos += 1;\n                let mut c = false;\n         \
    \       while c && pos < lst.len() {\n                    c = true;\n        \
    \            match lst[pos] {\n                        \")\" => {\n          \
    \                  break;\n                        },\n                      \
    \  \")\" => {\n                            c = false;\n                      \
    \      pos += 1;\n                        },\n                        _ => {\n\
    \                            pos += 1;\n                        }\n          \
    \          }\n                }\n                res = res.to_string() + String::from(\"\
    Yes\");\n            },\n            \")\" => {\n                break;\n    \
    \        },\n            _ => {\n                res = res.to_string() + String::from(\"\
    No\");\n            }\n        }\n        pos += 1;\n    }\n    return res;\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjl9121lb.rs:22:15\n   |\n\
    22 |         match lst[pos] {\n   |               ^^^^^^^^ expected `&str`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjl9121lb.rs:28:27\n\
    \   |\n28 |                     match lst[pos] {\n   |                       \
    \    ^^^^^^^^ expected `&str`, found struct `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjl9121lb.rs:41:41\n   |\n41 |                 res = res.to_string()\
    \ + String::from(\"Yes\");\n   |                                         ^^^^^^^^^^^^^^^^^^^\n\
    \   |                                         |\n   |                        \
    \                 expected `&str`, found struct `String`\n   |               \
    \                          help: consider borrowing here: `&String::from(\"Yes\"\
    )`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjl9121lb.rs:47:41\n   |\n\
    47 |                 res = res.to_string() + String::from(\"No\");\n   |     \
    \                                    ^^^^^^^^^^^^^^^^^^\n   |                \
    \                         |\n   |                                         expected\
    \ `&str`, found struct `String`\n   |                                        \
    \ help: consider borrowing here: `&String::from(\"No\")`\n\nerror: aborting due\
    \ to 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut ans = String::from(\"\
    No\");\n\n    for elem in lst {\n        if elem.is_empty() {\n            continue;\n\
    \        }\n\n        if elem.chars().any(|c| c == ')') {\n            if stack.len()\
    \ == 0 {\n                return ans;\n            }\n            stack.pop();\n\
    \        } else if elem.chars().any(|c| c == '(') {\n            stack.push(elem);\n\
    \        }\n    }\n\n    ans = \"Yes\".to_string();\n    ans\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpz_jli6gb.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut result = String::from(\"No\");\n    for s in lst {\n\
    \        let mut cur_char = s.chars().nth(0);\n        let mut has_open_bracket\
    \ = false;\n        let mut has_close_bracket = false;\n        while cur_char\
    \ != None {\n            if cur_char == b'(' {\n                has_open_bracket\
    \ = true;\n            } else if cur_char == b')' {\n                has_close_bracket\
    \ = true;\n            } else {\n                break;\n            }\n     \
    \       cur_char = cur_char.next()\n        }\n        if has_open_bracket {\n\
    \            if !has_close_bracket {\n                result.push_str(&s);\n \
    \           }\n        } else {\n            if has_close_bracket {\n        \
    \        result.push_str(&s);\n            }\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqrw8qp_l.rs:21:28\n   |\n\
    21 |             if cur_char == b'(' {\n   |                            ^^^^ expected\
    \ enum `Option`, found `u8`\n   |\n   = note: expected enum `Option<char>`\n \
    \             found type `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpqrw8qp_l.rs:23:35\n\
    \   |\n23 |             } else if cur_char == b')' {\n   |                   \
    \                ^^^^ expected enum `Option`, found `u8`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `u8`\n\nerror[E0599]: no method\
    \ named `next` found for enum `Option` in the current scope\n  --> /tmp/tmpqrw8qp_l.rs:28:33\n\
    \   |\n28 |             cur_char = cur_char.next()\n   |                     \
    \            ^^^^ method not found in `Option<char>`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_recur(Vec::from(lst), 0, \"\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_recur` in this scope\n\
    \  --> /tmp/tmp_o8jz745.rs:15:5\n   |\n15 |     match_parens_recur(Vec::from(lst),\
    \ 0, \"\")\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut ans = String::from(\"No\");\n    for (i, s) in lst.iter().enumerate()\
    \ {\n        if s.is_empty() {\n            ans = \"No\";\n            break;\n\
    \        }\n        let mut inside_parantheses = 0;\n        for c in s.chars()\
    \ {\n            if c == '(' {\n                inside_parantheses += 1;\n   \
    \         } else if c == '(' && inside_parantheses > 0 {\n                inside_parantheses\
    \ += 1;\n            } else if c == ')' {\n                inside_parantheses\
    \ -= 1;\n            } else if c == ')' && inside_parantheses == 0 {\n       \
    \         ans = \"Yes\";\n                break;\n            }\n        }\n \
    \   }\n    ans\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb0odqgwy.rs:18:19\n   |\n\
    15 |     let mut ans = String::from(\"No\");\n   |                   ------------------\
    \ expected due to this value\n...\n18 |             ans = \"No\";\n   |      \
    \             ^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                   |\n   |                   expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb0odqgwy.rs:30:23\n\
    \   |\n15 |     let mut ans = String::from(\"No\");\n   |                   ------------------\
    \ expected due to this value\n...\n30 |                 ans = \"Yes\";\n   | \
    \                      ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                       |\n   |                       expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::from(\"\");\n    let mut rev = lst.reverse();\n\
    \    let mut ans = String::from(\"\");\n    while rev.len() > 0 {\n        if\
    \ cur == String::from(\"\") && rev.len() > 1 {\n            if rev[0][0] == rev[1][0]\
    \ {\n                ans = cur;\n                cur = String::from(\"\");\n \
    \               rev = rev[1..];\n            } else {\n                cur = String::from(\"\
    \").concat(rev.remove(0));\n            }\n        } else if cur != String::from(\"\
    \") {\n            if rev[0][0] == rev[1][0] {\n                cur = cur + rev.remove(0).to_string();\n\
    \            } else {\n                ans = ans + cur;\n                cur =\
    \ String::from(\"\").concat(rev.remove(0));\n            }\n        } else if\
    \ rev.len() > 1 {\n            cur = String::from(\"\").concat(rev.remove(0));\n\
    \        }\n    }\n    ans = ans.to_string();\n    return if ans.contains(\"()\"\
    ) || ans.contains(\"[]\") {\n        String::from(\"Yes\")\n    } else {\n   \
    \     String::from(\"No\")\n    };\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmp4f3f_5yf.rs:18:15\n   |\n18 |     while rev.len() > 0 {\n\
    \   |               ^^^ method not found in `()`\n\nerror[E0599]: no method named\
    \ `len` found for unit type `()` in the current scope\n  --> /tmp/tmp4f3f_5yf.rs:19:43\n\
    \   |\n19 |         if cur == String::from(\"\") && rev.len() > 1 {\n   |    \
    \                                       ^^^ method not found in `()`\n\nerror[E0608]:\
    \ cannot index into a value of type `()`\n  --> /tmp/tmp4f3f_5yf.rs:20:16\n  \
    \ |\n20 |             if rev[0][0] == rev[1][0] {\n   |                ^^^^^^\
    \ help: to access tuple elements, use: `rev.0`\n\nerror[E0608]: cannot index into\
    \ a value of type `()`\n  --> /tmp/tmp4f3f_5yf.rs:20:29\n   |\n20 |          \
    \   if rev[0][0] == rev[1][0] {\n   |                             ^^^^^^ help:\
    \ to access tuple elements, use: `rev.1`\n\nerror[E0608]: cannot index into a\
    \ value of type `()`\n  --> /tmp/tmp4f3f_5yf.rs:23:23\n   |\n23 |            \
    \     rev = rev[1..];\n   |                       ^^^^^^^^\n   |\n   = help: to\
    \ access tuple elements, use tuple indexing syntax (e.g., `tuple.0`)\n\nerror[E0599]:\
    \ no method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp4f3f_5yf.rs:25:40\n   |\n25 |                 cur = String::from(\"\"\
    ).concat(rev.remove(0));\n   |                                        ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `remove` found for unit\
    \ type `()` in the current scope\n  --> /tmp/tmp4f3f_5yf.rs:25:51\n   |\n25 |\
    \                 cur = String::from(\"\").concat(rev.remove(0));\n   |      \
    \                                             ^^^^^^ method not found in `()`\n\
    \nerror[E0608]: cannot index into a value of type `()`\n  --> /tmp/tmp4f3f_5yf.rs:28:16\n\
    \   |\n28 |             if rev[0][0] == rev[1][0] {\n   |                ^^^^^^\
    \ help: to access tuple elements, use: `rev.0`\n\nerror[E0608]: cannot index into\
    \ a value of type `()`\n  --> /tmp/tmp4f3f_5yf.rs:28:29\n   |\n28 |          \
    \   if rev[0][0] == rev[1][0] {\n   |                    "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        0 => \"No\".to_string(),\n     \
    \   _ => helper(lst, 0),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `helper` in this scope\n  --> /tmp/tmp22rg8wp3.rs:17:14\n\
    \   |\n17 |         _ => helper(lst, 0),\n   |              ^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n\n    for el in lst {\n      \
    \  if el == \"(\" || el == \")\" {\n            stack.push(el);\n        }\n \
    \   }\n\n    match stack.len() {\n        0 => \"No\",\n        1 => \"Yes\",\n\
    \        _ => {\n            let mut res = String::new();\n\n            for el\
    \ in lst.iter() {\n                if el == \"(\" {\n                    res.push_str(&stack.pop().unwrap());\n\
    \                } else if el == \")\" {\n                    res.push_str(&stack.pop().unwrap());\n\
    \                    res.push_str(\")\");\n                }\n            }\n\n\
    \            res\n        }\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpib_dpsnp.rs:24:14\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n...\n24 | \
    \        0 => \"No\",\n   |              ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |              |\n   |              expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::<(Vec<String>, usize)>::new();\n\
    \    stack.push_back((vec![String::from(\"(\"), String::from(\")\")], 0));\n\n\
    \    let mut res = String::from(\"No\");\n    while !stack.is_empty() {\n    \
    \    let (sub, level) = stack.pop_front().unwrap();\n        res.push_str(&*sub);\n\
    \        let mut has_left = false;\n        let mut has_right = false;\n     \
    \   for (pos, c) in lst.iter().enumerate() {\n            if c == '(' {\n    \
    \            if level == 0 {\n                    has_left = true;\n         \
    \       } else {\n                    let mut sub_stack = VecDeque::<(Vec<String>,\
    \ usize)>::new();\n                    sub_stack.push_back((sub.clone(), level\
    \ + 1));\n                    stack.push_back(sub_stack);\n                }\n\
    \            } else if c == ')' {\n                if level == 0 {\n         \
    \           has_right = true;\n                } else {\n                    let\
    \ mut sub_stack = VecDeque::<(Vec<String>, usize)>::new();\n                 \
    \   sub_stack.push_back((sub.clone(), level - 1));\n                    stack.push_back(sub_stack);\n\
    \                }\n            }\n        }\n        if !has_left || !has_right\
    \ {\n            return res;\n        }\n    }\n    res\n}\n\nfn main() {\n  \
    \  let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpgoyrfkuo.rs:15:21\n   |\n15 |     let mut stack = VecDeque::<(Vec<String>,\
    \ usize)>::new();\n   |                     ^^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::VecDeque;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `VecDeque`\n\
    \  --> /tmp/tmpgoyrfkuo.rs:29:41\n   |\n29 |                     let mut sub_stack\
    \ = VecDeque::<(Vec<String>, usize)>::new();\n   |                           \
    \              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `VecDeque`\n  --> /tmp/tmpgoyrfkuo.rs:37:41\n\
    \   |\n37 |                     let mut sub_stack = VecDeque::<(Vec<String>, usize)>::new();\n\
    \   |                                         ^^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::VecDeque;\n\
    \   |\n\nerror[E0277]: can't compare `&String` with `char`\n  --> /tmp/tmpgoyrfkuo.rs:25:18\n\
    \   |\n25 |             if c == '(' {\n   |                  ^^ no implementation\
    \ for `&String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&String` with `char`\n  --> /tmp/tmpgoyrfkuo.rs:33:25\n   |\n33 |         \
    \    } else if c == ')' {\n   |                         ^^ no implementation for\
    \ `&String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&String`\n   = help: the following other"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut strings:\
    \ Vec<usize> = Vec::new();\n    for s in lst {\n        if s.is_empty() {\n  \
    \          continue;\n        }\n        stack.push((s.len() - 1, 0));\n     \
    \   strings.push(s.len() - 1);\n    }\n\n    let mut s = String::new();\n\n  \
    \  while stack.is_not_empty() {\n        let (s, pos) = stack.pop().unwrap();\n\
    \        let (len1, len2) = strings[pos].len();\n        let (len2, len3) = strings[pos\
    \ + 1].len();\n        for l in 0..len2 {\n            for r in 0..len1 {\n  \
    \              if !(r == 0 && l == 0) {\n                    s += s.chars().nth(pos\
    \ + l + r).unwrap();\n                }\n            }\n        }\n        if\
    \ s.chars().count() != (len1 + len2) {\n            continue;\n        }\n   \
    \     return String::from(s);\n    }\n    String::from(\"No\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8fowx6j.rs:21:20\n   |\n\
    21 |         stack.push((s.len() - 1, 0));\n   |                    ^^^^^^^^^^^^^^^^\
    \ expected `usize`, found tuple\n   |\n   = note: expected type `usize`\n    \
    \         found tuple `(usize, {integer})`\n\nerror[E0599]: no method named `is_not_empty`\
    \ found for struct `Vec<usize>` in the current scope\n  --> /tmp/tmpd8fowx6j.rs:27:17\n\
    \   |\n27 |     while stack.is_not_empty() {\n   |                 ^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_empty`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd8fowx6j.rs:28:13\n   |\n28 |         let (s,\
    \ pos) = stack.pop().unwrap();\n   |             ^^^^^^^^   --------------------\
    \ this expression has type `usize`\n   |             |\n   |             expected\
    \ `usize`, found tuple\n   |\n   = note: expected type `usize`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = String::new();\n\n    for s in lst {\n    \
    \    if s.contains(\"(\") || s.contains(\")\") {\n            stack += s;\n  \
    \      } else {\n            if stack.contains(s) {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    String::from(\"Yes\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9qn20_8l.rs:19:22\n   |\n\
    19 |             stack += s;\n   |                      ^\n   |              \
    \        |\n   |                      expected `&str`, found struct `String`\n\
    \   |                      help: consider borrowing here: `&s`\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `String`\n    --> /tmp/tmp9qn20_8l.rs:21:31\n\
    \     |\n21   |             if stack.contains(s) {\n     |                   \
    \   -------- ^ expected an implementor of trait `Pattern<'_>`\n     |        \
    \              |\n     |                      required by a bound introduced by\
    \ this call\n     |\n     = note: the trait bound `String: Pattern<'_>` is not\
    \ satisfied\n     = note: required because of the requirements on the impl of\
    \ `Pattern<'_>` for `String`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider borrowing here\n     |\n21   |             if stack.contains(&s)\
    \ {\n     |                               +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![\"()\"] => \"Yes\",\n        vec![\"\
    )\"] => \"No\",\n        _ => \"\".to_string(),\n    }\n}\n\nfn main() {\n   \
    \ let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpawpcni2x.rs:16:9\n\
    \   |\n16 |         vec![\"()\"] => \"Yes\",\n   |         ^^^^^^^^^^\n   |\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't allowed\
    \ in patterns\n  --> /tmp/tmpawpcni2x.rs:17:9\n   |\n17 |         vec![\")\"]\
    \ => \"No\",\n   |         ^^^^^^^^^\n   |\n   = note: this error originates in\
    \ the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpawpcni2x.rs:16:23\n   |\n14 |\
    \ fn match_parens(lst: Vec<String>) -> String {\n   |                        \
    \              ------ expected `String` because of return type\n15 |     match\
    \ lst {\n16 |         vec![\"()\"] => \"Yes\",\n   |                       ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `&str`\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    let mut res = String::new();\n\
    \n    for s in lst {\n        if s.is_empty() || (s.is_empty() && stack.is_empty())\
    \ {\n            return String::from(\"No\");\n        }\n        if s.is_empty()\
    \ {\n            res.push_str(\"(\");\n        }\n        stack.push_back(s);\n\
    \        if let Some(top) = stack.pop_back() {\n            if top.is_empty()\
    \ {\n                res.push_str(\")\");\n            } else if stack.is_empty()\
    \ {\n                res.push_str(\"(\");\n            } else {\n            \
    \    res.push_str(\")\");\n                res.push_str(top);\n            }\n\
    \        }\n    }\n\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmplgyfvsw_.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.iter().fold(String::new(), |acc, x| {\n        match\
    \ (acc.len() as i64, x.len() as i64) {\n            (acc, x) => acc + (acc.len()\
    \ - x.len()),\n            (acc, _)  => acc + (acc.len() - 1),\n        }\n  \
    \  })\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `}`\n  -->\
    \ /tmp/tmpyrte0xw6.rs:21:1\n   |\n15 |     match lst.iter().fold(String::new(),\
    \ |acc, x| {\n   |     ----- while parsing this `match` expression\n...\n20 |\
    \     })\n   |       - expected one of `.`, `?`, `{`, or an operator\n21 | }\n\
    \   | ^ unexpected token\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    let mut stack = Vec::new();\n\
    \    for s in lst {\n        let mut curr = s;\n        while !stack.is_empty()\
    \ && curr.contains('(') {\n            stack.push(curr);\n            curr = curr.chars().next().unwrap();\n\
    \        }\n        while !stack.is_empty() && curr.contains(')') {\n        \
    \    let v = stack.pop().unwrap();\n            curr += v;\n        }\n      \
    \  if stack.is_empty() {\n            s += curr;\n        }\n    }\n    \n   \
    \ if s == \"()()\" {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptkjozy_n.rs:21:20\n   |\n\
    18 |         let mut curr = s;\n   |                        - expected due to\
    \ this value\n...\n21 |             curr = curr.chars().next().unwrap();\n   |\
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptkjozy_n.rs:25:21\n\
    \   |\n25 |             curr += v;\n   |                     ^\n   |         \
    \            |\n   |                     expected `&str`, found struct `String`\n\
    \   |                     help: consider borrowing here: `&v`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmptkjozy_n.rs:28:18\n   |\n28 |             s\
    \ += curr;\n   |                  ^^^^\n   |                  |\n   |        \
    \          expected `&str`, found struct `String`\n   |                  help:\
    \ consider borrowing here: `&curr`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut state = Vec::new();\n    let mut current = String::from(\"\
    \");\n    let mut pos = 0;\n    let mut current_len = String::from(\"\");\n  \
    \  for s in lst {\n        if s.len() == 0 {\n            continue;\n        }\n\
    \        let mut state = Vec::new();\n        for c in s.chars() {\n         \
    \   match c {\n                '(' | ')' as char => state.push(c),\n         \
    \       _ => {\n                    state.push(char);\n                    state.push(current);\n\
    \                }\n            }\n        }\n        if current.len() != state.len()\
    \ {\n            return String::from(\"No\");\n        }\n        let current_len\
    \ = current.len();\n        if pos != 0 {\n            if pos < current_len {\n\
    \                return String::from(\"No\");\n            }\n            pos\
    \ += 1;\n        }\n        let mut pos = current_len;\n        if current.len()\
    \ == 0 {\n            pos += 1;\n        }\n        if pos > current_len {\n \
    \           pos = current_len;\n        }\n        current = String::from(\"\"\
    );\n        current = state[..pos].join(\"\").to_string();\n    }\n    match current\
    \ {\n        \"\" | current => String::from(\"Yes\"),\n        _ => String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmp4nuhrvl_.rs:26:27\n   |\n26 |                 '(' | ')'\
    \ as char => state.push(c),\n   |                           ^^ expected one of\
    \ `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0408]: variable `current` is\
    \ not bound in all patterns\n  --> /tmp/tmp4nuhrvl_.rs:54:9\n   |\n54 |      \
    \   \"\" | current => String::from(\"Yes\"),\n   |         ^^   ------- variable\
    \ not in all patterns\n   |         |\n   |         pattern doesn't bind `current`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4nuhrvl_.rs:54:9\n   |\n53 | \
    \    match current {\n   |           ------- this expression has type `String`\n\
    54 |         \"\" | current => String::from(\"Yes\"),\n   |         ^^ expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0408.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    fn is_balanced(s: &str) -> bool {\n        &s[1..s.len()] ==\
    \ &'(' || &s[1..s.len()] == &')'\n    }\n\n    fn is_good(s: &str) -> bool {\n\
    \        match_parens(s.split_str(\"()\")) == s\n    }\n\n    match lst.iter().find(|s|\
    \ is_balanced(s)) {\n        Some(i) if is_good(i) => String::from(\"Yes\"),\n\
    \        Some(i) => String::from(\"No\"),\n        _ => String::from(\"No\"),\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `str` with `char`\n  --> /tmp/tmpw588qabh.rs:16:24\n\
    \   |\n16 |         &s[1..s.len()] == &'(' || &s[1..s.len()] == &')'\n   |   \
    \                     ^^ no implementation for `str == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `str`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&char>` for `&str`\n\nerror[E0277]: can't compare `str` with\
    \ `char`\n  --> /tmp/tmpw588qabh.rs:16:50\n   |\n16 |         &s[1..s.len()] ==\
    \ &'(' || &s[1..s.len()] == &')'\n   |                                       \
    \           ^^ no implementation for `str == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `str`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&char>` for `&str`\n\nerror[E0599]: no method named `split_str`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpw588qabh.rs:20:24\n\
    \   |\n20 |         match_parens(s.split_str(\"()\")) == s\n   |             \
    \           ^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `split`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut counts = Vec::new();\n    for elem in lst {\n     \
    \   counts.push(elem.chars().filter(|&c| c == '(' || c == '[' || c == '{').count());\n\
    \    }\n    let mut sum = 0;\n    for elem in lst {\n        let count = counts.remove(elem);\n\
    \        sum += count;\n    }\n    if sum == lst.len() {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp86as_yu6.rs:21:35\n   |\n\
    21 |         let count = counts.remove(elem);\n   |                          \
    \         ^^^^ expected `usize`, found struct `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut index = 0;\n    let mut char_count = 0;\n    loop {\n\
    \        if index < lst.len() && lst[index].is_empty() {\n            char_count\
    \ += 1;\n            index += 1\n        } else if char_count > 2 {\n        \
    \    return String::from(\"No\");\n        } else {\n            char_count +=\
    \ 1;\n            index += 1\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpcsk4ac1x.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![String::from(\"()\"), String::from(\"\
    )]\")] => \"Yes\",\n        _ => \"No\",\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmp1sm5tbhg.rs:16:9\n\
    \   |\n16 |         vec![String::from(\"()\"), String::from(\")]\")] => \"Yes\"\
    ,\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note:\
    \ this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1sm5tbhg.rs:16:57\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n15 |\
    \     match lst {\n16 |         vec![String::from(\"()\"), String::from(\")]\"\
    )] => \"Yes\",\n   |                                                         ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \                                       |\n   |                              \
    \                           expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"\");\n    let mut stack = Vec::new();\n\
    \    for ele in lst {\n        if ele == \"(\" {\n            stack.push(ele);\n\
    \        }\n        if ele == \")\" {\n            if stack.len() == 0 {\n   \
    \             return String::from(\"No\");\n            } else {\n           \
    \     let mut tmp = stack.pop().to_string();\n                if tmp == String::from(\"\
    (\") && stack.len() > 0 {\n                    tmp += \")\";\n               \
    \ }\n                res += tmp;\n            }\n        }\n    }\n    res +=\
    \ \"Yes\".to_string();\n    return res.to_string();\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<String>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmpakj1w5f2.rs:25:43\n    |\n25  |                   let mut tmp\
    \ = stack.pop().to_string();\n    |                                          \
    \   ^^^^^^^^^ `Option<String>` cannot be formatted with the default formatter\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Option<String>: std::fmt::Display`\n            which is required by `Option<String>:\
    \ ToString`\n\nerror[E0277]: cannot add-assign `&str` to `&str`\n  --> /tmp/tmpakj1w5f2.rs:27:25\n\
    \   |\n27 |                     tmp += \")\";\n   |                         ^^\
    \ no implementation for `&str += &str`\n   |\n   = help: the trait `AddAssign<&str>`\
    \ is not implemented for `&str`\n   = help: the trait `AddAssign<&str>` is implemented\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpakj1w5f2.rs:33:12\n\
    \   |\n33 |     res += \"Yes\".to_string();\n   |            ^^^^^^^^^^^^^^^^^\n\
    \   |            |\n   |            expected `&str`, found struct `String`\n \
    \  |            help: consider borrowing here: `&\"Yes\".to_string()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len(), lst.iter().zip(&lst[1..]).count()) {\n  \
    \      (2, ()) => String::from(\"No\"),\n        (3, (_, _)) => String::from(\"\
    Yes\"),\n        _ => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmponpz48xi.rs:16:13\n   |\n\
    15 |     match (lst.len(), lst.iter().zip(&lst[1..]).count()) {\n   |        \
    \   ---------------------------------------------- this expression has type `(usize,\
    \ usize)`\n16 |         (2, ()) => String::from(\"No\"),\n   |             ^^\
    \ expected `usize`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmponpz48xi.rs:17:13\n\
    \   |\n15 |     match (lst.len(), lst.iter().zip(&lst[1..]).count()) {\n   | \
    \          ---------------------------------------------- this expression has\
    \ type `(usize, usize)`\n16 |         (2, ()) => String::from(\"No\"),\n17 | \
    \        (3, (_, _)) => String::from(\"Yes\"),\n   |             ^^^^^^ expected\
    \ `usize`, found tuple\n   |\n   = note: expected type `usize`\n             found\
    \ tuple `(_, _)`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        return \"No\";\n    }\n    let\
    \ mut ans = String::from(\"No\");\n    let mut is_good = true;\n    let mut stack\
    \ = Stack::new();\n    for s in lst {\n        if s.len() == 0 {\n           \
    \ is_good = false;\n        }\n        match s.chars().next().unwrap() {\n   \
    \         '(' | ')' | ')(') => stack.pop_all(|x| x.is_open_bracket()),\n     \
    \       _ => stack.push(false),\n        }\n        if is_good {\n           \
    \ ans.push_str(&s);\n        }\n        if !stack.empty() {\n            let first\
    \ = stack.pop();\n            if !first {\n                is_good = false;\n\
    \            }\n        }\n    }\n    if is_good {\n        ans.push_str(&ans[..]);\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmpgja_201w.rs:26:25\n\
    \   |\n26 |             '(' | ')' | ')(') => stack.pop_all(|x| x.is_open_bracket()),\n\
    \   |                         ^^^^\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n26 |             '(' | ')' | \")(\") => stack.pop_all(|x|\
    \ x.is_open_bracket()),\n   |                         ~~~~\n\nerror: unexpected\
    \ closing delimiter: `}`\n  --> /tmp/tmpgja_201w.rs:43:1\n   |\n39 |     if is_good\
    \ {\n   |                - this opening brace...\n40 |         ans.push_str(&ans[..]);\n\
    41 |     }\n   |     - ...matches this closing brace\n42 |     ans\n43 | }\n \
    \  | ^ unexpected closing delimiter\n\nerror: mismatched closing delimiter: `)`\n\
    \  --> /tmp/tmpgja_201w.rs:25:41\n   |\n25 |         match s.chars().next().unwrap()\
    \ {\n   |                                         ^ unclosed delimiter\n26 | \
    \            '(' | ')' | ')(') => stack.pop_all(|x| x.is_open_bracket()),\n  \
    \ |                             ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::new();\n    for elem in lst {\n     \
    \   if elem == \"(\" || elem == \")\" {\n            cur.push_str(elem);\n   \
    \     } else {\n            if cur.len() == 0 {\n                cur.push_str(\"\
    No\");\n            } else {\n                cur.push_str(\"Yes\");\n       \
    \     }\n        }\n    }\n    cur\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_vf4_y3h.rs:18:26\n   |\n\
    18 |             cur.push_str(elem);\n   |                          ^^^^\n   |\
    \                          |\n   |                          expected `&str`, found\
    \ struct `String`\n   |                          help: consider borrowing here:\
    \ `&elem`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\";\n    }\n\n    if\
    \ match_parens_helper(&lst[0], &lst[1]) {\n        String::from(\"Yes\")\n   \
    \ } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmpq3cpdn4x.rs:19:8\n   |\n19 |     if match_parens_helper(&lst[0],\
    \ &lst[1]) {\n   |        ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq3cpdn4x.rs:16:16\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n15 |     if lst.len() != 2 {\n16 |        \
    \ return \"No\";\n   |                ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    stack.push((String::from(\"\
    (\"), 0));\n    stack.push((String::from(\")\"), 0));\n    let mut str = String::from(\"\
    No\");\n    while let Some((curr, len)) = stack.pop() {\n        let mut start\
    \ = curr.to_string();\n        if len == 0 {\n            str = String::from(\"\
    Yes\");\n            break;\n        }\n        let mut cur = str;\n        let\
    \ mut found = false;\n        for _ in 0..len {\n            if curr == String::from(\"\
    (\") {\n                if stack.pop().is_none() {\n                    found\
    \ = true;\n                    break;\n                }\n                start\
    \ += String::from(\"(\");\n            } else if curr == String::from(\")\") {\n\
    \                if stack.top().is_none() {\n                    found = true;\n\
    \                    break;\n                }\n                cur = String::from(\"\
    (\");\n                start += String::from(\")\");\n            } else {\n \
    \               let (str, idx) = stack.pop();\n                cur += str;\n \
    \               start += cur;\n                cur = String::from(\"(\");\n  \
    \          }\n        }\n        if !found {\n            str = String::from(\"\
    No\");\n            break;\n        }\n    }\n    str\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpkswjcqt0.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![String::from(\"(\")] | vec![String::from(\"\
    )\")] => String::from(\"Yes\"),\n        vec![String::from(\")\"), String::from(\"\
    (\")] => String::from(\"No\"),\n        _ => String::from(\"No\"),\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpivjvz081.rs:16:9\n\
    \   |\n16 |         vec![String::from(\"(\")] | vec![String::from(\")\")] => String::from(\"\
    Yes\"),\n   |         ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this error originates\
    \ in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more\
    \ info)\n\nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpivjvz081.rs:16:35\n\
    \   |\n16 |         vec![String::from(\"(\")] | vec![String::from(\")\")] => String::from(\"\
    Yes\"),\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't allowed\
    \ in patterns\n  --> /tmp/tmpivjvz081.rs:17:9\n   |\n17 |         vec![String::from(\"\
    )\"), String::from(\"(\")] => String::from(\"No\"),\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n\n    loop {\n        let mut i\
    \ = 0;\n        let mut last = Vec::new();\n\n        for v in lst.iter() {\n\
    \            match v.chars().next() {\n                Some(c) => {\n        \
    \            if c == '(' || c == '[' || c == '{' {\n                        last.push(c);\n\
    \                    } else if c == '}' || c == ']' || c == ')' {\n          \
    \              if last.is_empty() {\n                            return String::from(\"\
    No\");\n                        }\n                        if last.is_len() ==\
    \ 1 {\n                            if last[0] == c {\n                       \
    \         break;\n                            }\n                        }\n \
    \                       s.push_str(&last);\n                        last.clear();\n\
    \                    }\n                }\n                None => break,\n  \
    \          }\n        }\n\n        if last.is_empty() {\n            return String::from(\"\
    No\");\n        }\n        if last.is_len() == 1 {\n            if last[0] ==\
    \ ')' {\n                break;\n            }\n        }\n        s.push_str(&last);\n\
    \    }\n\n    s.to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_len` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmpw8y__xe9.rs:30:33\n   |\n30 |             \
    \            if last.is_len() == 1 {\n   |                                 ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw8y__xe9.rs:35:36\n   |\n35 |              \
    \           s.push_str(&last);\n   |                                    ^^^^^\
    \ expected `str`, found struct `Vec`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&Vec<char>`\n\nerror[E0599]: no method named `is_len`\
    \ found for struct `Vec<char>` in the current scope\n  --> /tmp/tmpw8y__xe9.rs:46:17\n\
    \   |\n46 |         if last.is_len() == 1 {\n   |                 ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw8y__xe9.rs:51:20\n   |\n51 |         s.push_str(&last);\n\
    \   |                    ^^^^^ expected `str`, found struct `Vec`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&Vec<char>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        [] => \"No\",\n        x => match_parens(vec![x]),\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0529]: expected an array or slice, found `Vec<String>`\n  --> /tmp/tmpreed3ero.rs:16:9\n\
    \   |\n15 |     match lst {\n   |           --- help: consider slicing here: `lst[..]`\n\
    16 |         [] => \"No\",\n   |         ^^ pattern cannot match with input type\
    \ `Vec<String>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpreed3ero.rs:16:15\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n15 |\
    \     match lst {\n16 |         [] => \"No\",\n   |               ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |               |\n   |  \
    \             expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpreed3ero.rs:17:32\n   |\n17 |         x => match_parens(vec![x]),\n\
    \   |                                ^ expected struct `String`, found struct\
    \ `Vec`\n   |\n   = note: expected struct `String`\n              found struct\
    \ `Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0529.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut is_good = false;\n\n    // Keep track of open and closed\
    \ parens\n    let mut open_count = 0; // count of open parens\n    let mut close_count\
    \ = 0; // count of closed parens\n\n    for (i, s) in lst.into_iter().enumerate()\
    \ {\n        match s {\n            '(' | ')' => { open_count += 1;},\n      \
    \      _ => { open_count -= 1; }\n        }\n        if open_count == 0 && close_count\
    \ == 0 {\n            is_good = true;\n            break;\n        }\n    }\n\
    \    if is_good {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd9dc4biv.rs:23:13\n   |\n\
    22 |         match s {\n   |               - this expression has type `String`\n\
    23 |             '(' | ')' => { open_count += 1;},\n   |             ^^^ expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd9dc4biv.rs:23:19\n\
    \   |\n22 |         match s {\n   |               - this expression has type `String`\n\
    23 |             '(' | ')' => { open_count += 1;},\n   |                   ^^^\
    \ expected struct `String`, found `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    let mut stack: Vec<usize>\
    \ = Vec::new();\n    for str in lst {\n        match str {\n            \"(\"\
    \ => {\n                stack\n                    .iter()\n                 \
    \   .for_each(|i| {\n                        if let Some(i) = stack.pop() {\n\
    \                            *i += 1;\n                        }\n           \
    \         });\n                stack\n                    .push(0);\n        \
    \        match stack.iter().take(stack.len() + 1) {\n                    Some(v)\
    \ => res = String::from(format!(\"{}({})\", v, *v)),\n                    None\
    \ => res = String::from(\"No\"),\n                }\n            }\n         \
    \   _ => {\n                if let Some(i) = stack.pop() {\n                 \
    \   res = String::from(format!(\"{}{})\", res, String::from(String::from(&str[..i])));\n\
    \                } else {\n                    res = String::from(\"No\");\n \
    \               }\n            }\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpvb2xdd1g.rs:36:39\n\
    \   |\n35 |                 if let Some(i) = stack.pop() {\n   |             \
    \                                 - closing delimiter possibly meant for this\n\
    36 |                     res = String::from(format!(\"{}{})\", res, String::from(String::from(&str[..i])));\n\
    \   |                                       ^ unclosed delimiter\n37 |       \
    \          } else {\n   |                 ^ mismatched closing delimiter\n\nerror:\
    \ expected one of `)`, `,`, `.`, `?`, or an operator, found `;`\n  --> /tmp/tmpvb2xdd1g.rs:36:39\n\
    \   |\n36 |                     res = String::from(format!(\"{}{})\", res, String::from(String::from(&str[..i])));\n\
    \   |                                       ^ unclosed delimiter             \
    \                            ^ help: `)` may belong here\n\nerror: expected expression,\
    \ found `)`\n  --> /tmp/tmpvb2xdd1g.rs:37:17\n   |\n37 |                 } else\
    \ {\n   |                 ^ expected expression\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvb2xdd1g.rs:19:13\n   |\n18 |         match str {\n   |       \
    \        --- this expression has type `String`\n19 |             \"(\" => {\n\
    \   |             ^^^ expected struct `String`, found `&str`\n\nerror[E0614]:\
    \ type `usize` cannot be dereferenced\n  --> /tmp/tmpvb2xdd1g.rs:24:29\n   |\n\
    24 | ...                   *i += 1;\n   |                       ^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvb2xdd1g.rs:30:21\n   |\n29 |              \
    \   match stack.iter().take(stack.len() + 1) {\n   |                       ----------------------------------\
    \ this expression has type `std::iter::Take<std::slice::Iter<'_, usize>>`\n30\
    \ |                     Some(v) => res = String::from(format!(\"{}({})\", v, *v)),\n\
    \   |                     ^^^^^^^ expected struct `std::iter::Take`, found enum\
    \ `Option`\n   |\n   = note: expected struct `std::iter::Take<std::slice::Iter<'_,\
    \ usize>>`\n                found enum `Option<_>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvb2xdd1g.rs:31:21\n   |\n29 |                 match stack.iter().take(stack.len()\
    \ + 1) {"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new(Vec::new());\n    let mut result\
    \ = \"No\";\n\n    for s in lst {\n        if s.is_empty() {\n            result\
    \ += s;\n        } else {\n            match stack.pop() {\n                None\
    \ => break,\n                Some(&mut r) => {\n                    match r {\n\
    \                        \"(\") => stack.push(\"(\"),\n                      \
    \  \")\" => stack.push(\")\"),\n                    };\n                }\n  \
    \          };\n\n            match s {\n                \"(\" => stack.push(\"\
    (\"),\n                \")\" => stack.push(\")\"),\n                _ => {\n \
    \                   let mut stack2 = Stack::new(Vec::new());\n               \
    \     for s in lst {\n                        if s.is_empty() {\n            \
    \                result += s;\n                        } else {\n            \
    \                match stack2.pop() {\n                                None =>\
    \ break,\n                                Some(&mut r) => {\n                \
    \                    match r {\n                                        \"(\"\
    \ => stack2.push(\"(\"),\n                                        \")\" => stack2.push(\"\
    )\"),\n                                    };\n                              \
    \  }\n                            };\n\n                            match s {\n\
    \                                \"(\" => stack.push(\"(\"),\n               \
    \                 \")\" => stack.push(\")\"),\n                            };\n\
    \                        }\n                    }\n                    result\
    \ = String::from(result);\n                }\n            }\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected closing delimiter: `}`\n  --> /tmp/tmpa3yop4f3.rs:63:1\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - this opening brace...\n...\n61 |     }\n   |\
    \     - ...matches this closing brace\n62 |     result\n63 | }\n   | ^ unexpected\
    \ closing delimiter\n\nerror: mismatched closing delimiter: `)`\n  --> /tmp/tmpa3yop4f3.rs:25:29\n\
    \   |\n25 |                     match r {\n   |                             ^\
    \ unclosed delimiter\n26 |                         \"(\") => stack.push(\"(\"\
    ),\n   |                            ^ mismatched closing delimiter\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() < 2 {\n        return String::from(\"No\");\n\
    \    }\n    let mut stack = Stack::new();\n    let mut idx = 0;\n    while idx\
    \ < lst.len() {\n        let cur = lst[idx].unwrap();\n        if cur == String::from(\"\
    (\") {\n            stack.push(cur);\n        } else if cur == String::from(\"\
    )\") {\n            if !stack.is_empty() {\n                let top = stack.pop();\n\
    \                if top == cur {\n                    return String::from(\"Yes\"\
    );\n                }\n            } else {\n                return String::from(\"\
    No\");\n            }\n        }\n        idx += 1;\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp43i_cctl.rs:18:21\n   |\n18 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp43i_cctl.rs:21:28\n   |\n21 |         let cur = lst[idx].unwrap();\n\
    \   |                            ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() < 2 || lst.len() > 3 {\n        String::from(\"\
    No\")\n    } else {\n        let mut cur = vec![String::from(\"(\")]; // init\
    \ cur with the first character\n        for s in lst.iter().skip(1) {\n      \
    \      if s == String::from(\")\") {\n                // end cur is closed, append\
    \ s to cur\n                if cur.len() == 0 {\n                    return String::from(\"\
    No\");\n                }\n                cur.push(s);\n            } else {\n\
    \                // start cur is closed, append s to cur\n                cur.push(s);\n\
    \                if cur.len() < 2 {\n                    return String::from(\"\
    No\");\n                }\n                cur.push(String::from(\")\"));\n  \
    \          }\n        }\n        match cur.iter().rev() {\n            Some(v)\
    \ => String::from(\"Yes\"),\n            None => String::from(\"No\"),\n     \
    \   }\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `String`\n  --> /tmp/tmp7h3dnfcl.rs:20:18\n\
    \   |\n20 |             if s == String::from(\")\") {\n   |                  ^^\
    \ no implementation for `&String == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7h3dnfcl.rs:25:26\n\
    \   |\n25 |                 cur.push(s);\n   |                          ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \  |\n   |                          expected struct `String`, found `&String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7h3dnfcl.rs:28:26\n   |\n28 |\
    \                 cur.push(s);\n   |                          ^- help: try using\
    \ a conversion method: `.to_string()`\n   |                          |\n   | \
    \                         expected struct `String`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp7h3dnfcl.rs:36:13\n   |\n35 |         match\
    \ cur.iter().rev() {\n   |               ---------------- this expression has\
    \ type `Rev<std::slice::Iter<'_, String>>`\n36 |             Some(v) => String::from(\"\
    Yes\"),\n   |             ^^^^^^^ expected struct `Rev`, found enum `Option`\n\
    \   |\n   = note: expected struct `Rev<std::slice::Iter<'_, String>>`\n      \
    \          found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7h3dnfcl.rs:37:13\n\
    \   |\n35 |         match cur.iter().rev() {\n   |               ----------------\
    \ this expression has type `Rev<std::slice::Iter<'_, String>>`\n36 |         \
    \    Some(v) => String::from(\"Yes\"),\n37 |             None => String::from(\"\
    No\"),\n   |     "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut n = lst.len();\n    while n > 0 {\n        if n % 2\
    \ == 0 {\n            n = n / 2;\n        } else {\n            n = (n / 2) +\
    \ 1;\n        }\n    }\n    if lst.len() == 1 {\n        String::from(\"\")\n\
    \    } else {\n        String::from(&vec![lst[0], lst[1]].iter().collect::<String>())\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `String` cannot be built from an iterator\
    \ over elements of type `&String`\n    --> /tmp/tmpqllmy403.rs:26:51\n     |\n\
    26   |         String::from(&vec![lst[0], lst[1]].iter().collect::<String>())\n\
    \     |                                                   ^^^^^^^ value of type\
    \ `String` cannot be built from `std::iter::Iterator<Item=&String>`\n     |\n\
    \     = help: the trait `FromIterator<&String>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n\n    for l in lst {\n\
    \        let mut p = l.clone();\n        let mut stack: Vec<&str> = vec![];\n\
    \        for c in p.chars() {\n            if c == '(' {\n                stack.append(&mut\
    \ p);\n            }\n            if c == '{' {\n                let v = stack.pop();\n\
    \                p.push_str(v);\n            }\n            if c == '}' {\n  \
    \              let v = stack.pop();\n                p.push_str(v);\n        \
    \    }\n            if c == '[' {\n                let v = stack.pop();\n    \
    \            p.push_str(v);\n            }\n            if c == ']' {\n      \
    \          let v = stack.pop();\n                p.push_str(v);\n            }\n\
    \            if c == ')' {\n                let v = stack.pop();\n           \
    \     p.push_str(v);\n            }\n            if c == ']' {\n             \
    \   let v = stack.pop();\n                p.push_str(v);\n            }\n    \
    \    }\n        if p == l {\n            match stack.pop() {\n               \
    \ None => continue,\n                _ => res.push_str(l),\n            }\n  \
    \      }\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:22:30\n   |\n\
    22 |                 stack.append(&mut p);\n   |                             \
    \ ^^^^^^ expected struct `Vec`, found struct `String`\n   |\n   = note: expected\
    \ mutable reference `&mut Vec<&str>`\n              found mutable reference `&mut\
    \ String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:26:28\n\
    \   |\n26 |                 p.push_str(v);\n   |                            ^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9rxg1qeu.rs:30:28\n   |\n30 |                 p.push_str(v);\n\
    \   |                            ^ expected `&str`, found enum `Option`\n   |\n\
    \   = note: expected reference `&str`\n                   found enum `Option<&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:34:28\n   |\n34 |\
    \                 p.push_str(v);\n   |                            ^ expected `&str`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&str`\n          \
    \         found enum `Option<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:38:28\n\
    \   |\n38 |                 p.push_str(v);\n   |                            ^\
    \ expected `&str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \                   found enum `Option<&str>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp9rxg1qeu.rs:42:28\n   |\n42 |                 p.push_str(v);\n\
    \   |                            ^ expected `&str`, found enum `Option`\n   |\n\
    \   = note: expected reference `&str`\n                   found enum `Option<&str>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:46:28\n   |\n46 |\
    \                 p.push_str(v);\n   |                            ^ expected `&str`,\
    \ found enum `Option`\n   |\n   = note: expected reference `&str`\n          \
    \         found enum `Option<&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9rxg1qeu.rs:52:35\n\
    \   |\n52 |                 _ => res.push_str(l),\n   |                      \
    \             ^\n   |    "
  stdout: ''
  timestamp: 1659976207
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut is_good = true;\n    let mut i = 0;\n    loop {\n \
    \       if i == lst.len() {\n            return String::from(\"No\");\n      \
    \  }\n        if lst[i] != lst[i + 1] {\n            is_good = false;\n      \
    \      break;\n        }\n        i += 1;\n    }\n    if is_good {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp38d9e_7m.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    iterate_over(lst, \"Yes\")\n        .unwrap_or(String::from(\"\
    No\"))\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `iterate_over` in this scope\n  -->\
    \ /tmp/tmpaytxsw4v.rs:15:5\n   |\n15 |     iterate_over(lst, \"Yes\")\n   |  \
    \   ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![false; lst.len()];\n    let mut curr =\
    \ vec!['('; lst.len()];\n    let mut ans = String::new();\n    for c in lst {\n\
    \        if stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()] {\n\
    \            stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()] =\
    \ false;\n        } else {\n            curr.iter().enumerate().for_each(|(i,\
    \ &x)| *i != '(' && stack.push(*x));\n            ans = ans.push_str(c.clone()).unwrap();\n\
    \            stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()] =\
    \ true;\n            curr = vec!['('; lst.len()];\n        }\n    }\n    ans.into()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpchmifx0k.rs:19:34\n\
    \   |\n19 |         if stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()]\
    \ {\n   |                              --- ^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |                              |\n   |\
    \                              required by a bound introduced by this call\n \
    \  |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror[E0599]: the method `map` exists for struct `Zip<std::slice::Iter<'_, char>,\
    \ String>`, but its trait bounds were not satisfied\n   --> /tmp/tmpchmifx0k.rs:19:37\n\
    \    |\n19  |           if stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()]\
    \ {\n    |                                       ^^^ method cannot be called on\
    \ `Zip<std::slice::Iter<'_, char>, String>` due to unsatisfied trait bounds\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `String: Iterator`\n            which is required by `Zip<std::slice::Iter<'_,\
    \ char>, String>: Iterator`\n            `Zip<std::slice::Iter<'_, char>, String>:\
    \ Iterator`\n            which is required by `&mut Zip<std::slice::Iter<'_, char>,\
    \ String>: Iterator`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpchmifx0k.rs:19:30\n\
    \   |\n19 |         if stack[curr.iter().zip(c).map(|&(a, b)| *a == *b).sum::<bool>()]\
    \ {\n   |                              ^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0599]: the method `map` exists for struct\
    \ `Zip<std::slice::Iter<'_, char>, String>`, but its trait bounds were not satisfied\n\
    \   --> /tmp/tmpchmifx0k.rs:20:38\n    |\n20  |               stack[curr.iter().zip(c).map(|&(a,\
    \ b)| *a == *b).sum::<bool>()] = false;\n    |                               \
    \         ^^^ method cannot be called on"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = vec![String::from(\"Yes\")];\n    let mut current_stack\
    \ = String::from(\"No\");\n    for elem in lst {\n        if elem == ')' {\n \
    \           stack.pop();\n        } else {\n            if elem == '(' {\n   \
    \             stack.push(String::from(\"Yes\"));\n            } else {\n     \
    \           let new_stack = current_stack + elem[1..];\n                let mut\
    \ found = false;\n                for stack in &mut stack {\n                \
    \    if stack.contains(\"Yes\") {\n                        found = true;\n   \
    \                     break;\n                    }\n                }\n     \
    \           if found {\n                    current_stack = new_stack;\n     \
    \           } else {\n                    current_stack = String::from(\"No\"\
    );\n                }\n            }\n        }\n    }\n    return current_stack\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmplx_x6uqu.rs:18:17\n\
    \   |\n18 |         if elem == ')' {\n   |                 ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmplx_x6uqu.rs:21:21\n   |\n21 |          \
    \   if elem == '(' {\n   |                     ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplx_x6uqu.rs:24:49\n   |\n24 |                 let new_stack\
    \ = current_stack + elem[1..];\n   |                                         \
    \        ^^^^^^^^^\n   |                                                 |\n \
    \  |                                                 expected `&str`, found `str`\n\
    \   |                                                 help: consider borrowing\
    \ here: `&elem[1..]`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // dp[i][j]: how many parenthesis we can put in to the end?\n\
    \    // dp[i][j] = dp[i - 1][j - 1] + 1 if '(', dp[i][j] = dp[i - 1][j] if ')'\n\
    \    // dp[i][j] = 0 if none of the above\n    let mut dp = vec![vec![String::from(\"\
    No\"); 21]; 21];\n    for i in 0..21 {\n        for j in 0..21 {\n           \
    \ if i == 0 || j == 0 {\n                dp[i][j].to_string()\n            } else\
    \ {\n                let last = &dp[i - 1][j];\n                if last[last.len()\
    \ - 1] == '(' {\n                    dp[i][j].to_string()\n                } else\
    \ if last[last.len() - 1] == ')' {\n                    dp[i][j].to_string()\n\
    \                } else {\n                    dp[i][j].to_string()\n        \
    \        }\n            }\n        }\n    }\n    let mut ret = \"No\".to_string();\n\
    \    for ele in lst {\n        // println!(\"{:#?}\", ele);\n        for i in\
    \ 0..21 {\n            for j in 0..21 {\n                match ele.chars().nth(i).unwrap()\
    \ {\n                    '(' => {\n                        if dp[i][j].to_string()\
    \ == \"No\" {\n                            ret = \"Yes\".to_string();\n      \
    \                      break;\n                        }\n                   \
    \ },\n                    ')' => {\n                        if dp[i][j].to_string()\
    \ == \"No\" {\n                            ret = \"Yes\".to_string();\n      \
    \                      break;\n                        }\n                   \
    \ },\n                    _ => {\n                        break;\n           \
    \         }\n                }\n            }\n        }\n    }\n    ret\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmuotxkz3.rs:22:17\n   |\n\
    21 | /             if i == 0 || j == 0 {\n22 | |                 dp[i][j].to_string()\n\
    \   | |                 ^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `String`\n\
    23 | |             } else {\n24 | |                 let last = &dp[i - 1][j];\n\
    ...  |\n31 | |                 }\n32 | |             }\n   | |_____________- expected\
    \ this to be `()`\n   |\nhelp: consider using a semicolon here\n   |\n22 |   \
    \              dp[i][j].to_string();\n   |                                   \
    \  +\nhelp: consider using a semicolon here\n   |\n32 |             };\n   | \
    \             +\nhelp: you might have meant to return this value\n   |\n22 | \
    \                return dp[i][j].to_string();\n   |                 ++++++   \
    \                  +\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpmuotxkz3.rs:25:20\n   |\n25 |                 if last[last.len()\
    \ - 1] == '(' {\n   |                    ^^^^^^^^^^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmuotxkz3.rs:26:21\n\
    \   |\n25 | /                 if last[last.len() - 1] == '(' {\n26 | |       \
    \              dp[i][j].to_string()\n   | |                     ^^^^^^^^^^^^^^^^^^^^\
    \ expected `()`, found struct `String`\n27 | |                 } else if last[last.len()\
    \ - 1] == ')' {\n28 | |                     dp[i][j].to_string()\n29 | |     \
    \            } else {\n30 | |                     dp[i][j].to_string()\n31 | |\
    \                 }\n   | |_________________- expected this to be `()`\n   |\n\
    help: consider using a semico"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut i = 0;\n    let mut count = 0;\n    while i < lst.len()\
    \ {\n        let s = lst[i];\n        let mut j = i + 1;\n        let mut count\
    \ = 0;\n        while j < lst.len() {\n            let mut c = s[j];\n       \
    \     if c == '(' {\n                count += 1;\n            } else if c == ')'\
    \ {\n                if count == 0 {\n                    count = -1;\n      \
    \              break;\n                } else {\n                    count -=\
    \ 1;\n                }\n            } else {\n                count = 1;\n  \
    \          }\n            i += 1;\n            j += 1;\n        }\n        if\
    \ count != 0 {\n            i += 1;\n        } else {\n            return s.to_string();\n\
    \        }\n    }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2rmautnv.rs:22:25\n\
    \   |\n22 |             let mut c = s[j];\n   |                         ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::new();\n    for s in lst {\n        let\
    \ mut i = s.len();\n        for _ in 0..i {\n            let c = s.chars().nth(i);\n\
    \            if !((c == '(') || (c == ')')) {\n                return String::from(\"\
    No\");\n            }\n            i += 1;\n        }\n        cur.push_str(&s);\n\
    \    }\n    cur\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpax_kuxvr.rs:20:24\n   |\n\
    20 |             if !((c == '(') || (c == ')')) {\n   |                      \
    \  ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |             if !((c == Some('(')) || (c == ')')) {\n   |         \
    \               +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax_kuxvr.rs:20:38\n\
    \   |\n20 |             if !((c == '(') || (c == ')')) {\n   |               \
    \                       ^^^ expected enum `Option`, found `char`\n   |\n   = note:\
    \ expected enum `Option<char>`\n              found type `char`\nhelp: try wrapping\
    \ the expression in `Some`\n   |\n20 |             if !((c == '(') || (c == Some(')')))\
    \ {\n   |                                      +++++   +\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // This code is a bit inefficient, but it works for small inputs\n\
    \    let mut res = String::from(\"No\");\n    for s in lst.iter() {\n        let\
    \ mut is_open = false;\n        let mut i = 1;\n        while i <= s.len() {\n\
    \            if s[i] == '(' {\n                is_open = true;\n             \
    \   break;\n            } else if s[i] == ')' {\n                is_open = false;\n\
    \                break;\n            } else {\n                i += 1;\n     \
    \       }\n        }\n        if is_open == true {\n            res += \"Yes\"\
    ;\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphuexfl4y.rs:21:16\n\
    \   |\n21 |             if s[i] == '(' {\n   |                ^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphuexfl4y.rs:24:23\n   |\n24 |             } else if s[i] == ')'\
    \ {\n   |                       ^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new(true);\n    let mut stack_size =\
    \ -1;\n    let mut res = String::new();\n    for s in lst {\n        match &s[1..]\
    \ {\n            \"(\", &\")\" => {\n                stack.push(s);\n        \
    \        stack_size++;\n            }\n            _ => {}\n        }\n    }\n\
    \    if stack_size != 0 {\n        return String::from(\"No\");\n    }\n    for\
    \ s in lst {\n        match &s[1..] {\n            \"(\", &\")\" => {\n      \
    \          let mut pop = stack.top();\n                stack.pop();\n        \
    \        if !stack.is_empty() {\n                    let s = stack.pop();\n  \
    \                  if s.len() == 1 {\n                        let c = s.chars().next().unwrap();\n\
    \                        if *c != '(' && c != ')' {\n                        \
    \    res = String::from(\"No\");\n                        }\n                \
    \    } else {\n                        res = String::from(\"Yes\");\n        \
    \            }\n                } else {\n                    res = String::from(\"\
    Yes\");\n                }\n            }\n            _ => {}\n        }\n  \
    \  }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected `,` in pattern\n  --> /tmp/tmp_96jumjo.rs:20:16\n   |\n\
    20 |             \"(\", &\")\" => {\n   |                ^\n   |\nhelp: try adding\
    \ parentheses to match on a tuple...\n   |\n20 |             (\"(\", &\")\") =>\
    \ {\n   |             +         +\nhelp: ...or a vertical bar to match on multiple\
    \ alternatives\n   |\n20 |             \"(\" | &\")\" => {\n   |             ~~~~~~~~~~\n\
    \nerror: unexpected `,` in pattern\n  --> /tmp/tmp_96jumjo.rs:32:16\n   |\n32\
    \ |             \"(\", &\")\" => {\n   |                ^\n   |\nhelp: try adding\
    \ parentheses to match on a tuple...\n   |\n32 |             (\"(\", &\")\") =>\
    \ {\n   |             +         +\nhelp: ...or a vertical bar to match on multiple\
    \ alternatives\n   |\n32 |             \"(\" | &\")\" => {\n   |             ~~~~~~~~~~\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Stack`\n  --> /tmp/tmp_96jumjo.rs:15:21\n\
    \   |\n15 |     let mut stack = Stack::new(true);\n   |                     ^^^^^\
    \ use of undeclared type `Stack`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur: Vec<&String> = lst.clone();\n    let mut done\
    \ = vec![false; cur.len()];\n    let mut last_open_bracket = -1;\n    let mut\
    \ last_close_bracket = -1;\n    let mut open_brackets = 0;\n    let mut close_brackets\
    \ = 0;\n    let mut open_brackets_cnt = 0;\n    let mut close_brackets_cnt = 0;\n\
    \n    for (i, s) in cur.iter().enumerate() {\n        if s == String::from(\"\
    (\") {\n            open_brackets += 1;\n            open_brackets_cnt += 1;\n\
    \            last_open_bracket = i;\n        }\n        if s == String::from(\"\
    )\") {\n            open_brackets_cnt -= 1;\n            close_brackets += 1;\n\
    \            last_close_bracket = i;\n        }\n        if s == String::from(\"\
    (\") && open_brackets_cnt == 0 {\n            done[i] = true;\n        }\n   \
    \     if s == String::from(\")\") && close_brackets_cnt == 0 {\n            done[i]\
    \ = true;\n        }\n    }\n\n    let mut result = String::from(\"No\");\n  \
    \  for done in done.iter().take(cur.len()) {\n        if !done {\n           \
    \ break;\n        }\n        if last_open_bracket == -1 && last_close_bracket\
    \ == -1 && open_brackets == 0 && close_brackets == 0 {\n            result = String::from(\"\
    Yes\");\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwh888xke.rs:15:33\n   |\n\
    15 |     let mut cur: Vec<&String> = lst.clone();\n   |                  ------------\
    \   ^^^^^^^^^^^ expected `&String`, found struct `String`\n   |              \
    \    |\n   |                  expected due to this\n   |\n   = note: expected\
    \ struct `Vec<&String>`\n              found struct `Vec<String>`\n\nerror[E0277]:\
    \ can't compare `&&String` with `String`\n  --> /tmp/tmpwh888xke.rs:25:14\n  \
    \ |\n25 |         if s == String::from(\"(\") {\n   |              ^^ no implementation\
    \ for `&&String == String`\n   |\n   = help: the trait `PartialEq<String>` is\
    \ not implemented for `&&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n\
    \  --> /tmp/tmpwh888xke.rs:17:33\n   |\n17 |     let mut last_open_bracket = -1;\n\
    \   |                                 ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: can't compare `&&String` with `String`\n\
    \  --> /tmp/tmpwh888xke.rs:30:14\n   |\n30 |         if s == String::from(\")\"\
    ) {\n   |              ^^ no implementation for `&&String == String`\n   |\n \
    \  = help: the trait `PartialEq<String>` is not implemented for `&&String`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n           "
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().map(|&x| x.chars()).filter(|x| !x.is_empty()).all(|x|\
    \ match_paren(x))\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_paren` in this scope\n  --> /tmp/tmp9b8x7qao.rs:15:70\n\
    \   |\n15 |     lst.iter().map(|&x| x.chars()).filter(|x| !x.is_empty()).all(|x|\
    \ match_paren(x))\n   |                                                      \
    \                ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `is_empty` found for reference `&Chars<'_>` in the current scope\n  -->\
    \ /tmp/tmp9b8x7qao.rs:15:50\n   |\n15 |     lst.iter().map(|&x| x.chars()).filter(|x|\
    \ !x.is_empty()).all(|x| match_paren(x))\n   |                               \
    \                   ^^^^^^^^ method not found in `&Chars<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9b8x7qao.rs:15:5\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n15 |     lst.iter().map(|&x| x.chars()).filter(|x|\
    \ !x.is_empty()).all(|x| match_paren(x))\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `bool`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::from(\"Yes\");\n    for (i, elt) in lst.into_iter().enumerate()\
    \ {\n        for j in (i + 1, lst.len()) {\n            let elt2 = lst[j].to_string();\n\
    \            if elt != elt2 {\n                s = String::from(\"No\");\n   \
    \         }\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `(usize, usize)` is not an iterator\n  --> /tmp/tmpubees3ah.rs:17:18\n\
    \   |\n17 |         for j in (i + 1, lst.len()) {\n   |                  ^^^^^^^^^^^^^^^^^^\
    \ `(usize, usize)` is not an iterator\n   |\n   = help: the trait `Iterator` is\
    \ not implemented for `(usize, usize)`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `(usize, usize)`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::with_capacity(2);\n    for s in lst {\n\
    \        if s == String::from(\"(\") {\n            stack.push(s);\n        }\
    \ else if s == String::from(\")\") {\n            if stack.len() == 0 {\n    \
    \            return String::from(\"No\");\n            }\n            stack.pop();\n\
    \        } else {\n            return String::from(\"Yes\");\n        }\n    }\n\
    \    String::from(\"Yes\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpm892vrf0.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n\n    // Traverse the list by depth-first\
    \ search\n    for paren in lst.iter().rev() {\n        match paren {\n       \
    \     // If the string starts with open parentheses, remove one level of depth.\n\
    \            // Otherwise, keep one level of depth.\n            '(' => {\n  \
    \              s = s.pop();\n            },\n            // If the string ends\
    \ with close parentheses, add one level of depth.\n            // Otherwise, keep\
    \ one level of depth.\n            ')' => {\n                s += paren;\n   \
    \         },\n            _ => (),\n        }\n    }\n\n    s\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvvuvu_v1.rs:22:13\n   |\n\
    19 |         match paren {\n   |               ----- this expression has type\
    \ `&String`\n...\n22 |             '(' => {\n   |             ^^^ expected struct\
    \ `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvvuvu_v1.rs:27:13\n\
    \   |\n19 |         match paren {\n   |               ----- this expression has\
    \ type `&String`\n...\n27 |             ')' => {\n   |             ^^^ expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvvuvu_v1.rs:23:21\n\
    \   |\n15 |     let mut s = String::new();\n   |                 -------------\
    \ expected due to this value\n...\n23 |                 s = s.pop();\n   |   \
    \                  ^^^^^^^ expected struct `String`, found enum `Option`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Option<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    stack.push(String::from(\"\
    (\"));\n    for elem in lst {\n        let mut s = stack.top();\n        match\
    \ elem {\n            String::from(')') => stack.push(String::from(\")\")),\n\
    \            String::from('(') => stack.push(String::from(\"(\")),\n         \
    \   _ => {\n                while let Some(ref mut cur) = stack.try_pop() {\n\
    \                    if cur == elem {\n                        return String::from(\"\
    Yes\");\n                    } else if cur == String::from(\"(\") {\n        \
    \                stack.push(elem);\n                    }\n                }\n\
    \            }\n        }\n    }\n    stack.top()\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpbgeslvsx.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmpbgeslvsx.rs:20:13\n   |\n20 |             String::from(')') =>\
    \ stack.push(String::from(\")\")),\n   |             ^^^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmpbgeslvsx.rs:21:13\n   |\n21 |             String::from('(')\
    \ => stack.push(String::from(\"(\")),\n   |             ^^^^^^^^^^^^^^^^^ `fn`\
    \ calls are not allowed in patterns\n   |\n   = help: for more information, visit\
    \ https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror[E0277]: can't\
    \ compare `&mut _` with `String`\n  --> /tmp/tmpbgeslvsx.rs:24:28\n   |\n24 |\
    \                     if cur == elem {\n   |                            ^^ no\
    \ implementation for `&mut _ == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&mut _`\n\nerror[E0277]: can't compare `&mut _` with\
    \ `String`\n  --> /tmp/tmpbgeslvsx.rs:26:35\n   |\n26 |                     }\
    \ else if cur == String::from(\"(\") {\n   |                                 \
    \  ^^ no implementation for `&mut _ == String`\n   |\n   = help: the trait `PartialEq<String>`\
    \ is not implemented for `&mut _`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0164, E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976206
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"Yes\");\n    let mut lst = lst.into_iter().cloned().collect::<Vec<String>>();\n\
    \    loop {\n        if !is_valid(res) {\n            return res;\n        }\n\
    \        if lst.len() == 1 {\n            return res;\n        }\n        match\
    \ lst.iter().rev().fold(String::from(\"No\"), |s, c| {\n            match c {\n\
    \                '(' | ')' => s.push_str(c),\n                _ => s,\n      \
    \      }\n        });\n        lst.clear();\n        res += \")\";\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `;`\n  -->\
    \ /tmp/tmpmsvymeep.rs:29:11\n   |\n24 |         match lst.iter().rev().fold(String::from(\"\
    No\"), |s, c| {\n   |         -----\n   |         |\n   |         while parsing\
    \ this `match` expression\n   |         help: try removing this `match`\n...\n\
    29 |         });\n   |           ^ expected one of `.`, `?`, `{`, or an operator\n\
    \nerror[E0425]: cannot find function `is_valid` in this scope\n  --> /tmp/tmpmsvymeep.rs:18:13\n\
    \   |\n18 |         if !is_valid(res) {\n   |             ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0271]: type mismatch resolving `<std::vec::IntoIter<String>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpmsvymeep.rs:16:35\n     |\n16   |\
    \     let mut lst = lst.into_iter().cloned().collect::<Vec<String>>();\n     |\
    \                                   ^^^^^^ expected reference, found struct `String`\n\
    \     |\n     = note: expected reference `&_`\n                   found struct\
    \ `String`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<std::vec::IntoIter<String>>`, but its trait\
    \ bounds were not satisfied\n  --> /tmp/tmpmsvymeep.rs:16:44\n   |\n16 |     \
    \  let mut lst = lst.into_iter().cloned().collect::<Vec<String>>();\n   |    \
    \                                          ^^^^^^^ method cannot be called on\
    \ `Cloned<std::vec::IntoIter<String>>` due to unsatisfied trait bounds\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `<std::vec::IntoIter<String>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<std::vec::IntoIter<String>>:\
    \ Iterator`\n           `Cloned<std::vec::IntoIter<String>>: Iterator`\n     \
    \      which is required by `&mut Cloned<std::vec::IntoIter<String>>: Iterator`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0271`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = lst.clone();\n    let mut result = String::new();\n\
    \    loop {\n        if cur == vec![\"(\", \"(\"].iter() {\n            result\
    \ = \"Yes\";\n            break;\n        } else if cur == vec![\")\", \"(\"].iter()\
    \ {\n            result = \"No\";\n            break;\n        } else if cur ==\
    \ vec![\"(\"].iter() {\n            result = \"No\";\n            break;\n   \
    \     } else if cur == vec![\")\"].iter() {\n            result = \"Yes\";\n \
    \           break;\n        } else if cur == vec![\"(\", \")\"].iter() {\n   \
    \         result = \"Yes\";\n            break;\n        } else {\n          \
    \  break;\n        }\n        cur.pop();\n        cur.pop();\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplj09t_e_.rs:19:22\n   |\n\
    16 |     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n19 |             result = \"Yes\";\n   |  \
    \                    ^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: can't compare `Vec<String>` with `std::slice::Iter<'_,\
    \ &str>`\n  --> /tmp/tmplj09t_e_.rs:18:16\n   |\n18 |         if cur == vec![\"\
    (\", \"(\"].iter() {\n   |                ^^ no implementation for `Vec<String>\
    \ == std::slice::Iter<'_, &str>`\n   |\n   = help: the trait `PartialEq<std::slice::Iter<'_,\
    \ &str>>` is not implemented for `Vec<String>`\n   = help: the following other\
    \ types implement trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U,\
    \ A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T,\
    \ A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut [U]>>\n  \
    \           <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplj09t_e_.rs:22:22\n   |\n16 |\
    \     let mut result = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n22 |             result = \"No\";\n   |   \
    \                   ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `&str`\n\nerror[E0277]: can't compare `Vec<String>` with `std::slice::Iter<'_,\
    \ &str>`\n  --> /tmp/tmplj09t_e_.rs:21:23\n   |\n21 |         } else if cur ==\
    \ vec![\")\", \"(\"].iter() {\n   |                       ^^ no implementation\
    \ for `Vec<String> == std::slice::Iter<'_, &str>`\n   |\n   = help: the trait\
    \ `PartialEq<std::slice::Iter<'_, &str>>` is not implemented for `Vec<String>`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n             <Vec<T, A> as PartialEq<&[U;\
    \ N]>>\n             <Vec<T, A> as P"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = 0;\n    let mut start = 0;\n    let mut end\
    \ = lst.len();\n\n    while start < end {\n        if lst[start].is_parens(&mut\
    \ parens) {\n            parens += 1;\n        } else {\n            parens =\
    \ 0;\n        }\n        if parens == 0 {\n            break;\n        }\n   \
    \     start += 1;\n    }\n    if start == end {\n        if parens == 0 {\n  \
    \          String::from(\"No\")\n        } else {\n            String::from(\"\
    Yes\")\n        }\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_parens` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp4yaw1ayo.rs:20:23\n   |\n20 |         if lst[start].is_parens(&mut\
    \ parens) {\n   |                       ^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\";\n    }\n    let\
    \ mut res = vec![\"Yes\"];\n    for c in lst.iter() {\n        if c.chars().count()\
    \ == 1 {\n            res.push(\"No\");\n        } else if c.chars().count() >\
    \ 2 {\n            res.push(\"Yes\");\n        }\n    }\n    res.join(\", \")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2ygarb7c.rs:16:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     if\
    \ lst.len() != 2 {\n16 |         return \"No\";\n   |                ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    struct Stack<'a> {\n        elems: Vec<&'a str>,\n        index:\
    \ usize,\n    }\n\n    let mut stack = Stack {\n        elems: lst.into_iter().collect(),\n\
    \        index: 0,\n    };\n\n    let mut res = String::new();\n\n    while stack.index\
    \ > 0 {\n        match stack.elems[stack.index] {\n            \"(\" => {\n  \
    \              stack.pop();\n                res.push_str(\"Yes\");\n        \
    \    }\n            \")\" => {\n                res.push_str(\"No\");\n      \
    \          stack.index -= 1;\n            }\n            _ => {\n            \
    \    break;\n            }\n        }\n        stack.index += 1;\n    }\n\n  \
    \  res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `String`\n    --> /tmp/tmph9jf8s7k.rs:21:32\n     |\n\
    21   |         elems: lst.into_iter().collect(),\n     |                     \
    \           ^^^^^^^ value of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=String>`\n\
    \     |\n     = help: the trait `FromIterator<String>` is not implemented for\
    \ `Vec<&str>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `pop`\
    \ found for struct `Stack` in the current scope\n  --> /tmp/tmph9jf8s7k.rs:30:23\n\
    \   |\n15 |     struct Stack<'a> {\n   |     ---------------- method `pop` not\
    \ found for this\n...\n30 |                 stack.pop();\n   |               \
    \        ^^^ method not found in `Stack<'_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    for s in lst {\n \
    \       if s.is_empty() {\n            continue;\n        }\n        for (i, &ch)\
    \ in s.chars().enumerate() {\n            if ch.is_uppercase() {\n           \
    \     res.push_str(&s.to_string());\n                s.push_str(&\"X\");\n   \
    \             s.pop();\n                let res = String::from(s);\n         \
    \       res.pop();\n                res.pop();\n                let res = String::from(res.to_owned());\n\
    \                res.pop();\n                res.pop();\n                res.pop();\n\
    \                res.pop();\n                return res;\n            }\n    \
    \    }\n    }\n    return res;\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzpoewde9.rs:20:17\n   |\n\
    20 |         for (i, &ch) in s.chars().enumerate() {\n   |                 ^^^\
    \     --------------------- this expression has type `Option<(usize, char)>`\n\
    \   |                 |\n   |                 expected `char`, found reference\n\
    \   |                 help: you can probably remove the explicit borrow: `ch`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![String::from(\"()(\"), String::from(\"\
    )\")] | vec![String::from(\")\"), String::from(\")\")] => String::from(\"Yes\"\
    ),\n        vec![String::from(\")\"), String::from(\"()\")] => String::from(\"\
    No\"),\n        _ => panic!(\"Unexpected input data.\"),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpc017hnz8.rs:16:9\n\
    \   |\n16 |         vec![String::from(\"()(\"), String::from(\")\")] | vec![String::from(\"\
    )\"), String::from(\")\")] => String::from(\"Yes\"),\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't\
    \ allowed in patterns\n  --> /tmp/tmpc017hnz8.rs:16:56\n   |\n16 |         vec![String::from(\"\
    ()(\"), String::from(\")\")] | vec![String::from(\")\"), String::from(\")\")]\
    \ => String::from(\"Yes\"),\n   |                                            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmpc017hnz8.rs:17:9\n   |\n17 |         vec![String::from(\")\"),\
    \ String::from(\"()\")] => String::from(\"No\"),\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        return \"No\";\n    }\n    match\
    \ match lst.last() {\n        \"(\" => {\n            let mut stack: Vec<String>\
    \ = vec![];\n            for str in lst {\n                if str.starts_with(\"\
    (\") {\n                    stack.push(str);\n                } else if str.starts_with(\"\
    )\") {\n                    if stack.len() == 0 {\n                        return\
    \ str;\n                    }\n                    let mut cur = String::from(\"\
    \".to_string());\n                    while !stack.contains(&cur) {\n        \
    \                cur += stack.pop().unwrap();\n                    }\n       \
    \         }\n            }\n            \"Yes\"\n        }\n        \")\" => {\n\
    \            let mut stack: Vec<String> = vec![];\n            for str in lst\
    \ {\n                if str.starts_with(\")\") {\n                    stack.push(str);\n\
    \                } else if str.starts_with(\"(\") {\n                    if stack.len()\
    \ == 0 {\n                        return str;\n                    }\n       \
    \             let mut cur = String::from(\"\".to_string());\n                \
    \    while !stack.contains(&cur) {\n                        cur += stack.pop().unwrap();\n\
    \                    }\n                }\n            }\n            \"No\"\n\
    \        }\n        _ => panic!(\"Unexpected String: {}\", lst.last().unwrap()),\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `}`\n  -->\
    \ /tmp/tmphxcizvng.rs:55:1\n   |\n18 |     match match lst.last() {\n   |    \
    \ ----- while parsing this `match` expression\n...\n54 |     }\n   |      - expected\
    \ one of `.`, `?`, `{`, or an operator\n55 | }\n   | ^ unexpected token\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmphxcizvng.rs:16:16\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n15 |     if lst.len() == 0 {\n16 |        \
    \ return \"No\";\n   |                ^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                |\n   |                expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Find the length of all the open parenthesis lengths.\n \
    \   let mut sum = 0\n    for s in lst {\n        if s == '(' {\n            sum\
    \ += 1;\n        }\n        if s == ')' {\n            sum -= 1;\n        }\n\
    \    }\n    if sum == 0 {\n        String::from(\"No\")\n    } else {\n      \
    \  String::from(\"Yes\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `for`\n  --> /tmp/tmp_js_n58o.rs:16:20\n\
    \   |\n16 |     let mut sum = 0\n   |                    ^ help: add `;` here\n\
    17 |     for s in lst {\n   |     --- unexpected token\n\nerror[E0277]: can't\
    \ compare `String` with `char`\n  --> /tmp/tmp_js_n58o.rs:18:14\n   |\n18 |  \
    \       if s == '(' {\n   |              ^^ no implementation for `String == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmp_js_n58o.rs:21:14\n   |\n21 |         if\
    \ s == ')' {\n   |              ^^ no implementation for `String == char`\n  \
    \ |\n   = help: the trait `PartialEq<char>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 1 {\n        String::from(\"\")\n    } else\
    \ {\n        let mut s = String::from(\"\");\n        let mut paren_count = 0;\n\
    \        for e in lst {\n            if e.len() > 1 {\n                let e =\
    \ e.chars().filter_map(|c| c.is_open_bracket()).count();\n                let\
    \ n = e.clone() + 1;\n                let p = n + 1;\n                let m =\
    \ p + 1;\n                let b = m + 1;\n                if paren_count == 0\
    \ && n < paren_count && m > paren_count {\n                    s += String::from(\"\
    (\");\n                    s += String::from(\"\");\n                } else if\
    \ paren_count >= 2 && n > paren_count {\n                    s += String::from(\"\
    \");\n                } else if paren_count == 2 && n < paren_count && m > paren_count\
    \ {\n                    s += String::from(\")\");\n                    s += String::from(\"\
    \");\n                }\n                if paren_count == 0 {\n             \
    \       s += String::from(e.chars().next().unwrap());\n                }\n   \
    \             s += String::from(\"\");\n                s += String::from(\"\"\
    );\n            }\n            s += String::from(e.chars().next().unwrap());\n\
    \            s += String::from(\"\");\n        }\n        match paren_count {\n\
    \            1 => String::from(\"Yes\"),\n            0 => String::from(\"No\"\
    ),\n            _ => String::from(\"No\"),\n        }\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_open_bracket` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpw1ybz3aj.rs:22:52\n   |\n22 |             \
    \    let e = e.chars().filter_map(|c| c.is_open_bracket()).count();\n   |    \
    \                                                ^^^^^^^^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1ybz3aj.rs:28:26\n\
    \   |\n28 |                     s += String::from(\"(\");\n   |              \
    \            ^^^^^^^^^^^^^^^^^\n   |                          |\n   |        \
    \                  expected `&str`, found struct `String`\n   |              \
    \            help: consider borrowing here: `&String::from(\"(\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw1ybz3aj.rs:29:26\n   |\n29 |              \
    \       s += String::from(\"\");\n   |                          ^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&String::from(\"\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1ybz3aj.rs:31:26\n\
    \   |\n31 |                     s += String::from(\"\");\n   |               \
    \           ^^^^^^^^^^^^^^^^\n   |                          |\n   |          \
    \                expected `&str`, found struct `String`\n   |                \
    \          help: consider borrowing here: `&String::from(\"\")`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpw1ybz3aj.rs:33:26\n   |\n33 |              \
    \       s += String::from(\")\");\n   |                          ^^^^^^^^^^^^^^^^^\n\
    \   |                          |\n   |                          expected `&str`,\
    \ found struct `String`\n   |                          help: consider borrowing\
    \ here: `&String::from(\")\")`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw1ybz3aj.rs:34:26\n\
    \   |\n34 |                     s += String::from(\"\");\n   |               \
    \           ^^^^^^^^^^^^^^^^\n   |                          |\n   |          \
    \                expected `&str`, found struct `String`\n   |                \
    \          help: consider borrowing here: `&String::from(\"\")`\n\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    for s in lst {\n    \
    \    match s {\n            Some('(') => stack.push(\"(\"),\n            Some(')')\
    \ => stack.push(')'),\n            _ => {\n                let next = stack.pop();\n\
    \                if next != '(' && next != ')' {\n                    return String::from(\"\
    No\");\n                }\n            }\n        }\n    }\n    if stack.len()\
    \ == 0 {\n        return String::from(\"Yes\");\n    } else {\n        return\
    \ String::from(\"No\");\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpez9ju_q1.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpez9ju_q1.rs:18:13\n   |\n17 |  \
    \       match s {\n   |               - this expression has type `String`\n18\
    \ |             Some('(') => stack.push(\"(\"),\n   |             ^^^^^^^^^ expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpez9ju_q1.rs:19:13\n   |\n17 |         match s {\n   |              \
    \ - this expression has type `String`\n18 |             Some('(') => stack.push(\"\
    (\"),\n19 |             Some(')') => stack.push(')'),\n   |             ^^^^^^^^^\
    \ expected struct `String`, found enum `Option`\n   |\n   = note: expected struct\
    \ `String`\n                found enum `Option<_>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 101
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = String::new();\n    let mut done = false;\n\
    \    for paren in lst.iter() {\n        if paren == \"(\" {\n            parens.push_str(\"\
    (\");\n        } else if paren == \")\" {\n            parens.push_str(\")\");\n\
    \        } else if paren == \")()\" {\n            done = true;\n            parens.push_str(\"\
    )\");\n        }\n    }\n    parens\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\")\"`,\n right: `\"Yes\"`', /tmp/tmp1ypyx_ay.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst {\n        vec![String::from(\"()(\"), String::from(\"\
    )\")] => {\n            if match_parens_iter(lst, false, true)\n             \
    \   || match_parens_iter(lst, true, false)\n                || match_parens_iter(lst,\
    \ true, true)\n            {\n                String::from(\"Yes\")\n        \
    \    } else {\n                String::from(\"No\")\n            }\n        }\n\
    \        _ => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_iter` in this scope\n\
    \  --> /tmp/tmprlm3nkft.rs:17:16\n   |\n17 |             if match_parens_iter(lst,\
    \ false, true)\n   |                ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `match_parens_iter` in this scope\n  -->\
    \ /tmp/tmprlm3nkft.rs:18:20\n   |\n18 |                 || match_parens_iter(lst,\
    \ true, false)\n   |                    ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `match_parens_iter` in this scope\n  -->\
    \ /tmp/tmprlm3nkft.rs:19:20\n   |\n19 |                 || match_parens_iter(lst,\
    \ true, true)\n   |                    ^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmprlm3nkft.rs:16:9\n\
    \   |\n16 |         vec![String::from(\"()(\"), String::from(\")\")] => {\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: this\
    \ error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // The base case\n    if lst.len() == 1 {\n        return String::from(\"\
    \");\n    }\n\n    // The recursive case\n    let mut str = \"\";\n    let mut\
    \ last_idx = lst.len() - 1;\n    let mut open_balance = 0;\n    while last_idx\
    \ >= 0 {\n        if lst[last_idx] == \")\" {\n            open_balance -= 1;\n\
    \        }\n        if lst[last_idx] == \"]\" {\n            open_balance += 1;\n\
    \        }\n        if open_balance > 0 {\n            str += \")\";\n       \
    \ }\n        if open_balance < 0 {\n            str += \")\";\n        }\n   \
    \     last_idx -= 1;\n    }\n    return str\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmp77m8b9vi.rs:32:13\n   |\n32 |             str += \")\"\
    ;\n   |             ---^^^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `&str`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `&str`\n  --> /tmp/tmp77m8b9vi.rs:35:13\n   |\n35 |     \
    \        str += \")\";\n   |             ---^^^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp77m8b9vi.rs:39:12\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n...\n39 |     return str\n   |            ^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |            |\n   |     \
    \       expected struct `String`, found `&str`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len(), lst.into_iter().chain(lst.into_iter().map(|s|\
    \ s.into_string())).count()) {\n        (0, 0) => \"No\",\n        (l, _) => \"\
    Yes\",\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_string` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmphbc6_0f5.rs:15:71\n   |\n15 |     match (lst.len(),\
    \ lst.into_iter().chain(lst.into_iter().map(|s| s.into_string())).count()) {\n\
    \   |                                                                       ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphbc6_0f5.rs:16:19\n\
    \   |\n14 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                        ------ expected `String` because of return type\n15 |\
    \     match (lst.len(), lst.into_iter().chain(lst.into_iter().map(|s| s.into_string())).count())\
    \ {\n16 |         (0, 0) => \"No\",\n   |                   ^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |                   |\n   |        \
    \           expected struct `String`, found `&str`\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.iter().fold(String::from(\"No\"), |mut acc, x| {\n\
    \        if x.chars().any(|c| !acc.contains('(') && c != '(') {\n            acc.push_str(&*x);\n\
    \            acc\n        } else {\n            acc.push_str(\"No\");\n      \
    \      acc\n        }\n    });\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `?`, `{`, or an operator, found `;`\n  -->\
    \ /tmp/tmpv7twzer7.rs:23:7\n   |\n15 |     match lst.iter().fold(String::from(\"\
    No\"), |mut acc, x| {\n   |     -----\n   |     |\n   |     while parsing this\
    \ `match` expression\n   |     help: try removing this `match`\n...\n23 |    \
    \ });\n   |       ^ expected one of `.`, `?`, `{`, or an operator\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    let mut stack = Vec::new();\n\
    \    for s in lst {\n        let mut is_balanced = false;\n        for ch in s.chars()\
    \ {\n            if ch == '(' && !is_balanced {\n                is_balanced =\
    \ true;\n                stack.push(ch);\n            } else if ch == ')' && is_balanced\
    \ {\n                let top = stack.pop();\n                if top == ch {\n\
    \                    is_balanced = false;\n                } else {\n        \
    \            res = \"No\";\n                }\n            }\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfsypclpy.rs:25:27\n   |\n\
    25 |                 if top == ch {\n   |                           ^^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n\
    \              found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n25 |                 if top == Some(ch) {\n   |                       \
    \    +++++  +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfsypclpy.rs:28:27\n\
    \   |\n15 |     let mut res = String::from(\"No\");\n   |                   ------------------\
    \ expected due to this value\n...\n28 |                     res = \"No\";\n  \
    \ |                           ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                           |\n   |                           expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.sort_by_key(|s| s.len());\n    let mut stack = Vec::new();\n\
    \n    let mut s = String::new();\n    for (idx, s) in lst.iter().enumerate() {\n\
    \        if s.chars().any(|c| c == ('(' || ')')) {\n            stack.push((idx,\
    \ s));\n        }\n    }\n    if stack.len() == 0 {\n        \"No\".to_string()\n\
    \    } else {\n        let mut s = String::new();\n        for ((idx, s)) in stack\
    \ {\n            if let Some(idx) = idx {\n                s.append(&lst[idx..]);\n\
    \            } else {\n                s.append(&s);\n            }\n        }\n\
    \        if s.chars().all(|c| c == '(' || c == ')') {\n            \"Yes\".to_string()\n\
    \        } else {\n            \"No\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around pattern\n  --> /tmp/tmpxokj57wd.rs:28:13\n\
    \   |\n28 |         for ((idx, s)) in stack {\n   |             ^        ^\n \
    \  |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n28 -         for ((idx, s)) in stack {\n28 +         for (idx, s) in stack\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxokj57wd.rs:20:36\n\
    \   |\n20 |         if s.chars().any(|c| c == ('(' || ')')) {\n   |          \
    \                          ^^^ expected `bool`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxokj57wd.rs:20:43\n   |\n20 |         if s.chars().any(|c|\
    \ c == ('(' || ')')) {\n   |                                           ^^^ expected\
    \ `bool`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxokj57wd.rs:20:35\n\
    \   |\n20 |         if s.chars().any(|c| c == ('(' || ')')) {\n   |          \
    \                         ^^^^^^^^^^^^ expected `char`, found `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxokj57wd.rs:29:20\n   |\n29 |             if\
    \ let Some(idx) = idx {\n   |                    ^^^^^^^^^   --- this expression\
    \ has type `usize`\n   |                    |\n   |                    expected\
    \ `usize`, found enum `Option`\n   |\n   = note: expected type `usize`\n     \
    \         found enum `Option<_>`\n\nerror[E0599]: no method named `append` found\
    \ for reference `&String` in the current scope\n  --> /tmp/tmpxokj57wd.rs:30:19\n\
    \   |\n30 |                 s.append(&lst[idx..]);\n   |                   ^^^^^^\
    \ method not found in `&String`\n\nerror[E0599]: no method named `append` found\
    \ for reference `&String` in the current scope\n  --> /tmp/tmpxokj57wd.rs:32:19\n\
    \   |\n32 |                 s.append(&s);\n   |                   ^^^^^^ method\
    \ not found in `&String`\n\nerror: aborting due to 6 previous errors; 1 warning\
    \ emitted\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur: Vec<String> = Vec::new();\n    let mut last: Vec<&str>\
    \ = Vec::new();\n    let mut found = false;\n\n    for s in lst {\n        last\
    \ = cur;\n        cur.clear();\n        for ch in s.chars() {\n            cur.push(&*ch.to_string());\n\
    \            if ch == '(' {\n                cur.push(&*ch.to_string());\n   \
    \         } else if ch == ')' {\n                last = &cur[..];\n          \
    \      break;\n            }\n        }\n        if cur.len() == last.len() {\n\
    \            found = true;\n        } else {\n            found = false;\n   \
    \         break;\n        }\n    }\n    if !found {\n        return String::from(\"\
    No\");\n    } else {\n        return String::from(\"Yes\");\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprgr_kfwu.rs:20:16\n   |\n\
    16 |     let mut last: Vec<&str> = Vec::new();\n   |                   ---------\
    \ expected due to this type\n...\n20 |         last = cur;\n   |             \
    \   ^^^ expected `&str`, found struct `String`\n   |\n   = note: expected struct\
    \ `Vec<&str>`\n              found struct `Vec<String>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprgr_kfwu.rs:23:22\n   |\n23 |             cur.push(&*ch.to_string());\n\
    \   |                      ^^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmprgr_kfwu.rs:25:26\n   |\n25 |\
    \                 cur.push(&*ch.to_string());\n   |                          ^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmprgr_kfwu.rs:27:24\n   |\n16 |     let mut last: Vec<&str> = Vec::new();\n\
    \   |                   --------- expected due to this type\n...\n27 |       \
    \          last = &cur[..];\n   |                        ^^^^^^^^ expected struct\
    \ `Vec`, found `&[String]`\n   |\n   = note: expected struct `Vec<&str>`\n   \
    \        found reference `&[String]`\n\nerror: aborting due to 4 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n    let mut stack = Stack::new();\n\
    \    for s in lst {\n        if s.is_empty() {\n            continue;\n      \
    \  }\n        let mut tmp = String::from(s);\n        stack.push(tmp);\n     \
    \   while !stack.is_empty() {\n            let mut s = stack.pop().unwrap();\n\
    \            if !s.is_empty() {\n                if s.is_open_bracket() {\n  \
    \                  s.push(')');\n                    s.push('(');\n          \
    \      } else {\n                    s.push(')');\n                    s.push('(');\n\
    \                }\n                stack.push(s);\n            } else {\n   \
    \             res = String::from(\"Yes\") if s.is_balanced();\n            }\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmppnuwf7en.rs:35:43\n   |\n35 |                 res = String::from(\"\
    Yes\") if s.is_balanced();\n   |                                           ^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Stack`\n  --> /tmp/tmppnuwf7en.rs:16:21\n \
    \  |\n16 |     let mut stack = Stack::new();\n   |                     ^^^^^ use\
    \ of undeclared type `Stack`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut is_good = false;\n    let mut stack = Vec::new();\n\
    \n    let mut current = String::from(\"\");\n    for s in lst {\n        if s.starts_with(\"\
    (\") {\n            current = String::from(&s[1..]);\n        } else {\n     \
    \       stack.push(current);\n            current = String::from(&s[1..]);\n \
    \       }\n    }\n    if stack.is_empty() {\n        is_good = true;\n    } else\
    \ {\n        let mut curr = String::from(\"\");\n        for s in stack {\n  \
    \          if s.starts_with(\"(\") {\n                curr = curr + &s[1..];\n\
    \            } else {\n                let mut is_ok = true;\n               \
    \ for c in s.chars() {\n                    if !curr.starts_with('(') {\n    \
    \                    is_ok = false;\n                    } else if c == '(' &&\
    \ curr.starts_with('(') {\n                        break;\n                  \
    \  } else if c == '(' && curr != '(' {\n                        curr = &curr[1..];\n\
    \                    }\n                }\n                if !is_ok {\n     \
    \               is_good = false;\n                    break;\n               \
    \ }\n            }\n        }\n    }\n\n    if is_good {\n        \"Yes\"\n  \
    \  } else {\n        \"No\"\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmparpxdh5r.rs:41:48\n\
    \   |\n41 |                     } else if c == '(' && curr != '(' {\n   |    \
    \                                            ^^ no implementation for `String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmparpxdh5r.rs:42:32\n   |\n30 |         let mut curr = String::from(\"\
    \");\n   |                        ---------------- expected due to this value\n\
    ...\n42 |                         curr = &curr[1..];\n   |                   \
    \             ^^^^^^^^^^ expected struct `String`, found `&str`\n   |\nhelp: try\
    \ using a conversion method\n   |\n42 |                         curr = (&curr[1..]).to_string();\n\
    \   |                                +          +++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmparpxdh5r.rs:54:9\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n...\n54 |         \"Yes\"\n   |         ^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |         |\n   |  \
    \       expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmparpxdh5r.rs:56:9\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n...\n56 |         \"No\"\n   |         ^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |         |\n   |         expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some "
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    debug_assert!(lst.len() >= 2);\n    let mut str = String::from(\"\
    \");\n    match lst.iter().take(1).find(|x| x == \"(\") {\n        Some(first)\
    \ => {\n            str = format!(\"{}{}\", str, first);\n            match_parens(lst.iter().take(1).rev());\n\
    \        }\n        None => match (lst.iter().take(1).rev()).find(|x| x == \"\
    (\") {\n            Some(last) => {\n                str = format!(\"{}{}\", str,\
    \ last);\n                match_parens(lst.iter().take(1).rev());\n          \
    \  }\n            _ => format!(\"No\"),\n        }\n    }\n    str\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&String` with `str`\n  --> /tmp/tmpwppm21q6.rs:17:41\n\
    \   |\n17 |     match lst.iter().take(1).find(|x| x == \"(\") {\n   |        \
    \                                 ^^ no implementation for `&String == str`\n\
    \   |\n   = help: the trait `PartialEq<str>` is not implemented for `&String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n   = note: required because\
    \ of the requirements on the impl of `PartialEq<&str>` for `&&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwppm21q6.rs:20:26\n   |\n20 |             match_parens(lst.iter().take(1).rev());\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found struct `Rev`\n   |\n   = note: expected struct `Vec<String>`\n       \
    \       found struct `Rev<std::iter::Take<std::slice::Iter<'_, String>>>`\n\n\
    error[E0277]: can't compare `&String` with `str`\n  --> /tmp/tmpwppm21q6.rs:22:61\n\
    \   |\n22 |         None => match (lst.iter().take(1).rev()).find(|x| x == \"\
    (\") {\n   |                                                             ^^ no\
    \ implementation for `&String == str`\n   |\n   = help: the trait `PartialEq<str>`\
    \ is not implemented for `&String`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n   = note: required because of the requirements on the\
    \ i"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    for s in lst {\n       \
    \ if s.is_empty() {\n            continue;\n        }\n        let mut pos = 0;\n\
    \        while pos < s.len() {\n            if let Some(sp) = stack.peek() {\n\
    \                if let Some(ep) = s.span(&sp) {\n                    stack.pop();\n\
    \                    pos = ep.0;\n                    let mut rem = s.len() -\
    \ pos;\n                    while rem > 0 {\n                        let (op,\
    \ arg) = s.split_at(pos);\n                        *sp = Some((op, arg));\n  \
    \                      rem -= 1;\n                    }\n                }\n \
    \           }\n            stack.push(None);\n            if let Some((op, arg))\
    \ = s.split_at(pos) {\n                if let Some(op_len) = op.len() {\n    \
    \                stack.push(Some((op, op_len)));\n                }\n        \
    \        if let Some(arg_len) = arg.len() {\n                    stack.push(Some((op_len,\
    \ arg)));\n                }\n            }\n            pos += 1;\n        }\n\
    \    }\n\n    let mut s = String::new();\n    let mut done = false;\n    for s\
    \ in stack {\n        if let Some((op, arg)) = s {\n            if !done {\n \
    \               s.push('(');\n            } else {\n                s.push(')');\n\
    \            }\n            if arg.is_empty() {\n                continue;\n \
    \           }\n            if let Some((op_len, arg)) = op {\n               \
    \ s.push(')');\n                s.push('(');\n            }\n            if let\
    \ Some((op_len, arg)) = arg {\n                s.push(')');\n                s.push('(');\n\
    \            }\n            if let Some((op_len, arg)) = arg {\n             \
    \   s.push(')');\n                s.push('(');\n            }\n            if\
    \ let Some((op_len, arg)) = arg {\n                s.push(')');\n            \
    \    s.push('(');\n            }\n            done = true;\n        }\n    }\n\
    \n    s\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpcz_vrwfh.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0425]:\
    \ cannot find value `op_len` in this scope\n  --> /tmp/tmpcz_vrwfh.rs:40:38\n\
    \   |\n40 |                     stack.push(Some((op_len, arg)));\n   |       \
    \                               ^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `span` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpcz_vrwfh.rs:23:37\n   |\n23 |                 if let Some(ep) = s.span(&sp)\
    \ {\n   |                                     ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpcz_vrwfh.rs:35:20\n   |\n35 |\
    \             if let Some((op, arg)) = s.split_at(pos) {\n   |               \
    \     ^^^^^^^^^^^^^^^   --------------- this expression has type `(&str, &str)`\n\
    \   |                    |\n   |                    expected tuple, found enum\
    \ `Option`\n   |\n   = note: expected tuple `(&str, &str)`\n               found\
    \ enum `Option<_>`\n\nerror[E0599]: no method named `push` found for enum `Option`\
    \ in the current scope\n  --> /tmp/tmpcz_vrwfh.rs:52:19\n   |\n52 |          \
    \       s.push('(');\n   |                   ^^^^ method not found in `Option<(_,\
    \ _)>`\n\nerror[E0599]: no method named `push` found for enum `Option` in the\
    \ current scope\n  --> /tmp/tmpcz_vrwfh.rs:54:19\n   |\n54 |                 s.push(')');\n\
    \   |                   ^^^^ method not found in `Option<(_, _)>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cur = String::new();\n    let mut stack = Vec::new();\n\
    \n    for s in lst {\n        let mut last = cur;\n        for c in s.chars()\
    \ {\n            if c == '(' { stack.push(c); }\n            else if c == ')'\
    \ {\n                if !stack.is_empty() {\n                    cur = stack.pop().unwrap();\n\
    \                }\n                else {\n                    return String::from(\"\
    No\");\n                }\n            }\n            cur.push(c);\n         \
    \   last = c;\n        }\n    }\n\n    if !stack.is_empty() {\n        cur = stack.pop().unwrap();\n\
    \    }\n\n    String::from(cur)\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg1ou39vl.rs:24:27\n   |\n\
    15 |     let mut cur = String::new();\n   |                   ------------- expected\
    \ due to this value\n...\n24 |                     cur = stack.pop().unwrap();\n\
    \   |                           ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                           |\n   |             \
    \              expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg1ou39vl.rs:31:20\n   |\n19 |         let mut last = cur;\n\
    \   |                        --- expected due to this value\n...\n31 |       \
    \      last = c;\n   |                    ^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg1ou39vl.rs:36:15\n\
    \   |\n15 |     let mut cur = String::new();\n   |                   -------------\
    \ expected due to this value\n...\n36 |         cur = stack.pop().unwrap();\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |               |\n   |               expected struct `String`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut index = 0\n    let mut res = String::from(\"No\");\n\
    \    let mut stack = String::from(\"()\");\n    stack.push_str(&mut res);\n\n\
    \    while index < lst.len() {\n        if lst[index].len() <= 1 {\n         \
    \   stack.push_str(&mut res);\n            stack.pop();\n        } else {\n  \
    \          if lst[index][lst[index].len() - 1] == '(' {\n                stack.push_str(&mut\
    \ res);\n                stack.pop();\n            } else {\n                if\
    \ stack.pop() != ')' {\n                    stack.push_str(&mut res);\n      \
    \          }\n            }\n        }\n\n        if stack.len() < 1 {\n     \
    \       break;\n        }\n\n        index += 1;\n    }\n\n    res\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmpv0ph8pu9.rs:15:22\n\
    \   |\n15 |     let mut index = 0\n   |                      ^ help: add `;` here\n\
    16 |     let mut res = String::from(\"No\");\n   |     --- unexpected token\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpv0ph8pu9.rs:25:16\n\
    \   |\n25 |             if lst[index][lst[index].len() - 1] == '(' {\n   |   \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv0ph8pu9.rs:29:35\n\
    \   |\n29 |                 if stack.pop() != ')' {\n   |                    \
    \               ^^^ expected enum `Option`, found `char`\n   |\n   = note: expected\
    \ enum `Option<char>`\n              found type `char`\nhelp: try wrapping the\
    \ expression in `Some`\n   |\n29 |                 if stack.pop() != Some(')')\
    \ {\n   |                                   +++++   +\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n\n    for s in lst.into_iter()\
    \ {\n        if s == '(' {\n            stack.push(s);\n        } else {\n   \
    \         if !stack.is_empty() && stack.last().unwrap() == ')' {\n           \
    \     stack.pop();\n            } else {\n                return String::from(\"\
    No\");\n            }\n        }\n    }\n    if stack.is_empty() {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `char`\n  --> /tmp/tmpqk1dng1m.rs:18:14\n\
    \   |\n18 |         if s == '(' {\n   |              ^^ no implementation for\
    \ `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0277]: can't compare\
    \ `&String` with `char`\n  --> /tmp/tmpqk1dng1m.rs:21:59\n   |\n21 |         \
    \    if !stack.is_empty() && stack.last().unwrap() == ')' {\n   |            \
    \                                               ^^ no implementation for `&String\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut s = String::new();\n\
    \n    for i in lst.iter().rev() {\n        if i.len() > 0 && i.chars().all(|c|\
    \ c == '(') || i.len() > 0 && i.chars().all(|c| c == ')') {\n            if stack.is_empty()\
    \ {\n                s.push(format!(\"{}\", i.to_string()));\n            } else\
    \ {\n                let top = stack.pop();\n                if top != i {\n \
    \                   s.push(\"No\".to_owned());\n                }\n          \
    \  }\n        } else {\n            s.push(\"No\".to_owned());\n        }\n  \
    \      stack.push(i);\n    }\n\n    if !stack.is_empty() {\n        s.push(\"\
    No\".to_owned());\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpme7mvrgv.rs:21:24\n   |\n\
    21 |                 s.push(format!(\"{}\", i.to_string()));\n   |           \
    \             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpme7mvrgv.rs:24:27\n   |\n24 |                 if top != i {\n \
    \  |                           ^ expected enum `Option`, found `&String`\n   |\n\
    \   = note:   expected enum `Option<_>`\n           found reference `&String`\n\
    help: try wrapping the expression in `Some`\n   |\n24 |                 if top\
    \ != Some(i) {\n   |                           +++++ +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpme7mvrgv.rs:25:28\n   |\n25 |                     s.push(\"\
    No\".to_owned());\n   |                            ^^^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpme7mvrgv.rs:29:20\n\
    \   |\n29 |             s.push(\"No\".to_owned());\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpme7mvrgv.rs:35:16\n   |\n35 |         s.push(\"No\".to_owned());\n\
    \   |                ^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 5 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for e in lst {\n        if\
    \ let String::from(\")\") = e {\n            stack.clear();\n        } else if\
    \ let String::from(\"(\") = e {\n            stack.push(e);\n        } else {\n\
    \            if stack.len() == 0 {\n                return String::from(\"No\"\
    );\n            }\n            if stack.len() == 1 {\n                return String::from(\"\
    Yes\");\n            }\n            if stack.len() == 2 {\n                if\
    \ !contains_balanced(&stack) {\n                    return String::from(\"No\"\
    );\n                }\n            }\n        }\n    }\n    return String::from(\"\
    No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `contains_balanced` in this scope\n\
    \  --> /tmp/tmptm2pubps.rs:29:21\n   |\n29 |                 if !contains_balanced(&stack)\
    \ {\n   |                     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0164]:\
    \ expected tuple struct or tuple variant, found associated function `String::from`\n\
    \  --> /tmp/tmptm2pubps.rs:17:16\n   |\n17 |         if let String::from(\")\"\
    ) = e {\n   |                ^^^^^^^^^^^^^^^^^ `fn` calls are not allowed in patterns\n\
    \   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0164]: expected tuple struct or tuple variant, found associated function\
    \ `String::from`\n  --> /tmp/tmptm2pubps.rs:19:23\n   |\n19 |         } else if\
    \ let String::from(\"(\") = e {\n   |                       ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0164, E0425.\n\
    For more information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        0 => \"Yes\",\n        1 => \"No\"\
    ,\n        _ => {\n            let mut res = String::from(\"\");\n           \
    \ let mut stack = vec![];\n            for i in lst {\n                let c:\
    \ char = i[0];\n                let mut has_open = false;\n                for\
    \ j in stack {\n                    let jc: char = j[0];\n                   \
    \ if c == jc {\n                        has_open = true;\n                   \
    \     break;\n                    }\n                }\n                if has_open\
    \ {\n                    stack.push(i);\n                } else {\n          \
    \          if res.is_empty() || \"()\".contains(&res) {\n                    \
    \    res += &*i;\n                    } else {\n                        res +=\
    \ &*i + \")\";\n                    }\n                }\n            }\n    \
    \        \"No\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6ke0l2xv.rs:16:14\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     match\
    \ lst.len() {\n16 |         0 => \"Yes\",\n   |              ^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |              |\n   |       \
    \       expected struct `String`, found `&str`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp6ke0l2xv.rs:22:31\n   |\n22\
    \ |                 let c: char = i[0];\n   |                               ^^^^\
    \ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmp6ke0l2xv.rs:37:36\n\
    \   |\n37 |                         res += &*i + \")\";\n   |                \
    \                --- ^ --- &str\n   |                                |   |\n \
    \  |                                |   `+` cannot be used to concatenate two\
    \ `&str` strings\n   |                                &str\n   |\n   = note: string\
    \ concatenation requires an owned `String` on the left\nhelp: remove the borrow\
    \ to obtain an owned `String`\n   |\n37 -                         res += &*i +\
    \ \")\";\n37 +                         res += *i + \")\";\n   | \n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().fold(String::from(\"No\"), |acc, curr| {\n     \
    \   let mut open = false;\n        let mut open_bracket = 0;\n        let mut\
    \ closed_bracket = 0;\n        for (i, c) in acc.chars().enumerate() {\n     \
    \       match curr {\n                '(' | ')' => if c == '(' {\n           \
    \         open = true;\n                    open_bracket += 1;\n             \
    \   } else if c == '}' && open == true {\n                    open = false;\n\
    \                    closed_bracket += 1;\n                }\n               \
    \ _ => {}\n            }\n        }\n        if open_bracket > closed_bracket\
    \ {\n            acc.to_string()\n        } else {\n            \"No\".to_string()\n\
    \        }\n    })\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp30vf4jzm.rs:21:17\n   |\n\
    20 |             match curr {\n   |                   ---- this expression has\
    \ type `&String`\n21 |                 '(' | ')' => if c == '(' {\n   |      \
    \           ^^^ expected struct `String`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp30vf4jzm.rs:21:23\n   |\n20 |             match curr {\n\
    \   |                   ---- this expression has type `&String`\n21 |        \
    \         '(' | ')' => if c == '(' {\n   |                       ^^^ expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut str = String::from(\"No\");\n    let mut stack = VecDeque::new();\n\
    \    let mut open_count = stack.len();\n    let mut closed_count = open_count;\n\
    \    for s in lst {\n        let open = s.is_empty();\n        if open == open_count\
    \ {\n            open_count += 1;\n        } else {\n            if open_count\
    \ == stack.len() {\n                stack.pop_back();\n            }\n       \
    \     open_count -= 1;\n        }\n        let close = s.is_empty();\n       \
    \ if close == closed_count {\n            closed_count += 1;\n        } else {\n\
    \            if closed_count == stack.len() {\n                stack.pop_back();\n\
    \            }\n            closed_count -= 1;\n        }\n        if open {\n\
    \            stack.pop_back();\n        }\n        if close {\n            stack.push_back(true);\n\
    \        }\n    }\n    if open_count != stack.len() {\n        str = \"No\";\n\
    \    } else {\n        str = \"Yes\";\n    }\n    str\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmpa1a3s8jk.rs:16:21\n   |\n16 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `bool`\n\
    \  --> /tmp/tmpa1a3s8jk.rs:22:13\n   |\n22 |             open_count += 1;\n  \
    \ |             ----------^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `bool`\n\nerror[E0368]: binary assignment operation `-=` cannot\
    \ be applied to type `bool`\n  --> /tmp/tmpa1a3s8jk.rs:27:13\n   |\n27 |     \
    \        open_count -= 1;\n   |             ----------^^^^^\n   |            \
    \ |\n   |             cannot use `-=` on type `bool`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `bool`\n  --> /tmp/tmpa1a3s8jk.rs:31:13\n\
    \   |\n31 |             closed_count += 1;\n   |             ------------^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `bool`\n\nerror[E0368]:\
    \ binary assignment operation `-=` cannot be applied to type `bool`\n  --> /tmp/tmpa1a3s8jk.rs:36:13\n\
    \   |\n36 |             closed_count -= 1;\n   |             ------------^^^^^\n\
    \   |             |\n   |             cannot use `-=` on type `bool`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpa1a3s8jk.rs:46:15\n   |\n15 |     let mut str\
    \ = String::from(\"No\");\n   |                   ------------------ expected\
    \ due to this value\n...\n46 |         str = \"No\";\n   |               ^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |               |\n\
    \   |               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpa1a3s8jk.rs:48:15\n   |\n15 |     let mut str = String::from(\"\
    No\");\n   |                   ------------------ expected due to this value\n\
    ...\n48 |         str = \"Yes\";\n   |               ^^^^^- help: try using a\
    \ conversion method: `.to_string()`\n   |               |\n   |              \
    \ expected struct `String`, found `&str`\n\nerro"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<String> = Vec::new();\n    let mut cur_str:\
    \ String = \"\";\n    let mut is_good = true;\n\n    for s in lst.iter() {\n \
    \       if s == \"(\" || s == \"{\" || s == \"[\" {\n            stack.push(s);\n\
    \        } else {\n            if stack.is_empty() {\n                is_good\
    \ = false;\n                break;\n            }\n            let top = stack.pop();\n\
    \            if s == top {\n                continue;\n            }\n       \
    \     cur_str = cur_str + s;\n        }\n    }\n    if is_good {\n        String::from(cur_str)\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2u_64_di.rs:16:31\n   |\n\
    16 |     let mut cur_str: String = \"\";\n   |                      ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2u_64_di.rs:21:24\n   |\n21 |             stack.push(s);\n\
    \   |                        ^- help: try using a conversion method: `.to_string()`\n\
    \   |                        |\n   |                        expected struct `String`,\
    \ found `&String`\n\nerror[E0277]: can't compare `&String` with `Option<String>`\n\
    \  --> /tmp/tmp2u_64_di.rs:28:18\n   |\n28 |             if s == top {\n   | \
    \                 ^^ no implementation for `&String == Option<String>`\n   |\n\
    \   = help: the trait `PartialEq<Option<String>>` is not implemented for `&String`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         <&'a str as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n\
    \             <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // This solution works in O(n).\n    // We create a map of\
    \ all the '('s we have encountered in the given list.\n    let mut open_pars =\
    \ HashMap::new();\n    for s in lst {\n        if s.contains('(') {\n        \
    \    open_pars.insert(s.chars().next().unwrap(), '(');\n        }\n    }\n\n \
    \   // Start with an empty string and append valid strings to it.\n    let mut\
    \ str = String::new();\n    let mut cur = &str[..];\n    for s in lst {\n    \
    \    if s.contains('(') {\n            // If the current string has an open paren,\
    \ we check if that paren\n            // is currently balanced.\n            if\
    \ open_pars.get(&s[..]).unwrap() == '(' {\n                // If the paren is\
    \ balanced, then append the current string and make\n                // a new\
    \ string with only this paren.\n                str.push_str(&s[..]);\n      \
    \          cur = &str[..];\n            } else {\n                // Else, the\
    \ paren is not balanced. We append the current string and make\n             \
    \   // a new string with two parens added.\n                let (first, second)\
    \ = cur.split_at_mut(2);\n                first.push_str(&s[..]);\n          \
    \      second.push('(');\n                str.push_str(first);\n             \
    \   str.push_str(second);\n            }\n        }\n    }\n\n    // Check if\
    \ any parens were not balanced.\n    if cur != &str[..] {\n        // Yes, there\
    \ is an invalid string in the list\n        String::from(\"No\")\n    } else {\n\
    \        // No invalid strings in the list\n        String::from(\"Yes\")\n  \
    \  }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpat_ddh6r.rs:17:25\n   |\n17 |     let mut open_pars = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `push_str` found for mutable reference `&mut str` in the current\
    \ scope\n  --> /tmp/tmpat_ddh6r.rs:40:23\n   |\n40 |                 first.push_str(&s[..]);\n\
    \   |                       ^^^^^^^^ method not found in `&mut str`\n\nerror[E0599]:\
    \ no method named `push` found for mutable reference `&mut str` in the current\
    \ scope\n  --> /tmp/tmpat_ddh6r.rs:41:24\n   |\n41 |                 second.push('(');\n\
    \   |                        ^^^^ method not found in `&mut str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        0 => \"No\",\n        _ => match_parens(lst.into_iter().filter_map(|s|\
    \ s.is_open()).take_while(|x| !x.is_open()).collect())\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvqybsda0.rs:16:14\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     match\
    \ lst.len() {\n16 |         0 => \"No\",\n   |              ^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |              |\n   |             \
    \ expected struct `String`, found `&str`\n\nerror[E0599]: no method named `is_open`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpvqybsda0.rs:17:60\n\
    \   |\n17 |         _ => match_parens(lst.into_iter().filter_map(|s| s.is_open()).take_while(|x|\
    \ !x.is_open()).collect())\n   |                                             \
    \               ^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        0 => String::from(\"No\"),\n   \
    \     _ => if lst.is_sorted(|a, b| a.cmp(b).unwrap()) {\n            match (lst.iter().map(|s|\
    \ s.chars().count()).collect::<Vec<_>>()).iter().find(|&c| c == 1) {\n       \
    \         Some(1) => String::from(\"Yes\"),\n                Some(c) => String::from(\"\
    No\"),\n                None => String::from(\"No\"),\n            }\n       \
    \ } else {\n            String::from(\"No\"),\n        },\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `,`\n\
    \  --> /tmp/tmpb7xb0r2b.rs:24:31\n   |\n24 |             String::from(\"No\"),\n\
    \   |                               ^ expected one of `.`, `;`, `?`, `}`, or an\
    \ operator\n\nerror[E0658]: use of unstable library feature 'is_sorted': new API\n\
    \  --> /tmp/tmpb7xb0r2b.rs:17:21\n   |\n17 |         _ => if lst.is_sorted(|a,\
    \ b| a.cmp(b).unwrap()) {\n   |                     ^^^^^^^^^\n   |\n   = note:\
    \ see issue #53485 <https://github.com/rust-lang/rust/issues/53485> for more information\n\
    \nerror[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpb7xb0r2b.rs:17:21\n     |\n17   |         _ => if lst.is_sorted(|a,\
    \ b| a.cmp(b).unwrap()) {\n     |                     ^^^^^^^^^ ------------------------\
    \ supplied 1 argument\n     |                     |\n     |                  \
    \   expected 0 arguments\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ can't compare `&usize` with `{integer}`\n  --> /tmp/tmpb7xb0r2b.rs:18:98\n \
    \  |\n18 |             match (lst.iter().map(|s| s.chars().count()).collect::<Vec<_>>()).iter().find(|&c|\
    \ c == 1) {\n   |                                                            \
    \                                      ^^ no implementation for `&usize == {integer}`\n\
    \   |\n   = help: the trait `PartialEq<{integer}>` is not implemented for `&usize`\n\
    \   = help: the following other types implement trait `PartialEq<Rhs>`:\n    \
    \         f32\n             f64\n             i128\n             i16\n       \
    \      i32\n             i64\n             i8\n             isize\n          \
    \ and 6 others\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() <= 1 {\n        return String::from(\"No\");\n\
    \    }\n\n    match_parens_impl(lst, false, 0)\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_impl` in this scope\n\
    \  --> /tmp/tmptnfu9_6a.rs:19:5\n   |\n19 |     match_parens_impl(lst, false,\
    \ 0)\n   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new();\n    for s in lst {\n       \
    \ match s {\n            Character(c) => {\n                stack.push(c);\n \
    \           }\n            String::from(r) => {\n                stack.push(r);\n\
    \            }\n        }\n    }\n    match stack.pop() {\n        Some('(') =>\
    \ {\n            return \"Yes\";\n        }\n        Some(')') => {\n        \
    \    return \"No\";\n        }\n        None => return \"No\",\n    }\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpm8x7e0b2.rs:15:21\n   |\n15 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror[E0531]:\
    \ cannot find tuple struct or tuple variant `Character` in this scope\n  --> /tmp/tmpm8x7e0b2.rs:18:13\n\
    \   |\n18 |             Character(c) => {\n   |             ^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0164]: expected tuple struct or tuple variant, found\
    \ associated function `String::from`\n  --> /tmp/tmpm8x7e0b2.rs:21:13\n   |\n\
    21 |             String::from(r) => {\n   |             ^^^^^^^^^^^^^^^ `fn` calls\
    \ are not allowed in patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpm8x7e0b2.rs:28:20\n   |\n14 |\
    \ fn match_parens(lst: Vec<String>) -> String {\n   |                        \
    \              ------ expected `String` because of return type\n...\n28 |    \
    \         return \"Yes\";\n   |                    ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0164, E0308, E0433, E0531.\nFor more\
    \ information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<bool> = vec![false; lst.len() + 1];\n  \
    \  let mut incl = String::from(\"No\");\n    let mut excl = String::from(\"Yes\"\
    );\n    for s in lst {\n        stack.push(s.chars().any(|&b| b == '(' || b ==\
    \ ')'));\n    }\n    while let Some(i) = (stack.iter().position(|&b| b == false)\
    \ + 1) {\n        if stack[i] == true {\n            incl = String::from(\"No\"\
    );\n        } else {\n            stack[i] = true;\n            excl = String::from(\"\
    Yes\");\n        }\n        for s in lst {\n            if stack[i + s.len()]\
    \ {\n                stack[i + s.len()] = false;\n                let mut c =\
    \ 0;\n                while let Some(b) = s.chars().next() {\n               \
    \     c += 1;\n                    if c == i {\n                        let mut\
    \ s = String::from(\"No\");\n                        if stack[i + s.len()] ==\
    \ true {\n                            s = String::from(\"Yes\");\n           \
    \             }\n                        excl = s;\n                        break;\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   incl\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `let` scrutinee expression\n  -->\
    \ /tmp/tmparhi13xf.rs:21:25\n   |\n21 |     while let Some(i) = (stack.iter().position(|&b|\
    \ b == false) + 1) {\n   |                         ^                         \
    \                 ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n21 -     while let Some(i) = (stack.iter().position(|&b|\
    \ b == false) + 1) {\n21 +     while let Some(i) = stack.iter().position(|&b|\
    \ b == false) + 1 {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmparhi13xf.rs:19:35\n\
    \   |\n19 |         stack.push(s.chars().any(|&b| b == '(' || b == ')'));\n  \
    \ |                                   ^--\n   |                              \
    \     ||\n   |                                   |expected due to this\n   | \
    \                                  expected `char`, found reference\n   |    \
    \                               help: did you mean `b`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0369]: cannot\
    \ add `{integer}` to `Option<usize>`\n  --> /tmp/tmparhi13xf.rs:21:65\n   |\n\
    21 |     while let Some(i) = (stack.iter().position(|&b| b == false) + 1) {\n\
    \   |                          -------------------------------------- ^ - {integer}\n\
    \   |                          |\n   |                          Option<usize>\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0308, E0369.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"No\");\n\n    for str in lst {\n\
    \        let mut in_bracket = false;\n        for c in str.chars() {\n       \
    \     if c == '(' {\n                if in_bracket {\n                    res.push_str(\"\
    No\");\n                    return res;\n                }\n                in_bracket\
    \ = true;\n            } else {\n                res.push_str(&str[c.len()..]);\n\
    \            }\n        }\n\n        res.push_str(&str[str.len()..]);\n    }\n\
    \n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpi5yycjz8.rs:27:37\n   |\n27 |                 res.push_str(&str[c.len()..]);\n\
    \   |                                     ^^^ method not found in `char`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst.len() as i32, &*lst.last().unwrap()) {\n       \
    \ (2, Some('(')) => String::from(\"Yes\"),\n        (2, Some(')')) => String::from(\"\
    No\"),\n        _ => unreachable!(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_qh0deua.rs:16:13\n   |\n\
    15 |     match (lst.len() as i32, &*lst.last().unwrap()) {\n   |           -----------------------------------------\
    \ this expression has type `(i32, &String)`\n16 |         (2, Some('(')) => String::from(\"\
    Yes\"),\n   |             ^^^^^^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp_qh0deua.rs:17:13\n   |\n15 |\
    \     match (lst.len() as i32, &*lst.last().unwrap()) {\n   |           -----------------------------------------\
    \ this expression has type `(i32, &String)`\n16 |         (2, Some('(')) => String::from(\"\
    Yes\"),\n17 |         (2, Some(')')) => String::from(\"No\"),\n   |          \
    \   ^^^^^^^^^ expected struct `String`, found enum `Option`\n   |\n   = note:\
    \ expected struct `String`\n                found enum `Option<_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<bool> = Vec::new();\n    stack.push(true);\n\
    \    let mut res = String::from(\"No\");\n    for i in 1..lst.len() {\n      \
    \  match stack.pop() {\n            true => {\n                if lst[i - 1] ==\
    \ '(' && lst[i - 1] == lst[i] {\n                    stack.push(false);\n    \
    \            }\n            }\n            false => {\n                if lst[i\
    \ - 1] == '{' && lst[i - 1] == lst[i] {\n                    stack.push(false);\n\
    \                }\n            }\n        }\n        if stack.is_empty() {\n\
    \            res = \"Yes\".to_string();\n            return res;\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmw6mxcu9.rs:20:13\n   |\n\
    19 |         match stack.pop() {\n   |               ----------- this expression\
    \ has type `Option<bool>`\n20 |             true => {\n   |             ^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<bool>`\n\
    \              found type `bool`\nhelp: try wrapping the pattern in `Some`\n \
    \  |\n20 |             Some(true) => {\n   |             +++++    +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmw6mxcu9.rs:25:13\n   |\n19 |         match\
    \ stack.pop() {\n   |               ----------- this expression has type `Option<bool>`\n\
    ...\n25 |             false => {\n   |             ^^^^^ expected enum `Option`,\
    \ found `bool`\n   |\n   = note: expected enum `Option<bool>`\n              found\
    \ type `bool`\nhelp: try wrapping the pattern in `Some`\n   |\n25 |          \
    \   Some(false) => {\n   |             +++++     +\n\nerror[E0277]: can't compare\
    \ `String` with `char`\n  --> /tmp/tmpmw6mxcu9.rs:21:31\n   |\n21 |          \
    \       if lst[i - 1] == '(' && lst[i - 1] == lst[i] {\n   |                 \
    \              ^^ no implementation for `String == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n\
    \             <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror[E0277]: can't compare `String` with `char`\n\
    \  --> /tmp/tmpmw6mxcu9.rs:26:31\n   |\n26 |                 if lst[i - 1] ==\
    \ '{' && lst[i - 1] == lst[i] {\n   |                               ^^ no implementation\
    \ for `String == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             <&'a s"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        1 => \"Yes\".to_string(),\n    \
    \    _ => return \"No\".to_string(),\n    }\n\n    let mut open_braces = Vec::new();\n\
    \    let mut close_braces = Vec::new();\n\n    for s in lst {\n        if s.contains('(')\
    \ {\n            open_braces.push(s);\n        } else {\n            close_braces.push(s);\n\
    \        }\n    }\n\n    if open_braces.len() == close_braces.len() {\n      \
    \  if open_braces.len() == 1 {\n            if open_braces[0] == close_braces[0]\
    \ {\n                \"Yes\".to_string()\n            } else {\n             \
    \   \"No\".to_string()\n            }\n        } else {\n            \"No\".to_string()\n\
    \        }\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvnzx6qgx.rs:15:5\n   |\n\
    15 | /     match lst.len() {\n16 | |         1 => \"Yes\".to_string(),\n17 | |\
    \         _ => return \"No\".to_string(),\n18 | |     }\n   | |     ^- help: consider\
    \ using a semicolon here\n   | |_____|\n   |       expected `()`, found struct\
    \ `String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Stack::new(0);\n    for s in lst {\n      \
    \  if let Some(index) = stack.find(s) {\n            if index > 0 {\n        \
    \        return String::from(\"No\");\n            }\n        }\n        stack.add(s);\n\
    \    }\n    match stack.len() {\n        0 => String::from(\"Yes\"),\n       \
    \ _ => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp8bcc8qez.rs:15:21\n   |\n15 |     let mut stack = Stack::new(0);\n \
    \  |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Convert each string to a map of \"chars\" and \"depth\"\
    \ where each char is\n    // mapped to the depth of the corresponding closing\
    \ parentheses.\n    // For example, the string \"()\" has depth 0, and \"(\" has\
    \ depth 1.\n    let mut chars = Vec::new();\n    for s in lst.iter() {\n     \
    \   for ch in s.chars() {\n            if chars.len() == 0 {\n               \
    \ chars.push(ch);\n            } else {\n                let mut curr_char = chars.remove(0);\n\
    \                chars.push((ch, curr_char.0));\n            }\n        }\n  \
    \  }\n\n    // Create a mapping from the strings to the lengths of the strings,\
    \ and then\n    // sort the mapping by key.\n    let mut str_to_len = Vec::new();\n\
    \    for s in chars {\n        str_to_len.push((s.0, s.1));\n    }\n    str_to_len.sort_by_key(|(_,\
    \ len)| len);\n\n    // Iterate over the mapping, checking for opening and closing\
    \ parentheses.\n    fn check_parens(mut depth: usize) -> usize {\n        depth\
    \ -= 1;\n        if depth != 0 {\n            let depth = check_parens(depth);\n\
    \        }\n        depth\n    }\n\n    let mut depth = check_parens(0);\n\n \
    \   match str_to_len.iter().next() {\n        Some((_, s)) => match_parens_helper(s,\
    \ s.0, &chars, &mut depth),\n        None => {\n            let mut depth = check_parens(depth);\n\
    \            if depth != 0 {\n                return match_parens_helper(&String::from(\"\
    Yes\"), 0, &chars, &mut depth)\n            }\n            match_parens_helper(&String::from(\"\
    No\"), 0, &chars, &mut depth)\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmpqwi1sgs9.rs:50:25\n   |\n50 |         Some((_, s)) => match_parens_helper(s,\
    \ s.0, &chars, &mut depth),\n   |                         ^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `match_parens_helper`\
    \ in this scope\n  --> /tmp/tmpqwi1sgs9.rs:54:24\n   |\n54 |                 return\
    \ match_parens_helper(&String::from(\"Yes\"), 0, &chars, &mut depth)\n   |   \
    \                     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `match_parens_helper` in this scope\n  --> /tmp/tmpqwi1sgs9.rs:56:13\n\
    \   |\n56 |             match_parens_helper(&String::from(\"No\"), 0, &chars,\
    \ &mut depth)\n   |             ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0610]: `char` is a primitive type and therefore doesn't have fields\n \
    \ --> /tmp/tmpqwi1sgs9.rs:25:43\n   |\n25 |                 chars.push((ch, curr_char.0));\n\
    \   |                                           ^\n\nerror[E0610]: `char` is a\
    \ primitive type and therefore doesn't have fields\n  --> /tmp/tmpqwi1sgs9.rs:34:28\n\
    \   |\n34 |         str_to_len.push((s.0, s.1));\n   |                       \
    \     ^\n\nerror[E0610]: `char` is a primitive type and therefore doesn't have\
    \ fields\n  --> /tmp/tmpqwi1sgs9.rs:34:33\n   |\n34 |         str_to_len.push((s.0,\
    \ s.1));\n   |                                 ^\n\nerror[E0609]: no field `0`\
    \ on type `&_`\n  --> /tmp/tmpqwi1sgs9.rs:50:50\n   |\n50 |         Some((_, s))\
    \ => match_parens_helper(s, s.0, &chars, &mut depth),\n   |                  \
    \                                ^\n\nerror: aborting due to 7 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0609, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    debug_assert!(lst.len() == 2);\n\n    let mut seen = HashMap::new();\n\
    \    seen.insert(String::from(\"(\"), String::from(\")\"));\n\n    for s in lst\
    \ {\n        let mut found = false;\n        for ch in s.chars() {\n         \
    \   if !seen.contains_key(&ch) {\n                found = true;\n            \
    \    seen.insert(ch, String::from(\"(\"));\n            } else if ch == ')' {\n\
    \                if !seen.contains_key(&ch) {\n                    found = true;\n\
    \                    seen.insert(ch, String::from(\")\"));\n                }\
    \ else {\n                    let left = seen.get(&ch).unwrap();\n           \
    \         let right = seen.get(&s.chars().last().unwrap()).unwrap();\n       \
    \             let new_string = left.chars().cloned().join(&right).to_string();\n\
    \                    seen.insert(ch, new_string);\n                }\n       \
    \     }\n        }\n\n        if !found {\n            return String::from(\"\
    No\");\n        }\n    }\n\n    let left = seen.get(&ch).unwrap();\n    let right\
    \ = seen.get(&s.chars().last().unwrap()).unwrap();\n    let new_string = left.chars().cloned().join(&right).to_string();\n\
    \    seen.insert(ch, new_string);\n    String::from(new_string)\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpi8nhu8n3.rs:17:20\n   |\n17 |     let mut seen = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `ch` in this scope\n  --> /tmp/tmpi8nhu8n3.rs:44:26\n   |\n\
    44 |     let left = seen.get(&ch).unwrap();\n   |                          ^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `s` in this scope\n\
    \  --> /tmp/tmpi8nhu8n3.rs:45:27\n   |\n45 |     let right = seen.get(&s.chars().last().unwrap()).unwrap();\n\
    \   |                           ^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ch` in this scope\n  --> /tmp/tmpi8nhu8n3.rs:47:17\n   |\n47 | \
    \    seen.insert(ch, new_string);\n   |                 ^^ not found in this scope\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    debug_assert!(lst.len() == 2);\n    if lst.iter().find(|s|\
    \ s.contains(\")\")) == Some(lst.len() - 1) {\n        String::from(\"Yes\")\n\
    \    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpcywl183j.rs:16:53\n   |\n\
    16 |     if lst.iter().find(|s| s.contains(\")\")) == Some(lst.len() - 1) {\n\
    \   |                                                     ^^^^^^^^^^^^^ expected\
    \ `&String`, found `usize`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Your code here\n    let mut state = StackState::new(&lst);\n\
    \    match state.check_parens(0) {\n        Ok(Some(mut state)) => \"Yes\",\n\
    \        Ok(None) => \"No\",\n        Err(_) => \"\",\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `StackState`\n\
    \  --> /tmp/tmpbq159atb.rs:16:21\n   |\n16 |     let mut state = StackState::new(&lst);\n\
    \   |                     ^^^^^^^^^^ use of undeclared type `StackState`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbq159atb.rs:18:32\n   |\n14 | fn match_parens(lst:\
    \ Vec<String>) -> String {\n   |                                      ------ expected\
    \ `String` because of return type\n...\n18 |         Ok(Some(mut state)) => \"\
    Yes\",\n   |                                ^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                                |\n   |        \
    \                        expected struct `String`, found `&str`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<bool> = vec![true; lst.len()];\n    let\
    \ mut ans = String::from(\"No\");\n\n    for s in lst {\n        for _ in 0..=s.len()\
    \ {\n            stack.push(false);\n        }\n        while !stack.is_empty()\
    \ {\n            if stack.pop() == true {\n                ans = ans.push_str(&s);\n\
    \                if s.len() == 1 {\n                    break;\n             \
    \   }\n            } else {\n                let open = s.pop();\n           \
    \     let close = s.pop();\n                stack.push(open == close);\n     \
    \       }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfv1gfyfr.rs:23:31\n   |\n\
    23 |             if stack.pop() == true {\n   |                              \
    \ ^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<bool>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n23 |             if stack.pop() == Some(true) {\n   |                 \
    \              +++++    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfv1gfyfr.rs:24:23\n\
    \   |\n16 |     let mut ans = String::from(\"No\");\n   |                   ------------------\
    \ expected due to this value\n...\n24 |                 ans = ans.push_str(&s);\n\
    \   |                       ^^^^^^^^^^^^^^^^ expected struct `String`, found `()`\n\
    \   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpfv1gfyfr.rs:24:27\n\
    \   |\n24 |                 ans = ans.push_str(&s);\n   |                    \
    \   --- ^^^^^^^^ this call modifies `ans` in-place\n   |                     \
    \  |\n   |                       you probably want to use this value after calling\
    \ the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.into_iter().fold(\"Yes\", |s, &x| {\n        match_parens_helper(&x,\
    \ &s)\n    }).unwrap()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `match_parens_helper` in this scope\n\
    \  --> /tmp/tmp_9wvsqgr.rs:16:9\n   |\n16 |         match_parens_helper(&x, &s)\n\
    \   |         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_9wvsqgr.rs:15:37\n   |\n15 |     lst.into_iter().fold(\"\
    Yes\", |s, &x| {\n   |                                     ^--\n   |         \
    \                            ||\n   |                                     |expected\
    \ due to this\n   |                                     expected struct `String`,\
    \ found reference\n   |                                     help: did you mean\
    \ `x`: `&String`\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\n\nerror[E0599]: no method named `unwrap` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmp_9wvsqgr.rs:17:8\n   |\n17 |    \
    \ }).unwrap()\n   |        ^^^^^^ method not found in `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_internal(vec![String::from(\"()\"), String::from(\"\
    )\"), &lst)\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `)`\n  --> /tmp/tmpjb29ocj7.rs:15:31\n\
    \   |\n15 |     match_parens_internal(vec![String::from(\"()\"), String::from(\"\
    )\"), &lst)\n   |                          -    ^ unclosed delimiter         \
    \               ^ mismatched closing delimiter\n   |                         \
    \ |\n   |                          closing delimiter possibly meant for this\n\
    \nerror[E0425]: cannot find function `match_parens_internal` in this scope\n \
    \ --> /tmp/tmpjb29ocj7.rs:15:5\n   |\n15 |     match_parens_internal(vec![String::from(\"\
    ()\"), String::from(\")\"), &lst)\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjb29ocj7.rs:15:71\n\
    \   |\n15 |     match_parens_internal(vec![String::from(\"()\"), String::from(\"\
    )\"), &lst)\n   |                                                            \
    \           ^^^^ expected struct `String`, found `&Vec<String>`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&Vec<String>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = vec![0; lst.len()];\n    stack.push(0);\n\
    \    loop {\n        let top = stack.len();\n        let mut next = vec![0; lst.len()];\n\
    \        for &s in lst {\n            if next == top {\n                break\
    \ String::from(\"No\");\n            }\n            if s == '(' { stack.push(next[0]);\
    \ }\n            else if s == ')' { next[0] = stack[top]; }\n            next.push(0);\n\
    \        }\n        if stack.len() == top { break \"Yes\"; }\n    }\n    \"No\"\
    \n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0571]: `break` with value from a `for` loop\n  --> /tmp/tmpvyj1t1gs.rs:22:17\n\
    \   |\n20 |         for &s in lst {\n   |         ------------- you can't `break`\
    \ with a value in a `for` loop\n21 |             if next == top {\n22 |      \
    \           break String::from(\"No\");\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ can only break with a value inside `loop` or breakable block\n   |\nhelp: use\
    \ `break` on its own without a value inside this `for` loop\n   |\n22 |      \
    \           break;\n   |                 ~~~~~\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvyj1t1gs.rs:20:13\n   |\n20 |         for &s in lst {\n   |   \
    \          ^^    --- this expression has type `Option<String>`\n   |         \
    \    |\n   |             expected struct `String`, found reference\n   |     \
    \        help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror[E0277]: can't\
    \ compare `Vec<{integer}>` with `usize`\n  --> /tmp/tmpvyj1t1gs.rs:21:21\n   |\n\
    21 |             if next == top {\n   |                     ^^ no implementation\
    \ for `Vec<{integer}> == usize`\n   |\n   = help: the trait `PartialEq<usize>`\
    \ is not implemented for `Vec<{integer}>`\n   = help: the following other types\
    \ implement trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U,\
    \ A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T,\
    \ A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut [U]>>\n  \
    \           <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvyj1t1gs.rs:28:39\n   |\n28 |\
    \         if stack.len() == top { break \"Yes\"; }\n   |                     \
    \                  ^^^^^ expected `()`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvyj1t1gs.rs:30:5\n   |\n14 | fn match_parens(lst: Vec<String>)\
    \ -> String {\n   |                                      ------ expected `String`\
    \ because of return type\n...\n30 |     \"No\"\n   |     ^^^^- help: try using\
    \ a conversion method: `.to_string()`\n   |     |\n  "
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() < 2 {\n        return \"No\";\n    }\n\n    let\
    \ mut left = 0;\n    let mut right = 0;\n    let mut result = String::new();\n\
    \n    for str in lst {\n        if str.contains(\"(\") {\n            left +=\
    \ 1;\n        } else {\n            right += 1;\n        }\n\n        if right\
    \ < left {\n            return \"No\";\n        }\n\n        if right == left\
    \ {\n            result += '(';\n            result += str;\n            result\
    \ += ')';\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphhr29cck.rs:16:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     if\
    \ lst.len() < 2 {\n16 |         return \"No\";\n   |                ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphhr29cck.rs:35:23\n   |\n35 |             result += '(';\n\
    \   |                       ^^^ expected `&str`, found `char`\n   |\nhelp: if\
    \ you meant to write a `str` literal, use double quotes\n   |\n35 |          \
    \   result += \"(\";\n   |                       ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphhr29cck.rs:36:23\n   |\n36 |             result += str;\n\
    \   |                       ^^^\n   |                       |\n   |          \
    \             expected `&str`, found struct `String`\n   |                   \
    \    help: consider borrowing here: `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmphhr29cck.rs:37:23\n   |\n37 |             result += ')';\n   |\
    \                       ^^^ expected `&str`, found `char`\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n37 |             result\
    \ += \")\";\n   |                       ~~~\n\nerror: aborting due to 4 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut res = String::from(\"Yes\");\n    let mut stack: Vec<usize>\
    \ = Vec::new();\n    let mut pos = 0;\n    for s in lst {\n        if s.starts_with(\"\
    (\") {\n            stack.push(pos);\n        } else {\n            match stack.pop()\
    \ {\n                None => res.push_str(s),\n                Some(pos) => {\n\
    \                    let left = &lst[pos];\n                    let right = &lst[pos\
    \ + 1];\n                    if left.ends_with(right) {\n                    \
    \    res = \"No\".into();\n                        break;\n                  \
    \  }\n                }\n            }\n        }\n        pos += 1;\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9g3848ut.rs:23:38\n   |\n\
    23 |                 None => res.push_str(s),\n   |                          \
    \            ^\n   |                                      |\n   |            \
    \                          expected `&str`, found struct `String`\n   |      \
    \                                help: consider borrowing here: `&s`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<usize> = Vec::new();\n    let mut curr_str\
    \ = \"\".to_owned();\n\n    lst\n        .iter()\n        .filter_map(|x| x.is_empty())\n\
    \        .for_each(|x| {\n            stack.push(0);\n        });\n\n    match\
    \ &lst[0] {\n        String::from(\"(\") => \"Yes\".to_owned(),\n        _ =>\
    \ \"No\".to_owned(),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjmvdsdm8.rs:20:25\n   |\n\
    20 |         .filter_map(|x| x.is_empty())\n   |                         ^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n20 |         .filter_map(|x| Some(x.is_empty()))\n   |                \
    \         +++++            +\n\nerror[E0164]: expected tuple struct or tuple variant,\
    \ found associated function `String::from`\n  --> /tmp/tmpjmvdsdm8.rs:26:9\n \
    \  |\n26 |         String::from(\"(\") => \"Yes\".to_owned(),\n   |         ^^^^^^^^^^^^^^^^^\
    \ `fn` calls are not allowed in patterns\n   |\n   = help: for more information,\
    \ visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0164, E0308.\n\
    For more information about an error, try `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Scan the list and build the list of open and closed parenthesis\n\
    \    let mut lst_of_parens = vec![];\n    for i in lst {\n        if i.is_empty()\
    \ {\n            break;\n        }\n        let c = i.chars().next().unwrap();\n\
    \        if c == '(' {\n            lst_of_parens.push(i);\n        } else if\
    \ c == ')' {\n            for p in &lst_of_parens[..] {\n                if p.len()\
    \ > 1 {\n                    break;\n                }\n            }\n      \
    \      lst_of_parens.pop();\n        }\n    }\n\n    // Build stack of open and\
    \ closed parenthesis\n    let mut stack = vec![];\n    for i in lst_of_parens\
    \ {\n        if i.is_empty() {\n            break;\n        }\n        stack.push(i);\n\
    \    }\n\n    // If there's not a single open parenthesis left,\n    // return\
    \ No.\n    if stack.len() != 1 {\n        return \"No\".to_string();\n    }\n\n\
    \    // Get the last open and closed parenthesis\n    let open = stack.pop().unwrap();\n\
    \    let closed = stack.pop().unwrap();\n\n    // If there's an open parenthesis\
    \ at the same place as closed,\n    // return Yes.\n    if open.chars().count()\
    \ == closed.len() {\n        return \"Yes\".to_string();\n    }\n\n    // Otherwise,\
    \ try to build a new string by combining open and close\n    // with the string\
    \ open\n    let mut new_str = String::from(\"\");\n    for i in &open {\n    \
    \    new_str = new_str.insert(i, &closed);\n    }\n    return \"Yes\".to_string();\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpbs1pfpi5.rs:62:14\n\
    \   |\n62 |     for i in &open {\n   |              ^^^^^ `&String` is not an\
    \ iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbs1pfpi5.rs:63:37\n\
    \   |\n63 |         new_str = new_str.insert(i, &closed);\n   |              \
    \                       ^^^^^^^ expected `char`, found `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbs1pfpi5.rs:63:19\n   |\n61 |     let mut new_str\
    \ = String::from(\"\");\n   |                       ---------------- expected\
    \ due to this value\n62 |     for i in &open {\n63 |         new_str = new_str.insert(i,\
    \ &closed);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `insert` modifies its receiver in-place\n\
    \  --> /tmp/tmpbs1pfpi5.rs:63:27\n   |\n63 |         new_str = new_str.insert(i,\
    \ &closed);\n   |                   ------- ^^^^^^ this call modifies `new_str`\
    \ in-place\n   |                   |\n   |                   you probably want\
    \ to use this value after calling the method...\n   = note: ...instead of the\
    \ `()` output of method `insert`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().filter_map(|elem| elem.chars().filter(|c|\n    \
    \    c == '(' || c == ')').count() == 2).is_empty()\n        .to_string()\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzz7ppylu.rs:16:11\n\
    \   |\n16 |         c == '(' || c == ')').count() == 2).is_empty()\n   |     \
    \      ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpzz7ppylu.rs:16:23\n\
    \   |\n16 |         c == '(' || c == ')').count() == 2).is_empty()\n   |     \
    \                  ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpzz7ppylu.rs:15:34\n   |\n15 |       lst.iter().filter_map(|elem| elem.chars().filter(|c|\n\
    \   |  __________________________________^\n16 | |         c == '(' || c == ')').count()\
    \ == 2).is_empty()\n   | |__________________________________________^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n15 ~     lst.iter().filter_map(|elem| Some(elem.chars().filter(|c|\n16\
    \ ~         c == '(' || c == ')').count() == 2)).is_empty()\n   |\n\nerror[E0599]:\
    \ no method named `is_empty` found for struct `FilterMap` in the current scope\n\
    \  --> /tmp/tmpzz7ppylu.rs:16:45\n   |\n16 |         c == '(' || c == ')').count()\
    \ == 2).is_empty()\n   |                                             ^^^^^^^^\
    \ method not found in `FilterMap<std::slice::Iter<'_, String>, [closure@/tmp/tmpzz7ppylu.rs:15:27:\
    \ 16:43]>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\";\n    }\n\n    fn\
    \ has_open_par(l: &[String]) -> bool {\n        l.iter().any(|s| s.contains(\"\
    (\"))\n    }\n    fn has_close_par(l: &[String]) -> bool {\n        l.iter().any(|s|\
    \ s.contains(\")\"))\n    }\n\n    if !has_open_par(lst[0]) && !has_close_par(lst[1])\
    \ {\n        return \"No\";\n    }\n\n    if has_open_par(lst[0]) && has_close_par(lst[1])\
    \ {\n        if let Some(i) = lst.iter().position(|s| s.contains(\")\")) {\n \
    \           let j = i + 1;\n            match lst.iter().skip(i).take(j - i) {\n\
    \                None => (),\n                Some(lst) => return \"No\",\n  \
    \          }\n        }\n    }\n\n    if !has_open_par(lst[0]) && !has_open_par(lst[1])\
    \ {\n        return \"No\";\n    }\n\n    if !has_close_par(lst[0]) && !has_close_par(lst[1])\
    \ {\n        return \"No\";\n    }\n\n    if has_open_par(lst[0]) && has_close_par(lst[1])\
    \ {\n        if let Some(i) = lst.iter().position(|s| s.contains(\")\")) {\n \
    \           let j = i + 1;\n            match lst.iter().skip(i).take(j - i) {\n\
    \                None => (),\n                Some(lst) => return \"No\",\n  \
    \          }\n        }\n    }\n\n    if !has_open_par(lst[0]) && !has_open_par(lst[1])\
    \ {\n        return \"No\";\n    }\n\n    if has_close_par(lst[0]) && has_open_par(lst[1])\
    \ {\n        if let Some(i) = lst.iter().position(|s| s.contains(\"(\")) {\n \
    \           let j = i + 1;\n            match lst.iter().skip(i).take(j - i) {\n\
    \                None => (),\n                Some(lst) => return \"No\",\n  \
    \          }\n        }\n    }\n\n    return \"Yes\"\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphf24xgil.rs:16:16\n   |\n\
    14 | fn match_parens(lst: Vec<String>) -> String {\n   |                     \
    \                 ------ expected `String` because of return type\n15 |     if\
    \ lst.len() != 2 {\n16 |         return \"No\";\n   |                ^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                |\n   | \
    \               expected struct `String`, found `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphf24xgil.rs:26:22\n   |\n26 |     if !has_open_par(lst[0])\
    \ && !has_close_par(lst[1]) {\n   |                      ^^^^^^ expected `&[String]`,\
    \ found struct `String`\n   |\n   = note: expected reference `&[String]`\n   \
    \              found struct `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphf24xgil.rs:26:48\n   |\n26 |     if !has_open_par(lst[0]) && !has_close_par(lst[1])\
    \ {\n   |                                                ^^^^^^ expected `&[String]`,\
    \ found struct `String`\n   |\n   = note: expected reference `&[String]`\n   \
    \              found struct `String`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphf24xgil.rs:30:21\n   |\n30 |     if has_open_par(lst[0]) && has_close_par(lst[1])\
    \ {\n   |                     ^^^^^^ expected `&[String]`, found struct `String`\n\
    \   |\n   = note: expected reference `&[String]`\n                 found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphf24xgil.rs:30:46\n\
    \   |\n30 |     if has_open_par(lst[0]) && has_close_par(lst[1]) {\n   |     \
    \                                         ^^^^^^ expected `&[String]`, found struct\
    \ `String`\n   |\n   = note: expected reference `&[String]`\n                \
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphf24xgil.rs:34:17\n\
    \   |\n33 |             match lst.iter().skip(i).take(j - i) {\n   |         \
    \          ------------------------------ this expression has type `std::iter::Take<Skip<std::slice::Iter<'_,\
    \ String>>>`\n34 |                 None => (),\n   |                 ^^^^ expected\
    \ struct `std::iter::Take`, found enum `Option`\n   |\n   = note: expected struct "
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // a map to mark valid parenthesis\n    let mut map: HashMap<&str,\
    \ &str> = HashMap::new();\n    let mut parens = false;\n    for &s in lst {\n\
    \        if let Some(open) = map.get(&s) {\n            if open != s {\n     \
    \           map.remove(&s);\n            } else {\n                parens = true;\n\
    \            }\n        } else {\n            map.insert(s, s);\n        }\n \
    \   }\n\n    if parens {\n        String::from(\"Yes\")\n    } else {\n      \
    \  String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmprjxc9rgx.rs:16:18\n\
    \   |\n16 |     let mut map: HashMap<&str, &str> = HashMap::new();\n   |     \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmprjxc9rgx.rs:16:40\n\
    \   |\n16 |     let mut map: HashMap<&str, &str> = HashMap::new();\n   |     \
    \                                   ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprjxc9rgx.rs:18:9\n   |\n\
    18 |     for &s in lst {\n   |         ^^    --- this expression has type `Option<String>`\n\
    \   |         |\n   |         expected struct `String`, found reference\n   |\
    \         help: you can probably remove the explicit borrow: `s`\n   |\n   = note:\
    \ expected struct `String`\n           found reference `&_`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0412,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst.len() {\n        2 => if lst.first().unwrap().is_empty()\
    \ {\n            String::from(\"No\")\n        } else {\n            match lst.last().unwrap().unwrap().as_char().unwrap()\
    \ {\n                '(' => String::from(\"Yes\"),\n                ')' => String::from(\"\
    Yes\"),\n                _ => String::from(\"No\"),\n            }\n        },\n\
    \        _ => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for reference `&String` in\
    \ the current scope\n  --> /tmp/tmpp0adbi0j.rs:19:39\n   |\n19 |             match\
    \ lst.last().unwrap().unwrap().as_char().unwrap() {\n   |                    \
    \                   ^^^^^^ method not found in `&String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976207
- exit_code: 1
  program: "/// You are given a vector of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// >>> match_parens(vec![String::from(\"\
    ()(\"), String::from(\")\")])\n/// String::from(\"Yes\")\n/// >>> match_parens(vec![String::from(\"\
    )\"), String::from(\")\")])\n/// String::from(\"No\")\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = VecDeque::new();\n    for ele in lst {\n  \
    \      if let Some(ele) = ele.as_ref() {\n            match ele {\n          \
    \      '(' => {\n                    stack.push_back(true);\n                }\n\
    \                '(' | ')' => {\n                    stack.push_back(false);\n\
    \                }\n                _ => {}\n            }\n        }\n    }\n\
    \    if stack.is_empty() {\n        // no unmatched parantheses found\n      \
    \  String::from(\"No\")\n    } else {\n        // stack is empty, we can make\
    \ the resulting string 'Yes'\n        String::from(\"Yes\")\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `VecDeque`\n  -->\
    \ /tmp/tmp52jal903.rs:15:21\n   |\n15 |     let mut stack = VecDeque::new();\n\
    \   |                     ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\n\
    error[E0277]: the trait bound `String: AsRef<Option<_>>` is not satisfied\n  -->\
    \ /tmp/tmp52jal903.rs:17:32\n   |\n17 |         if let Some(ele) = ele.as_ref()\
    \ {\n   |                                ^^^^^^ the trait `AsRef<Option<_>>` is\
    \ not implemented for `String`\n   |\n   = help: the following other types implement\
    \ trait `AsRef<T>`:\n             <String as AsRef<OsStr>>\n             <String\
    \ as AsRef<Path>>\n             <String as AsRef<[u8]>>\n             <String\
    \ as AsRef<str>>\n             <str as AsRef<OsStr>>\n             <str as AsRef<Path>>\n\
    \             <str as AsRef<[u8]>>\n             <str as AsRef<str>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976207
