language: rs
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Find the longest palindrome in q.\n    let mut longest_palindrome\
    \ = 0;\n    for i in 0..q.len() {\n        if q[i] != i {\n            if longest_palindrome\
    \ < q.len() - i {\n                longest_palindrome = q.len() - i;\n       \
    \     }\n        }\n    }\n\n    // If q is balanced, return false.\n    let mut\
    \ sum = 0;\n    for i in 0..q.len() {\n        if q[i] != i {\n            if\
    \ q[i] == i {\n                sum += q[i];\n            }\n        }\n    }\n\
    \    if sum == w {\n        return false;\n    }\n\n    // If q isn't balanced,\
    \ return true.\n    longest_palindrome\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptgjdfelu.rs:20:20\n   |\n\
    20 |         if q[i] != i {\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |         if q[i] != i.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmptgjdfelu.rs:30:20\n   |\n30 |         if q[i] != i {\n\
    \   |                    ^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n30 |         if q[i] != i.try_into().unwrap() {\n   |                 \
    \    ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptgjdfelu.rs:31:24\n\
    \   |\n31 |             if q[i] == i {\n   |                        ^ expected\
    \ `isize`, found `usize`\n   |\nhelp: you can convert a `usize` to an `isize`\
    \ and panic if the converted value doesn't fit\n   |\n31 |             if q[i]\
    \ == i.try_into().unwrap() {\n   |                         ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmptgjdfelu.rs:41:5\n   |\n16 | fn\
    \ will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |                       \
    \                     ---- expected `bool` because of return type\n...\n41 | \
    \    longest_palindrome\n   |     ^^^^^^^^^^^^^^^^^^ expected `bool`, found `usize`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = 0;\n    let mut sum = 0;\n    for (i, &elem) in q.iter().enumerate()\
    \ {\n        sum += *elem;\n        if sum > max {\n            max = sum;\n \
    \       }\n    }\n\n    // if the sum is too big, it's not balanced\n    if sum\
    \ >= w {\n        return false;\n    }\n\n    // if the max is too small, it's\
    \ balanced\n    if max < w {\n        return true;\n    }\n\n    // otherwise\
    \ it might be balanced, so check each element\n    let mut balanced = false;\n\
    \    for (i, &elem) in q.iter().enumerate() {\n        let diff = *elem - (*q.len()\
    \ - i - 1);\n        if diff > 0 {\n            balanced = true;\n           \
    \ break;\n        }\n    }\n\n    if balanced {\n        // it might be balanced\
    \ with a little bit of fuzziness\n        let fuzz = max / w;\n        if *q.len()\
    \ < fuzz {\n            return true;\n        }\n\n        // and it's balanced\
    \ if we just use fuzzy\n        // by going through each element and adding up\
    \ all elements\n        // until we find a smaller one\n        let mut max =\
    \ 0;\n        let mut sum = 0;\n        for (i, &elem) in q.iter().enumerate()\
    \ {\n            sum += *elem;\n            if sum > max {\n                max\
    \ = sum;\n            }\n        }\n        if *q.len() > fuzz {\n           \
    \ for (i, &elem) in q.iter().enumerate() {\n                let diff = *elem -\
    \ (*q.len() - i);\n                if diff > 0 {\n                    break;\n\
    \                }\n            }\n        }\n        return sum < max;\n    }\n\
    \n    // it might not be balanced so return false\n    return false;\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpq6h0g5u3.rs:20:16\n\
    \   |\n20 |         sum += *elem;\n   |                ^^^^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpq6h0g5u3.rs:39:20\n   |\n\
    39 |         let diff = *elem - (*q.len() - i - 1);\n   |                    ^^^^^\n\
    \nerror[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpq6h0g5u3.rs:39:29\n\
    \   |\n39 |         let diff = *elem - (*q.len() - i - 1);\n   |             \
    \                ^^^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpq6h0g5u3.rs:49:12\n   |\n49 |         if *q.len() < fuzz {\n  \
    \ |            ^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpq6h0g5u3.rs:59:20\n   |\n59 |             sum += *elem;\n   | \
    \                   ^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpq6h0g5u3.rs:64:12\n   |\n64 |         if *q.len() > fuzz {\n  \
    \ |            ^^^^^^^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n\
    \  --> /tmp/tmpq6h0g5u3.rs:66:28\n   |\n66 |                 let diff = *elem\
    \ - (*q.len() - i);\n   |                            ^^^^^\n\nerror[E0614]: type\
    \ `usize` cannot be dereferenced\n  --> /tmp/tmpq6h0g5u3.rs:66:37\n   |\n66 |\
    \                 let diff = *elem - (*q.len() - i);\n   |                   \
    \                  ^^^^^^^^\n\nerror: aborting due to 8 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut found = false;\n    if q.len() == 0 {\n        found = true;\n\
    \    }\n    else if q.len() == 1 && q[0] < w {\n        found = true;\n    }\n\
    \    else {\n        let mut sum = 0;\n        for el in q.iter() {\n        \
    \    sum += el;\n        }\n        if sum < w {\n            found = true;\n\
    \        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp6axlxkx7.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn is_balanced<P>(q: &P) -> bool\n    where\n        P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n    {\n        let mut min_sum = q.iter().sum::<isize>();\n   \
    \     let mut max_weight = *q.iter().max(&min_sum).unwrap();\n        let mut\
    \ max_sum = q.iter().sum::<isize>();\n        for v in q.iter() {\n          \
    \  if *v < max_weight {\n                return false;\n            }\n      \
    \      max_weight -= v;\n            max_sum += v;\n        }\n        true\n\
    \    }\n\n    fn is_balanced<P>(q: &P) -> bool\n    where\n        P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n    {\n        let mut min_sum = q.iter().sum::<isize>();\n   \
    \     let mut max_weight = *q.iter().max(&min_sum).unwrap();\n        let mut\
    \ max_sum = q.iter().sum::<isize>();\n        for v in q.iter() {\n          \
    \  if *v < max_weight {\n                return false;\n            }\n      \
    \      max_weight -= v;\n            max_sum += v;\n        }\n        true\n\
    \    }\n\n    fn is_balanced<P>(q: &P) -> bool\n    where\n        P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n    {\n        let mut min_sum = q.iter().sum::<isize>();\n   \
    \     let mut max_weight = *q.iter().max(&min_sum).unwrap();\n        let mut\
    \ max_sum = q.iter().sum::<isize>();\n        for v in q.iter() {\n          \
    \  if *v < max_weight {\n                return false;\n            }\n      \
    \      max_weight -= v;\n            max_sum += v;\n        }\n        true\n\
    \    }\n\n    fn is_balanced<P>(q: &P) -> bool\n    where\n        P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n    {\n        let mut min_sum = q.iter().sum::<isize>();\n   \
    \     let mut max_weight = *q.iter().max(&min_sum).unwrap();\n        let mut\
    \ max_sum = q.iter().sum::<isize>();\n        for v in q.iter() {\n          \
    \  if *v < max_weight {\n                return false;\n            }\n      \
    \      max_weight -= v;\n            max_sum += v;\n        }\n        true\n\
    \    }\n\n    fn is_balanced<P>(q: &P) -> bool\n    where\n        P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n    {\n        let mut min_sum = q.iter().sum\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpwnb9g4pw.rs:100:3\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n88  |  \
    \   {\n    |     - this delimiter might not be properly closed...\n89  |     \
    \    let mut min_sum = q.iter().sum\n90  | }\n    | - ...as it matches this but\
    \ it has different indentation\n...\n100 | }\n    |   ^\n\nerror: expected `;`,\
    \ found `}`\n  --> /tmp/tmpwnb9g4pw.rs:89:39\n   |\n89 |         let mut min_sum\
    \ = q.iter().sum\n   |                                       ^ help: add `;` here\n\
    90 | }\n   | - unexpected token\n\nerror[E0428]: the name `is_balanced` is defined\
    \ multiple times\n  --> /tmp/tmpwnb9g4pw.rs:34:5\n   |\n17 | /     fn is_balanced<P>(q:\
    \ &P) -> bool\n18 | |     where\n19 | |         P: RangePushBack<Vec<isize>, ExactSize>,\n\
    20 | |     {\n...  |\n31 | |         true\n32 | |     }\n   | |_____- previous\
    \ definition of the value `is_balanced` here\n33 | \n34 | /     fn is_balanced<P>(q:\
    \ &P) -> bool\n35 | |     where\n36 | |         P: RangePushBack<Vec<isize>, ExactSize>,\n\
    37 | |     {\n...  |\n48 | |         true\n49 | |     }\n   | |_____^ `is_balanced`\
    \ redefined here\n   |\n   = note: `is_balanced` must be defined only once in\
    \ the value namespace of this block\n\nerror[E0428]: the name `is_balanced` is\
    \ defined multiple times\n  --> /tmp/tmpwnb9g4pw.rs:51:5\n   |\n17 | /     fn\
    \ is_balanced<P>(q: &P) -> bool\n18 | |     where\n19 | |         P: RangePushBack<Vec<isize>,\
    \ ExactSize>,\n20 | |     {\n...  |\n31 | |         true\n32 | |     }\n   | |_____-\
    \ previous definition of the value `is_balanced` here\n...\n51 | /     fn is_balanced<P>(q:\
    \ &P) -> bool\n52 | |     where\n53 | |         P: RangePushBack<Vec<isize>, ExactSize>,\n\
    54 | |     {\n...  |\n65 | |         true\n66 | |     }\n   | |_____^ `is_balanced`\
    \ redefined here\n   |\n   = note: `is_balanced` must be defined only once in\
    \ the value namespace of this block\n\nerror[E0428]: the name `is_balanced` is\
    \ defined multiple times\n  --> /tmp/tmpwnb9g4pw.rs:68:5\n   |\n17 | /     fn\
    \ is_ba"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n\n    let\
    \ mut is_fly_balanced = true;\n\n    if sum < w {\n        is_fly_balanced = false;\n\
    \    }\n\n    if q.len() > 0 {\n        let mut q = q.clone();\n        q.sort_unstable();\n\
    \        let mut j = q.len() - 1;\n        while j >= 0 {\n            let j =\
    \ q.len() - 1;\n            if q[j] != q[j + 1] {\n                is_fly_balanced\
    \ = false;\n                break;\n            }\n            j -= 1;\n     \
    \   }\n    }\n\n    is_fly_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `j` is never read\n  --> /tmp/tmpr4ev4ecg.rs:38:13\n\
    \   |\n38 |             j -= 1;\n   |             ^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nwarning:\
    \ variable does not need to be mutable\n  --> /tmp/tmpr4ev4ecg.rs:31:13\n   |\n\
    31 |         let mut j = q.len() - 1;\n   |             ----^\n   |          \
    \   |\n   |             help: remove this `mut`\n   |\n   = note: `#[warn(unused_mut)]`\
    \ on by default\n\nerror[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpr4ev4ecg.rs:28:8\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n17  |     let mut sum = 0;\n18  |     for i in q {\n    |\
    \              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    28  |     if q.len() > 0 {\n    |        ^^^^^^^ value borrowed here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n18  |     for i in &q {\n    |    \
    \          +\n\nerror[E0384]: cannot assign twice to immutable variable `j`\n\
    \  --> /tmp/tmpr4ev4ecg.rs:38:13\n   |\n33 |             let j = q.len() - 1;\n\
    \   |                 -\n   |                 |\n   |                 first assignment\
    \ to `j`\n   |                 help: consider making this binding mutable: `mut\
    \ j`\n...\n38 |             j -= 1;\n   |             ^^^^^^ cannot assign twice\
    \ to immutable variable\n\nerror: aborting due to 2 previous errors; 2 warnings\
    \ emitted\n\nSome errors have detailed explanations: E0382, E0384.\nFor more information\
    \ about an error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    use std::cmp::Ordering;\n    let mut fly_counter = 0;\n\n    // Check\
    \ whether the vector is balanced\n    for i in q {\n        if i == q[q.len()\
    \ - 1] {\n            fly_counter++;\n        } else {\n            return false;\n\
    \        }\n    }\n\n    // Calculate the sum of its elements\n    let mut sum\
    \ = 0;\n    for i in q {\n        sum += i;\n    }\n\n    // If the sum is less\
    \ or equal to the maximum possible weight\n    fly_counter <= w && sum <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpaagsr_4a.rs:23:24\n\
    \   |\n23 |             fly_counter++;\n   |                        ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n23 |             { let\
    \ tmp = fly_counter; fly_counter += 1; tmp };\n   |             +++++++++++  \
    \          ~~~~~~~~~~~~~~~~~~~~~~~~~\n23 -             fly_counter++;\n23 +  \
    \           fly_counter += 1;\n   | \n\nwarning: unused import: `std::cmp::Ordering`\n\
    \  --> /tmp/tmpaagsr_4a.rs:17:9\n   |\n17 |     use std::cmp::Ordering;\n   |\
    \         ^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by\
    \ default\n\nerror: aborting due to previous error; 1 warning emitted\n\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.len() <= w ||\n    (&q[q.len() - 1] == &q[q.len() - w] &&\n    q.iter().zip(q[q.len()\
    \ - w..q.len()].iter()).all(|&(v1, v2)| v1 < v2))\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy2ir70z6.rs:17:16\n   |\n\
    17 |     q.len() <= w ||\n   |                ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     q.len() <= w.try_into().unwrap() ||\n   |\
    \                 ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpy2ir70z6.rs:18:38\n   |\n18 |     (&q[q.len() - 1] == &q[q.len() - w]\
    \ &&\n   |                                      ^ expected `usize`, found `isize`\n\
    \nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpy2ir70z6.rs:18:36\n\
    \   |\n18 |     (&q[q.len() - 1] == &q[q.len() - w] &&\n   |                 \
    \                   ^ no implementation for `usize - isize`\n   |\n   = help:\
    \ the trait `Sub<isize>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n\
    \             <&'a f64 as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n  \
    \           <&'a i16 as Sub<i16>>\n             <&'a i32 as Sub<i32>>\n      \
    \       <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n            \
    \ <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpy2ir70z6.rs:19:30\n   |\n19 |     q.iter().zip(q[q.len()\
    \ - w..q.len()].iter()).all(|&(v1, v2)| v1 < v2))\n   |                      \
    \        ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `isize`\
    \ from `usize`\n  --> /tmp/tmpy2ir70z6.rs:19:28\n   |\n19 |     q.iter().zip(q[q.len()\
    \ - w..q.len()].iter()).all(|&(v1, v2)| v1 < v2))\n   |                      \
    \      ^ no implementation for `usize - isize`\n   |\n   = help: the trait `Sub<isize>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Sub<Rhs>`:\n             <&'a f32 as Sub<f32>>\n             <&'a f64\
    \ as Sub<f64>>\n             <&'a i128 as Sub<i128>>\n             <&'a i16 as\
    \ Sub<i16>>\n             <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n\
    \             <&'a i8 as Sub<i8>>\n             <&'a isi"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q\n        .iter()\n        .fold(true, (move |acc, i| acc && (i != q[0]\
    \ || i != q[q.len() - 1]))) // test if the sum equals 0\n        && q.iter().fold(true,\
    \ (move |acc, i| acc && (i != q[0] || i != q[q.len() - 1]))) {\n        let mut\
    \ c = q.clone();\n        c.pop(); // we check with the last element\n       \
    \ acc == q.iter().fold(false, (move |acc, i| acc + w))\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n\
    \  --> /tmp/tmpvt4hwhpw.rs:20:91\n   |\n20 |         && q.iter().fold(true, (move\
    \ |acc, i| acc && (i != q[0] || i != q[q.len() - 1]))) {\n   |               \
    \                                                                            ^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to\
    \ previous error\n\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // If the object is a palindrome (it's a vector which consists of two\
    \ equal numbers)\n    // and it's sum equals the maximum possible weight.\n  \
    \  match q.is_palindrom() && q.iter().sum::<isize>() <= w {\n        true => true,\n\
    \        false => false,\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrom` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp9q4g2tu9.rs:19:13\n   |\n19 |     match\
    \ q.is_palindrom() && q.iter().sum::<isize>() <= w {\n   |             ^^^^^^^^^^^^\
    \ method not found in `Vec<isize>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > w {\n        return false\n    }\n    q.sort_unstable();\n\
    \    for i in q.rev() {\n        if i >= w {\n            return true;\n     \
    \   }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiy1f54sr.rs:17:18\n   |\n\
    17 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0599]: `Vec<isize>` is not\
    \ an iterator\n   --> /tmp/tmpiy1f54sr.rs:21:16\n    |\n21  |       for i in q.rev()\
    \ {\n    |                  ^^^ `Vec<isize>` is not an iterator\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `Vec<isize>:\
    \ Iterator`\n            which is required by `&mut Vec<isize>: Iterator`\n  \
    \          `[isize]: Iterator`\n            which is required by `&mut [isize]:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s = q.iter().rev().fold(0, |acc, el| acc + el);\n    s <= w &&\
    \ q.is_palindromic()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindromic` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpw89ibbjh.rs:18:17\n   |\n18 |     s <= w\
    \ && q.is_palindromic()\n   |                 ^^^^^^^^^^^^^^ method not found\
    \ in `Vec<isize>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if let Vec::new(q) = q {\n        return is_balanced(q) && is_palindrome(q)\
    \ && q\n            .iter()\n            .fold(true, (|sum, w| sum && w <= w))\n\
    \    } else {\n        return is_balanced(q) && is_palindrome(q) && q == vec![0]\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpz2jce5_c.rs:18:16\n\
    \   |\n18 |         return is_balanced(q) && is_palindrome(q) && q\n   |     \
    \           ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_palindrome` in this scope\n  --> /tmp/tmpz2jce5_c.rs:18:34\n   |\n18 | \
    \        return is_balanced(q) && is_palindrome(q) && q\n   |                \
    \                  ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_balanced` in this scope\n  --> /tmp/tmpz2jce5_c.rs:22:16\n\
    \   |\n22 |         return is_balanced(q) && is_palindrome(q) && q == vec![0]\n\
    \   |                ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmpz2jce5_c.rs:22:34\n\
    \   |\n22 |         return is_balanced(q) && is_palindrome(q) && q == vec![0]\n\
    \   |                                  ^^^^^^^^^^^^^ not found in this scope\n\
    \nwarning: unnecessary parentheses around method argument\n  --> /tmp/tmpz2jce5_c.rs:20:25\n\
    \   |\n20 |             .fold(true, (|sum, w| sum && w <= w))\n   |          \
    \               ^                      ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n20 -             .fold(true,\
    \ (|sum, w| sum && w <= w))\n20 +             .fold(true, |sum, w| sum && w <=\
    \ w)\n   | \n\nerror[E0164]: expected tuple struct or tuple variant, found associated\
    \ function `Vec::new`\n  --> /tmp/tmpz2jce5_c.rs:17:12\n   |\n17 |     if let\
    \ Vec::new(q) = q {\n   |            ^^^^^^^^^^^ `fn` calls are not allowed in\
    \ patterns\n   |\n   = help: for more information, visit https://doc.rust-lang.org/book/ch18-00-patterns.html\n\
    \nerror: aborting due to 5 previous errors; 1 warning emitted\n\nSome errors have\
    \ detailed explanations: E0164, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0164`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut qf = q.clone();\n    qf.sort_unstable();\n    if qf.len() > w\
    \ {\n        return false;\n    }\n    qf.reverse();\n    qf.iter().sum::<isize>()\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy4wyrl_1.rs:19:19\n   |\n\
    19 |     if qf.len() > w {\n   |                   ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n19 |     if qf.len() > w.try_into().unwrap() {\n  \
    \ |                    ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = q.len() - 1;\n    let mut sum = 0;\n    while i >= 0 {\n\
    \        sum += q[i];\n        i -= 1;\n    }\n    sum < w && sum == (q.iter().rev().fold(0,\
    \ |acc, x| acc + x));\n}\n\nfn main() {\n    let candidate = will_it_fly;\n  \
    \  assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpiffhxutc.rs:16:44\n   |\n\
    16 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |    -----------  \
    \                           ^^^^ expected `bool`, found `()`\n   |    |\n   |\
    \    implicitly returns `()` as its body has no tail or `return` expression\n\
    ...\n23 |     sum < w && sum == (q.iter().rev().fold(0, |acc, x| acc + x));\n\
    \   |                                                                 - help:\
    \ remove this semicolon\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut is_balanced = true;\n\n    for &n in q.iter().rev() {\n     \
    \   if n > w {\n            is_balanced = false;\n            break;\n       \
    \ }\n    }\n\n    is_balanced && (q.iter().sum::<usize>() <= w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `usize: Sum<&isize>` is not satisfied\n \
    \   --> /tmp/tmpvfph645s.rs:26:30\n     |\n26   |     is_balanced && (q.iter().sum::<usize>()\
    \ <= w)\n     |                              ^^^ the trait `Sum<&isize>` is not\
    \ implemented for `usize`\n     |\n     = help: the following other types implement\
    \ trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n               <f32 as\
    \ Sum>\n               <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n  \
    \             <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n        \
    \       <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n             and 20\
    \ others\nnote: required by a bound in `std::iter::Iterator::sum`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpvfph645s.rs:26:48\n   |\n26 |     is_balanced\
    \ && (q.iter().sum::<usize>() <= w)\n   |                                    \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n26\
    \ |     is_balanced && (q.iter().sum::<usize>() <= w.try_into().unwrap())\n  \
    \ |                                                 ++++++++++++++++++++\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for (i, ws) in q.iter().enumerate() {\n       \
    \ if i < ws - 1 {\n            sum += w;\n        }\n    }\n    sum < w\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3x50a5m8.rs:19:16\n   |\n\
    19 |         if i < ws - 1 {\n   |                ^^^^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |         if i < (ws - 1).try_into().unwrap()\
    \ {\n   |                +      +++++++++++++++++++++\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    debug_assert!(q.is_palindromic());\n    let mut n = q.len() - 1;\n  \
    \  let mut sum = 0;\n    let mut max_sum_fly_weight = 0;\n    while n >= 0 {\n\
    \        if q[n] != q[n + 1] {\n            break;\n        }\n        n -= 1;\n\
    \        sum += q[n];\n    }\n    max_sum_fly_weight = if sum < w {\n        w\n\
    \    } else {\n        w\n    };\n    (sum + w) <= max_sum_fly_weight\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindromic` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpjcnpt3ny.rs:17:21\n   |\n17 |     debug_assert!(q.is_palindromic());\n\
    \   |                     ^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // The function should return true if the object will fly (it's a palindromic\
    \ vector and sum of its elements is less than or equal the maximum possible weight)\
    \ and false otherwise.\n    if q.len() == 0 || w < q.iter().min() {\n        return\
    \ false;\n    }\n    let mut is_palin_sum = false;\n    let mut max = 0;\n   \
    \ let mut min_val = q.iter().min();\n    let mut max_val = q.iter().max();\n \
    \   while w >= q.iter().min() && w <= q.iter().max() {\n        if q.iter().any(|&x|\
    \ x == q.iter().max()) {\n            is_palin_sum = true;\n            break;\n\
    \        }\n        let mut sum = 0;\n        for (index, &x) in q.iter().enumerate()\
    \ {\n            sum += x;\n            if sum == w {\n                is_palin_sum\
    \ = true;\n                break;\n            }\n            if sum > w {\n \
    \               break;\n            }\n        }\n        if is_palin_sum && sum\
    \ == w {\n            is_palin_sum = false;\n            break;\n        }\n \
    \       if sum > w {\n            break;\n        }\n        max += w;\n     \
    \   if sum < w {\n            break;\n        }\n        min_val -= w;\n     \
    \   if sum > w {\n            break;\n        }\n        max_val += w;\n    }\n\
    \    is_palin_sum && !is_palin(q) && max <= w && w >= min_val && w <= max_val\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palin` in this scope\n  --> /tmp/tmpwd5jrc68.rs:58:22\n\
    \   |\n58 |     is_palin_sum && !is_palin(q) && max <= w && w >= min_val && w\
    \ <= max_val\n   |                      ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwd5jrc68.rs:18:28\n   |\n18 |     if q.len()\
    \ == 0 || w < q.iter().min() {\n   |                            ^^^^^^^^^^^^^^\
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwd5jrc68.rs:25:16\n   |\n25 |     while w >= q.iter().min() &&\
    \ w <= q.iter().max() {\n   |                ^^^^^^^^^^^^^^ expected `isize`,\
    \ found enum `Option`\n   |\n   = note: expected type `isize`\n              found\
    \ enum `Option<&isize>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwd5jrc68.rs:25:39\n\
    \   |\n25 |     while w >= q.iter().min() && w <= q.iter().max() {\n   |     \
    \                                  ^^^^^^^^^^^^^^ expected `isize`, found enum\
    \ `Option`\n   |\n   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwd5jrc68.rs:26:35\n   |\n26 |\
    \         if q.iter().any(|&x| x == q.iter().max()) {\n   |                  \
    \                 ^^^^^^^^^^^^^^ expected `isize`, found enum `Option`\n   |\n\
    \   = note: expected type `isize`\n              found enum `Option<&isize>`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpwd5jrc68.rs:52:9\n   |\n52 |         min_val -= w;\n   |      \
    \   -------^^^^^\n   |         |\n   |         cannot use `-=` on type `Option<&isize>`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `Option<&isize>`\n\
    \  --> /tmp/tmpwd5jrc68.rs:56:9\n   |\n56 |         max_val += w;\n   |      \
    \   -------^^^^^\n   |         |\n   |         cannot use `+=` on type `Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpwd5jrc68.rs:58:54\n   |\n58 |\
    \     is_palin_sum && !is_palin(q) && max <= w && w >= min_val && w <= m"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    use num_traits::{One, Zero};\n\n    // Find max weight of q.\n    let\
    \ mut max_weight = 0;\n    for i in q.iter().rev() {\n        max_weight = if\
    \ *i < w { *i } else { w };\n    }\n    let mut q = q.iter().rev().take(q.len()\
    \ - max_weight);\n    let mut w = q.next().unwrap();\n\n    // Check if it's balanced.\
    \ If not, return false.\n    if max_weight % w != 0 {\n        return false;\n\
    \    }\n\n    // Check if sum of all elements of q is less than or equal to w.\n\
    \    let mut q: Vec<_> = q.iter().cloned().collect();\n    let mut sum: usize\
    \ = q.len();\n    for i in q.iter_mut().rev() {\n        *i = *i + 1;\n      \
    \  sum = *i as usize + sum;\n    }\n    if sum < w {\n        return true;\n \
    \   }\n\n    // If we reach here, q isn't balanced. return false.\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num_traits`\n  --> /tmp/tmpzivne04b.rs:17:9\n\
    \   |\n17 |     use num_traits::{One, Zero};\n   |         ^^^^^^^^^^ maybe a\
    \ missing crate `num_traits`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzivne04b.rs:24:47\n\
    \   |\n24 |     let mut q = q.iter().rev().take(q.len() - max_weight);\n   | \
    \                                              ^^^^^^^^^^ expected `usize`, found\
    \ `isize`\n\nerror[E0277]: cannot subtract `isize` from `usize`\n  --> /tmp/tmpzivne04b.rs:24:45\n\
    \   |\n24 |     let mut q = q.iter().rev().take(q.len() - max_weight);\n   | \
    \                                            ^ no implementation for `usize -\
    \ isize`\n   |\n   = help: the trait `Sub<isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0599]:\
    \ no method named `iter` found for struct `std::iter::Take` in the current scope\n\
    \  --> /tmp/tmpzivne04b.rs:33:27\n   |\n33 |     let mut q: Vec<_> = q.iter().cloned().collect();\n\
    \   |                           ^^^^ private field, not a method\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzivne04b.rs:39:14\n   |\n39 |     if sum < w\
    \ {\n   |              ^ expected `usize`, found `&isize`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0432, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max_weight = 0;\n    for elem in q {\n        max_weight = max(max_weight,\
    \ elem);\n    }\n    let mut balanced = false;\n    for elem in q {\n        balanced\
    \ = balanced || (elem == max_weight);\n    }\n    let mut sum_weights = 0;\n \
    \   for elem in q {\n        sum_weights += elem;\n    }\n    sum_weights <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpa184b_li.rs:19:22\n\
    \   |\n19 |         max_weight = max(max_weight, elem);\n   |                \
    \      ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut weight = q.iter().sum();\n\n \
    \   if weight > w {\n        weight = w;\n        balanced = true;\n    }\n\n\
    \    if q.len() <= 2 {\n        return balanced;\n    }\n\n    if q[q.len() -\
    \ 1] == q[0] {\n        return balanced;\n    }\n\n    match q.len() {\n     \
    \   3 | 5 | 7 => {\n            let mut palindrome = true;\n\n            for\
    \ (pos, v) in q.iter().enumerate() {\n                if !v == q[q.len() - 1 -\
    \ pos] {\n                    palindrome = false;\n                    break;\n\
    \                }\n            }\n\n            palindrome && q.iter().sum()\
    \ <= w && balanced\n        }\n        _ => balanced,\n    }\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0283]: type annotations needed\n    --> /tmp/tmpf_eyx0p3.rs:44:36\n\
    \     |\n44   |             palindrome && q.iter().sum() <= w && balanced\n  \
    \   |                                    ^^^ cannot infer type for type parameter\
    \ `S` declared on the associated function `sum`\n     |\n     = note: cannot satisfy\
    \ `_: Sum<&isize>`\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    help: consider specifying the type argument in the method call\n     |\n44   |\
    \             palindrome && q.iter().sum::<S>() <= w && balanced\n     |     \
    \                                  +++++\nhelp: consider specifying the type argument\
    \ in the function call\n     |\n44   |             palindrome && q.iter().sum::<S>()\
    \ <= w && balanced\n     |                                       +++++\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0283`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = w;\n    for i in q {\n        if i == 0 {\n           \
    \ return false;\n        }\n        max = i.max(max);\n    }\n    max <= w &&\
    \ q == q.iter().cloned().reverse().collect()\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `reverse` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpjv960vun.rs:24:40\n   |\n24 |     max <= w && q\
    \ == q.iter().cloned().reverse().collect()\n   |                             \
    \           ^^^^^^^ method not found in `Cloned<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = std::cmp::max(q.len(), w);\n    q.sort();\n    let mut\
    \ v = q.iter().rev().peekable();\n    let mut found = false;\n    while !v.is_empty()\
    \ {\n        if *v.ptr() > w {\n            v.rev().peekable().next();\n     \
    \       max = std::cmp::min(max, w - v.sum());\n        } else {\n           \
    \ max = std::cmp::max(max, *v.ptr());\n            v.next().peekable();\n    \
    \        found = true;\n        }\n    }\n    found\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6axi5s71.rs:17:42\n   |\n\
    17 |     let mut max = std::cmp::max(q.len(), w);\n   |                      \
    \                    ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     let mut max = std::cmp::max(q.len(), w.try_into().unwrap());\n   |  \
    \                                         ++++++++++++++++++++\n\nerror[E0658]:\
    \ use of unstable library feature 'exact_size_is_empty'\n  --> /tmp/tmp6axi5s71.rs:21:14\n\
    \   |\n21 |     while !v.is_empty() {\n   |              ^^^^^^^^\n   |\n   =\
    \ note: see issue #35428 <https://github.com/rust-lang/rust/issues/35428> for\
    \ more information\n\nerror[E0599]: no method named `ptr` found for struct `Peekable`\
    \ in the current scope\n  --> /tmp/tmp6axi5s71.rs:22:15\n   |\n22 |         if\
    \ *v.ptr() > w {\n   |               ^^^ method not found in `Peekable<Rev<std::slice::Iter<'_,\
    \ isize>>>`\n\nerror[E0599]: no method named `ptr` found for struct `Peekable`\
    \ in the current scope\n  --> /tmp/tmp6axi5s71.rs:26:41\n   |\n26 |          \
    \   max = std::cmp::max(max, *v.ptr());\n   |                                \
    \         ^^^ method not found in `Peekable<Rev<std::slice::Iter<'_, isize>>>`\n\
    \nerror[E0599]: `Option<&isize>` is not an iterator\n   --> /tmp/tmp6axi5s71.rs:27:22\n\
    \    |\n27  |               v.next().peekable();\n    |                      \
    \  ^^^^^^^^ `Option<&isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Option<&isize>: Iterator`\n \
    \           which is required by `&mut Option<&isize>: Iterator`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0658.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut sum = 0;\n    let mut max = w;\n\
    \    for x in q.iter() {\n        if x >= w {\n            balanced = true;\n\
    \            break;\n        }\n        sum += x;\n        if sum > max {\n  \
    \          break;\n        }\n    }\n    balanced && sum == max\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzh2dal55.rs:21:17\n   |\n\
    21 |         if x >= w {\n   |                 ^\n   |                 |\n   |\
    \                 expected `&isize`, found `isize`\n   |                 help:\
    \ consider borrowing here: `&w`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = q.clone();\n    let mut right = q.clone();\n    let mut\
    \ max = w.clone();\n    loop {\n        if left.len() == 0 || right.len() == 0\
    \ || max < 0 {\n            break;\n        }\n        if left.len() == 1 {\n\
    \            if *left.is_empty() {\n                break;\n            } else\
    \ {\n                *right = *left;\n                *left = [];\n          \
    \      break;\n            }\n        }\n        if right.len() == 1 {\n     \
    \       if *right.is_empty() {\n                break;\n            } else {\n\
    \                *left = *right;\n                *right = [];\n             \
    \   break;\n            }\n        }\n        if *left.len() <= *right.len() {\n\
    \            if *left.len() > max {\n                max = *left.len();\n    \
    \        }\n            if *right.is_empty() {\n                *right = *left.clone();\n\
    \                *left = [];\n            }\n        } else {\n            if\
    \ *right.len() > max {\n                max = *right.len();\n            }\n \
    \           if *left.is_empty() {\n                *left = *right.clone();\n \
    \               *right = [];\n            }\n        }\n    }\n    let res = *left\
    \ == *right;\n    if !res {\n        println!(\"{} {} won't fly\", *left.iter().collect::<Vec<&str>>(),\
    \ *right.iter().collect::<Vec<&str>>());\n    }\n    res\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmpuecxtqih.rs:25:16\n\
    \   |\n25 |             if *left.is_empty() {\n   |                ^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpuecxtqih.rs:28:17\n   |\n28 |                 *right = *left;\n\
    \   |                 ^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[isize]`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuecxtqih.rs:29:25\n   |\n29 |              \
    \   *left = [];\n   |                 -----   ^^ expected slice `[isize]`, found\
    \ array of 0 elements\n   |                 |\n   |                 expected due\
    \ to the type of this binding\n   |\n   = note: expected slice `[isize]`\n   \
    \           found array `[_; 0]`\n\nerror[E0277]: the size for values of type\
    \ `[isize]` cannot be known at compilation time\n  --> /tmp/tmpuecxtqih.rs:29:17\n\
    \   |\n29 |                 *left = [];\n   |                 ^^^^^ doesn't have\
    \ a size known at compile-time\n   |\n   = help: the trait `Sized` is not implemented\
    \ for `[isize]`\n   = note: the left-hand-side of an assignment must have a statically\
    \ known size\n\nerror[E0614]: type `bool` cannot be dereferenced\n  --> /tmp/tmpuecxtqih.rs:34:16\n\
    \   |\n34 |             if *right.is_empty() {\n   |                ^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: the size for values of type `[isize]` cannot be known at compilation\
    \ time\n  --> /tmp/tmpuecxtqih.rs:37:17\n   |\n37 |                 *left = *right;\n\
    \   |                 ^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[isize]`\n   = note: the\
    \ left-hand-side of an assignment must have a statically known size\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuecxtqih.rs:38:26\n   |\n38 |              \
    \   *right = [];\n   |                 ------   ^^ expected slice `[isize]`, found\
    \ array of 0 elements\n   |                 |\n   |                 expec"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 1 {\n        if q[0] == 0 {\n            return true;\n\
    \        }\n        return false;\n    }\n    let mut sum = q[0];\n    for i in\
    \ 1..q.len() {\n        if q[i] > sum {\n            return false;\n        }\n\
    \        sum += q[i];\n    }\n    if sum > w {\n        return false;\n    }\n\
    \    if sum == w {\n        return true;\n    }\n    let mut max_sum = w;\n  \
    \  let mut max_weight = w;\n    for i in 1..q.len() {\n        if q[i] > max_weight\
    \ {\n            max_weight = q[i];\n        }\n        if q[i] > max_sum {\n\
    \            max_sum = q[i];\n        }\n    }\n    if max_sum > w {\n       \
    \ return false;\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpglxsarzy.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > w {\n        false\n    } else {\n        let mut sum =\
    \ 0;\n        for i in 0..q.len() {\n            sum += q[i];\n            if\
    \ sum > w {\n                sum = 0;\n                break;\n            }\n\
    \        }\n        true\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwq5_c6qd.rs:17:18\n   |\n\
    17 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_rev = q.iter().rev().collect::<Vec<_>>();\n    q_rev.iter().all(|&i|\
    \ i % w == 0 || i / w == q.len() - 1);\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmprb7_mh4z.rs:18:50\n   |\n\
    18 |     q_rev.iter().all(|&i| i % w == 0 || i / w == q.len() - 1);\n   |    \
    \                                              ^^^^^^^^^^^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n18 |     q_rev.iter().all(|&i| i % w == 0\
    \ || i / w == (q.len() - 1).try_into().unwrap());\n   |                      \
    \                            +           +++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprb7_mh4z.rs:16:44\n   |\n16 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |    -----------                       \
    \      ^^^^ expected `bool`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n17 |     let mut q_rev\
    \ = q.iter().rev().collect::<Vec<_>>();\n18 |     q_rev.iter().all(|&i| i % w\
    \ == 0 || i / w == q.len() - 1);\n   |                                       \
    \                       - help: remove this semicolon\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max: isize = *q;\n    let mut sum: isize = 0;\n    for v in q.iter()\
    \ {\n        sum += v;\n        if max < w {\n            max = w;\n        }\n\
    \        if sum >= w {\n            return false;\n        }\n    }\n    true\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw8kzxmz4.rs:17:26\n   |\n\
    17 |     let mut max: isize = *q;\n   |                  -----   ^^ expected `isize`,\
    \ found slice `[isize]`\n   |                  |\n   |                  expected\
    \ due to this\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // The object q will fly, if it is a palindrome and has the sum of the\
    \ elements less than or equals to the weight w\n    let mut q_palindrome = true;\n\
    \    q_palindrome &= is_palindromic(q);\n    q_palindrome &= q.iter().filter(|&x|\
    \ x <= w).sum::<isize>() <= w;\n    q_palindrome\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpvw45cd80.rs:19:21\n   |\n19 |     q_palindrome &= is_palindromic(q);\n\
    \   |                     ^^^^^^^^^^^^^^ help: a local variable with a similar\
    \ name exists: `q_palindrome`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvw45cd80.rs:20:47\n\
    \   |\n20 |     q_palindrome &= q.iter().filter(|&x| x <= w).sum::<isize>() <=\
    \ w;\n   |                                               ^\n   |             \
    \                                  |\n   |                                   \
    \            expected `&isize`, found `isize`\n   |                          \
    \                     help: consider borrowing here: `&w`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = true;\n    let mut sum = 0;\n\n    for i in q.iter_mut()\
    \ {\n        sum += i;\n        balanced = balanced && sum < w;\n    }\n\n   \
    \ balanced && sum >= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `&mut isize` to `{integer}`\n  --> /tmp/tmp6gjn4sas.rs:21:13\n\
    \   |\n21 |         sum += i;\n   |             ^^ no implementation for `{integer}\
    \ += &mut isize`\n   |\n   = help: the trait `AddAssign<&mut isize>` is not implemented\
    \ for `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q.to_vec();\n    let mut l = q.len();\n    let mut s = 0;\n\
    \n    while l > 0 {\n        q.swap(l,0);\n        l -= 1;\n\n        match q[l\
    \ / 2] {\n            0 => (),\n            _ => {\n                s += q[l /\
    \ 2];\n            }\n        }\n    }\n\n    s == w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''index out of bounds: the len is 3 but the
    index is 3'', /tmp/tmp3sdb9l3e.rs:22:11

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if let Some(&x) = q.iter().cloned().rev() {\n        let mut sum = x\
    \ * (x + 1) / 2;\n        for a in q.iter().cloned() {\n            sum = sum\
    \ + a;\n            if sum == w {\n                return true;\n            }\n\
    \            sum -= a;\n            if sum < w {\n                return false;\n\
    \            }\n        }\n    }\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpieafujbr.rs:17:12\n   |\n\
    17 |     if let Some(&x) = q.iter().cloned().rev() {\n   |            ^^^^^^^^\
    \   ----------------------- this expression has type `Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n   |            |\n   |            expected struct `Rev`, found enum\
    \ `Option`\n   |\n   = note: expected struct `Rev<Cloned<std::slice::Iter<'_,\
    \ isize>>>`\n                found enum `Option<_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_c = q.clone();\n    q_c = q_c.reverse();\n\n    let mut w_c\
    \ = 0;\n    let mut qw = q.iter().zip(q.iter().cloned()).map(|(v1, v2)| {\n  \
    \      w_c += v1;\n        w_c += v2;\n        w_c\n    });\n\n    if qw > w {\n\
    \        return false;\n    }\n\n    let mut sum = 0;\n    let mut is_balanced\
    \ = true;\n    \n    while qw < w && is_balanced {\n        is_balanced = qw ==\
    \ w_c || is_balanced;\n        qw.push(w_c.clone());\n        sum += w_c;\n  \
    \      qw.pop();\n        w_c += 1;\n    }\n\n    if qw > w {\n        is_balanced\
    \ = false;\n    }\n\n    !is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr2ckaufz.rs:18:11\n   |\n\
    17 |     let mut q_c = q.clone();\n   |                   --------- expected due\
    \ to this value\n18 |     q_c = q_c.reverse();\n   |           ^^^^^^^^^^^^^ expected\
    \ struct `Vec`, found `()`\n   |\n   = note: expected struct `Vec<isize>`\n  \
    \         found unit type `()`\n\nerror[E0369]: binary operation `>` cannot be\
    \ applied to type `Map<Zip<std::slice::Iter<'_, isize>, Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>`\n  --> /tmp/tmpr2ckaufz.rs:27:11\n\
    \   |\n27 |     if qw > w {\n   |        -- ^ - isize\n   |        |\n   |   \
    \     Map<Zip<std::slice::Iter<'_, isize>, Cloned<std::slice::Iter<'_, isize>>>,\
    \ [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>\n\nerror[E0369]: binary operation\
    \ `<` cannot be applied to type `Map<Zip<std::slice::Iter<'_, isize>, Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>`\n  --> /tmp/tmpr2ckaufz.rs:34:14\n\
    \   |\n34 |     while qw < w && is_balanced {\n   |           -- ^ - isize\n \
    \  |           |\n   |           Map<Zip<std::slice::Iter<'_, isize>, Cloned<std::slice::Iter<'_,\
    \ isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>\n\nerror[E0369]: binary\
    \ operation `==` cannot be applied to type `Map<Zip<std::slice::Iter<'_, isize>,\
    \ Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>`\n\
    \  --> /tmp/tmpr2ckaufz.rs:35:26\n   |\n35 |         is_balanced = qw == w_c ||\
    \ is_balanced;\n   |                       -- ^^ --- isize\n   |             \
    \          |\n   |                       Map<Zip<std::slice::Iter<'_, isize>,\
    \ Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>\n\
    \nerror[E0599]: no method named `push` found for struct `Map` in the current scope\n\
    \  --> /tmp/tmpr2ckaufz.rs:36:12\n   |\n36 |         qw.push(w_c.clone());\n \
    \  |            ^^^^ method not found in `Map<Zip<std::slice::Iter<'_, isize>,\
    \ Cloned<std::slice::Iter<'_, isize>>>, [closure@/tmp/tmpr2ckaufz.rs:21:54: 25:6]>`\n\
    \nerror[E0599]: no method named `pop` found for struct `Map` in the"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = 0;\n    for v in q.iter() {\n        if v > max {\n   \
    \         max = v;\n        }\n    }\n\n    for v in q.iter() {\n        if v\
    \ > w {\n            return false;\n        }\n    }\n\n    max <= w\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvs9g30gq.rs:19:16\n   |\n\
    19 |         if v > max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvs9g30gq.rs:20:19\n\
    \   |\n17 |     let mut max = 0;\n   |                   - expected due to this\
    \ value\n...\n20 |             max = v;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n20 |  \
    \           max = *v;\n   |                   +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpvs9g30gq.rs:25:16\n   |\n25 |         if v > w {\n   |        \
    \        ^\n   |                |\n   |                expected `&isize`, found\
    \ `isize`\n   |                help: consider borrowing here: `&w`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    will_it_fly_impl(q, w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_impl` in this scope\n \
    \ --> /tmp/tmpocs21ytl.rs:17:5\n   |\n17 |     will_it_fly_impl(q, w)\n   |  \
    \   ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn is_balanced(v: &Vec<isize>) -> bool {\n        let mut s = v.len();\n\
    \        let mut i = 0;\n        while i < (s >> 1) {\n            if s[i] !=\
    \ v[((i >> 1) + s.len() & 1)] {\n                return false;\n            }\n\
    \            i += 1;\n        }\n        true\n    }\n\n    fn is_palindromic(v:\
    \ &Vec<isize>) -> bool {\n        let mut i = 0;\n        while i < v.len() {\n\
    \            if v[i] != v[v.len() - i - 1] {\n                return false;\n\
    \            }\n            i += 1;\n        }\n        true\n    }\n\n    fn\
    \ is_fly(v: &Vec<isize>) -> bool {\n        let mut s = v.len();\n        let\
    \ mut i = 0;\n        while i < s {\n            if i == (s >> 1) {\n        \
    \        return false;\n            }\n            if v[i] != v[((i >> 1) + s.len()\
    \ & 1)] {\n                return false;\n            }\n            i += 1;\n\
    \        }\n        true\n    }\n\n    fn max_weight_left(q: &Vec<isize>, mut\
    \ i: isize, mut s: usize) -> usize {\n        if i >= (s >> 1) {\n           \
    \ return s;\n        }\n        if q[i] != q[((i >> 1) + s.len() & 1)] {\n   \
    \         return max_weight_left(q, i + 1, s + (q[i] as isize));\n        }\n\
    \        return max_weight_left(q, i + 1, s);\n    }\n\n    q.len() >= max_weight_left(q,\
    \ 0, 0, w)\n        && is_balanced(&q)\n        && is_palindromic(&q)\n      \
    \  && is_fly(&q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 3 arguments but 4 arguments were supplied\n\
    \  --> /tmp/tmpng50qjfg.rs:65:16\n   |\n65 |     q.len() >= max_weight_left(q,\
    \ 0, 0, w)\n   |                ^^^^^^^^^^^^^^^ -  -  -  - supplied 4 arguments\n\
    \   |                |\n   |                expected 3 arguments\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpng50qjfg.rs:55:8\n   |\n55 |     fn max_weight_left(q:\
    \ &Vec<isize>, mut i: isize, mut s: usize) -> usize {\n   |        ^^^^^^^^^^^^^^^\
    \ --------------  ------------  ------------\n\nerror[E0608]: cannot index into\
    \ a value of type `usize`\n  --> /tmp/tmpng50qjfg.rs:21:16\n   |\n21 |       \
    \      if s[i] != v[((i >> 1) + s.len() & 1)] {\n   |                ^^^^\n\n\
    error[E0599]: no method named `len` found for type `usize` in the current scope\n\
    \  --> /tmp/tmpng50qjfg.rs:21:40\n   |\n21 |             if s[i] != v[((i >> 1)\
    \ + s.len() & 1)] {\n   |                                        ^^^ method not\
    \ found in `usize`\n\nerror[E0599]: no method named `len` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpng50qjfg.rs:47:40\n   |\n47 |          \
    \   if v[i] != v[((i >> 1) + s.len() & 1)] {\n   |                           \
    \             ^^^ method not found in `usize`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpng50qjfg.rs:56:17\n   |\n56 |         if i >= (s >> 1) {\n   |\
    \                 ^^^^^^^^ expected `isize`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `isize` and panic if the converted value doesn't fit\n\
    \   |\n56 |         if i >= ((s >> 1)).try_into().unwrap() {\n   |           \
    \      +        +++++++++++++++++++++\n\nerror[E0277]: the type `[isize]` cannot\
    \ be indexed by `isize`\n  --> /tmp/tmpng50qjfg.rs:59:12\n   |\n59 |         if\
    \ q[i] != q[((i >> 1) + s.len() & 1)] {\n   |            ^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[isize]>`\
    \ is not implemented for `isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<isize>` for `Vec<isize>`\n\nerror[E0599"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.to_string();\n    if q.len() < 4 {\n        return false;\n\
    \    }\n    let mut sum = 0;\n    for i in 0..q.len() {\n        sum += q.chars().nth(i).unwrap();\n\
    \    }\n    sum <= w && is_balanced(q) && is_palindrome(q) && is_sum(q, sum)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp9jynqen2.rs:25:17\n\
    \   |\n25 |     sum <= w && is_balanced(q) && is_palindrome(q) && is_sum(q, sum)\n\
    \   |                 ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_palindrome` in this scope\n  --> /tmp/tmp9jynqen2.rs:25:35\n\
    \   |\n25 |     sum <= w && is_balanced(q) && is_palindrome(q) && is_sum(q, sum)\n\
    \   |                                   ^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_sum` in this scope\n  --> /tmp/tmp9jynqen2.rs:25:55\n\
    \   |\n25 |     sum <= w && is_balanced(q) && is_palindrome(q) && is_sum(q, sum)\n\
    \   |                                                       ^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: `Vec<isize>` doesn't implement `std::fmt::Display`\n\
    \   --> /tmp/tmp9jynqen2.rs:17:15\n    |\n17  |       let q = q.to_string();\n\
    \    |                 ^^^^^^^^^ `Vec<isize>` cannot be formatted with the default\
    \ formatter\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: std::fmt::Display`\n            which is required by\
    \ `Vec<isize>: ToString`\n            `[isize]: std::fmt::Display`\n         \
    \   which is required by `[isize]: ToString`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        return false;\n    }\n    if w == q[0] {\n\
    \        return will_it_fly(q[1..].to_vec(), w);\n    }\n    let mut max_w = w;\n\
    \    let mut max_q = q;\n    let mut sum = 0;\n    for i in 1..q.len() {\n   \
    \     if q[i..].iter().zip(q.iter()).any(|(a, b)| {\n            a.0 != b.0 ||\
    \ b.0 - a.0 > max_w\n        }) {\n            max_w = q.len() - i;\n        \
    \    max_q = q[i..];\n        }\n        sum += q[i];\n    }\n    sum < max_w\
    \ && sum == max_q[0]\n}\n\nfn main() {\n    let candidate = will_it_fly;\n   \
    \ assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpr9i7lu9q.rs:28:15\n\
    \   |\n28 |             a.0 != b.0 || b.0 - a.0 > max_w\n   |               ^\n\
    \nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpr9i7lu9q.rs:28:22\n\
    \   |\n28 |             a.0 != b.0 || b.0 - a.0 > max_w\n   |                \
    \      ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpr9i7lu9q.rs:28:29\n\
    \   |\n28 |             a.0 != b.0 || b.0 - a.0 > max_w\n   |                \
    \             ^\n\nerror[E0609]: no field `0` on type `&isize`\n  --> /tmp/tmpr9i7lu9q.rs:28:35\n\
    \   |\n28 |             a.0 != b.0 || b.0 - a.0 > max_w\n   |                \
    \                   ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr9i7lu9q.rs:30:21\n\
    \   |\n23 |     let mut max_w = w;\n   |                     - expected due to\
    \ this value\n...\n30 |             max_w = q.len() - i;\n   |               \
    \      ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpr9i7lu9q.rs:31:21\n   |\n24 |     let mut max_q = q;\n\
    \   |                     - expected due to this value\n...\n31 |            \
    \ max_q = q[i..];\n   |                     ^^^^^^- help: try using a conversion\
    \ method: `.to_vec()`\n   |                     |\n   |                     expected\
    \ struct `Vec`, found slice `[isize]`\n   |\n   = note: expected struct `Vec<isize>`\n\
    \               found slice `[isize]`\n\nerror: aborting due to 6 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0609.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut found = false;\n    let mut max_w = w;\n\
    \    for x in q.iter() {\n        sum += x;\n        if sum > max_w {\n      \
    \      max_w = sum;\n        }\n        if sum == max_w {\n            found =\
    \ true;\n        }\n    }\n    found\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpr8xtuizz.rs:34:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        return false;\n    }\n    let mut sum = 0;\n\
    \    let mut max = 0;\n    for e in q {\n        sum += e;\n        if sum > w\
    \ {\n            return false;\n        }\n        if max < w {\n            max\
    \ = sum;\n        }\n    }\n    if max >= w {\n        return true;\n    }\n \
    \   return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp6vvidnts.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n    let mut fly_outer = false;\n\n    let mut is_balanced = false;\n\
    \n    let mut total = 0;\n\n    let mut maximum = 0;\n\n    // Go through each\
    \ element in the array and add it to total.\n    for i in q.iter() {\n       \
    \ total += *i;\n\n        // If the total is less than the maximum possible weight,\
    \ we know that the total will not be greater than the maximum possible weight.\n\
    \        if total < maximum {\n            maximum = total;\n        }\n    }\n\
    \n    // If the total is less than the maximum possible weight, it's not balanced.\n\
    \    // This means that the weight won't be greater than the maximum possible\
    \ weight,\n    // but the total won't be less than the maximum possible weight.\n\
    \    if total < maximum {\n        fly_outer = true;\n        is_balanced = false;\n\
    \    } else if total > maximum {\n        // The total will be greater than the\
    \ maximum possible weight, so the weight will be less than or equal to the maximum\
    \ possible weight.\n        fly_outer = false;\n        is_balanced = true;\n\
    \    } else {\n        // The total will be equal to the maximum possible weight,\
    \ so the weight will be equal to the maximum possible weight.\n        fly_outer\
    \ = true;\n        is_balanced = true;\n    }\n\n    // Return the boolean value.\n\
    \    fly_outer\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpt619e8_z.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        return true;\n    }\n    let mut a = q.clone();\n\
    \    let mut b = q.clone();\n\n    a.sort();\n    b.sort();\n    for i in 0..a.len()\
    \ {\n        if a[i] != b[a.len() - i - 1] {\n            return false;\n    \
    \    }\n    }\n    let mut c = vec![0; q.len()];\n    c.sort();\n    c.reverse();\n\
    \    c.iter().cloned().for_each(|&x| if x == w {\n        true\n    } else {\n\
    \        false\n    })\n}\n\nfn main() {\n    let candidate = will_it_fly;\n \
    \   assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavxhhk_w.rs:33:33\n   |\n\
    33 |     c.iter().cloned().for_each(|&x| if x == w {\n   |                   \
    \              ^--\n   |                                 ||\n   |            \
    \                     |expected due to this\n   |                            \
    \     expected integer, found reference\n   |                                \
    \ help: did you mean `x`: `&{integer}`\n   |\n   = note:   expected type `{integer}`\n\
    \           found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpavxhhk_w.rs:34:9\n\
    \   |\n33 |       c.iter().cloned().for_each(|&x| if x == w {\n   |  _____________________________________-\n\
    34 | |         true\n   | |         ^^^^ expected `()`, found `bool`\n35 | | \
    \    } else {\n36 | |         false\n37 | |     })\n   | |_____- expected this\
    \ to be `()`\n   |\nhelp: you might have meant to return this value\n   |\n34\
    \ |         return true;\n   |         ++++++     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpavxhhk_w.rs:36:9\n   |\n33 |       c.iter().cloned().for_each(|&x|\
    \ if x == w {\n   |  _____________________________________-\n34 | |         true\n\
    35 | |     } else {\n36 | |         false\n   | |         ^^^^^ expected `()`,\
    \ found `bool`\n37 | |     })\n   | |_____- expected this to be `()`\n   |\nhelp:\
    \ you might have meant to return this value\n   |\n36 |         return false;\n\
    \   |         ++++++      +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpavxhhk_w.rs:33:5\n\
    \   |\n16 |   fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |        \
    \                                      ---- expected `bool` because of return\
    \ type\n...\n33 | /     c.iter().cloned().for_each(|&x| if x == w {\n34 | |  \
    \       true\n35 | |     } else {\n36 | |         false\n37 | |     })\n   | |______^\
    \ expected `bool`, found `()`\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut total_weight = 0;\n    let mut is_palindromic = false;\n    let\
    \ mut max_weight = w;\n    let mut current_sum = 0;\n    for x in q.iter() {\n\
    \        total_weight += x;\n        current_sum += x;\n        max_weight = std::cmp::min(max_weight,\
    \ x);\n        if x > max_weight {\n            is_palindromic = false;\n    \
    \        break;\n        }\n        if x == total_weight {\n            is_palindromic\
    \ = true;\n            break;\n        }\n    }\n    if is_palindromic == true\
    \ {\n        current_sum < max_weight\n    } else if current_sum == max_weight\
    \ {\n        is_palindromic == true\n    } else {\n        is_palindromic == false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_9dy7njn.rs:24:48\n   |\n\
    24 |         max_weight = std::cmp::min(max_weight, x);\n   |                \
    \                                ^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n24 |         max_weight = std::cmp::min(max_weight,\
    \ *x);\n   |                                                +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_9dy7njn.rs:25:16\n   |\n25 |         if x >\
    \ max_weight {\n   |                ^^^^^^^^^^\n   |                |\n   |  \
    \              expected `&isize`, found `isize`\n   |                help: consider\
    \ borrowing here: `&max_weight`\n\nerror[E0277]: can't compare `&isize` with `isize`\n\
    \  --> /tmp/tmp_9dy7njn.rs:29:14\n   |\n29 |         if x == total_weight {\n\
    \   |              ^^ no implementation for `&isize == isize`\n   |\n   = help:\
    \ the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        false\n    } else if q.len() == 1 {\n    \
    \    q.iter().all(|&x| x == 0)\n    } else {\n        let mut q1 = q.clone();\n\
    \        q1.reverse();\n        q.iter().all(|&x| x >= w) && q1.iter().all(|&x|\
    \ x == 0)\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp92rs36i3.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut min_max_weight = (q.len(), w);\n    for\
    \ v in q.iter().rev() {\n        sum += v;\n        min_max_weight = (min_max_weight.0,\
    \ min_max_weight.1).min(|a, b| *a > *b);\n    }\n    sum == min_max_weight.1 &&\
    \ q.iter().all(|v| v == q.iter().rev().last().unwrap())\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpaehx_d2e.rs:21:68\n\
    \   |\n21 |         min_max_weight = (min_max_weight.0, min_max_weight.1).min(|a,\
    \ b| *a > *b);\n   |                                                         \
    \           ^ consider giving this closure parameter a type\n   |\n   = note:\
    \ type must be known at this point\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.is_palindrom() && q.iter().sum() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrom` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpumz2m92u.rs:17:7\n   |\n17 |     q.is_palindrom()\
    \ && q.iter().sum() <= w\n   |       ^^^^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() <= 1 {\n        return false;\n    }\n    sum::<isize>(q)\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum` in this scope\n  --> /tmp/tmpd1wm__k_.rs:20:5\n\
    \   |\n20 |     sum::<isize>(q) <= w\n   |     ^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() <= 1 || q.len() > w {\n        true\n    } else if is_palindromic(q)\
    \ && q.iter().sum::<isize>() <= w {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpjxkbyeyx.rs:19:15\n   |\n19 |     } else if is_palindromic(q) && q.iter().sum::<isize>()\
    \ <= w {\n   |               ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpjxkbyeyx.rs:17:34\n   |\n17 |     if q.len()\
    \ <= 1 || q.len() > w {\n   |                                  ^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n17 |     if q.len() <= 1 || q.len()\
    \ > w.try_into().unwrap() {\n   |                                   ++++++++++++++++++++\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().fold(false, |b, e| b && b == b.rev() && q.pop().iter().all(|x|\
    \ e + x <= w))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `bool` is not an iterator\n  --> /tmp/tmpso2343iq.rs:17:45\n\
    \   |\n17 |     q.iter().fold(false, |b, e| b && b == b.rev() && q.pop().iter().all(|x|\
    \ e + x <= w))\n   |                                             ^^^ `bool` is\
    \ not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `bool: Iterator`\n           which is required by `&mut bool: Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut l = q.len();\n    let mut r = l;\n    let mut w = 0;\n\n    while\
    \ l != r {\n        l -= 1;\n        r -= 1;\n        if q[l] != q[r] {\n    \
    \        return false;\n        }\n\n        w = (w * 10) + q[l];\n    }\n\n \
    \   w = (w * 10) + w;\n    w <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmppnxckn9w.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let max_weight = vec![0 .. w];\n    let mut min_weight = max_weight.clone();\n\
    \    let mut has_min = vec![false; q.len()];\n    let mut has_max = vec![false;\
    \ q.len()];\n    for (i, e) in q.iter().enumerate() {\n        if e < min_weight.len()\
    \ {\n            min_weight.push(false);\n            has_min[i] = true;\n   \
    \         min_weight[e] = e;\n        }\n        if e > max_weight.len() {\n \
    \           max_weight.push(e);\n            has_max[i] = true;\n            max_weight[e]\
    \ = e;\n        }\n    }\n    for (_, e) in q.iter().enumerate() {\n        if\
    \ min_weight[e] < max_weight[e] && has_min[e] == has_max[e] {\n            return\
    \ false;\n        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpckp30p1d.rs:22:16\n   |\n\
    22 |         if e < min_weight.len() {\n   |                ^^^^^^^^^^^^^^^^ expected\
    \ `&isize`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpckp30p1d.rs:23:29\n\
    \   |\n23 |             min_weight.push(false);\n   |                        \
    \     ^^^^^ expected struct `std::ops::Range`, found `bool`\n   |\n   = note:\
    \ expected struct `std::ops::Range<isize>`\n                found type `bool`\n\
    \nerror[E0277]: the type `[std::ops::Range<isize>]` cannot be indexed by `&isize`\n\
    \  --> /tmp/tmpckp30p1d.rs:25:13\n   |\n25 |             min_weight[e] = e;\n\
    \   |             ^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<isize>]>` is\
    \ not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<std::ops::Range<isize>>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpckp30p1d.rs:27:16\n   |\n27 |         if e > max_weight.len()\
    \ {\n   |                ^^^^^^^^^^^^^^^^ expected `&isize`, found `usize`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpckp30p1d.rs:28:29\n   |\n28 |  \
    \           max_weight.push(e);\n   |                             ^ expected struct\
    \ `std::ops::Range`, found `&isize`\n   |\n   = note: expected struct `std::ops::Range<isize>`\n\
    \           found reference `&isize`\n\nerror[E0277]: the type `[std::ops::Range<isize>]`\
    \ cannot be indexed by `&isize`\n  --> /tmp/tmpckp30p1d.rs:30:13\n   |\n30 | \
    \            max_weight[e] = e;\n   |             ^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[std::ops::Range<isize>]>`\
    \ is not implemented for `&isize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<&isize>` for `Vec<std::ops::Range<isize>>`\n\nerror[E0277]: the type\
    \ `[std::ops::Range<isize>]` cannot be indexed by `&isize`\n  --> /t"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    match w.to_lowercase() {\n        \"max\" => true,\n        \"min\" =>\
    \ false,\n        _ => {\n            let n = q.len();\n            if n == 0\
    \ { return false; }\n            let mut q2 = q.iter().cloned().collect::<Vec<_>>();\n\
    \            q2.reverse();\n            if n == q2.len() {\n                //\
    \ if the length of the vector is equal to its length, the vector will still be\
    \ balanced\n                return true;\n            } else {\n             \
    \   let mut total = 0;\n                for i in 0..n {\n                    total\
    \ += q[i];\n                }\n                total += w;\n                return\
    \ total <= w;\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lowercase` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpjd0a9fld.rs:17:13\n   |\n17 |     match w.to_lowercase()\
    \ {\n   |             ^^^^^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Return true if q will fly, and false otherwise.\n    let mut q1 =\
    \ q.clone();\n    q1.reverse();\n    if q1 == q {\n        true\n    } else {\n\
    \        let mut q2 = q.clone();\n        q2.reverse();\n        q1.iter().all(|&x|\
    \ q2 == q.iter().rev().take(x))\n    }\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi8chtcka.rs:25:54\n   |\n\
    25 |         q1.iter().all(|&x| q2 == q.iter().rev().take(x))\n   |          \
    \                                            ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n25 |         q1.iter().all(|&x| q2 == q.iter().rev().take(x.try_into().unwrap()))\n\
    \   |                                                       ++++++++++++++++++++\n\
    \nerror[E0277]: can't compare `Vec<isize>` with `std::iter::Take<Rev<std::slice::Iter<'_,\
    \ isize>>>`\n  --> /tmp/tmpi8chtcka.rs:25:31\n   |\n25 |         q1.iter().all(|&x|\
    \ q2 == q.iter().rev().take(x))\n   |                               ^^ no implementation\
    \ for `Vec<isize> == std::iter::Take<Rev<std::slice::Iter<'_, isize>>>`\n   |\n\
    \   = help: the trait `PartialEq<std::iter::Take<Rev<std::slice::Iter<'_, isize>>>>`\
    \ is not implemented for `Vec<isize>`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U, A2>>>\n\
    \             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T, A> as PartialEq<&[U]>>\n\
    \             <Vec<T, A> as PartialEq<&mut [U]>>\n             <Vec<T, A> as PartialEq<[U;\
    \ N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0277, E0308.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        true\n    } else {\n        let mut q_rev\
    \ = q.rev();\n        if q_rev == q.iter().rev().collect::<Vec<isize>>() {\n \
    \           true\n        } else {\n            if q_rev.iter().sum::<isize>()\
    \ <= w {\n                true\n            } else {\n                false\n\
    \            }\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpmwrjimqq.rs:20:27\n\
    \    |\n20  |           let mut q_rev = q.rev();\n    |                      \
    \       ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0277]:\
    \ a value of type `Vec<isize>` cannot be built from an iterator over elements\
    \ of type `&isize`\n    --> /tmp/tmpmwrjimqq.rs:21:36\n     |\n21   |        \
    \ if q_rev == q.iter().rev().collect::<Vec<isize>>() {\n     |               \
    \                     ^^^^^^^ value of type `Vec<isize>` cannot be built from\
    \ `std::iter::Iterator<Item=&isize>`\n     |\n     = help: the trait `FromIterator<&isize>`\
    \ is not implemented for `Vec<isize>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = q.iter().sum();\n    let max_weight = w;\n    if sum <\
    \ w {\n        return false;\n    }\n    let mut found = false;\n    for (i, e)\
    \ in q.iter().enumerate() {\n        let n = e;\n        if *q + n >= max_weight\
    \ {\n            // found a bigger element\n            found = true;\n      \
    \      break;\n        }\n        // else move the bigger element to q\n     \
    \   *q += n;\n    }\n    found\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&isize` to `[isize]`\n  --> /tmp/tmp0pxefgu0.rs:25:15\n\
    \   |\n25 |         if *q + n >= max_weight {\n   |            -- ^ - &isize\n\
    \   |            |\n   |            [isize]\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `[isize]`\n  --> /tmp/tmp0pxefgu0.rs:31:9\n\
    \   |\n31 |         *q += n;\n   |         --^^^^^\n   |         |\n   |     \
    \    cannot use `+=` on type `[isize]`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0368, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > w {\n        false\n    } else {\n        let mut m = q.len();\n\
    \        let mut n = q.len();\n        let mut sum = 0;\n        while n != 0\
    \ {\n            sum += *q[n];\n            if sum >= w {\n                m +=\
    \ 1;\n                sum -= w;\n            } else {\n                m += 1;\n\
    \            }\n            n -= 1;\n        }\n        m == q.len() && sum ==\
    \ w && q.is_palindromic()\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphnr7zt64.rs:17:18\n   |\n\
    17 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0614]: type `isize` cannot\
    \ be dereferenced\n  --> /tmp/tmphnr7zt64.rs:24:20\n   |\n24 |             sum\
    \ += *q[n];\n   |                    ^^^^^\n\nerror[E0599]: no method named `is_palindromic`\
    \ found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmphnr7zt64.rs:33:39\n\
    \   |\n33 |         m == q.len() && sum == w && q.is_palindromic()\n   |     \
    \                                  ^^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w.is_zero() {\n        return true;\n    }\n\n    // find the maximum\
    \ possible sum of weights\n    let mut max_possible_weight = isize::max_value();\n\
    \    let mut max_possible_balance = false;\n\n    let mut fly_count = 0;\n   \
    \ for v in q.iter() {\n        if *v > max_possible_weight {\n            max_possible_weight\
    \ = *v;\n        }\n    }\n\n    for v in q.iter() {\n        let mut v = *v;\n\
    \        if v == 0 {\n            fly_count += 1;\n            continue;\n   \
    \     }\n        let mut falsy = true;\n        while !falsy {\n            let\
    \ mut k = v;\n            while k % 2 == 1 {\n                k /= 2;\n      \
    \      }\n            if k == 1 {\n                fly_count += 1;\n         \
    \       falsy = false;\n            } else {\n                let mut j = v;\n\
    \                while j % 2 == 1 {\n                    j /= 2;\n           \
    \     }\n                if j == 1 {\n                    falsy = false;\n   \
    \             } else {\n                    let mut k = v;\n                 \
    \   while k == 1 {\n                        k /= 2;\n                    }\n \
    \                   if k == 2 {\n                        fly_count += 1;\n   \
    \                     falsy = false;\n                    } else {\n         \
    \               let mut j = v;\n                        while j == 1 {\n     \
    \                       j /= 2;\n                        }\n                 \
    \       if j == 2 {\n                            falsy = false;\n            \
    \            } else {\n                            let mut k = v;\n          \
    \                  while k == 1 {\n                                k /= 2;\n \
    \                           }\n                            if k == 3 {\n     \
    \                           fly_count += 1;\n                                falsy\
    \ = false;\n                            } else {\n                           \
    \     let mut j = v;\n                                while j == 1 {\n       \
    \                             j /= 2;\n                                }\n   \
    \                             if j == 3 {\n                                  \
    \  falsy = false;\n                                } else {\n                \
    \                    let mut k = v;\n                                    while\
    \ k == 1 {\n                                        k /= 2;\n                \
    \                    }\n                                    if k == 3 {\n    \
    \                                    falsy = false;\n                        \
    \            } else {\n                                        let mut j = v;\n\
    \                                        while j == 1 {\n                    \
    \                        j /= 2;\n                                        }\n\
    \                                        if j == 3 {\n                       \
    \                     falsy = false;\n                                       \
    \ } else {\n                                            let mut k = v;\n     \
    \                                       while k == 1 {\n                     \
    \                           k /= 2;\n                                        \
    \    }\n                                            if k == 3 {\n            \
    \                                    falsy = false;\n                        \
    \                    } else {\n                                              \
    \  let mut j = v;\n                                                while j ==\
    \ 1 {\n                                                    j /= 2;\n         \
    \                                       }\n                                  \
    \              if j == 3 {\n                                                 \
    \   falsy = false;\n                                                } else {\n\
    \                                                    let mut j = v;\n        \
    \                                            while j == 1 {\n                \
    \                                        j /= 2;\n                           \
    \                         }\n                                                \
    \    if j == 3 {\n                                                        fal\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpx8oqq8w5.rs:129:3\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n32  |  \
    \   for v in q.iter() {\n    |                       - unclosed delimiter\n...\n\
    39  |         while !falsy {\n    |                      - unclosed delimiter\n\
    ...\n47  |             } else {\n    |                    - unclosed delimiter\n\
    ...\n54  |                 } else {\n    |                        - unclosed delimiter\n\
    ...\n62  |                     } else {\n    |                            - unclosed\
    \ delimiter\n...\n69  |                         } else {\n    |              \
    \                  - unclosed delimiter\n...\n77  |                          \
    \   } else {\n    |                                    - unclosed delimiter\n\
    ...\n84  |                                 } else {\n    |                   \
    \                     - unclosed delimiter\n...\n91  |                       \
    \              } else {\n    |                                            - unclosed\
    \ delimiter\n...\n98  |                                         } else {\n   \
    \ |                                                - unclosed delimiter\n...\n\
    105 |                                             } else {\n    |            \
    \                                        - unclosed delimiter\n...\n112 |    \
    \                                             } else {\n    |                \
    \                                        - unclosed delimiter\n...\n117 |    \
    \                                                 if j == 3 {\n    |         \
    \                                                      - this delimiter might\
    \ not be properly closed...\n118 |                                           \
    \              fal\n119 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n129 | }\n    |   ^\n\nerror[E0425]: cannot find value `fal`\
    \ in this scope\n   --> /tmp/tmpx8oqq8w5.rs:118:57\n    |\n118 | ...         \
    \          fal\n    |                       ^^^ not found in this scope\n\nerro"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut w = 0;\n    for i in q {\n        if i\
    \ < w {\n            sum += i;\n        }\n        else {\n            w += i;\n\
    \        }\n    }\n    let max = w - w;\n    sum <= max\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpvf_o0kmw.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fly_balancer::is_balanced(q) && calc_sum_less_than_or_equal_to_weight(w,\
    \ q)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `fly_balancer`\n\
    \  --> /tmp/tmpqbh6_z54.rs:17:5\n   |\n17 |     fly_balancer::is_balanced(q) &&\
    \ calc_sum_less_than_or_equal_to_weight(w, q)\n   |     ^^^^^^^^^^^^ use of undeclared\
    \ crate or module `fly_balancer`\n\nerror[E0425]: cannot find function `calc_sum_less_than_or_equal_to_weight`\
    \ in this scope\n  --> /tmp/tmpqbh6_z54.rs:17:37\n   |\n17 |     fly_balancer::is_balanced(q)\
    \ && calc_sum_less_than_or_equal_to_weight(w, q)\n   |                       \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = 0;\n    let mut s = w;\n    let mut b = true;\n    for\
    \ &i in q {\n        s = s + i;\n        if s > max {\n            max = 0;\n\
    \        }\n        if s == w {\n            b = false;\n            break;\n\
    \        }\n        max = max + i;\n    }\n    b\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbeohoiu2.rs:20:9\n   |\n\
    20 |     for &i in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `i`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balance = false;\n    let mut max_weight = 0;\n\n    for s in\
    \ q.iter() {\n        balance &= s < w;\n        max_weight += s;\n    }\n\n \
    \   balance && q.len() <= max_weight\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2dsdl6nz.rs:21:24\n   |\n\
    21 |         balance &= s < w;\n   |                        ^\n   |          \
    \              |\n   |                        expected `&isize`, found `isize`\n\
    \   |                        help: consider borrowing here: `&w`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2dsdl6nz.rs:25:27\n   |\n25 |     balance &&\
    \ q.len() <= max_weight\n   |                           ^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n25 |     balance && q.len() <= max_weight.try_into().unwrap()\n\
    \   |                                     ++++++++++++++++++++\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut total = 0;\n    let mut max = 0;\n    for &n in q {\n       \
    \ total += n;\n        max = std::cmp::max(max, n);\n    }\n    total <= w &&\
    \ total >= max\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp35vpp06q.rs:19:9\n   |\n\
    19 |     for &n in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `n`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut f = false;\n    for &x in q {\n        f |= x == w;\n    }\n\
    \    f && (q.reduce(|a, b| a || b))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa_wmqt52.rs:18:9\n   |\n\
    18 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmpa_wmqt52.rs:21:13\n    |\n21  |       f &&\
    \ (q.reduce(|a, b| a || b))\n    |               ^^^^^^ `Vec<isize>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = q.len() - 1;\n    let mut max_i = w.len() - 1;\n\n    while\
    \ i >= 0 {\n        if q[i] != w[max_i] {\n            break;\n        }\n   \
    \     max_i--;\n        i--;\n    }\n\n    max_i >= 0\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpikmqrly9.rs:24:16\n\
    \   |\n24 |         max_i--;\n   |                ^ expected expression\n\nerror[E0599]:\
    \ no method named `len` found for type `isize` in the current scope\n  --> /tmp/tmpikmqrly9.rs:18:23\n\
    \   |\n18 |     let mut max_i = w.len() - 1;\n   |                       ^^^ method\
    \ not found in `isize`\n\nerror[E0608]: cannot index into a value of type `isize`\n\
    \  --> /tmp/tmpikmqrly9.rs:21:20\n   |\n21 |         if q[i] != w[max_i] {\n \
    \  |                    ^^^^^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0599, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let v = Vec::new();\n    v.extend_from_slice(q);\n\n    let mut s = vec![0];\n\
    \    s.push(0);\n\n    let mut max = 0;\n    loop {\n        for a in v.iter()\
    \ {\n            let m = &s * &a + 1;\n            if m > max {\n            \
    \    max = *m;\n            }\n        }\n        if max <= w {\n            return\
    \ true;\n        }\n        s.pop();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl5xxp3aa.rs:18:25\n   |\n\
    18 |     v.extend_from_slice(q);\n   |                         ^\n   |       \
    \                  |\n   |                         expected `&[_]`, found struct\
    \ `Vec`\n   |                         help: consider borrowing here: `&q`\n  \
    \ |\n   = note: expected reference `&[_]`\n                 found struct `Vec<isize>`\n\
    \nerror[E0369]: cannot multiply `&Vec<{integer}>` by `&&_`\n  --> /tmp/tmpl5xxp3aa.rs:26:24\n\
    \   |\n26 |             let m = &s * &a + 1;\n   |                     -- ^ --\
    \ &&_\n   |                     |\n   |                     &Vec<{integer}>\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q1 = q.clone();\n    q1.reverse();\n    (balanced_helper(q1,\
    \ w) && q.iter().all(|&x| x < w))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `balanced_helper` in this scope\n  -->\
    \ /tmp/tmpeueyrxqq.rs:19:6\n   |\n19 |     (balanced_helper(q1, w) && q.iter().all(|&x|\
    \ x < w))\n   |      ^^^^^^^^^^^^^^^ not found in this scope\n\nwarning: unnecessary\
    \ parentheses around block return value\n  --> /tmp/tmpeueyrxqq.rs:19:5\n   |\n\
    19 |     (balanced_helper(q1, w) && q.iter().all(|&x| x < w))\n   |     ^    \
    \                                              ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n19 -     (balanced_helper(q1,\
    \ w) && q.iter().all(|&x| x < w))\n19 +     balanced_helper(q1, w) && q.iter().all(|&x|\
    \ x < w)\n   | \n\nerror: aborting due to previous error; 1 warning emitted\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n\n    match will_it_fly_helper(q, &mut balanced,\
    \ &w) {\n        Ok(_) => balanced,\n        Err(_) => balanced,\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_helper` in this scope\n\
    \  --> /tmp/tmpuz_8fcnv.rs:19:11\n   |\n19 |     match will_it_fly_helper(q, &mut\
    \ balanced, &w) {\n   |           ^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // We only care about balanced lists.\n    if q.len() < 1 {\n       \
    \ return false;\n    }\n\n    // We only care about palindromic lists.\n    if\
    \ q.len() < 2 {\n        return q.len() == 1;\n    }\n\n    let mut last_item:\
    \ Option<isize> = None;\n\n    for &item in q {\n        // If the last item isn't\
    \ the head of the list, we can't fly.\n        if last_item.is_none() {\n    \
    \        return false;\n        }\n\n        // If the last item is equal to the\
    \ head, we can't fly.\n        if item == last_item.unwrap() {\n            return\
    \ false;\n        }\n\n        // If the last item and item don't match, we can't\
    \ fly.\n        if item != last_item.unwrap() {\n            return false;\n \
    \       }\n\n        last_item = Some(item);\n    }\n\n    // Everything in the\
    \ list was equal.\n    if last_item.is_none() {\n        return false;\n    }\n\
    \n    // Everything in the list was unequal, so we must fly.\n    let max_weight_possible\
    \ = |v: &[isize]| v.iter().fold(0, |a, b| a + b);\n\n    // If we've already fly,\
    \ then the answer is yes.\n    if max_weight_possible(q) == w {\n        return\
    \ true;\n    }\n\n    // The list is not balanced, so it's not possible to fly.\n\
    \    // Return false if the list contains more than one item, if the\n    // sum\
    \ of its elements is less than or equal to the maximum possible weight,\n    //\
    \ or if the list contains only the head and doesn't equal the maximum possible\
    \ weight.\n    if q.len() > 2 {\n        // The list contains more than one item,\
    \ because it is not balanced.\n        if q.len() != 1 {\n            return false;\n\
    \        }\n\n        // The list contains only one item, but it's not balanced.\n\
    \        if max_weight_possible(q) != w {\n            return false;\n       \
    \ }\n    }\n\n    // The list contains only the head and doesn't equal the maximum\
    \ possible weight.\n    // We return true if max_weight_possible(q) equals w.\n\
    \    max_weight_possible(q) == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwc_h1jo8.rs:29:9\n   |\n\
    29 |     for &item in q {\n   |         ^^^^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `item`\n   |\n   = note:\
    \   expected type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwc_h1jo8.rs:57:28\n   |\n57 |     if max_weight_possible(q)\
    \ == w {\n   |                            ^\n   |                            |\n\
    \   |                            expected `&[isize]`, found struct `Vec`\n   |\
    \                            help: consider borrowing here: `&q`\n   |\n   = note:\
    \ expected reference `&[isize]`\n                 found struct `Vec<isize>`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpwc_h1jo8.rs:72:32\n   |\n72 |  \
    \       if max_weight_possible(q) != w {\n   |                               \
    \ ^\n   |                                |\n   |                             \
    \   expected `&[isize]`, found struct `Vec`\n   |                            \
    \    help: consider borrowing here: `&q`\n   |\n   = note: expected reference\
    \ `&[isize]`\n                 found struct `Vec<isize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwc_h1jo8.rs:79:25\n   |\n79 |     max_weight_possible(q)\
    \ == w\n   |                         ^\n   |                         |\n   | \
    \                        expected `&[isize]`, found struct `Vec`\n   |       \
    \                  help: consider borrowing here: `&q`\n   |\n   = note: expected\
    \ reference `&[isize]`\n                 found struct `Vec<isize>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() < 2 {\n        return false;\n    }\n\n    let mut min = q.iter().min();\n\
    \    let mut max = q.iter().max();\n\n    let mut p = 0;\n    let mut i = 0;\n\
    \    for &x in q {\n        p = p * x + i;\n        i += 1;\n        if p < w\
    \ {\n            p = 0;\n            min = x;\n        } else {\n            p\
    \ = p - w;\n            max = x;\n        }\n    }\n\n    p < w && max - min <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptwptxx0d.rs:26:9\n   |\n\
    26 |     for &x in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `x`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0277]: cannot multiply\
    \ `isize` by `Option<&isize>`\n  --> /tmp/tmptwptxx0d.rs:27:15\n   |\n27 |   \
    \      p = p * x + i;\n   |               ^ no implementation for `isize * Option<&isize>`\n\
    \   |\n   = help: the trait `Mul<Option<&isize>>` is not implemented for `isize`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0369]:\
    \ cannot subtract `Option<&isize>` from `Option<&isize>`\n  --> /tmp/tmptwptxx0d.rs:38:18\n\
    \   |\n38 |     p < w && max - min <= w\n   |              --- ^ --- Option<&isize>\n\
    \   |              |\n   |              Option<&isize>\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0369.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    use self::MaxSum::*;\n    let mut m = Vec::with_capacity(q.len());\n\
    \    let mut sum = Vec::with_capacity(q.len());\n    for i in q.iter() {\n   \
    \     m.push(i);\n    }\n    m.sort_by_key(|&x| x);\n    for i in m.iter().rev()\
    \ {\n        sum.push(i);\n    }\n    sum.sort_by_key(|&x| x);\n    sum.push(w);\n\
    \    if sum.rev().iter().rev().fold(true, |&x, &y| x && y) {\n        true\n \
    \   } else {\n        false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `self::MaxSum`\n  --> /tmp/tmpfcfvh5jn.rs:17:15\n\
    \   |\n17 |     use self::MaxSum::*;\n   |               ^^^^^^ maybe a missing\
    \ crate `MaxSum`?\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfcfvh5jn.rs:28:14\n\
    \   |\n28 |     sum.push(w);\n   |              ^ expected `&&isize`, found `isize`\n\
    \nerror[E0599]: `Vec<&&isize>` is not an iterator\n   --> /tmp/tmpfcfvh5jn.rs:29:12\n\
    \    |\n29  |       if sum.rev().iter().rev().fold(true, |&x, &y| x && y) {\n\
    \    |              ^^^ `Vec<&&isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<&&isize>: Iterator`\n\
    \            which is required by `&mut Vec<&&isize>: Iterator`\n            `[&&isize]:\
    \ Iterator`\n            which is required by `&mut [&&isize]: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0432, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = true;\n    let mut sum = 0;\n    for i in q {\n  \
    \      sum += i;\n        balanced = if sum < w { !balanced } else { balanced\
    \ };\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphyk9o_pv.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q.to_vec();\n    let mut sum = 0;\n    while q.len() > 0\
    \ {\n        sum += q.last().unwrap();\n        q.pop();\n    }\n    sum >= w\
    \ && q == q.to_vec().rev()\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpifkx6b29.rs:23:33\n\
    \    |\n23  |       sum >= w && q == q.to_vec().rev()\n    |                 \
    \                  ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the\
    \ following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut k = q.len();\n    while k > 0 {\n     \
    \   sum += q.last();\n        k /= 2;\n    }\n    sum < w && is_balanced(q)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmprpzwk9dz.rs:23:16\n\
    \   |\n23 |     sum < w && is_balanced(q)\n   |                ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0277]: cannot add-assign `Option<&isize>` to `{integer}`\n\
    \  --> /tmp/tmprpzwk9dz.rs:20:13\n   |\n20 |         sum += q.last();\n   |  \
    \           ^^ no implementation for `{integer} += Option<&isize>`\n   |\n   =\
    \ help: the trait `AddAssign<Option<&isize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w.is_zero() {\n        return true;\n    }\n\n    let mut w = w;\n\
    \    let mut l = q;\n\n    while l.len() > 1 {\n        if *l.first() >= *l.last()\
    \ {\n            w.swap(l.first(), l.last());\n        }\n\n        l = l.pop().unwrap();\n\
    \    }\n\n    q.iter().all(|&i| i + w >= w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmp0l9r7x4j.rs:17:10\n   |\n17 |     if w.is_zero() {\n  \
    \ |          ^^^^^^^ method not found in `isize`\n\nerror[E0614]: type `Option<&isize>`\
    \ cannot be dereferenced\n  --> /tmp/tmp0l9r7x4j.rs:25:12\n   |\n25 |        \
    \ if *l.first() >= *l.last() {\n   |            ^^^^^^^^^^\n\nerror[E0614]: type\
    \ `Option<&isize>` cannot be dereferenced\n  --> /tmp/tmp0l9r7x4j.rs:25:26\n \
    \  |\n25 |         if *l.first() >= *l.last() {\n   |                        \
    \  ^^^^^^^^^\n\nerror[E0599]: no method named `swap` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmp0l9r7x4j.rs:26:15\n   |\n26 |             w.swap(l.first(),\
    \ l.last());\n   |               ^^^^ method not found in `isize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0l9r7x4j.rs:29:13\n   |\n22 |     let mut l\
    \ = q;\n   |                 - expected due to this value\n...\n29 |         l\
    \ = l.pop().unwrap();\n   |             ^^^^^^^^^^^^^^^^ expected struct `Vec`,\
    \ found `isize`\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `isize`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut w = w;\n    let mut r = false;\n    let mut m = q.len();\n  \
    \  while !r {\n        r = true;\n        while m > 0 {\n            if q[m -\
    \ 1] > w {\n                q[m-1] -= w;\n                w += w;\n          \
    \      m -= 1;\n                r = false;\n            } else {\n           \
    \     w += q[m - 1];\n                m -= 1;\n            }\n        }\n    }\n\
    \    r\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp93xhfrtb.rs:24:17\n   |\n16 | fn will_it_fly(q: Vec<isize>, w:\
    \ isize) -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n24 |                 q[m-1] -= w;\n   |                 ^ cannot\
    \ borrow as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q.to_vec();\n    q.sort();\n    let mut sum = 0;\n    while\
    \ !q.is_empty() {\n        sum += q.front();\n        q.pop();\n    }\n    sum\
    \ < w && q.len() == 0 || sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `front` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmpdr5cabl2.rs:21:18\n   |\n21 |         sum +=\
    \ q.front();\n   |                  ^^^^^ method not found in `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn is_balanced(q: Vec<isize>, w: isize) -> bool {\n        q.len() ==\
    \ q.pin().sum() || q.len() == w.len()\n    }\n\n    fn max_weights(q: Vec<isize>,\
    \ w: isize) -> isize {\n        q.iter().fold(w, |w, &x| w + x)\n    }\n\n   \
    \ is_balanced(q, w) && q.pin().sum() <= max_weights(q, w)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pin` found for struct `Vec<isize>` in the\
    \ current scope\n  --> /tmp/tmp9tp9uv_u.rs:25:28\n   |\n25 |     is_balanced(q,\
    \ w) && q.pin().sum() <= max_weights(q, w)\n   |                            ^^^\
    \ help: there is an associated function with a similar name: `splitn`\n\nerror[E0599]:\
    \ no method named `pin` found for struct `Vec<isize>` in the current scope\n \
    \ --> /tmp/tmp9tp9uv_u.rs:18:22\n   |\n18 |         q.len() == q.pin().sum() ||\
    \ q.len() == w.len()\n   |                      ^^^ help: there is an associated\
    \ function with a similar name: `splitn`\n\nerror[E0599]: no method named `len`\
    \ found for type `isize` in the current scope\n  --> /tmp/tmp9tp9uv_u.rs:18:50\n\
    \   |\n18 |         q.len() == q.pin().sum() || q.len() == w.len()\n   |     \
    \                                             ^^^ method not found in `isize`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for i in q {\n        sum += i;\n    }\n    (w\
    \ >= 0 && sum >= w) || (w < 0 && sum < w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpm7j3xk13.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 { return false; }\n    let mut max_w = 0;\n    let mut\
    \ max_c = 0;\n    for i in 0..q.len() {\n        let c = q.iter().nth(i).unwrap();\n\
    \        if c > max_w {\n            max_w = c;\n        }\n        if c >= w\
    \ {\n            max_c = c;\n        }\n    }\n    if q.len() == w { max_c ==\
    \ 1 }\n    else { max_c >= w }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphe7k_nmn.rs:22:16\n   |\n\
    22 |         if c > max_w {\n   |                ^^^^^\n   |                |\n\
    \   |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&max_w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphe7k_nmn.rs:23:21\n\
    \   |\n18 |     let mut max_w = 0;\n   |                     - expected due to\
    \ this value\n...\n23 |             max_w = c;\n   |                     ^ expected\
    \ integer, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    23 |             max_w = *c;\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphe7k_nmn.rs:25:17\n   |\n25 |         if c >= w {\n   |\
    \                 ^\n   |                 |\n   |                 expected `&isize`,\
    \ found `isize`\n   |                 help: consider borrowing here: `&w`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphe7k_nmn.rs:26:21\n   |\n19 |  \
    \   let mut max_c = 0;\n   |                     - expected due to this value\n\
    ...\n26 |             max_c = c;\n   |                     ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n26 |  \
    \           max_c = *c;\n   |                     +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphe7k_nmn.rs:29:19\n   |\n29 |     if q.len() == w { max_c\
    \ == 1 }\n   |                   ^ expected `usize`, found `isize`\n   |\nhelp:\
    \ you can convert an `isize` to a `usize` and panic if the converted value doesn't\
    \ fit\n   |\n29 |     if q.len() == w.try_into().unwrap() { max_c == 1 }\n   |\
    \                    ++++++++++++++++++++\n\nerror: aborting due to 5 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut sum = 0;\n    let mut n = q.len();\n\
    \    while n != 0 {\n        sum += *q.last().unwrap();\n        balanced = n\
    \ > 0 && sum < w;\n        if balanced {\n            break;\n        }\n    \
    \    q.remove(0);\n        n -= 1;\n    }\n    balanced\n}\n\nfn main() {\n  \
    \  let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp9nqmyji4.rs:26:9\n   |\n16 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n26 |         q.remove(0);\n   |         ^^^^^^^^^^^ cannot borrow\
    \ as mutable\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0596`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q.as_slice();\n    q.sort();\n    if q.len() <= 1 {\n   \
    \     return false;\n    }\n    if will_it_fly_helper(q, w) {\n        return\
    \ true;\n    }\n    return false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_helper` in this scope\n\
    \  --> /tmp/tmpvsmsbpav.rs:22:8\n   |\n22 |     if will_it_fly_helper(q, w) {\n\
    \   |        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q_size = q.len();\n    let mut max_weight = w;\n    q.resize(q.len());\n\
    \    q.sort();\n\n    let mut i = 0;\n    while i < q_size {\n        let mut\
    \ cur = &q[..];\n        cur.swap(i, q_size-1);\n        i += 1;\n        q_size\
    \ = q_size - 1;\n        let mut j = 0;\n        while j < q_size {\n        \
    \    let mut cur_i = cur[j];\n            let mut cur_j = cur[j+1];\n        \
    \    let w = cur_i + cur_j;\n            if w > max_weight {\n               \
    \ max_weight = w;\n            }\n            j = j + 1;\n        }\n    }\n \
    \   max_weight <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmps3kgd032.rs:19:7\n     |\n19   |     q.resize(q.len());\n   \
    \  |       ^^^^^^ ------- supplied 1 argument\n     |       |\n     |       expected\
    \ 2 arguments\n     |\nnote: associated function defined here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659976609
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn is_balanced(v: &[isize]) -> bool {\n        let mut a = v.len();\n\
    \        let mut b = v.len();\n        let mut c = v.len();\n        let mut d\
    \ = v.len();\n\n        while a != 0 {\n            if v[a-1] > v[a] {\n     \
    \           b = a;\n            }\n            if v[b-1] > v[b] {\n          \
    \      c = b;\n            }\n            if v[c-1] > v[c] {\n               \
    \ d = c;\n            }\n            a -= 1;\n            b -= 1;\n          \
    \  c -= 1;\n            d -= 1;\n        }\n        let mut sum: isize = 0;\n\
    \        for &element in v {\n            sum += element;\n        }\n       \
    \ sum < w && sum == v\n    }\n\n    fn is_palindromic(v: &[isize]) -> bool {\n\
    \        let mut i = 0;\n        let mut j = v.len();\n        while i != j {\n\
    \            if v[i++] != v[j--] {\n                return false;\n          \
    \  }\n        }\n        true\n    }\n\n    if is_balanced(&q) && is_palindromic(&q)\
    \ && q.iter().sum::<isize>() == w {\n        true\n    } else {\n        false\n\
    \    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpej7_2crx.rs:49:19\n\
    \   |\n49 |             if v[i++] != v[j--] {\n   |                   ^^ not a\
    \ valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n49 |         \
    \    if v[{ let tmp = i; i += 1; tmp }] != v[j--] {\n   |                  +++++++++++\
    \  ~~~~~~~~~~~~~~~\n49 -             if v[i++] != v[j--] {\n49 +             if\
    \ v[i += 1] != v[j--] {\n   | \n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmpej7_2crx.rs:42:15\n   |\n42 |         sum < w &&\
    \ sum == v\n   |               ^\n   |\n   = help: use the `|| { ... }` closure\
    \ form instead\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpej7_2crx.rs:42:27\n\
    \   |\n42 |         sum < w && sum == v\n   |                           ^ expected\
    \ `isize`, found `&[isize]`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0434.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.iter().cloned().collect::<Vec<_>>();\n    let mut max = 0;\n\
    \    q.into_iter().for_each(|x|{\n        if x > max {\n            max = x;\n\
    \        }\n    });\n    let mut sum = 0;\n    q.into_iter().for_each(|x|{\n \
    \       sum += x;\n    });\n    max <= w && sum <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmpcg5m00xr.rs:25:5\n\
    \    |\n17  |     let q = q.iter().cloned().collect::<Vec<_>>();\n    |      \
    \   - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n18  |     let mut max = 0;\n19  |     q.into_iter().for_each(|x|{\n\
    \    |       ----------- `q` moved due to this method call\n...\n25  |     q.into_iter().for_each(|x|{\n\
    \    |     ^ value used here after move\n    |\nnote: this function takes ownership\
    \ of the receiver `self`, which moves `q`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut c = Vec::new();\n    let mut d = Vec::new();\n    q.iter().for_each(|&x|\
    \ {\n        c.push(x);\n    });\n    for i in 0..q.len() {\n        match c {\n\
    \            vec![n] => return false,\n            vec![] => d.push(i),\n    \
    \        vec![n1,n2] => {\n                if n1 > n2 {\n                    d.push(i);\n\
    \                } else {\n                    d.push(i);\n                }\n\
    \            }\n        }\n    }\n    if w.to_ascii_lowercase().chars().filter(|c|c\
    \ == '1').count() == q[q.len() - 1].to_ascii_lowercase().chars().filter(|c|c ==\
    \ '1').count() {\n        true\n    } else {\n        false\n    }\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `n` in this scope\n  --> /tmp/tmpt4ipgjje.rs:24:18\n\
    \   |\n24 |             vec![n] => return false,\n   |                  ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `n1` in this scope\n  --> /tmp/tmpt4ipgjje.rs:26:18\n   |\n26 |      \
    \       vec![n1,n2] => {\n   |                  ^^ not found in this scope\n\n\
    error[E0425]: cannot find value `n2` in this scope\n  --> /tmp/tmpt4ipgjje.rs:26:21\n\
    \   |\n26 |             vec![n1,n2] => {\n   |                     ^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `n1` in this scope\n  --> /tmp/tmpt4ipgjje.rs:27:20\n\
    \   |\n27 |                 if n1 > n2 {\n   |                    ^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `n2` in this scope\n  --> /tmp/tmpt4ipgjje.rs:27:25\n\
    \   |\n27 |                 if n1 > n2 {\n   |                         ^^ not\
    \ found in this scope\n\nerror: arbitrary expressions aren't allowed in patterns\n\
    \  --> /tmp/tmpt4ipgjje.rs:24:13\n   |\n24 |             vec![n] => return false,\n\
    \   |             ^^^^^^^\n   |\n   = note: this error originates in the macro\
    \ `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror:\
    \ arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpt4ipgjje.rs:25:13\n\
    \   |\n25 |             vec![] => d.push(i),\n   |             ^^^^^^\n   |\n\
    \   = note: this error originates in the macro `vec` (in Nightly builds, run with\
    \ -Z macro-backtrace for more info)\n\nerror: arbitrary expressions aren't allowed\
    \ in patterns\n  --> /tmp/tmpt4ipgjje.rs:26:13\n   |\n26 |             vec![n1,n2]\
    \ => {\n   |             ^^^^^^^^^^^\n   |\n   = note: this error originates in\
    \ the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n\
    \nerror[E0599]: no method named `to_ascii_lowercase` found for type `isize` in\
    \ the current scope\n  --> /tmp/tmpt4ipgjje.rs:35:10\n   |\n35 |     if w.to_ascii_lowercase().chars().filter(|c|c\
    \ == '1').count() == q[q.len() - 1].to_ascii_lowercase().chars().filter(|c|c ==\
    \ '1').coun...\n   |          ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = vec![0; q.len()];\n\n    for &i in &q {\n        sum +=\
    \ i;\n    }\n\n    if q.len() <= 1 || sum.iter().max() >= w {\n        return\
    \ true;\n    }\n\n    let mut n = q.len();\n    sum -= w;\n    while n > 0 {\n\
    \        sum -= q.back();\n        q.pop_back();\n        n -= 1;\n    }\n\n \
    \   sum == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `Vec<{integer}>`\n  --> /tmp/tmpmttcda4g.rs:20:9\n   |\n20 |         sum +=\
    \ i;\n   |         ---^^^^^\n   |         |\n   |         cannot use `+=` on type\
    \ `Vec<{integer}>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmttcda4g.rs:23:44\n\
    \   |\n23 |     if q.len() <= 1 || sum.iter().max() >= w {\n   |             \
    \                               ^ expected enum `Option`, found `isize`\n   |\n\
    \   = note: expected enum `Option<&{integer}>`\n              found type `isize`\n\
    \nerror[E0368]: binary assignment operation `-=` cannot be applied to type `Vec<{integer}>`\n\
    \  --> /tmp/tmpmttcda4g.rs:28:5\n   |\n28 |     sum -= w;\n   |     ---^^^^^\n\
    \   |     |\n   |     cannot use `-=` on type `Vec<{integer}>`\n\nerror[E0599]:\
    \ no method named `back` found for struct `Vec<isize>` in the current scope\n\
    \  --> /tmp/tmpmttcda4g.rs:30:18\n   |\n30 |         sum -= q.back();\n   |  \
    \                ^^^^ method not found in `Vec<isize>`\n\nerror[E0599]: no method\
    \ named `pop_back` found for struct `Vec<isize>` in the current scope\n  --> /tmp/tmpmttcda4g.rs:31:11\n\
    \   |\n31 |         q.pop_back();\n   |           ^^^^^^^^ method not found in\
    \ `Vec<isize>`\n\nerror[E0277]: can't compare `Vec<{integer}>` with `isize`\n\
    \  --> /tmp/tmpmttcda4g.rs:35:9\n   |\n35 |     sum == w\n   |         ^^ no implementation\
    \ for `Vec<{integer}> == isize`\n   |\n   = help: the trait `PartialEq<isize>`\
    \ is not implemented for `Vec<{integer}>`\n   = help: the following other types\
    \ implement trait `PartialEq<Rhs>`:\n             <Vec<T, A1> as PartialEq<Vec<U,\
    \ A2>>>\n             <Vec<T, A> as PartialEq<&[U; N]>>\n             <Vec<T,\
    \ A> as PartialEq<&[U]>>\n             <Vec<T, A> as PartialEq<&mut [U]>>\n  \
    \           <Vec<T, A> as PartialEq<[U; N]>>\n             <Vec<T, A> as PartialEq<[U]>>\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // The sum of the elements of q is less than or equal to the maximum\
    \ possible weight.\n    if q.iter().sum::<usize>() <= w {\n        // The object\
    \ q is balanced.\n        return is_palindromic(q);\n    }\n    // The object\
    \ q isn't balanced.\n    // The sum of the elements of q is greater than or equal\
    \ to the maximum possible weight.\n    q.iter().sum::<usize>() >= w\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpxqhfb508.rs:20:16\n   |\n20 |         return is_palindromic(q);\n  \
    \ |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the\
    \ trait bound `usize: Sum<&isize>` is not satisfied\n    --> /tmp/tmpxqhfb508.rs:18:17\n\
    \     |\n18   |     if q.iter().sum::<usize>() <= w {\n     |                \
    \ ^^^ the trait `Sum<&isize>` is not implemented for `usize`\n     |\n     = help:\
    \ the following other types implement trait `Sum<A>`:\n               <f32 as\
    \ Sum<&'a f32>>\n               <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n\
    \               <f64 as Sum>\n               <i128 as Sum<&'a i128>>\n       \
    \        <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n               <i16\
    \ as Sum>\n             and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxqhfb508.rs:18:35\n   |\n18 |\
    \     if q.iter().sum::<usize>() <= w {\n   |                                \
    \   ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n18 |     if\
    \ q.iter().sum::<usize>() <= w.try_into().unwrap() {\n   |                   \
    \                 ++++++++++++++++++++\n\nerror[E0277]: the trait bound `usize:\
    \ Sum<&isize>` is not satisfied\n    --> /tmp/tmpxqhfb508.rs:24:14\n     |\n24\
    \   |     q.iter().sum::<usize>() >= w\n     |              ^^^ the trait `Sum<&isize>`\
    \ is not implemented for `usize`\n     |\n     = help: the following other types\
    \ implement trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n          \
    \     <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n               <f64\
    \ as Sum>\n               <i128 as Sum<&'a i128>>\n               <i128 as Sum>\n\
    \               <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n         \
    \    and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxqhfb508.rs:24:32\n   |\n24 |  \
    \   q.iter().sum::<usize>() >= w\n   |                        "
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum: usize = 0;\n    for v in q.iter() {\n        sum += v;\n\
    \    }\n    sum == w && is_palindromic(q) && sum >= w && is_balanced(q)\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpadmbqp_7.rs:21:17\n   |\n21 |     sum == w && is_palindromic(q) && sum\
    \ >= w && is_balanced(q)\n   |                 ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n  -->\
    \ /tmp/tmpadmbqp_7.rs:21:50\n   |\n21 |     sum == w && is_palindromic(q) && sum\
    \ >= w && is_balanced(q)\n   |                                               \
    \   ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpadmbqp_7.rs:19:16\n   |\n19 |         sum += v;\n   |              \
    \  ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot add-assign `&isize`\
    \ to `usize`\n  --> /tmp/tmpadmbqp_7.rs:19:13\n   |\n19 |         sum += v;\n\
    \   |             ^^ no implementation for `usize += &isize`\n   |\n   = help:\
    \ the trait `AddAssign<&isize>` is not implemented for `usize`\n   = help: the\
    \ following other types implement trait `AddAssign<Rhs>`:\n             <f32 as\
    \ AddAssign<&f32>>\n             <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n\
    \             <f64 as AddAssign>\n             <i128 as AddAssign<&i128>>\n  \
    \           <i128 as AddAssign>\n             <i16 as AddAssign<&i16>>\n     \
    \        <i16 as AddAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpadmbqp_7.rs:21:12\n   |\n21 |     sum == w && is_palindromic(q)\
    \ && sum >= w && is_balanced(q)\n   |            ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n21 |     sum == w.try_into().unwrap() && is_palindromic(q)\
    \ && sum >= w && is_balanced(q)\n   |             ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpadmbqp_7.rs:21:45\n   |\n21 |     sum == w &&\
    \ is_palindromic(q) && sum >= w && is_balanced(q)\n   |                      \
    \                       ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n21 |     sum == w && is_palindromic(q) && s"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for i in q {\n        if i != 0 && i % 2 == 0 {\n\
    \            sum += i;\n        }\n    }\n    if sum > w {\n        return false;\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpe8o2uter.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut n = q.len();\n    let mut sum = 0;\n    let mut max_possible\
    \ = if n > w { w } else { n };\n    while n > 0 {\n        let a = q.split_off(n);\n\
    \        let r = a + a.split_off(n);\n        sum += *r.iter().cloned().collect::<Vec<_>>().sum();\n\
    \        n -= r.len();\n    }\n    sum < max_possible && sum == q.iter().cloned().collect::<Vec<_>>().sum()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwaqhhxum.rs:19:35\n   |\n\
    19 |     let mut max_possible = if n > w { w } else { n };\n   |             \
    \                      ^ expected `usize`, found `isize`\n   |\nhelp: you can\
    \ convert an `isize` to a `usize` and panic if the converted value doesn't fit\n\
    \   |\n19 |     let mut max_possible = if n > w.try_into().unwrap() { w } else\
    \ { n };\n   |                                    ++++++++++++++++++++\n\nerror[E0308]:\
    \ `if` and `else` have incompatible types\n  --> /tmp/tmpwaqhhxum.rs:19:50\n \
    \  |\n19 |     let mut max_possible = if n > w { w } else { n };\n   |       \
    \                                -          ^ expected `isize`, found `usize`\n\
    \   |                                       |\n   |                          \
    \             expected because of this\n\nerror[E0369]: cannot add `Vec<isize>`\
    \ to `Vec<isize>`\n  --> /tmp/tmpwaqhhxum.rs:22:19\n   |\n22 |         let r =\
    \ a + a.split_off(n);\n   |                 - ^ -------------- Vec<isize>\n  \
    \ |                 |\n   |                 Vec<isize>\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmpwaqhhxum.rs:26:72\n    |\n26  |       sum\
    \ < max_possible && sum == q.iter().cloned().collect::<Vec<_>>().sum()\n    |\
    \                                                                          ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0369,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // If q is balanced, then q.length <= w, and sum of its elements is less\
    \ than or equal to w.\n    let q = q.iter().cloned().collect::<Vec<_>>();\n  \
    \  let sum = q.iter().sum();\n    sum <=\n        w && q.len() <= w && (q.iter().cloned().collect::<Vec<_>>().iter().rev().sum()\
    \ <= w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpby861ock.rs:21:25\n   |\n\
    21 |         w && q.len() <= w && (q.iter().cloned().collect::<Vec<_>>().iter().rev().sum()\
    \ <= w)\n   |                         ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n21 |         w && q.len() <= w.try_into().unwrap() && (q.iter().cloned().collect::<Vec<_>>().iter().rev().sum()\
    \ <= w)\n   |                          ++++++++++++++++++++\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.len() > w && is_balanced(q) && is_palindromic(q) && is_non_negative(w)\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp1t776ao4.rs:17:20\n\
    \   |\n17 |     q.len() > w && is_balanced(q) && is_palindromic(q) && is_non_negative(w)\n\
    \   |                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_palindromic` in this scope\n  --> /tmp/tmp1t776ao4.rs:17:38\n\
    \   |\n17 |     q.len() > w && is_balanced(q) && is_palindromic(q) && is_non_negative(w)\n\
    \   |                                      ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `is_non_negative` in this scope\n  --> /tmp/tmp1t776ao4.rs:17:59\n\
    \   |\n17 |     q.len() > w && is_balanced(q) && is_palindromic(q) && is_non_negative(w)\n\
    \   |                                                           ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1t776ao4.rs:17:15\n\
    \   |\n17 |     q.len() > w && is_balanced(q) && is_palindromic(q) && is_non_negative(w)\n\
    \   |               ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    17 |     q.len() > w.try_into().unwrap() && is_balanced(q) && is_palindromic(q)\
    \ && is_non_negative(w)\n   |                ++++++++++++++++++++\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    debug_assert!(\n        q.len() <= w && w <= &q.iter().max(),\n     \
    \   \"The object q will not fly, since it is too long (length: {}), or too short\
    \ (max: {}).\",\n        q.len(),\n        w\n    );\n    let mut left = &q;\n\
    \    let mut right = &q;\n    let mut sum = 0;\n    let mut max_weight = &w;\n\
    \    while *left != *right {\n        if *left > sum {\n            sum += *left;\n\
    \        } else if *left < sum {\n            sum = *left;\n        } else {\n\
    \            return false;\n        }\n        *left = (*left + 1) as isize;\n\
    \        sum += *left;\n        *right = (*right - 1) as isize;\n    }\n    if\
    \ sum == *max_weight {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9c48061v.rs:18:20\n   |\n\
    18 |         q.len() <= w && w <= &q.iter().max(),\n   |                    ^\
    \ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to a\
    \ `usize` and panic if the converted value doesn't fit\n   |\n18 |         q.len()\
    \ <= w.try_into().unwrap() && w <= &q.iter().max(),\n   |                    \
    \ ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9c48061v.rs:18:30\n\
    \   |\n18 |         q.len() <= w && w <= &q.iter().max(),\n   |              \
    \                ^^^^^^^^^^^^^^^ expected `isize`, found `&Option<&isize>`\n \
    \  |\n   = note:   expected type `isize`\n           found reference `&Option<&isize>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9c48061v.rs:28:20\n   |\n28 |\
    \         if *left > sum {\n   |                    ^^^ expected struct `Vec`,\
    \ found integer\n   |\n   = note: expected struct `Vec<isize>`\n             \
    \   found type `{integer}`\n\nerror[E0277]: cannot add-assign `Vec<isize>` to\
    \ `{integer}`\n  --> /tmp/tmp9c48061v.rs:29:17\n   |\n29 |             sum +=\
    \ *left;\n   |                 ^^ no implementation for `{integer} += Vec<isize>`\n\
    \   |\n   = help: the trait `AddAssign<Vec<isize>>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `AddAssign<Rhs>`:\n    \
    \         <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n        \
    \     <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n            \
    \ <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n             <i16\
    \ as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and 20 others\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp9c48061v.rs:30:27\n   |\n30 |\
    \         } else if *left < sum {\n   |                           ^^^ expected\
    \ struct `Vec`, found integer\n   |\n   = note: expected struct `Vec<isize>`\n\
    \                found type `{integer}`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp9c48061v.rs:31:19\n   |\n25 |     let mut sum = 0;\n   |           \
    \        - expected due to this value\n...\n31 |             sum = *left;\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum: isize = q.iter().fold(0, |sum, x| sum + x);\n    if sum\
    \ > w {\n        return false;\n    }\n    let mut max = q.iter().fold(0, |max,\
    \ x| if x > max { x } else { max });\n    let mut index = 0;\n    while max >\
    \ sum {\n        sum -= q[index];\n        index += 1;\n        max -= q[index];\n\
    \    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpy7ydwevb.rs:21:52\n   |\n\
    21 |     let mut max = q.iter().fold(0, |max, x| if x > max { x } else { max });\n\
    \   |                                                    ^^^\n   |           \
    \                                         |\n   |                            \
    \                        expected `&isize`, found integer\n   |              \
    \                                      help: consider borrowing here: `&max`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpy7ydwevb.rs:21:58\n   |\n21 |\
    \     let mut max = q.iter().fold(0, |max, x| if x > max { x } else { max });\n\
    \   |                                                          ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n21 |  \
    \   let mut max = q.iter().fold(0, |max, x| if x > max { *x } else { max });\n\
    \   |                                                          +\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut n = q.len();\n    let mut q1 = q.clone();\n    fn can_fly(&mut\
    \ q, &mut n, w: isize) -> bool {\n        if n == 0 {\n            true\n    \
    \    } else {\n            if let Some(i) = q1.pop() {\n                if i <=\
    \ w {\n                    q1.push(i);\n                    return can_fly(q,\
    \ n - 1, w) || can_fly(q1, n - 1, w)\n                } else {\n             \
    \       false\n                }\n            } else {\n                false\n\
    \            }\n        }\n    }\n    can_fly(&mut q, &mut n, w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `:`, `@`, or `|`, found `,`\n  --> /tmp/tmp08jaha4o.rs:19:22\n\
    \   |\n19 |     fn can_fly(&mut q, &mut n, w: isize) -> bool {\n   |         \
    \             ^ expected one of `:`, `@`, or `|`\n   |\n   = note: anonymous parameters\
    \ are removed in the 2018 edition (see RFC 1685)\nhelp: if this is a `self` type,\
    \ give it a parameter name\n   |\n19 |     fn can_fly(self: &mut q, &mut n, w:\
    \ isize) -> bool {\n   |                +++++\nhelp: if this is a parameter name,\
    \ give it a type\n   |\n19 |     fn can_fly(q: &mut TypeName, &mut n, w: isize)\
    \ -> bool {\n   |                ~~~~~~~~~~~~~~~~\nhelp: if this is a type, explicitly\
    \ ignore the parameter name\n   |\n19 |     fn can_fly(_: &mut q, &mut n, w: isize)\
    \ -> bool {\n   |                ++\n\nerror: expected one of `:`, `@`, or `|`,\
    \ found `,`\n  --> /tmp/tmp08jaha4o.rs:19:30\n   |\n19 |     fn can_fly(&mut q,\
    \ &mut n, w: isize) -> bool {\n   |                              ^ expected one\
    \ of `:`, `@`, or `|`\n   |\n   = note: anonymous parameters are removed in the\
    \ 2018 edition (see RFC 1685)\nhelp: if this is a parameter name, give it a type\n\
    \   |\n19 |     fn can_fly(&mut q, n: &mut TypeName, w: isize) -> bool {\n   |\
    \                        ~~~~~~~~~~~~~~~~\nhelp: if this is a type, explicitly\
    \ ignore the parameter name\n   |\n19 |     fn can_fly(&mut q, _: &mut n, w: isize)\
    \ -> bool {\n   |                        ++\n\nerror[E0434]: can't capture dynamic\
    \ environment in a fn item\n  --> /tmp/tmp08jaha4o.rs:23:30\n   |\n23 |      \
    \       if let Some(i) = q1.pop() {\n   |                              ^^\n  \
    \ |\n   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't\
    \ capture dynamic environment in a fn item\n  --> /tmp/tmp08jaha4o.rs:25:21\n\
    \   |\n25 |                     q1.push(i);\n   |                     ^^\n   |\n\
    \   = help: use the `|| { ... }` closure form instead\n\nerror[E0434]: can't capture\
    \ dynamic environment in a fn item\n  --> /tmp/tmp08jaha4o.rs:26:60\n   |\n26\
    \ |                     return can_fly(q, n - 1, w) || can_fly(q1, n - 1, w)\n\
    \   |                                       "
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Check balance.\n    if q.is_palindromic() && (q.reduce::<usize>()\
    \ <= w)\n        && (q.iter().sum::<usize>() <= w)\n    {\n        return true;\n\
    \    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindromic` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpzebdonx7.rs:18:10\n   |\n18 |     if q.is_palindromic()\
    \ && (q.reduce::<usize>() <= w)\n   |          ^^^^^^^^^^^^^^ method not found\
    \ in `Vec<isize>`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpzebdonx7.rs:18:33\n\
    \    |\n18  |       if q.is_palindromic() && (q.reduce::<usize>() <= w)\n    |\
    \                                   ^^^^^^ `Vec<isize>` is not an iterator\n \
    \   |\n    = note: the following trait bounds were not satisfied:\n          \
    \  `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0277]: the trait bound `usize: Sum<&isize>`\
    \ is not satisfied\n    --> /tmp/tmpzebdonx7.rs:19:22\n     |\n19   |        \
    \ && (q.iter().sum::<usize>() <= w)\n     |                      ^^^ the trait\
    \ `Sum<&isize>` is not implemented for `usize`\n     |\n     = help: the following\
    \ other types implement trait `Sum<A>`:\n               <f32 as Sum<&'a f32>>\n\
    \               <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n         \
    \      <f64 as Sum>\n               <i128 as Sum<&'a i128>>\n               <i128\
    \ as Sum>\n               <i16 as Sum<&'a i16>>\n               <i16 as Sum>\n\
    \             and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzebdonx7.rs:19:40\n   |\n19 |\
    \         && (q.iter().sum::<usize>() <= w)\n   |                            \
    \            ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an\
    \ `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n19\
    \ |         && (q.iter().sum::<usize>() <= w.try_into().unwrap())\n   |      \
    \                                   ++++++++++++++++++++\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Base case: the palindrome and the sum of its elements are less than\
    \ or equal the weight w.\n    if q.is_empty() {\n        return true;\n    }\n\
    \    if q[0] == q[q.len() - 1] {\n        return will_it_fly(q.iter().rev(), w);\n\
    \    }\n\n    // Recursive case: the sum of the elements q[1..q.len()-1] is less\
    \ than or equal the weight w, and the palindrome is balanced.\n    let mut n =\
    \ q.len() - 1;\n    while n >= 1 && q[n] == q[n - 1] {\n        n -= 1;\n    }\n\
    \    if n >= 1 && q[n] == q[n - 1] {\n        // Palindrome is balanced. Sum of\
    \ the elements q[1..n-1] is less than or equal the weight w. \n        if w >\
    \ q.iter().sum::<isize>() {\n            return false;\n        }\n        return\
    \ will_it_fly(q.iter().rev(), w);\n    }\n    true\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz9cpu0xb.rs:22:28\n   |\n\
    22 |         return will_it_fly(q.iter().rev(), w);\n   |                    \
    \        ^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n   |\n   =\
    \ note: expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpz9cpu0xb.rs:35:28\n\
    \   |\n35 |         return will_it_fly(q.iter().rev(), w);\n   |             \
    \               ^^^^^^^^^^^^^^ expected struct `Vec`, found struct `Rev`\n   |\n\
    \   = note: expected struct `Vec<isize>`\n              found struct `Rev<std::slice::Iter<'_,\
    \ isize>>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut total: usize = 0;\n    let mut max_weight: usize = w;\n\n   \
    \ let mut balanced = false;\n\n    // Go through all the numbers in `q`, adding\
    \ them up to `total`\n    for &num in q {\n        total += num;\n        // If\
    \ the number is greater than the maximum weight,\n        // then we've found\
    \ a palindrome\n        if total > max_weight {\n            // If we haven't\
    \ found a palindrome,\n            // then we can flip a balanced vector to true\n\
    \            if !balanced {\n                balanced = true;\n            }\n\
    \            break;\n        }\n    }\n\n    // If we've found a palindrome,\n\
    \    // then the vector should be balanced\n    balanced\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgd0b8tz3.rs:18:33\n   |\n\
    18 |     let mut max_weight: usize = w;\n   |                         -----  \
    \ ^ expected `usize`, found `isize`\n   |                         |\n   |    \
    \                     expected due to this\n   |\nhelp: you can convert an `isize`\
    \ to a `usize` and panic if the converted value doesn't fit\n   |\n18 |     let\
    \ mut max_weight: usize = w.try_into().unwrap();\n   |                       \
    \           ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgd0b8tz3.rs:23:9\n\
    \   |\n23 |     for &num in q {\n   |         ^^^^    - this expression has type\
    \ `Option<isize>`\n   |         |\n   |         expected `isize`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `num`\n   |\n\
    \   = note:   expected type `isize`\n           found reference `&_`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let n = q.len();\n    if n <= 1 {\n        return false;\n    }\n   \
    \ let mut max = w;\n    let mut sum_of_weights = 0;\n    let mut palindrome =\
    \ true;\n\n    for &x in q.iter().rev() {\n        let y = x - 1;\n        let\
    \ mut d = *x + y;\n        if d > max {\n            max = d;\n        }\n   \
    \     sum_of_weights += *x + y;\n        if *q != *y {\n            palindrome\
    \ = false;\n            break;\n        }\n    }\n    match n {\n        0 =>\
    \ return true,\n        1 => return palindrome,\n        _ => {\n            if\
    \ sum_of_weights <= max {\n                return palindrome;\n            }\n\
    \            return false;\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpwjthsa22.rs:27:21\n\
    \   |\n27 |         let mut d = *x + y;\n   |                     ^^\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpwjthsa22.rs:31:27\n   |\n\
    31 |         sum_of_weights += *x + y;\n   |                           ^^\n\n\
    error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpwjthsa22.rs:32:18\n\
    \   |\n32 |         if *q != *y {\n   |                  ^^\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = true\n    let mut sum_weight = 0isize;\n    for v\
    \ in q.iter().rev() {\n        if v > w {\n            return false;\n       \
    \ }\n        balanced = balanced && v == q.len() / 2;\n        sum_weight += v;\n\
    \    }\n    balanced && sum_weight <= w\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `let`\n  --> /tmp/tmptjolhogj.rs:17:28\n\
    \   |\n17 |     let mut balanced = true\n   |                            ^ help:\
    \ add `;` here\n18 |     let mut sum_weight = 0isize;\n   |     --- unexpected\
    \ token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptjolhogj.rs:20:16\n \
    \  |\n20 |         if v > w {\n   |                ^\n   |                |\n\
    \   |                expected `&isize`, found `isize`\n   |                help:\
    \ consider borrowing here: `&w`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmptjolhogj.rs:23:37\n\
    \   |\n23 |         balanced = balanced && v == q.len() / 2;\n   |           \
    \                          ^^^^^^^^^^^ expected `isize`, found `usize`\n\nerror[E0277]:\
    \ can't compare `&isize` with `usize`\n  --> /tmp/tmptjolhogj.rs:23:34\n   |\n\
    23 |         balanced = balanced && v == q.len() / 2;\n   |                  \
    \                ^^ no implementation for `&isize == usize`\n   |\n   = help:\
    \ the trait `PartialEq<usize>` is not implemented for `&isize`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let w = w as isize;\n    let mut q = q.to_vec();\n    q.reverse();\n\
    \    let mut sum = w;\n    while q.len() > 0 {\n        sum += q.pop();\n    }\n\
    \    sum < w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `isize`\n  --> /tmp/tmp6ot87__i.rs:22:13\n\
    \   |\n22 |         sum += q.pop();\n   |             ^^ no implementation for\
    \ `isize += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>`\
    \ is not implemented for `isize`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    will_it_fly_impl(&q, &w, 0, 0)\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_impl` in this scope\n \
    \ --> /tmp/tmpqaavb8dn.rs:17:5\n   |\n17 |     will_it_fly_impl(&q, &w, 0, 0)\n\
    \   |     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // A vector is a palindrome, if it's the same and has the same weight\
    \ (sum of its elements).\n    // Palindromic vectors are also balanced (each element\
    \ has at most one other element that is less than it).\n    //\n    // To check\
    \ if a vector is a palindromic vector, we need to iterate through each element\
    \ and\n    // check if it equals itself, or if one of its elements equals itself.\n\
    \    //\n    // To check if the vector is balanced, we check if each element has\
    \ at most one other element that is less than it,\n    // that means the sum of\
    \ all the elements in the vector must be less than or equal to the maximum possible\
    \ weight.\n    let mut sum = 0;\n    for i in 0..q.len() {\n        sum += q[i];\n\
    \        if sum < w {\n            // It is not balanced.\n            return\
    \ false;\n        }\n    }\n    // The vector is balanced.\n    true\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmprb4dgai2.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        return true;\n    }\n    let mut found = false;\n\
    \    for &i in &q {\n        let mut max = 0;\n        for &j in &q {\n      \
    \      if i == j {\n                continue;\n            }\n            if max\
    \ < i {\n                max = i;\n            }\n        }\n        if max >\
    \ w {\n            return false;\n        }\n    }\n    found = true;\n    false\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpuvnk2yd7.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Write your solution here\n    \n    let mut x = q.iter().cloned().collect::<Vec<isize>>();\n\
    \    let mut y = x.reverse().collect::<Vec<isize>>();\n    let mut sum = 0;\n\
    \    for &i in x {\n        sum += i;\n    }\n    if sum == w {\n        if x\
    \ == y {\n            return true;\n        } else {\n            return false;\n\
    \        }\n    } else {\n        return false;\n    }\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmp_tzywj_n.rs:20:29\n\
    \   |\n20 |     let mut y = x.reverse().collect::<Vec<isize>>();\n   |       \
    \                      ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_tzywj_n.rs:22:9\n   |\n22 |     for &i in x {\n   |         ^^    -\
    \ this expression has type `Option<isize>`\n   |         |\n   |         expected\
    \ `isize`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `i`\n   |\n   = note:   expected type `isize`\n           found reference\
    \ `&_`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w.is_even() {\n        q.len() == 0 || will_it_fly(q, w / 2)\n   \
    \ } else {\n        q.len() == 0 || will_it_fly(q.clone(), w)\n    }\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_even` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpi0qig0oi.rs:17:10\n   |\n17 |     if w.is_even() {\n  \
    \ |          ^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut min_weight = q.iter().min().unwrap();\n    let mut max_weight\
    \ = q.iter().max().unwrap();\n\n    while let Some(w) = max_weight {\n       \
    \ if *w == min_weight {\n            min_weight -= *w;\n            break;\n \
    \       }\n\n        if w > min_weight {\n            max_weight -= w;\n     \
    \   } else {\n            min_weight -= w;\n        }\n    }\n\n    max_weight\
    \ <= w && q.iter().sum() <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpt8jpwwut.rs:20:15\n   |\n\
    20 |     while let Some(w) = max_weight {\n   |               ^^^^^^^   ----------\
    \ this expression has type `&isize`\n   |               |\n   |              \
    \ expected `isize`, found enum `Option`\n   |\n   = note: expected type `isize`\n\
    \              found enum `Option<_>`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `&isize`\n  --> /tmp/tmpt8jpwwut.rs:22:13\n \
    \  |\n22 |             min_weight -= *w;\n   |             ----------^^^^^^\n\
    \   |             |\n   |             cannot use `-=` on type `&isize`\n   |\n\
    help: `-=` can be used on `isize`, you can dereference `min_weight`\n   |\n22\
    \ |             *min_weight -= *w;\n   |             +\n\nerror[E0277]: can't\
    \ compare `isize` with `&isize`\n  --> /tmp/tmpt8jpwwut.rs:21:15\n   |\n21 | \
    \        if *w == min_weight {\n   |               ^^ no implementation for `isize\
    \ == &isize`\n   |\n   = help: the trait `PartialEq<&isize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0368]: binary assignment operation `-=` cannot be\
    \ applied to type `&isize`\n  --> /tmp/tmpt8jpwwut.rs:27:13\n   |\n27 |      \
    \       max_weight -= w;\n   |             ----------^^^^^\n   |             |\n\
    \   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=` can be used\
    \ on `isize`, you can dereference `max_weight`\n   |\n27 |             *max_weight\
    \ -= w;\n   |             +\n\nerror[E0368]: binary assignment operation `-=`\
    \ cannot be applied to type `&isize`\n  --> /tmp/tmpt8jpwwut.rs:29:13\n   |\n\
    29 |             min_weight -= w;\n   |             ----------^^^^^\n   |    \
    \         |\n   |             cannot use `-=` on type `&isize`\n   |\nhelp: `-=`\
    \ can be used on `isize`, you can dereference `min_weight`\n   |\n29 |       \
    \      *min_weight -= w;\n   |             +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpt8j"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q2 = q.clone();\n    let mut max_weight = 0;\n    let mut max_weight_count\
    \ = 0;\n    for i in q2.iter().rev() {\n        let mut count = 0;\n        for\
    \ j in q {\n            if i == j {\n                count += 1;\n           \
    \ }\n        }\n        if count > max_weight_count {\n            max_weight_count\
    \ = count;\n            max_weight = i;\n        }\n    }\n    let mut reversed_q:\
    \ Vec<isize> = q.clone();\n    reversed_q.iter().rev();\n    if reversed_q[0]\
    \ == reversed_q[q.len() - 1] {\n        // The vector is palindromic\n       \
    \ let mut sum = 0;\n        for i in q.iter().rev() {\n            sum += i;\n\
    \        }\n        return sum <= w;\n    } else {\n        // The vector is unbalanced\n\
    \        return false;\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpr5xgizan.rs:23:18\n\
    \   |\n23 |             if i == j {\n   |                  ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpr5xgizan.rs:29:26\n   |\n18 |     let mut max_weight = 0;\n   |    \
    \                      - expected due to this value\n...\n29 |             max_weight\
    \ = i;\n   |                          ^ expected integer, found `&isize`\n   |\n\
    help: consider dereferencing the borrow\n   |\n29 |             max_weight = *i;\n\
    \   |                          +\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() <= 1 {\n        return false\n    }\n    match vec::reverse(q)\
    \ {\n        None => false,\n        Some(rev) => rev[0] + rev[1] < w,\n    }\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n\
    \  --> /tmp/tmpf1xg1ue9.rs:20:11\n   |\n20 |     match vec::reverse(q) {\n   |\
    \           ^^^ use of undeclared crate or module `vec`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.to_vec();\n    let mut sum = 0;\n    for i in q.iter() {\n\
    \        if i == q[q.len() - 1] {\n            sum += i;\n        } else if i\
    \ != q[q.len() - 1] {\n            sum += q[q.len() - 1] - i;\n        }\n   \
    \ }\n    if sum == w {\n        true\n    } else {\n        false\n    }\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpjer9o_ly.rs:20:14\n\
    \   |\n20 |         if i == q[q.len() - 1] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmpjer9o_ly.rs:22:21\n   |\n22 |         } else if\
    \ i != q[q.len() - 1] {\n   |                     ^^ no implementation for `&isize\
    \ == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let max_sum = w / 2;\n    let mut balanced = true;\n    let mut total_sum\
    \ = 0;\n    for v in q {\n        total_sum += v;\n        balanced &= (total_sum\
    \ - max_sum) < (max_sum / 2);\n    }\n    balanced && q == rev(rev(q));\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rev` in this scope\n  --> /tmp/tmpigs80_5h.rs:24:22\n\
    \   |\n24 |     balanced && q == rev(rev(q));\n   |                      ^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `rev` in this scope\n\
    \  --> /tmp/tmpigs80_5h.rs:24:26\n   |\n24 |     balanced && q == rev(rev(q));\n\
    \   |                          ^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpigs80_5h.rs:16:44\n   |\n16 | fn will_it_fly(q: Vec<isize>,\
    \ w: isize) -> bool {\n   |    -----------                             ^^^^ expected\
    \ `bool`, found `()`\n   |    |\n   |    implicitly returns `()` as its body has\
    \ no tail or `return` expression\n...\n24 |     balanced && q == rev(rev(q));\n\
    \   |                                 - help: remove this semicolon\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Find a starting index for comparison: if the first element of the\
    \ vector is equal to `w`, then it's \"less\" than the weight.\n    let mut first_idx\
    \ = 0;\n    while q.len() > 0 {\n        if *q.iter().next().unwrap() == w {\n\
    \            return false;\n        }\n        if *q.iter().next().unwrap() >\
    \ *w {\n            break;\n        }\n        first_idx++;\n    }\n    let mut\
    \ i = first_idx + 1;\n    let mut j = 0;\n    let mut k = 0;\n    let mut max_weight\
    \ = w;\n    let mut min_weight = -w;\n    let mut current_weight = 0;\n    //\
    \ Keep comparing elements until the sum of their weights is greater than `w`.\n\
    \    while i < q.len() {\n        j = 0;\n        while j < q.len() {\n      \
    \      k = i;\n            while k < q.len() {\n                if *k == w {\n\
    \                    break;\n                }\n                k = k + 1;\n \
    \           }\n            // If the current element and the sum of its weights\
    \ is less than or equal to `w`, then it's balanced.\n            if k == q.len()\
    \ {\n                current_weight = current_weight + w;\n                if\
    \ current_weight < w {\n                    // If the sum of all weights is less\
    \ than or equal to the max weight, then it's balanced.\n                    if\
    \ current_weight > max_weight {\n                        return true;\n      \
    \              }\n                    // If the sum of all weights is greater\
    \ than the min weight, then it's unbalanced.\n                    else if current_weight\
    \ < min_weight {\n                        return false;\n                    }\n\
    \                }\n                current_weight = 0;\n            }\n     \
    \       current_weight = current_weight + q.iter().next().unwrap();\n        \
    \    j = j + 1;\n        }\n        i = i + 1;\n    }\n    return false;\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmpbw5b9jcn.rs:26:18\n\
    \   |\n26 |         first_idx++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n26 |         { let tmp = first_idx;\
    \ first_idx += 1; tmp };\n   |         +++++++++++          ~~~~~~~~~~~~~~~~~~~~~~~\n\
    26 -         first_idx++;\n26 +         first_idx += 1;\n   | \n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpbw5b9jcn.rs:23:40\n   |\n\
    23 |         if *q.iter().next().unwrap() > *w {\n   |                       \
    \                 ^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n  -->\
    \ /tmp/tmpbw5b9jcn.rs:40:20\n   |\n40 |                 if *k == w {\n   |   \
    \                 ^^\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut max = 0;\n    for (i, _) in q.iter().enumerate()\
    \ {\n        sum += q[i];\n        max = max if q[i] > max { max = q[i] };\n \
    \   }\n    if sum >= w { return true; }\n    else if sum < w { return false; }\n\
    \    else { return max <= w; }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator,\
    \ found keyword `if`\n  --> /tmp/tmpt73dhod9.rs:21:19\n   |\n21 |         max\
    \ = max if q[i] > max { max = q[i] };\n   |                   ^^ expected one\
    \ of 8 possible tokens\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() <= 1 {\n        return true;\n    }\n\n    let mut max = q.clone();\n\
    \    max.reverse();\n    if max < vec![] {\n        // it's balanced\n       \
    \ return true;\n    }\n\n    // the sum of its elements is less than or equal\
    \ the maximum possible weight w\n    let max = w.abs();\n    for i in 0..q.len()\
    \ {\n        if max == 0 { break; }\n\n        if q[i] > max {\n            return\
    \ false;\n        }\n\n        max -= q[i];\n    }\n    true\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0384]: cannot assign twice to immutable variable `max`\n  --> /tmp/tmpwt1lr_a6.rs:37:9\n\
    \   |\n29 |     let max = w.abs();\n   |         ---\n   |         |\n   |   \
    \      first assignment to `max`\n   |         help: consider making this binding\
    \ mutable: `mut max`\n...\n37 |         max -= q[i];\n   |         ^^^^^^^^^^^\
    \ cannot assign twice to immutable variable\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0384`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() != w\n        || (q.iter().rev().zip(nth(q)).rev()\n     \
    \       .fold(true, |a, (_, e)| !a && (e > 0 || e == q.len() - 1))\n        ||\
    \ w < 0\n    ) return false;\n\n    let mut max: isize = 0;\n    for &e in q {\n\
    \        max = std::cmp::max(max, e);\n    }\n\n    let mut sum = 0;\n    for\
    \ &e in q {\n        sum += e;\n    }\n\n    return sum == max && sum < w;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `return`\n  --> /tmp/tmpcq19icta.rs:21:7\n\
    \   |\n17 |     if q.len() != w\n   |     -- this `if` expression has a condition,\
    \ but no block\n...\n21 |     ) return false;\n   |       ^^^^^^ expected `{`\n\
    \   |\nhelp: try placing this code inside a block\n   |\n21 |     ) { return false\
    \ };\n   |       +              +\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() < 2 {\n        return false;\n    }\n    let mut wsum = 0;\n\
    \    let mut wmax = 0;\n    for i in 0..q.len() {\n        wsum += q[i];\n   \
    \     if wsum > w {\n            return false;\n        }\n        if wsum >=\
    \ w {\n            wmax = wsum;\n        }\n    }\n    if wsum != w {\n      \
    \  return false;\n    }\n    if wmax < w {\n        return true;\n    }\n    let\
    \ mut is_palindromic = true;\n    for i1 in 0..q.len() {\n        let mut i2 =\
    \ i1;\n        while i2 >= 0 {\n            if q[i1] != q[i2] {\n            \
    \    is_palindromic = false;\n                break;\n            }\n        \
    \    i2 -= 1;\n        }\n        if !is_palindromic {\n            break;\n \
    \       }\n    }\n    return is_palindromic;\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpzssjuh4k.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 || w == 0 {\n        return false;\n    }\n    let mut\
    \ total = 0;\n    let mut max = 0;\n    for v in q.iter() {\n        if v > max\
    \ {\n            max = v;\n        }\n        total += v;\n    }\n    if w ==\
    \ max {\n        return true;\n    }\n    total >= w && total == w*max\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmps8hbfw6x.rs:23:16\n   |\n\
    23 |         if v > max {\n   |                ^^^\n   |                |\n  \
    \ |                expected `&isize`, found integer\n   |                help:\
    \ consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps8hbfw6x.rs:24:19\n\
    \   |\n21 |     let mut max = 0;\n   |                   - expected due to this\
    \ value\n...\n24 |             max = v;\n   |                   ^ expected integer,\
    \ found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |  \
    \           max = *v;\n   |                   +\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        false\n    } else {\n        let mut sum =\
    \ 0;\n        for i in q.iter() {\n            sum += i;\n        }\n        sum\
    \ == w\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmphkvlm7gm.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > max_num_weights {\n        return false;\n    }\n    let\
    \ mut total: isize = 0;\n    let mut sum = 0;\n    let mut sum_size = 0;\n   \
    \ for &num in q.iter() {\n        total += num;\n        sum += *num;\n      \
    \  sum_size += 1;\n    }\n\n    if total >= w {\n        // It's unbalanced.\n\
    \        return false;\n    }\n\n    if sum < w {\n        // It's not balanced.\n\
    \        return false;\n    }\n\n    if sum_size < w {\n        // It's balanced.\n\
    \        return true;\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `max_num_weights` in this scope\n  -->\
    \ /tmp/tmpjxgaplfp.rs:17:18\n   |\n17 |     if q.len() > max_num_weights {\n \
    \  |                  ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]:\
    \ type `isize` cannot be dereferenced\n  --> /tmp/tmpjxgaplfp.rs:25:16\n   |\n\
    25 |         sum += *num;\n   |                ^^^^\n\nerror[E0317]: `if` may\
    \ be missing an `else` clause\n  --> /tmp/tmpjxgaplfp.rs:39:5\n   |\n16 |   fn\
    \ will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |                       \
    \                       ---- expected `bool` because of this return type\n...\n\
    39 | /     if sum_size < w {\n40 | |         // It's balanced.\n41 | |       \
    \  return true;\n42 | |     }\n   | |_____^ expected `bool`, found `()`\n   |\n\
    \   = note: `if` expressions without `else` evaluate to `()`\n   = help: consider\
    \ adding an `else` block that evaluates to the expected type\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0317, E0425,\
    \ E0614.\nFor more information about an error, try `rustc --explain E0317`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    debug_assert!(q.is_palindrom());\n    if q.is_empty() {\n        true\n\
    \    } else if q.iter().sum::<usize>() >= w {\n        true\n    } else {\n  \
    \      false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrom` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp8ujdo8og.rs:17:21\n   |\n17 |     debug_assert!(q.is_palindrom());\n\
    \   |                     ^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror[E0277]:\
    \ the trait bound `usize: Sum<&isize>` is not satisfied\n    --> /tmp/tmp8ujdo8og.rs:20:24\n\
    \     |\n20   |     } else if q.iter().sum::<usize>() >= w {\n     |         \
    \               ^^^ the trait `Sum<&isize>` is not implemented for `usize`\n \
    \    |\n     = help: the following other types implement trait `Sum<A>`:\n   \
    \            <f32 as Sum<&'a f32>>\n               <f32 as Sum>\n            \
    \   <f64 as Sum<&'a f64>>\n               <f64 as Sum>\n               <i128 as\
    \ Sum<&'a i128>>\n               <i128 as Sum>\n               <i16 as Sum<&'a\
    \ i16>>\n               <i16 as Sum>\n             and 20 others\nnote: required\
    \ by a bound in `std::iter::Iterator::sum`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8ujdo8og.rs:20:42\n   |\n20 |     } else if q.iter().sum::<usize>()\
    \ >= w {\n   |                                          ^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n20 |     } else if q.iter().sum::<usize>()\
    \ >= w.try_into().unwrap() {\n   |                                           ++++++++++++++++++++\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // write your solution here\n    false\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpco0iaa2l.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = 0;\n    for el in q {\n        let x = el - w as isize;\n\
    \        if x > (max - w) {\n            max = x;\n        }\n    }\n    max <=\
    \ w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpi02piysu.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 1 || (q.len() == 2 && q.iter().sum::<isize>() == w) {\n\
    \        // There is only one element and it matches its weight, so it's balanced.\n\
    \        true\n    } else {\n        // Check that the vector is palindromic and\
    \ has more than or equal to its maximum possible weight.\n        // If it isn't\
    \ then it must fly because it's unbalanced.\n        let mut reversed = q.rev();\n\
    \        match will_it_fly(&reversed, w) {\n            false => true,\n     \
    \       true => false,\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpi1i7vnyk.rs:23:30\n\
    \    |\n23  |           let mut reversed = q.rev();\n    |                   \
    \             ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpi1i7vnyk.rs:24:27\n   |\n24 |         match\
    \ will_it_fly(&reversed, w) {\n   |                           ^^^^^^^^^ expected\
    \ struct `Vec`, found reference\n   |\n   = note: expected struct `Vec<isize>`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n24\
    \ -         match will_it_fly(&reversed, w) {\n24 +         match will_it_fly(reversed,\
    \ w) {\n   | \n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let max_possible = q.iter().map(|&x| x.abs()).max();\n    let sum_of_weights\
    \ = q.iter().map(|&x| x).sum();\n    sum_of_weights == max_possible && q.is_palindrome()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_palindrome` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpdjth4sxt.rs:19:41\n   |\n19 |     sum_of_weights\
    \ == max_possible && q.is_palindrome()\n   |                                 \
    \        ^^^^^^^^^^^^^ method not found in `Vec<isize>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 || w == 0 {\n        return true\n    }\n    if q.len()\
    \ == 1 {\n        return false\n    }\n    let mut max = w;\n    let mut sum =\
    \ 0;\n    let mut last_value = q.iter().last().unwrap();\n    let mut counter\
    \ = 0;\n    let mut max_counter = 0;\n    let mut max_value = q.iter().last().unwrap();\n\
    \    match &q[q.len() - 1] {\n        0 => true,\n        _ => {\n           \
    \ max = q.iter().last().unwrap();\n        }\n    }\n    q.iter().rev().for_each(|el|\
    \ {\n        let v = el;\n        sum += v;\n        if max >= v {\n         \
    \   max_counter = counter;\n            max_value = v;\n        }\n        counter\
    \ += 1;\n    })\n    if max != w {\n        // the vector is not balanced.\n \
    \       return false\n    }\n    sum == max && max_value == last_value && max_counter\
    \ >= w / 2 && max_counter <= max\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found keyword `if`\n  --> /tmp/tmpyi6b1gx0.rs:43:7\n\
    \   |\n43 |     })\n   |       ^ help: add `;` here\n44 |     if max != w {\n\
    \   |     -- unexpected token\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyi6b1gx0.rs:32:19\n\
    \   |\n23 |     let mut max = w;\n   |                   - expected due to this\
    \ value\n...\n32 |             max = q.iter().last().unwrap();\n   |         \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^ expected `isize`, found `&isize`\n   |\nhelp:\
    \ consider dereferencing the borrow\n   |\n32 |             max = *q.iter().last().unwrap();\n\
    \   |                   +\n\nerror[E0308]: `match` arms have incompatible types\n\
    \  --> /tmp/tmpyi6b1gx0.rs:32:13\n   |\n29 | /     match &q[q.len() - 1] {\n30\
    \ | |         0 => true,\n   | |              ---- this is found to be of type\
    \ `bool`\n31 | |         _ => {\n32 | |             max = q.iter().last().unwrap();\n\
    \   | |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `()`\n\
    33 | |         }\n34 | |     }\n   | |_____- `match` arms have incompatible types\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpyi6b1gx0.rs:38:19\n   |\n38 |\
    \         if max >= v {\n   |                   ^ expected `isize`, found `&isize`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n38 |         if max >= *v\
    \ {\n   |                   +\n\nerror: aborting due to 4 previous errors\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.is_balanced() && (q.iter().sum() <= w)\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_balanced` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpcv7pki2o.rs:17:7\n   |\n17 |     q.is_balanced()\
    \ && (q.iter().sum() <= w)\n   |       ^^^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = w.clone();\n    q.sort();\n    if q.len() > max {\n   \
    \     return false;\n    }\n    let mut sum = 0;\n    for &elt in &q {\n     \
    \   sum += elt;\n    }\n    sum >= max\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa52n4xyn.rs:19:18\n   |\n\
    19 |     if q.len() > max {\n   |                  ^^^ expected `usize`, found\
    \ `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic if the\
    \ converted value doesn't fit\n   |\n19 |     if q.len() > max.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q\n        .iter()\n        .rev()\n        .pop_if(balanced_palindrome)\n\
    \        .len() <= w\n        && q.iter().sum() <= w\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `balanced_palindrome` in this scope\n \
    \ --> /tmp/tmpljfan5b6.rs:20:17\n   |\n20 |         .pop_if(balanced_palindrome)\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `pop_if` found for struct `Rev` in the current scope\n  -->\
    \ /tmp/tmpljfan5b6.rs:20:10\n   |\n20 |         .pop_if(balanced_palindrome)\n\
    \   |          ^^^^^^ method not found in `Rev<std::slice::Iter<'_, isize>>`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut max_weight = 0;\n    for v in\
    \ q.iter() {\n        let v = *v;\n        balanced = v % 2 == 0;\n        max_weight\
    \ = if balanced {\n            max_weight + v;\n        } else {\n           \
    \ max_weight - v;\n        };\n    }\n    match max_weight <= w {\n        true\
    \ => true,\n        false => false,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7g499hxq.rs:22:34\n   |\n\
    22 |           max_weight = if balanced {\n   |  __________________________________^\n\
    23 | |             max_weight + v;\n   | |                           - help: remove\
    \ this semicolon\n24 | |         } else {\n   | |_________^ expected integer,\
    \ found `()`\n   |\n   = note:   expected type `isize`\n           found unit\
    \ type `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7g499hxq.rs:24:16\n\
    \   |\n24 |           } else {\n   |  ________________^\n25 | |             max_weight\
    \ - v;\n   | |                           - help: remove this semicolon\n26 | |\
    \         };\n   | |_________^ expected `isize`, found `()`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s = q.iter().cloned().collect::<Vec<_>>();\n    let mut max_s\
    \ = w.to_isize();\n    match s.len() {\n        0 => true,\n        1 => true,\n\
    \        _ => {\n            let mut is_balanced = false;\n            for i in\
    \ 0..s.len() {\n                if s[i] == s[s.len() - 1 - i] {\n            \
    \        is_balanced = true;\n                    break;\n                }\n\
    \            }\n            if is_balanced {\n                max_s = max_s.checked_add(s.iter().cloned().sum::<isize>()).unwrap();\n\
    \            }\n        }\n    }\n    max_s < w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_isize` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp21n2vtvu.rs:18:23\n   |\n18 |     let mut max_s\
    \ = w.to_isize();\n   |                       ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut max = 0;\n    for i in q {\n        sum\
    \ += i;\n        if sum > max {\n            max = sum;\n        }\n    }\n  \
    \  if !q.is_balanced().unwrap() && sum < w {\n        true\n    } else {\n   \
    \     false\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_balanced` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpfdcid63s.rs:25:11\n   |\n25 |     if !q.is_balanced().unwrap()\
    \ && sum < w {\n   |           ^^^^^^^^^^^ method not found in `Vec<isize>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // Base case.\n    if q.len() == 0 {\n        return true;\n    }\n\n\
    \    // Base case.\n    if q.len() == 1 {\n        if q[0] % 2 != 0 {\n      \
    \      return true;\n        }\n        if q[0] < w {\n            return false;\n\
    \        }\n    }\n\n    // If the first element of the list is a palindrome,\n\
    \    // then we know that the list will fly.\n    if !will_it_fly(q.to_vec().rev(),\
    \ w) {\n        return false;\n    }\n\n    let mut reversed = q.to_vec().rev();\n\
    \    let mut sum: isize = 0;\n    let mut min_sum = w as isize;\n    let mut index\
    \ = 0;\n    while index < reversed.len() {\n        sum += reversed[index];\n\
    \        if sum < min_sum {\n            min_sum = sum;\n        }\n        index\
    \ += 1;\n    }\n\n    // If the minimum sum is equal to the weight w\n    // then\
    \ we know that the list will fly.\n    if min_sum == w {\n        return true;\n\
    \    }\n\n    // If the minimum sum is greater than the weight w,\n    // then\
    \ we know that the list won't fly.\n    if min_sum > w {\n        return false;\n\
    \    }\n\n    // Recursively check the tail.\n    return will_it_fly(reversed,\
    \ min_sum);\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp1bg78xgs.rs:34:32\n\
    \    |\n34  |       if !will_it_fly(q.to_vec().rev(), w) {\n    |            \
    \                      ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror[E0599]:\
    \ `Vec<isize>` is not an iterator\n   --> /tmp/tmp1bg78xgs.rs:38:35\n    |\n38\
    \  |       let mut reversed = q.to_vec().rev();\n    |                       \
    \              ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return true;\n    }\n    if q.len() == 1 {\n\
    \        return false;\n    }\n    let mut p = 0;\n    let mut n = 0;\n    for\
    \ i in 0..q.len() {\n        if q[i] != i {\n            return false;\n     \
    \   }\n    }\n    let mut i = 0;\n    let mut s = q.len();\n    while s < w {\n\
    \        if p == 0 && n == 0 {\n            i += 1;\n            p += 1;\n   \
    \     }\n        if q[i] == i {\n            n += 1;\n            i += 1;\n  \
    \          p += 1;\n        }\n        if n != 0 {\n            return false;\n\
    \        }\n        if p != 0 {\n            return false;\n        }\n    }\n\
    \    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphvvuvi3o.rs:26:20\n   |\n\
    26 |         if q[i] != i {\n   |                    ^ expected `isize`, found\
    \ `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic if the\
    \ converted value doesn't fit\n   |\n26 |         if q[i] != i.try_into().unwrap()\
    \ {\n   |                     ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphvvuvi3o.rs:32:15\n   |\n32 |     while s < w {\n   | \
    \              ^ expected `usize`, found `isize`\n   |\nhelp: you can convert\
    \ an `isize` to a `usize` and panic if the converted value doesn't fit\n   |\n\
    32 |     while s < w.try_into().unwrap() {\n   |                ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphvvuvi3o.rs:37:20\n   |\n37 |\
    \         if q[i] == i {\n   |                    ^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n37 |         if q[i] == i.try_into().unwrap() {\n \
    \  |                     ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    match (q, w) {\n        (vec![0], _) => true,\n        (vec![], _) =>\
    \ true,\n        (vec![isize], _) => true,\n        (vec![isize; 1], 0) => true,\n\
    \        (vec![isize; 1], 1) => true,\n        (vec![isize; 2], 0) => true,\n\
    \        (vec![isize; 2], 1) => true,\n        (vec![isize; 3], 0) => true,\n\
    \        (vec![isize; 3], 1) => true,\n        (vec![isize; 4], 0) => true,\n\
    \        (vec![isize; 4], 1) => true,\n        (vec![isize; 5], 0) => true,\n\
    \        (vec![isize; 5], 1) => true,\n        (vec![isize; 6], 0) => true,\n\
    \        (vec![isize; 6], 1) => true,\n        (vec![isize; 7], 0) => true,\n\
    \        (vec![isize; 7], 1) => true,\n        (vec![isize; 8], 0) => true,\n\
    \        (vec![isize; 8], 1) => true,\n        (vec![isize; 9], 0) => true,\n\
    \        (vec![isize; 9], 1) => true,\n        (vec![1isize; 9], 0) => true,\n\
    \        (vec![1isize; 9], 1) => true,\n        (vec![1isize; 10], 0) => true,\n\
    \        (vec![1isize; 10], 1) => true,\n        (vec![1isize; 11], 0) => true,\n\
    \        (vec![1isize; 11], 1) => true,\n        (vec![1isize; 12], 0) => true,\n\
    \        (vec![1isize; 12], 1) => true,\n        (vec![1isize; 13], 0) => true,\n\
    \        (vec![1isize; 13], 1) => true,\n        (vec![1isize; 14], 0) => true,\n\
    \        (vec![1isize; 14], 1) => true,\n        (vec![1isize; 15], 0) => true,\n\
    \        (vec![1isize; 15], 1) => true,\n        (vec![1isize; 16], 0) => true,\n\
    \        (vec![1isize; 16], 1) => true,\n        (vec![1isize; 17], 0) => true,\n\
    \        (vec![1isize; 17], 1) => true,\n        (vec![1isize; 18], 0) => true,\n\
    \        (vec![1isize; 18], 1) => true,\n        (vec![1isize; 19], 0) => true,\n\
    \n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpihq9n5o4.rs:71:3\n\
    \   |\n16 | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n   |          \
    \                                       - unclosed delimiter\n17 |     match (q,\
    \ w) {\n   |                  - this delimiter might not be properly closed...\n\
    ...\n61 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    71 | }\n   |   ^\n\nerror[E0423]: expected value, found builtin type `isize`\n\
    \  --> /tmp/tmpihq9n5o4.rs:20:15\n   |\n20 |         (vec![isize], _) => true,\n\
    \   |               ^^^^^ not a value\n\nerror[E0423]: expected value, found builtin\
    \ type `isize`\n  --> /tmp/tmpihq9n5o4.rs:21:15\n   |\n21 |         (vec![isize;\
    \ 1], 0) => true,\n   |               ^^^^^ not a value\n\nerror[E0423]: expected\
    \ value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:22:15\n   |\n22\
    \ |         (vec![isize; 1], 1) => true,\n   |               ^^^^^ not a value\n\
    \nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:23:15\n\
    \   |\n23 |         (vec![isize; 2], 0) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:24:15\n\
    \   |\n24 |         (vec![isize; 2], 1) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:25:15\n\
    \   |\n25 |         (vec![isize; 3], 0) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:26:15\n\
    \   |\n26 |         (vec![isize; 3], 1) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:27:15\n\
    \   |\n27 |         (vec![isize; 4], 0) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:28:15\n\
    \   |\n28 |         (vec![isize; 4], 1) => true,\n   |               ^^^^^ not\
    \ a value\n\nerror[E0423]: expected value, found builtin type `isize`\n  --> /tmp/tmpihq9n5o4.rs:"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut w: isize = w;\n    let mut sum = 0;\n    let mut max_weight =\
    \ q.len() * w / 2;\n    for i in q.rtem().rev() {\n        sum += *i;\n      \
    \  max_weight = std::cmp::max(max_weight, sum);\n    }\n    sum == max_weight\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxvdyt7b1.rs:19:36\n   |\n\
    19 |     let mut max_weight = q.len() * w / 2;\n   |                         \
    \           ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply\
    \ `usize` by `isize`\n  --> /tmp/tmpxvdyt7b1.rs:19:34\n   |\n19 |     let mut\
    \ max_weight = q.len() * w / 2;\n   |                                  ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0599]: no method named `rtem` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmpxvdyt7b1.rs:20:16\n   |\n20 |     for i\
    \ in q.rtem().rev() {\n   |                ^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum_weight = 0isize;\n    q.iter().fold(false, |acc, v| {\n \
    \       if acc {\n            sum_weight += v;\n            true\n        } else\
    \ {\n            sum_weight += w;\n            !acc\n        }\n    });\n    sum_weight\
    \ <= w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp38c2zwaw.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut n = q.len();\n    if n < w {\n        return false;\n    }\n\
    \    let mut x = q[n - 1] as isize;\n    let mut y = q[0] as isize;\n    for &y\
    \ in q[1..] {\n        if x != y {\n            return false;\n        }\n   \
    \     x -= y;\n    }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbk4kjgkk.rs:18:12\n   |\n\
    18 |     if n < w {\n   |            ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n18 |     if n < w.try_into().unwrap() {\n   |           \
    \  ++++++++++++++++++++\n\nerror[E0277]: the size for values of type `[isize]`\
    \ cannot be known at compilation time\n  --> /tmp/tmpbk4kjgkk.rs:23:15\n   |\n\
    23 |     for &y in q[1..] {\n   |               ^^^^^^ expected an implementor\
    \ of trait `IntoIterator`\n   |\n   = note: the trait bound `[isize]: IntoIterator`\
    \ is not satisfied\n   = note: required because of the requirements on the impl\
    \ of `IntoIterator` for `[isize]`\nhelp: consider borrowing here\n   |\n23 | \
    \    for &y in &q[1..] {\n   |               +\n23 |     for &y in &mut q[1..]\
    \ {\n   |               ++++\n\nerror[E0277]: `[isize]` is not an iterator\n \
    \ --> /tmp/tmpbk4kjgkk.rs:23:15\n   |\n23 |     for &y in q[1..] {\n   |     \
    \          ^^^^^^ expected an implementor of trait `IntoIterator`\n   |\n   =\
    \ note: the trait bound `[isize]: IntoIterator` is not satisfied\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `[isize]`\nhelp:\
    \ consider borrowing here\n   |\n23 |     for &y in &q[1..] {\n   |          \
    \     +\n23 |     for &y in &mut q[1..] {\n   |               ++++\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balancing_sum = 0;\n    let mut max_weight_sum = 0;\n    for\
    \ i in q.iter() {\n        balancing_sum += i;\n        max_weight_sum += w;\n\
    \    }\n\n    balancing_sum < max_weight_sum\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp0_akqqga.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.is_balanced() && q.iter().sum() <= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_balanced` found for struct `Vec<isize>`\
    \ in the current scope\n  --> /tmp/tmp6gmfi75g.rs:17:7\n   |\n17 |     q.is_balanced()\
    \ && q.iter().sum() <= w\n   |       ^^^^^^^^^^^ method not found in `Vec<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // If w is zero, it's a palindromic vector and we don't need to check\
    \ it because it doesn't have a negative weight.\n    if w == 0 {\n        return\
    \ true;\n    }\n\n    let mut p = 0;\n    for i in q.iter().rev() {\n        if\
    \ *i != i {\n            p++;\n        } else {\n            p = 0;\n        }\n\
    \    }\n    if p == w {\n        return true;\n    }\n    if p > w {\n       \
    \ return false;\n    }\n    // Otherwise, we have to check whether q is a palindromic\
    \ vector.\n    for i in q.iter() {\n        // If the current weight of q is not\
    \ equal to the weight, i, that means that the vector q is\n        // not palindromic.\n\
    \        if i != *i {\n            return false;\n        }\n    }\n    return\
    \ true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp0yyjagz7.rs:25:14\n\
    \   |\n25 |             p++;\n   |              ^^ not a valid postfix operator\n\
    \   |\nhelp: use `+= 1` instead\n   |\n25 |             { let tmp = p; p += 1;\
    \ tmp };\n   |             +++++++++++  ~~~~~~~~~~~~~~~\n25 -             p++;\n\
    25 +             p += 1;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0yyjagz7.rs:24:18\n\
    \   |\n24 |         if *i != i {\n   |                  ^ expected `isize`, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n24 |        \
    \ if *i != *i {\n   |                  +\n\nerror[E0277]: can't compare `&isize`\
    \ with `isize`\n  --> /tmp/tmp0yyjagz7.rs:40:14\n   |\n40 |         if i != *i\
    \ {\n   |              ^^ no implementation for `&isize == isize`\n   |\n   =\
    \ help: the trait `PartialEq<isize>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `PartialEq<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut i = q.len() - 1;\n    let mut j = q.len() - 1;\n    loop {\n\
    \        if q[i] < 0 || q[j] < 0 {\n            return false;\n        }\n   \
    \     while i >= 0 && j >= 0 {\n            if q[i] > q[j] {\n               \
    \ j -= 1;\n            }\n            else if q[i] < q[j] {\n                i\
    \ -= 1;\n            }\n            else {\n                i -= 1;\n        \
    \        j -= 1;\n            }\n        }\n        if i < 0 {\n            return\
    \ true;\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpgypo6zcg.rs:31:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut ans = false;\n    for e in q {\n        if e > w {\n        \
    \    break;\n        }\n        if e == w {\n            ans = true;\n       \
    \ } else {\n            if e == q[q.len() - 1] {\n                ans = true;\n\
    \            }\n        }\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpfm_33q89.rs:25:21\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n17  |     let mut ans = false;\n18  |     for e in q {\n \
    \   |              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    25  |             if e == q[q.len() - 1] {\n    |                     ^ value\
    \ borrowed here after move\n    |\nnote: this function takes ownership of the\
    \ receiver `self`, which moves `q`\nhelp: consider iterating over a slice of the\
    \ `Vec<isize>`'s content to avoid moving into the `for` loop\n    |\n18  |   \
    \  for e in &q {\n    |              +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.len() == 0 || q == &[w]\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpozqa8dw9.rs:22:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut max = w.to_owned();\n    for e\
    \ in q {\n        if e > max {\n            balanced = true;\n            break;\n\
    \        }\n        max -= e;\n    }\n    balanced && sum::<isize>(&q) <= max\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `sum` in this scope\n  --> /tmp/tmpanvq6kks.rs:26:17\n\
    \   |\n26 |     balanced && sum::<isize>(&q) <= max\n   |                 ^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut balanced = false;\n    for (i, &v) in q.iter().enumerate()\
    \ {\n        let mut j = i;\n        let mut vv = v;\n        while j != 0 {\n\
    \            let t = vv;\n            vv = q[j - 1];\n            q[j - 1] = t;\n\
    \            j = j - 1;\n        }\n        if v > sum {\n            sum = v;\n\
    \        }\n        if sum == w {\n            balanced = true;\n            break;\n\
    \        }\n    }\n    balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmpsg2ad4w_.rs:25:13\n   |\n16 | fn will_it_fly(q: Vec<isize>, w:\
    \ isize) -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n25 |             q[j - 1] = t;\n   |             ^ cannot borrow\
    \ as mutable\n\nerror[E0502]: cannot borrow `q` as mutable because it is also\
    \ borrowed as immutable\n  --> /tmp/tmpsg2ad4w_.rs:25:13\n   |\n19 |     for (i,\
    \ &v) in q.iter().enumerate() {\n   |                    --------------------\n\
    \   |                    |\n   |                    immutable borrow occurs here\n\
    \   |                    immutable borrow later used here\n...\n25 |         \
    \    q[j - 1] = t;\n   |             ^ mutable borrow occurs here\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0502, E0596.\n\
    For more information about an error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    match w.cmp(&q.len()) {\n        Ordering::Less => true,\n        Ordering::Greater\
    \ => false,\n        _ => false,\n    }\n}\n\nfn main() {\n    let candidate =\
    \ will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Ordering`\n  -->\
    \ /tmp/tmpax78rk4e.rs:18:9\n   |\n18 |         Ordering::Less => true,\n   | \
    \        ^^^^^^^^ use of undeclared type `Ordering`\n\nerror[E0433]: failed to\
    \ resolve: use of undeclared type `Ordering`\n  --> /tmp/tmpax78rk4e.rs:19:9\n\
    \   |\n19 |         Ordering::Greater => false,\n   |         ^^^^^^^^ use of\
    \ undeclared type `Ordering`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpax78rk4e.rs:17:17\n\
    \   |\n17 |     match w.cmp(&q.len()) {\n   |                 ^^^^^^^^ expected\
    \ `isize`, found `usize`\n   |\n   = note: expected reference `&isize`\n     \
    \         found reference `&usize`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max_possible: isize = 0;\n    for i in q.iter().rev() {\n   \
    \     max_possible += i;\n    }\n    if max_possible > w {\n        // It doesn't\
    \ fly.\n        return false;\n    }\n    let mut sum = 0;\n    for i in q.iter()\
    \ {\n        sum += i;\n        if sum > w {\n            // It doesn't fly.\n\
    \            return false;\n        }\n    }\n    true\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpc7jfpi9p.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn palindrome(q: Vec<isize>) -> bool {\n        let mut rev: Vec<isize>\
    \ = q;\n        rev.iter().rev().for_each(|x| *x = x.clone());\n        rev ==\
    \ q\n    }\n\n    fn is_balanced(q: Vec<isize>) -> bool {\n        let mut sum\
    \ = 0;\n        for &x in q {\n            sum += x;\n        }\n        sum ==\
    \ w\n    }\n\n    fn max_possible(q: Vec<isize>, mut f: &mut FenwickTree<isize>)\
    \ -> isize {\n        let mut max_possible = w;\n\n        for &x in q {\n   \
    \         let mut f = f.clone();\n            f.add_and_get(x - 1);\n        \
    \    if f.is_empty() {\n                return max_possible;\n            }\n\
    \            max_possible = std::cmp::min(max_possible, f.get_value());\n    \
    \    }\n\n        max_possible\n    }\n\n    if q.len() == 1 {\n        false\n\
    \    } else if q.len() == 0 {\n        true\n    } else if palindrome(q) {\n \
    \       false\n    } else if is_balanced(q) {\n        false\n    } else {\n \
    \       let mut f = FenwickTree::<isize>::new();\n        f.add_and_get(q.len()\
    \ - 1);\n        let mut max_possible = max_possible(q, &mut f);\n        if f.is_empty()\
    \ {\n            true\n        } else {\n            f.sub_and_get(max_possible\
    \ - q.len());\n            if f.is_empty() {\n                false\n        \
    \    } else {\n                max_possible = max_possible - f.get_value()\n \
    \           }\n        }\n    }\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0434]: can't capture dynamic environment in a fn item\n  --> /tmp/tmpowzb7dpx.rs:28:16\n\
    \   |\n28 |         sum == w\n   |                ^\n   |\n   = help: use the\
    \ `|| { ... }` closure form instead\n\nerror[E0434]: can't capture dynamic environment\
    \ in a fn item\n  --> /tmp/tmpowzb7dpx.rs:32:32\n   |\n32 |         let mut max_possible\
    \ = w;\n   |                                ^\n   |\n   = help: use the `|| {\
    \ ... }` closure form instead\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `FenwickTree`\n  --> /tmp/tmpowzb7dpx.rs:55:21\n   |\n55 |         let\
    \ mut f = FenwickTree::<isize>::new();\n   |                     ^^^^^^^^^^^ use\
    \ of undeclared type `FenwickTree`\n\nerror[E0412]: cannot find type `FenwickTree`\
    \ in this scope\n  --> /tmp/tmpowzb7dpx.rs:31:48\n   |\n31 |     fn max_possible(q:\
    \ Vec<isize>, mut f: &mut FenwickTree<isize>) -> isize {\n   |               \
    \                                 ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpowzb7dpx.rs:61:42\n   |\n61 |             f.sub_and_get(max_possible\
    \ - q.len());\n   |                                          ^^^^^^^ expected\
    \ `isize`, found `usize`\n\nerror[E0277]: cannot subtract `usize` from `isize`\n\
    \  --> /tmp/tmpowzb7dpx.rs:61:40\n   |\n61 |             f.sub_and_get(max_possible\
    \ - q.len());\n   |                                        ^ no implementation\
    \ for `isize - usize`\n   |\n   = help: the trait `Sub<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Sub<Rhs>`:\n\
    \             <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n    \
    \         <&'a i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n      \
    \       <&'a i32 as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n          \
    \   <&'a i8 as Sub<i8>>\n             <&'a isize as Sub<isize>>\n           and\
    \ 48 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpowzb7dpx.rs:65:17\n\
    \   |\n65 |                 max_possible = max_possible - f.get_value()\n   |\
    \                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`,\
    \ found `()`"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    fn fly_q(q: Vec<isize>, w: isize) -> bool {\n        let mut s = 0.0;\n\
    \        let mut n = 0.0;\n        for v in q {\n            s += v;\n       \
    \     n += 1;\n        }\n        s <= w && n == q.len()\n    }\n    let max =\
    \ (q.len() * w).checked_div(2).unwrap();\n    fly_q(q.reverse(), max) || fly_q(q.clone(),\
    \ max)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8av116wp.rs:26:26\n   |\n\
    26 |     let max = (q.len() * w).checked_div(2).unwrap();\n   |              \
    \            ^ expected `usize`, found `isize`\n\nerror[E0277]: cannot multiply\
    \ `usize` by `isize`\n  --> /tmp/tmp8av116wp.rs:26:24\n   |\n26 |     let max\
    \ = (q.len() * w).checked_div(2).unwrap();\n   |                        ^ no implementation\
    \ for `usize * isize`\n   |\n   = help: the trait `Mul<isize>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Mul<Rhs>`:\n\
    \             <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n    \
    \         <&'a i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n      \
    \       <&'a i32 as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n          \
    \   <&'a i8 as Mul<i8>>\n             <&'a isize as Mul<isize>>\n           and\
    \ 49 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8av116wp.rs:27:11\n\
    \   |\n27 |     fly_q(q.reverse(), max) || fly_q(q.clone(), max)\n   |       \
    \    ^^^^^^^^^^^ expected struct `Vec`, found `()`\n   |\n   = note: expected\
    \ struct `Vec<isize>`\n           found unit type `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8av116wp.rs:27:24\n   |\n27 |     fly_q(q.reverse(), max)\
    \ || fly_q(q.clone(), max)\n   |                        ^^^ expected `isize`,\
    \ found `usize`\n   |\nhelp: you can convert a `usize` to an `isize` and panic\
    \ if the converted value doesn't fit\n   |\n27 |     fly_q(q.reverse(), max.try_into().unwrap())\
    \ || fly_q(q.clone(), max)\n   |                           ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8av116wp.rs:27:49\n   |\n27 |\
    \     fly_q(q.reverse(), max) || fly_q(q.clone(), max)\n   |                 \
    \                                ^^^ expected `isize`, found `usize`\n   |\nhelp:\
    \ you can convert a `usize` to an `isize` and panic if the converted value doesn't\
    \ fit\n   |\n27 |     fly_q(q.reverse(), max) || fly_q(q.clone(), max.try_into().unwrap())\n\
    \   |                                                    ++++++++++++++++++++\n\
    \nerror[E0277]: cannot add-assign `isize` t"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    match balance_palindrome(q) {\n        Ok(true) => true,\n        Ok(false)\
    \ => false,\n        Err(e) => {\n            println!(\"will_it_fly(vec!{}, {}):\
    \ {}\", q, w, e);\n            true\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `balance_palindrome` in this scope\n\
    \  --> /tmp/tmpbvkh9dgj.rs:17:11\n   |\n17 |     match balance_palindrome(q) {\n\
    \   |           ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: `Vec<isize>`\
    \ doesn't implement `std::fmt::Display`\n  --> /tmp/tmpbvkh9dgj.rs:21:53\n   |\n\
    21 |             println!(\"will_it_fly(vec!{}, {}): {}\", q, w, e);\n   |   \
    \                                                  ^ `Vec<isize>` cannot be formatted\
    \ with the default formatter\n   |\n   = help: the trait `std::fmt::Display` is\
    \ not implemented for `Vec<isize>`\n   = note: in format strings you may be able\
    \ to use `{:?}` (or {:#?} for pretty-print) instead\n   = note: this error originates\
    \ in the macro `$crate::format_args_nl` (in Nightly builds, run with -Z macro-backtrace\
    \ for more info)\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 || w == 0 {\n        return false;\n    }\n    if q.len()\
    \ == 1 {\n        return w == q[0]\n    }\n    if will_it_fly(q.rev(), w - q[0])\
    \ {\n        return true;\n    }\n    return will_it_fly(q, w - q[0]);\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmp6z5zv3w2.rs:23:22\n\
    \    |\n23  |       if will_it_fly(q.rev(), w - q[0]) {\n    |               \
    \         ^^^ `Vec<isize>` is not an iterator\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n     \
    \       which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = 0;\n    for i in q.iter() {\n        if *i > *max {\n \
    \           max = *i;\n        }\n    }\n    for i in q.iter() {\n        if *i\
    \ >= w {\n            return false;\n        }\n    }\n    let mut sum = 0;\n\
    \    for i in q.iter() {\n        sum += i;\n    }\n    return sum < w;\n}\n\n\
    fn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `{integer}` cannot be dereferenced\n  --> /tmp/tmpmgocza38.rs:19:17\n\
    \   |\n19 |         if *i > *max {\n   |                 ^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut a = q.iter().cloned().collect::<Vec<isize>>();\n    let mut b\
    \ = a.clone().into_iter().rev();\n    let mut c = w.to_owned();\n    let mut d\
    \ = c.clone();\n\n    // If q has zero elements, then we'll have to move one element\
    \ and compare it to w\n    if q.len() == 0 {\n        a.push(1);\n    }\n\n  \
    \  // Copy c into d, and decrement c until it reaches zero\n    while c.checked_sub(*d).is_some()\
    \ {\n        let j = if *d >= *c { *d - *c } else { 0 };\n        c.push(j);\n\
    \    }\n\n    // Since c is now decremented, we know that c is less than or equal\
    \ to w\n    c.iter().any(|&i| i < w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpc1uqiuzs.rs:28:25\n\
    \   |\n28 |     while c.checked_sub(*d).is_some() {\n   |                    \
    \     ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpc1uqiuzs.rs:29:20\n\
    \   |\n29 |         let j = if *d >= *c { *d - *c } else { 0 };\n   |        \
    \            ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpc1uqiuzs.rs:29:26\n\
    \   |\n29 |         let j = if *d >= *c { *d - *c } else { 0 };\n   |        \
    \                  ^^\n\nerror[E0614]: type `isize` cannot be dereferenced\n \
    \ --> /tmp/tmpc1uqiuzs.rs:29:31\n   |\n29 |         let j = if *d >= *c { *d -\
    \ *c } else { 0 };\n   |                               ^^\n\nerror[E0614]: type\
    \ `isize` cannot be dereferenced\n  --> /tmp/tmpc1uqiuzs.rs:29:36\n   |\n29 |\
    \         let j = if *d >= *c { *d - *c } else { 0 };\n   |                  \
    \                  ^^\n\nerror[E0599]: no method named `push` found for type `isize`\
    \ in the current scope\n  --> /tmp/tmpc1uqiuzs.rs:30:11\n   |\n30 |         c.push(j);\n\
    \   |           ^^^^ method not found in `isize`\n\nerror[E0599]: no method named\
    \ `iter` found for type `isize` in the current scope\n  --> /tmp/tmpc1uqiuzs.rs:34:7\n\
    \   |\n34 |     c.iter().any(|&i| i < w)\n   |       ^^^^ method not found in\
    \ `isize`\n\nerror: aborting due to 7 previous errors\n\nSome errors have detailed\
    \ explanations: E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut palindrome = false;\n    let mut weight = 0;\n    let mut max\
    \ = 0;\n    q.sort_unstable();\n    for i in q {\n        weight += i;\n     \
    \   if weight > max {\n            max = weight;\n        }\n    }\n    if max\
    \ > w {\n        palindrome = true;\n    }\n    let mut palindrome_balanced =\
    \ false;\n    q.sort_unstable();\n    for i in q {\n        weight += i;\n   \
    \     if weight >= w {\n            palindrome_balanced = true;\n            break;\n\
    \        }\n    }\n    palindrome_balanced && palindrome\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0596]: cannot borrow `q` as mutable, as it is not declared as mutable\n\
    \  --> /tmp/tmp6aefuljh.rs:20:5\n   |\n16 | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n   |                - help: consider changing this to be mutable:\
    \ `mut q`\n...\n20 |     q.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^ cannot\
    \ borrow as mutable\n\nerror[E0596]: cannot borrow `q` as mutable, as it is not\
    \ declared as mutable\n  --> /tmp/tmp6aefuljh.rs:31:5\n   |\n16 | fn will_it_fly(q:\
    \ Vec<isize>, w: isize) -> bool {\n   |                - help: consider changing\
    \ this to be mutable: `mut q`\n...\n31 |     q.sort_unstable();\n   |     ^^^^^^^^^^^^^^^^^\
    \ cannot borrow as mutable\n\nerror[E0382]: borrow of moved value: `q`\n   -->\
    \ /tmp/tmp6aefuljh.rs:31:5\n    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize)\
    \ -> bool {\n    |                - move occurs because `q` has type `Vec<isize>`,\
    \ which does not implement the `Copy` trait\n...\n21  |     for i in q {\n   \
    \ |              - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    31  |     q.sort_unstable();\n    |     ^^^^^^^^^^^^^^^^^ value borrowed here\
    \ after move\n    |\nnote: this function takes ownership of the receiver `self`,\
    \ which moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n21  |     for i in &q {\n\
    \    |              +\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0382, E0596.\nFor more information about an error,\
    \ try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut n = q.len();\n    let mut s = Vec::new();\n    \n    loop {\n\
    \        s.push(*q.iter().rev().next().unwrap());\n        \n        if n != q.len()\
    \ {\n            q.swap(n - 1, n);\n        }\n        \n        if n == 0 ||\
    \ s.last().unwrap() > w {\n            return false;\n        }\n        \n  \
    \      if s.last().unwrap() == w {\n            return true;\n        }\n    \
    \    \n        s.pop();\n        n -= 1;\n    }\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvtn75tny.rs:27:42\n   |\n\
    27 |         if n == 0 || s.last().unwrap() > w {\n   |                      \
    \                    ^\n   |                                          |\n   |\
    \                                          expected `&isize`, found `isize`\n\
    \   |                                          help: consider borrowing here:\
    \ `&w`\n\nerror[E0277]: can't compare `&isize` with `isize`\n  --> /tmp/tmpvtn75tny.rs:31:30\n\
    \   |\n31 |         if s.last().unwrap() == w {\n   |                        \
    \      ^^ no implementation for `&isize == isize`\n   |\n   = help: the trait\
    \ `PartialEq<isize>` is not implemented for `&isize`\n   = help: the following\
    \ other types implement trait `PartialEq<Rhs>`:\n             f32\n          \
    \   f64\n             i128\n             i16\n             i32\n             i64\n\
    \             i8\n             isize\n           and 6 others\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut qf = vec![false; q.len()];\n    qf.iter().for_each(|&b| {\n \
    \       qf[b] = true;\n    });\n    qf.iter().for_each(|&b| {\n        q = q.to_owned();\n\
    \        q[b] = false;\n    });\n    !(qf.iter().any(|&b| {\n        will_it_fly2(q,\
    \ w)\n    }))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly2` in this scope\n  -->\
    \ /tmp/tmp7vqfr22i.rs:26:9\n   |\n26 |         will_it_fly2(q, w)\n   |      \
    \   ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[bool]` cannot\
    \ be indexed by `bool`\n  --> /tmp/tmp7vqfr22i.rs:19:9\n   |\n19 |         qf[b]\
    \ = true;\n   |         ^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[bool]>` is not implemented for `bool`\n\
    \   = note: required because of the requirements on the impl of `Index<bool>`\
    \ for `Vec<bool>`\n\nerror[E0277]: the type `[isize]` cannot be indexed by `bool`\n\
    \  --> /tmp/tmp7vqfr22i.rs:23:9\n   |\n23 |         q[b] = false;\n   |      \
    \   ^^^^ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<[isize]>` is not implemented for `bool`\n   = note: required\
    \ because of the requirements on the impl of `Index<bool>` for `Vec<isize>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut wf = Vec::new();\n    let mut lf = Vec::new();\n    let mut bf\
    \ = Vec::new();\n    let mut wl = Vec::new();\n    let mut bl = Vec::new();\n\
    \    let mut bb = Vec::new();\n    for w in q.iter() {\n        wf.push(w);\n\
    \        if w == w {\n            bf.push(w);\n        } else {\n            bf.push(0);\n\
    \        }\n        if w == w {\n            bl\n                .iter_mut()\n\
    \                .enumerate()\n                .filter(|(_, v)| v != 0)\n    \
    \            .for_each(|(_, v)| {\n                    wl.push(w);\n         \
    \           bl.push(v);\n                });\n        } else {\n            bl\n\
    \                .iter_mut()\n                .enumerate()\n                .filter(|(_,\
    \ v)| v != 0)\n                .for_each(|(_, v)| {\n                    bl.push(0);\n\
    \                });\n        }\n        if w == w {\n            bb\n       \
    \         .iter_mut()\n                .enumerate()\n                .filter(|(_,\
    \ v)| v != 0)\n                .for_each(|(_, v)| {\n                    bb.push(v);\n\
    \                });\n        } else {\n            bb\n                .iter_mut()\n\
    \                .enumerate()\n                .filter(|(_, v)| v != 0)\n    \
    \            .for_each(|(_, v)| {\n                    bb.push(0);\n         \
    \       });\n        }\n    }\n\n    let mut min_sum = std::isize::MAX;\n    let\
    \ mut min_sum = std::isize::MAX;\n    let mut sum = 0;\n    for b in bf {\n  \
    \      for w in wf {\n            sum += w;\n            if sum > w {\n      \
    \          break;\n            }\n        }\n        if sum >= w {\n         \
    \   break;\n        }\n        sum += b;\n        if sum < w {\n            min_sum\
    \ = std::cmp::min(min_sum, sum);\n        }\n    }\n    for b in bl {\n      \
    \  for w in wl {\n            sum += w;\n            if sum > w {\n          \
    \      break;\n            }\n        }\n        if sum >= w {\n            break;\n\
    \        }\n        sum += b;\n        if sum < w {\n            min_sum = std::cmp::min(min_sum,\
    \ sum);\n        }\n    }\n    for b in bb {\n        for w in wf {\n        \
    \    sum += w;\n            if sum > w {\n                break;\n           \
    \ }\n        }\n        if sum >= w {\n            break;\n        }\n       \
    \ sum += b;\n        if sum < w {\n            min_sum = std::cmp::min(min_sum,\
    \ sum);\n\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmphfxbh_w6.rs:124:3\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \                                          - unclosed delimiter\n...\n100 |  \
    \   for b in bb {\n    |                 - unclosed delimiter\n...\n111 |    \
    \     if sum < w {\n    |                    - this delimiter might not be properly\
    \ closed...\n...\n114 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n124 | }\n    |   ^\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmphfxbh_w6.rs:28:21\n   |\n28 |             bf.push(0);\n   |        \
    \             ^\n   |                     |\n   |                     expected\
    \ `&isize`, found integer\n   |                     help: consider borrowing here:\
    \ `&0`\n\nerror[E0277]: can't compare `&&mut _` with `{integer}`\n  --> /tmp/tmphfxbh_w6.rs:34:36\n\
    \   |\n34 |                 .filter(|(_, v)| v != 0)\n   |                   \
    \                 ^^ no implementation for `&&mut _ == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&&mut _`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphfxbh_w6.rs:37:29\n   |\n37 |  \
    \                   bl.push(v);\n   |                             ^- help: try\
    \ using a conversion method: `.to_string()`\n   |                            \
    \ |\n   |                             cyclic type of infinite size\n\nerror[E0277]:\
    \ can't compare `&&mut _` with `{integer}`\n  --> /tmp/tmphfxbh_w6.rs:43:36\n\
    \   |\n43 |                 .filter(|(_, v)| v != 0)\n   |                   \
    \                 ^^ no implementation for `&&mut _ == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&&mut _`\n\n\
    error[E0277]: can't compare `&&mut _` with `{integer}`\n  --> /tmp/tmphfxbh_w6.rs:52:36\n\
    \   |\n52 |                 .filter(|(_, v)| v != 0)\n   |                   \
    \                 ^^ no implementation for `&&mut _ == {integer}`\n   |\n   =\
    \ help: the trait `PartialEq<{integer}>` is not implemented for `&&mut _`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmphfxbh_w6.rs:54:29\n   |"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let q = q.to_vec();\n    let mut sum = 0;\n    let mut max_sum = w;\n\
    \    for &v in q {\n        sum += v;\n        max_sum = std::cmp::max(sum, max_sum);\n\
    \    }\n\n    let mut i = 0;\n    for &v in q {\n        if *v > w {\n       \
    \     return false;\n        }\n\n        if sum < max_sum {\n            return\
    \ false;\n        }\n\n        i += 1;\n    }\n\n    *q == *q.iter().rev().take(i).rev().cloned()\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz5k_fjpx.rs:20:9\n   |\n\
    20 |     for &v in q {\n   |         ^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `isize`\n           found reference `&_`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpz5k_fjpx.rs:26:9\n   |\n26 |     for &v in q {\n   |         ^^\
    \    - this expression has type `Option<isize>`\n   |         |\n   |        \
    \ expected `isize`, found reference\n   |         help: you can probably remove\
    \ the explicit borrow: `v`\n   |\n   = note:   expected type `isize`\n       \
    \    found reference `&_`\n\nerror[E0614]: type `Cloned<Rev<std::iter::Take<Rev<std::slice::Iter<'_,\
    \ isize>>>>>` cannot be dereferenced\n  --> /tmp/tmpz5k_fjpx.rs:38:11\n   |\n\
    38 |     *q == *q.iter().rev().take(i).rev().cloned()\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut left = q.len() - 1;\n    let mut right = q.len() - 1;\n    let\
    \ mut sum = 0;\n    loop {\n        match q[left] {\n            0 => return sum\
    \ == w,\n            1 => sum += q[left],\n            2 => sum += q[left] * q[left],\n\
    \            _ => break,\n        }\n        if sum < w {\n            left--;\n\
    \        } else {\n            right++;\n        }\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpfvhb_xij.rs:28:19\n\
    \   |\n28 |             left--;\n   |                   ^ expected expression\n\
    \nerror: Rust has no postfix increment operator\n  --> /tmp/tmpfvhb_xij.rs:30:18\n\
    \   |\n30 |             right++;\n   |                  ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n30 |             { let tmp =\
    \ right; right += 1; tmp };\n   |             +++++++++++      ~~~~~~~~~~~~~~~~~~~\n\
    30 -             right++;\n30 +             right += 1;\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut f = false;\n    let mut s = q.len();\n    let mut max_weight\
    \ = w;\n    let mut max_sum = 0;\n    loop {\n        s += q.iter().sum();\n \
    \       if s >= max_weight {\n            max_sum = s;\n            break;\n \
    \       }\n        if max_sum == max_weight {\n            max_sum += q.iter().sum();\n\
    \            max_weight += 1;\n        }\n        f |= max_sum == w;\n    }\n\
    \    f\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxqvh5mg5.rs:23:17\n   |\n\
    23 |         if s >= max_weight {\n   |                 ^^^^^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n23 |         if s >= max_weight.try_into().unwrap()\
    \ {\n   |                           ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxqvh5mg5.rs:27:23\n   |\n27 |         if max_sum == max_weight\
    \ {\n   |                       ^^^^^^^^^^ expected `usize`, found `isize`\n \
    \  |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n27 |         if max_sum == max_weight.try_into().unwrap()\
    \ {\n   |                                 ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxqvh5mg5.rs:31:25\n   |\n31 |         f |= max_sum\
    \ == w;\n   |                         ^ expected `usize`, found `isize`\n   |\n\
    help: you can convert an `isize` to a `usize` and panic if the converted value\
    \ doesn't fit\n   |\n31 |         f |= max_sum == w.try_into().unwrap();\n   |\
    \                          ++++++++++++++++++++\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let n = q.len();\n    let mut sum = 0;\n    for i in 0..n {\n       \
    \ sum += q[i];\n    }\n    return n == 1 || sum == w || sum == w - q[n - 1];\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmp0sz6_fwb.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut sum = 0;\n    q.iter().for_each(|x|\
    \ {\n        sum = sum + x;\n    });\n    sum = sum % w;\n    (balanced && sum\
    \ >= w) || (!balanced && sum == w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpikr0bec0.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // The sum of its elements is less than or equal the maximum possible\
    \ weight.\n    q.iter().fold(true, |a, b| a && (b + a) <= w)\n}\n\nfn main() {\n\
    \    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `bool` to `&isize`\n  --> /tmp/tmp8c22exab.rs:18:40\n\
    \   |\n18 |     q.iter().fold(true, |a, b| a && (b + a) <= w)\n   |          \
    \                              ^ no implementation for `&isize + bool`\n   |\n\
    \   = help: the trait `Add<bool>` is not implemented for `&isize`\n   = help:\
    \ the following other types implement trait `Add<Rhs>`:\n             <&'a f32\
    \ as Add<f32>>\n             <&'a f64 as Add<f64>>\n             <&'a i128 as\
    \ Add<i128>>\n             <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n\
    \             <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n      \
    \       <&'a isize as Add<isize>>\n           and 48 others\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut balanced = false;\n    let mut sum_ = 0;\n\n    for e in q {\n\
    \        sum_ += e;\n        if sum_ > w {\n            balanced = true;\n   \
    \     }\n    }\n    balanced && q.iter().rev().all(|&x| x <= w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmpvp8196op.rs:26:17\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |     for e in q {\n    |              - `q` moved\
    \ due to this implicit call to `.into_iter()`\n...\n26  |     balanced && q.iter().rev().all(|&x|\
    \ x <= w)\n    |                 ^^^^^^^^ value borrowed here after move\n   \
    \ |\nnote: this function takes ownership of the receiver `self`, which moves `q`\n\
    \    = note: borrow occurs due to deref coercion to `[isize]`\nhelp: consider\
    \ iterating over a slice of the `Vec<isize>`'s content to avoid moving into the\
    \ `for` loop\n    |\n20  |     for e in &q {\n    |              +\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    // TODO: This should be done with bsearch or something faster.\n    q\n\
    \        .iter()\n        .zip(q.iter().rev())\n        .all(|(a, b)| (a == b)\
    \ || (a < w && b <= w))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzqre8b41.rs:21:40\n   |\n\
    21 |         .all(|(a, b)| (a == b) || (a < w && b <= w))\n   |              \
    \                          ^\n   |                                        |\n\
    \   |                                        expected `&isize`, found `isize`\n\
    \   |                                        help: consider borrowing here: `&w`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzqre8b41.rs:21:50\n   |\n21 |\
    \         .all(|(a, b)| (a == b) || (a < w && b <= w))\n   |                 \
    \                                 ^\n   |                                    \
    \              |\n   |                                                  expected\
    \ `&isize`, found `isize`\n   |                                              \
    \    help: consider borrowing here: `&w`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > 1 {\n        let mut fly_sum = 0;\n        let mut fly_count\
    \ = 0;\n        for el in q {\n            if el > 0 {\n                fly_sum\
    \ += el;\n                fly_count += 1;\n            }\n        }\n\n      \
    \  if fly_sum > w {\n            return false;\n        }\n\n        if fly_count\
    \ > q.len() / 2 {\n            return true;\n        }\n    }\n\n    return false;\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `q`\n   --> /tmp/tmp14hu9vyg.rs:31:24\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n...\n20  |         for el in q {\n    |                  \
    \ - `q` moved due to this implicit call to `.into_iter()`\n...\n31  |        \
    \ if fly_count > q.len() / 2 {\n    |                        ^^^^^^^ value borrowed\
    \ here after move\n    |\nnote: this function takes ownership of the receiver\
    \ `self`, which moves `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s\
    \ content to avoid moving into the `for` loop\n    |\n20  |         for el in\
    \ &q {\n    |                   +\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let w = w / q.len();\n    if will_it_fly_helper(q).is_ok() && w < q.len()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `will_it_fly_helper` in this scope\n\
    \  --> /tmp/tmpbmd8p_1u.rs:18:8\n   |\n18 |     if will_it_fly_helper(q).is_ok()\
    \ && w < q.len() {\n   |        ^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpbmd8p_1u.rs:17:17\n   |\n17 |  \
    \   let w = w / q.len();\n   |                 ^^^^^^^ expected `isize`, found\
    \ `usize`\n\nerror[E0277]: cannot divide `isize` by `usize`\n  --> /tmp/tmpbmd8p_1u.rs:17:15\n\
    \   |\n17 |     let w = w / q.len();\n   |               ^ no implementation for\
    \ `isize / usize`\n   |\n   = help: the trait `Div<usize>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `Div<Rhs>`:\n\
    \             <&'a f32 as Div<f32>>\n             <&'a f64 as Div<f64>>\n    \
    \         <&'a i128 as Div<i128>>\n             <&'a i16 as Div<i16>>\n      \
    \       <&'a i32 as Div<i32>>\n             <&'a i64 as Div<i64>>\n          \
    \   <&'a i8 as Div<i8>>\n             <&'a isize as Div<isize>>\n           and\
    \ 54 others\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbmd8p_1u.rs:18:45\n\
    \   |\n18 |     if will_it_fly_helper(q).is_ok() && w < q.len() {\n   |      \
    \                                       ^^^^^^^ expected `isize`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `isize` and panic if the converted\
    \ value doesn't fit\n   |\n18 |     if will_it_fly_helper(q).is_ok() && w < q.len().try_into().unwrap()\
    \ {\n   |                                                    ++++++++++++++++++++\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0425.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut max_weight = w;\n    for v in q.iter()\
    \ {\n        if v < max_weight {\n            max_weight -= v;\n        }\n  \
    \      sum += v;\n    }\n    sum >= max_weight\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8fjg8lnu.rs:20:16\n   |\n\
    20 |         if v < max_weight {\n   |                ^^^^^^^^^^\n   |       \
    \         |\n   |                expected `&isize`, found `isize`\n   |      \
    \          help: consider borrowing here: `&max_weight`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut maximum = w;\n    let mut current = q.clone();\n\
    \n    for &i in &current {\n        sum += *i;\n        maximum = match sum {\n\
    \            0 => maximum,\n            _ => if sum > maximum {\n            \
    \    maximum\n            } else {\n                sum\n            }\n     \
    \   };\n    }\n    !current.is_empty() && sum <= maximum\n}\n\nfn main() {\n \
    \   let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9),\
    \ true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `isize` cannot be dereferenced\n  --> /tmp/tmpj5ahvuy9.rs:22:16\n\
    \   |\n22 |         sum += *i;\n   |                ^^\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut f = false;\n    for i in q.iter().rev() {\n        if f {\n \
    \           return false;\n        }\n        if i != q[q.len() - i - 1] {\n \
    \           f = true;\n        }\n    }\n    f && q.rev().iter().sum() <= w\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmphyzj2w_s.rs:22:29\n   |\n\
    22 |         if i != q[q.len() - i - 1] {\n   |                             ^\
    \ expected `usize`, found `isize`\n\nerror[E0277]: cannot subtract `&isize` from\
    \ `usize`\n  --> /tmp/tmphyzj2w_s.rs:22:27\n   |\n22 |         if i != q[q.len()\
    \ - i - 1] {\n   |                           ^ no implementation for `usize -\
    \ &isize`\n   |\n   = help: the trait `Sub<&isize>` is not implemented for `usize`\n\
    \   = help: the following other types implement trait `Sub<Rhs>`:\n          \
    \   <&'a f32 as Sub<f32>>\n             <&'a f64 as Sub<f64>>\n             <&'a\
    \ i128 as Sub<i128>>\n             <&'a i16 as Sub<i16>>\n             <&'a i32\
    \ as Sub<i32>>\n             <&'a i64 as Sub<i64>>\n             <&'a i8 as Sub<i8>>\n\
    \             <&'a isize as Sub<isize>>\n           and 48 others\n\nerror[E0277]:\
    \ can't compare `&isize` with `isize`\n  --> /tmp/tmphyzj2w_s.rs:22:14\n   |\n\
    22 |         if i != q[q.len() - i - 1] {\n   |              ^^ no implementation\
    \ for `&isize == isize`\n   |\n   = help: the trait `PartialEq<isize>` is not\
    \ implemented for `&isize`\n   = help: the following other types implement trait\
    \ `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n \
    \            i16\n             i32\n             i64\n             i8\n      \
    \       isize\n           and 6 others\n\nerror[E0599]: `Vec<isize>` is not an\
    \ iterator\n   --> /tmp/tmphyzj2w_s.rs:26:12\n    |\n26  |       f && q.rev().iter().sum()\
    \ <= w\n    |              ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().rev().sum() <= w && q.iter().forall(|x| x <= w)\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `forall` found for struct `std::slice::Iter`\
    \ in the current scope\n  --> /tmp/tmpdzt0b8b3.rs:17:43\n   |\n17 |     q.iter().rev().sum()\
    \ <= w && q.iter().forall(|x| x <= w)\n   |                                  \
    \         ^^^^^^ method not found in `std::slice::Iter<'_, isize>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.is_empty() {\n        return false;\n    }\n\n    let mut s = q.iter().map(|x|\
    \ x * x).sum();\n\n    if w < 0 {\n        w = -w;\n    }\n\n    if s == w {\n\
    \        return true;\n    }\n\n    if s < w {\n        return false;\n    }\n\
    \n    let mut j = q.len() - 1;\n\n    while j >= 0 {\n        let mut i = j;\n\
    \n        while i >= 0 {\n            if q[j] != q[i] {\n                break;\n\
    \            }\n\n            i -= 1;\n        }\n\n        if i == j {\n    \
    \        break;\n        }\n\n        j -= 1;\n    }\n\n    if j == 0 {\n    \
    \    return true;\n    }\n\n    if j == q.len() {\n        return false;\n   \
    \ }\n\n    let mut k = j;\n\n    while k >= 0 {\n        let mut i = k;\n\n  \
    \      while i >= 0 {\n            if q[j] != q[i] {\n                break;\n\
    \            }\n\n            i -= 1;\n        }\n\n        if i == k {\n    \
    \        break;\n        }\n\n        k -= 1;\n    }\n\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmp6naza3_y.rs:21:9\n\
    \   |\n21 |     let mut s = q.iter().map(|x| x * x).sum();\n   |         ^^^^^\
    \ consider giving `s` a type\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut fly_check = true;\n    let mut sum = 0;\n\n    for i in q.iter().rev()\
    \ {\n        sum += *i;\n\n        if sum > w {\n            fly_check = false;\n\
    \            break;\n        }\n    }\n\n    fly_check\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmp9zfqjwvb.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max: Vec<isize> = Vec::new();\n    for el in q {\n        max.push(el);\n\
    \    }\n    let mut s = Vec::new();\n    for el in max {\n        s.insert(0,\
    \ el);\n    }\n    let mut sum = 0;\n    let mut i = 0;\n    while i < s.len()\
    \ {\n        sum += s[i++];\n        if sum == w {\n            return true;\n\
    \        }\n    }\n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmptmc34gmf.rs:28:19\n\
    \   |\n28 |         sum += s[i++];\n   |                   ^^ not a valid postfix\
    \ operator\n   |\nhelp: use `+= 1` instead\n   |\n28 |         sum += s[{ let\
    \ tmp = i; i += 1; tmp }];\n   |                  +++++++++++  ~~~~~~~~~~~~~~~\n\
    28 -         sum += s[i++];\n28 +         sum += s[i += 1];\n   | \n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut p = q.iter();\n    p.rev();\n    let mut ans = true;\n    for\
    \ &i in p.cloned() {\n        let q = q.rev();\n        let w = w - i;\n     \
    \   if q == vec![w] {\n            ans = false;\n            break;\n        }\n\
    \    }\n    ans\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpz99hxthj.rs:20:9\n   |\n\
    20 |     for &i in p.cloned() {\n   |         ^^    ---------- this expression\
    \ has type `Option<isize>`\n   |         |\n   |         expected `isize`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `i`\n\
    \   |\n   = note:   expected type `isize`\n           found reference `&_`\n\n\
    error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpz99hxthj.rs:21:19\n\
    \    |\n21  |           let q = q.rev();\n    |                     ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    let mut is_balanced = true;\n    for x in q.iter().rev()\
    \ {\n        sum += x;\n        is_balanced = (sum == w) && (sum != 0 || is_balanced);\n\
    \    }\n    is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `false`,\n right: `true`', /tmp/tmpnl1qti3s.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() != 0 {\n        if !is_palindromic(q) {\n            return\
    \ false;\n        }\n        let mut sum = 0;\n        for i in q {\n        \
    \    sum += i;\n        }\n        if sum < w {\n            return false;\n \
    \       }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_palindromic` in this scope\n  -->\
    \ /tmp/tmpro2__grd.rs:18:13\n   |\n18 |         if !is_palindromic(q) {\n   |\
    \             ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() < 1 {\n        return false;\n    }\n    let mut max = 0;\n\
    \    let mut sum = 0;\n    for &el in q {\n        if el > max {\n           \
    \ max = el;\n        }\n        sum += el;\n    }\n    if w <= 0 || sum < w {\n\
    \        return false;\n    }\n    if q.rev().iter().all().filter(|&el| el >=\
    \ w).count() > 0 {\n        return false;\n    }\n    let diff = w - sum;\n  \
    \  if q[0] > max {\n        return false;\n    }\n    for &el in q.rev() {\n \
    \       if el > max {\n            return false;\n        }\n        diff -= el;\n\
    \    }\n    if diff < 0 {\n        return false;\n    }\n    return true;\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2w593n7q.rs:22:9\n   |\n\
    22 |     for &el in q {\n   |         ^^^    - this expression has type `Option<isize>`\n\
    \   |         |\n   |         expected `isize`, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `el`\n   |\n   = note:  \
    \ expected type `isize`\n           found reference `&_`\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmp2w593n7q.rs:31:10\n    |\n31  |       if\
    \ q.rev().iter().all().filter(|&el| el >= w).count() > 0 {\n    |            ^^^\
    \ `Vec<isize>` is not an iterator\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<isize>: Iterator`\n            which is\
    \ required by `&mut Vec<isize>: Iterator`\n            `[isize]: Iterator`\n \
    \           which is required by `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmp2w593n7q.rs:38:18\n    |\n38  |       for\
    \ &el in q.rev() {\n    |                    ^^^ `Vec<isize>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut w = w;\n    let mut q = q.clone();\n    let mut sum = 0;\n  \
    \  for v in q.iter() {\n        if *v > w {\n            return false;\n     \
    \   }\n        w = *v;\n        sum += *v;\n    }\n    if sum >= w {\n       \
    \ return true;\n    }\n    let mut q: Vec<isize>;\n    q.push(0);\n    q.push(1);\n\
    \    let mut x = 1;\n    while *q.len() > x {\n        q.swap(0, q.len());\n \
    \       q.push(x+1);\n        x += 2;\n    }\n    let mut y = 1;\n    while sum+y\
    \ <= w {\n        q.swap(0, q.len());\n        q.push(y+1);\n        y += 2;\n\
    \    }\n    for v in q.iter() {\n        if *v < w {\n            return false;\n\
    \        }\n    }\n    return true;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpma9m4ye3.rs:34:11\n\
    \   |\n34 |     while *q.len() > x {\n   |           ^^^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    q.iter().fold(true, |result, element| result && element <= w && (q.iter().sum()\
    \ <= w))\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpavqp5z6q.rs:17:64\n   |\n\
    17 |     q.iter().fold(true, |result, element| result && element <= w && (q.iter().sum()\
    \ <= w))\n   |                                                               \
    \ ^\n   |                                                                |\n \
    \  |                                                                expected `&isize`,\
    \ found `isize`\n   |                                                        \
    \        help: consider borrowing here: `&w`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    sum.clone_from_slice(q.as_slice());\n    for v\
    \ in q.iter() {\n        if v < 0 || sum > w {\n            return false;\n  \
    \      }\n        sum += v;\n    }\n    true\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `clone_from_slice` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmprgeqy5zv.rs:18:9\n   |\n18 |     sum.clone_from_slice(q.as_slice());\n\
    \   |         ^^^^^^^^^^^^^^^^ method not found in `{integer}`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmprgeqy5zv.rs:20:16\n   |\n20 |         if v <\
    \ 0 || sum > w {\n   |                ^\n   |                |\n   |         \
    \       expected `&isize`, found integer\n   |                help: consider borrowing\
    \ here: `&0`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut q = q.iter();\n    let mut sum = 0;\n    let mut max_weight =\
    \ 0;\n    let mut is_balanced = false;\n    while let Some(item) = q.next() {\n\
    \        sum += item;\n        max_weight = if sum == w {\n            if max_weight\
    \ < item {\n                max_weight = item;\n            }\n            false\n\
    \        } else {\n            true\n        }\n    }\n    is_balanced = max_weight\
    \ <= w && sum >= w;\n    is_balanced\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8sgl4n69.rs:25:30\n   |\n\
    19 |     let mut max_weight = 0;\n   |                          - expected due\
    \ to this value\n...\n25 |                 max_weight = item;\n   |          \
    \                    ^^^^ expected `isize`, found `&isize`\n   |\nhelp: consider\
    \ dereferencing the borrow\n   |\n25 |                 max_weight = *item;\n \
    \  |                              +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8sgl4n69.rs:27:13\n\
    \   |\n27 |             false\n   |             ^^^^^ expected `isize`, found\
    \ `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8sgl4n69.rs:29:13\n\
    \   |\n29 |             true\n   |             ^^^^ expected `isize`, found `bool`\n\
    \nerror[E0277]: can't compare `isize` with `&isize`\n  --> /tmp/tmp8sgl4n69.rs:24:27\n\
    \   |\n24 |             if max_weight < item {\n   |                         \
    \  ^ no implementation for `isize < &isize` and `isize > &isize`\n   |\n   = help:\
    \ the trait `PartialOrd<&isize>` is not implemented for `isize`\n   = help: the\
    \ following other types implement trait `PartialOrd<Rhs>`:\n             f32\n\
    \             f64\n             i128\n             i16\n             i32\n   \
    \          i64\n             i8\n             isize\n           and 6 others\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > w.to_isize() {\n        return false;\n    }\n    if q.is_empty()\
    \ {\n        return true;\n    }\n    let mut is_balanced = true;\n    let mut\
    \ max_weight = 0;\n    let mut i = 1;\n    while i <= q.len() {\n        let mut\
    \ sum = 0;\n        let mut j = i;\n        while j < q.len() {\n            sum\
    \ += q[j];\n            j += 1;\n        }\n        if sum > max_weight {\n  \
    \          is_balanced = false;\n            break;\n        }\n        max_weight\
    \ = sum;\n        i += 1;\n    }\n    \n    if max_weight <= w {\n        return\
    \ true;\n    }\n    \n    false\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_isize` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmp1gxg7j5k.rs:17:20\n   |\n17 |     if q.len() >\
    \ w.to_isize() {\n   |                    ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut reversed = q;\n    reversed.rev();\n    let mut total_weight\
    \ = 0;\n    let mut fly_weight = 0;\n    let mut balanced = false;\n    for i\
    \ in &mut reversed {\n        total_weight += *i;\n        if w == total_weight\
    \ {\n            fly_weight += *i;\n        }\n        if w > total_weight {\n\
    \            balanced = true;\n            break;\n        }\n    }\n    balanced\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpkz3c___l.rs:18:14\n\
    \    |\n18  |       reversed.rev();\n    |                ^^^ `Vec<isize>` is\
    \ not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 1 {\n        return false;\n    }\n    let mut m = q.len()\
    \ - 1;\n    let mut sum = 0;\n    while m >= 0 && q[m] == q[m+1] {\n        m--;\n\
    \    }\n    sum += q[m];\n    let mut max_weight = w / sum;\n    m.checked_add(-m);\n\
    \    if sum > max_weight {\n        return false;\n    }\n    true\n}\n\nfn main()\
    \ {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3],\
    \ 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmplv_06q2_.rs:23:12\n\
    \   |\n23 |         m--;\n   |            ^ expected expression\n\nerror[E0600]:\
    \ cannot apply unary operator `-` to type `usize`\n  --> /tmp/tmplv_06q2_.rs:27:19\n\
    \   |\n27 |     m.checked_add(-m);\n   |                   ^^ cannot apply unary\
    \ operator `-`\n   |\n   = note: unsigned values cannot be negated\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0600`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    vec::all(|v| *v >= w || q.iter().rev().zip(0..).all(|(i, _)| v == i))\n\
    }\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `vec`\n\
    \  --> /tmp/tmpodgr41ry.rs:17:5\n   |\n17 |     vec::all(|v| *v >= w || q.iter().rev().zip(0..).all(|(i,\
    \ _)| v == i))\n   |     ^^^ use of undeclared crate or module `vec`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut p = q.clone();\n    let mut max = p;\n    for i in p.iter_mut()\
    \ {\n        *i /= *max;\n        if *i < w {\n            *i = 1;\n        }\
    \ else {\n            *i = *max - *i;\n        }\n    }\n\n    q.iter().all(|&i|\
    \ i > w)\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `[isize]` cannot be known at\
    \ compilation time\n  --> /tmp/tmpd5c22us4.rs:20:12\n   |\n20 |         *i /=\
    \ *max;\n   |            ^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[isize]`\n\nerror[E0277]:\
    \ cannot divide-assign `isize` by `[isize]`\n  --> /tmp/tmpd5c22us4.rs:20:12\n\
    \   |\n20 |         *i /= *max;\n   |            ^^ no implementation for `isize\
    \ /= [isize]`\n   |\n   = help: the trait `DivAssign<[isize]>` is not implemented\
    \ for `isize`\n   = help: the following other types implement trait `DivAssign<Rhs>`:\n\
    \             <f32 as DivAssign<&f32>>\n             <f32 as DivAssign>\n    \
    \         <f64 as DivAssign<&f64>>\n             <f64 as DivAssign>\n        \
    \     <i128 as DivAssign<&i128>>\n             <i128 as DivAssign>\n         \
    \    <i16 as DivAssign<&i16>>\n             <i16 as DivAssign>\n           and\
    \ 20 others\n\nerror[E0369]: cannot subtract `isize` from `[isize]`\n  --> /tmp/tmpd5c22us4.rs:24:23\n\
    \   |\n24 |             *i = *max - *i;\n   |                  ---- ^ -- isize\n\
    \   |                  |\n   |                  [isize]\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0369.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() < 2 {\n        return false;\n    }\n    let mut q = q.to_owned();\n\
    \    let mut max = 0;\n    while q.len() > 0 {\n        q.swap(0, q.len() - 1);\n\
    \        max = q[0] + q[q.len() - 1];\n        if max > w {\n            break;\n\
    \        }\n        q.swap(0, q.len() - 1);\n    }\n    q == q.to_owned()\n}\n\
    \nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "warning: value assigned to `max` is never read\n  --> /tmp/tmp8z86_t3m.rs:21:13\n\
    \   |\n21 |     let mut max = 0;\n   |             ^^^\n   |\n   = note: `#[warn(unused_assignments)]`\
    \ on by default\n   = help: maybe it is overwritten before being read?\n\nerror[E0502]:\
    \ cannot borrow `q` as immutable because it is also borrowed as mutable\n  -->\
    \ /tmp/tmp8z86_t3m.rs:23:19\n   |\n23 |         q.swap(0, q.len() - 1);\n   |\
    \         ----------^^^^^^^-----\n   |         | |       |\n   |         | | \
    \      immutable borrow occurs here\n   |         | mutable borrow later used\
    \ by call\n   |         mutable borrow occurs here\n   |\nhelp: try adding a local\
    \ storing this argument...\n  --> /tmp/tmp8z86_t3m.rs:23:19\n   |\n23 |      \
    \   q.swap(0, q.len() - 1);\n   |                   ^^^^^^^\nhelp: ...and then\
    \ using that local as the argument to this call\n  --> /tmp/tmp8z86_t3m.rs:23:9\n\
    \   |\n23 |         q.swap(0, q.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0502]: cannot borrow `q` as immutable because it is also borrowed as\
    \ mutable\n  --> /tmp/tmp8z86_t3m.rs:28:19\n   |\n28 |         q.swap(0, q.len()\
    \ - 1);\n   |         ----------^^^^^^^-----\n   |         | |       |\n   | \
    \        | |       immutable borrow occurs here\n   |         | mutable borrow\
    \ later used by call\n   |         mutable borrow occurs here\n   |\nhelp: try\
    \ adding a local storing this argument...\n  --> /tmp/tmp8z86_t3m.rs:28:19\n \
    \  |\n28 |         q.swap(0, q.len() - 1);\n   |                   ^^^^^^^\nhelp:\
    \ ...and then using that local as the argument to this call\n  --> /tmp/tmp8z86_t3m.rs:28:9\n\
    \   |\n28 |         q.swap(0, q.len() - 1);\n   |         ^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 101
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 0 {\n        return false;\n    }\n    let mut q2 = q.clone();\n\
    \    let mut ans = false;\n    let mut weight = 0;\n    let mut max_weight = 0;\n\
    \    let mut i = 0;\n    while i < q.len() {\n        q2.remove(i);\n        weight\
    \ += &q[i];\n        if weight > max_weight {\n            max_weight = weight;\n\
    \        }\n        let mut j = 0;\n        while j < q.len() {\n            if\
    \ j == i {\n                q2.remove(j);\n            }\n            j += 1;\n\
    \        }\n        if weight <= w {\n            ans = true;\n            break;\n\
    \        }\n        i += 1;\n    }\n    ans\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `true`,\n right: `false`', /tmp/tmpwp0rbves.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut sum = 0;\n    for elt in q {\n        sum += elt;\n    }\n  \
    \  if sum == w {\n        return true;\n    }\n    if sum < w {\n        return\
    \ false;\n    }\n    let mut max_weight = 0;\n    let mut balance_found = false;\n\
    \    for elt in q {\n        if max_weight < elt {\n            max_weight = elt;\n\
    \        }\n        if elt == max_weight {\n            balance_found = true;\n\
    \        }\n    }\n    if balance_found {\n        return true;\n    }\n    return\
    \ false;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: use of moved value: `q`\n   --> /tmp/tmp1v8ut7jl.rs:29:16\n\
    \    |\n16  | fn will_it_fly(q: Vec<isize>, w: isize) -> bool {\n    |       \
    \         - move occurs because `q` has type `Vec<isize>`, which does not implement\
    \ the `Copy` trait\n17  |     let mut sum = 0;\n18  |     for elt in q {\n   \
    \ |                - `q` moved due to this implicit call to `.into_iter()`\n...\n\
    29  |     for elt in q {\n    |                ^ value used here after move\n\
    \    |\nnote: this function takes ownership of the receiver `self`, which moves\
    \ `q`\nhelp: consider iterating over a slice of the `Vec<isize>`'s content to\
    \ avoid moving into the `for` loop\n    |\n18  |     for elt in &q {\n    |  \
    \              +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut s = Vec::new();\n    let mut m = 0;\n    for e in q {\n     \
    \   s.push(e);\n        m += e;\n    }\n\n    let mut i = q.len() - 1;\n    while\
    \ i >= 0 && q[i] < m {\n        s.pop();\n        i--;\n    }\n\n    i > 0 &&\
    \ q[i] == m\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `;`\n  --> /tmp/tmpaja4v7_u.rs:27:12\n\
    \   |\n27 |         i--;\n   |            ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut w = w;\n    let mut q_rev = q.iter().rev();\n    let mut z =\
    \ 0;\n    while let Some(i) = q_rev.next() {\n        if i != z {\n          \
    \  if z == 0 {\n                z += i;\n            } else {\n              \
    \  z -= i;\n                return false;\n            }\n        }\n        w\
    \ -= i;\n    }\n    z > 0 && z == w\n}\n\nfn main() {\n    let candidate = will_it_fly;\n\
    \    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&isize` with `{integer}`\n  --> /tmp/tmppviucqwp.rs:21:14\n\
    \   |\n21 |         if i != z {\n   |              ^^ no implementation for `&isize\
    \ == {integer}`\n   |\n   = help: the trait `PartialEq<{integer}>` is not implemented\
    \ for `&isize`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if w.is_zero() {\n        return false;\n    }\n    let max_sum = (1..w).sum();\n\
    \    let mut fly_flag = true;\n    let mut qr = q;\n    while fly_flag {\n   \
    \     fly_flag = qr\n            .iter()\n            .zip(qr.rev())\n       \
    \     .all(|(v, w)| v == w || v - w <= max_sum);\n        qr = qr.rev();\n   \
    \ }\n    true\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_zero` found for type `isize` in the current\
    \ scope\n  --> /tmp/tmpgyxtjskv.rs:17:10\n   |\n17 |     if w.is_zero() {\n  \
    \ |          ^^^^^^^ method not found in `isize`\n\nerror[E0599]: `Vec<isize>`\
    \ is not an iterator\n   --> /tmp/tmpgyxtjskv.rs:26:21\n    |\n26  |         \
    \      .zip(qr.rev())\n    |                       ^^^ `Vec<isize>` is not an\
    \ iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror[E0599]: `Vec<isize>` is not an iterator\n\
    \   --> /tmp/tmpgyxtjskv.rs:28:17\n    |\n28  |           qr = qr.rev();\n   \
    \ |                   ^^^ `Vec<isize>` is not an iterator\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `Vec<isize>: Iterator`\n\
    \            which is required by `&mut Vec<isize>: Iterator`\n            `[isize]:\
    \ Iterator`\n            which is required by `&mut [isize]: Iterator`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max = -std::isize::MAX;\n    q.sort_unstable();\n    for i in\
    \ q {\n        if i > max {\n            max = i;\n        }\n    }\n\n    let\
    \ mut counter = vec![0];\n    let mut last = 0;\n    for i in q.iter().rev() {\n\
    \        counter.push(i);\n        last *= i as isize;\n    }\n\n    let sum =\
    \ counter.iter().sum();\n    let maxsum = max * w as isize;\n    sum < maxsum\
    \ && sum == last\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpchkcrvwv.rs:28:22\n   |\n\
    28 |         counter.push(i);\n   |                      ^ expected integer, found\
    \ `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n28 |        \
    \ counter.push(*i);\n   |                      +\n\nerror[E0606]: casting `&isize`\
    \ as `isize` is invalid\n  --> /tmp/tmpchkcrvwv.rs:29:17\n   |\n29 |         last\
    \ *= i as isize;\n   |                 -^^^^^^^^^\n   |                 |\n  \
    \ |                 cannot cast `&isize` as `isize`\n   |                 help:\
    \ dereference the expression: `*i`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0606.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut max: isize = 0;\n    for i in q.iter().rev() {\n        if i\
    \ > max { max = i; }\n    }\n    max >= w\n}\n\nfn main() {\n    let candidate\
    \ = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n    assert_eq!(candidate(vec![1,\
    \ 2], 5), false);\n    assert_eq!(candidate(vec![3], 5), true);\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 1), false);\n    assert_eq!(candidate(vec![1, 2, 3], 6), false);\n  \
    \  assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnew_6cit.rs:19:16\n   |\n\
    19 |         if i > max { max = i; }\n   |                ^^^\n   |          \
    \      |\n   |                expected `&isize`, found `isize`\n   |         \
    \       help: consider borrowing here: `&max`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpnew_6cit.rs:19:28\n   |\n17 |     let mut max: isize = 0;\n   |\
    \                  ----- expected due to this type\n18 |     for i in q.iter().rev()\
    \ {\n19 |         if i > max { max = i; }\n   |                            ^ expected\
    \ `isize`, found `&isize`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    19 |         if i > max { max = *i; }\n   |                            +\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() > w {\n        return false;\n    }\n    let mut will_it_fly\
    \ = false;\n    let mut max_weight = w;\n    let mut i = 1;\n    while i <= q.len()\
    \ {\n        if q.first() <= i {\n            return false;\n        }\n     \
    \   if i != q.last() {\n            will_it_fly = true;\n            max_weight\
    \ -= q.last() - q.first();\n        }\n        i += 1;\n    }\n    if max_weight\
    \ < 0 {\n        return false;\n    }\n    will_it_fly\n}\n\nfn main() {\n   \
    \ let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbtac59zz.rs:17:18\n   |\n\
    17 |     if q.len() > w {\n   |                  ^ expected `usize`, found `isize`\n\
    \   |\nhelp: you can convert an `isize` to a `usize` and panic if the converted\
    \ value doesn't fit\n   |\n17 |     if q.len() > w.try_into().unwrap() {\n   |\
    \                   ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpbtac59zz.rs:24:25\n   |\n24 |         if q.first() <= i {\n   |\
    \                         ^ expected enum `Option`, found `usize`\n   |\n   =\
    \ note: expected enum `Option<&isize>`\n              found type `usize`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpbtac59zz.rs:27:17\n   |\n27 |         if i !=\
    \ q.last() {\n   |                 ^^^^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<&isize>`\n\
    \nerror[E0369]: cannot subtract `Option<&isize>` from `Option<&isize>`\n  -->\
    \ /tmp/tmpbtac59zz.rs:29:36\n   |\n29 |             max_weight -= q.last() - q.first();\n\
    \   |                           -------- ^ --------- Option<&isize>\n   |    \
    \                       |\n   |                           Option<&isize>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let mut is_balanced = false;\n    let mut q_balanced: Vec<_> = q.to_vec();\n\
    \    let mut sum = 0;\n    while !q_balanced.is_empty() {\n        let v = q_balanced.pop();\n\
    \        sum += v;\n        if sum < w {\n            is_balanced = true;\n  \
    \      }\n        q_balanced.push(*v);\n    }\n    return is_balanced\n}\n\nfn\
    \ main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `Option<isize>` to `{integer}`\n  --> /tmp/tmp3oyn1ksw.rs:22:13\n\
    \   |\n22 |         sum += v;\n   |             ^^ no implementation for `{integer}\
    \ += Option<isize>`\n   |\n   = help: the trait `AddAssign<Option<isize>>` is\
    \ not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n\
    \           and 20 others\n\nerror[E0614]: type `Option<isize>` cannot be dereferenced\n\
    \  --> /tmp/tmp3oyn1ksw.rs:26:25\n   |\n26 |         q_balanced.push(*v);\n  \
    \ |                         ^^\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0614.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    let n = q.len();\n    let mut v = Vec::with_capacity(2 * n);\n    v.extend(q);\n\
    \n    // write your code here\n    let mut rev = 0;\n    let mut carry = 0;\n\n\
    \    for &i in &v {\n        rev = (rev*10)+i;\n        carry = rev /10;\n\n \
    \       if rev < 0 {\n            rev = rev + w;\n        }\n\n        v.insert(rev%10,\
    \ carry);\n    }\n\n    if v.iter().sum::<usize>() > w {\n        return false;\n\
    \    }\n\n    let mut is_palindromic = true;\n\n    for i in v {\n        if i\
    \ != v.rev() {\n            is_palindromic = false;\n        }\n    }\n\n    return\
    \ is_palindromic;\n}\n\nfn main() {\n    let candidate = will_it_fly;\n    assert_eq!(candidate(vec![3,\
    \ 2, 3], 9), true);\n    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfbpe8j98.rs:33:18\n   |\n\
    33 |         v.insert(rev%10, carry);\n   |                  ^^^^^^ expected `usize`,\
    \ found `isize`\n   |\nhelp: you can convert an `isize` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n33 |         v.insert((rev%10).try_into().unwrap(),\
    \ carry);\n   |                  +      +++++++++++++++++++++\n\nerror[E0277]:\
    \ the trait bound `usize: Sum<&isize>` is not satisfied\n    --> /tmp/tmpfbpe8j98.rs:36:17\n\
    \     |\n36   |     if v.iter().sum::<usize>() > w {\n     |                 ^^^\
    \ the trait `Sum<&isize>` is not implemented for `usize`\n     |\n     = help:\
    \ the following other types implement trait `Sum<A>`:\n               <f32 as\
    \ Sum<&'a f32>>\n               <f32 as Sum>\n               <f64 as Sum<&'a f64>>\n\
    \               <f64 as Sum>\n               <i128 as Sum<&'a i128>>\n       \
    \        <i128 as Sum>\n               <i16 as Sum<&'a i16>>\n               <i16\
    \ as Sum>\n             and 20 others\nnote: required by a bound in `std::iter::Iterator::sum`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpfbpe8j98.rs:36:34\n   |\n36 |\
    \     if v.iter().sum::<usize>() > w {\n   |                                 \
    \ ^ expected `usize`, found `isize`\n   |\nhelp: you can convert an `isize` to\
    \ a `usize` and panic if the converted value doesn't fit\n   |\n36 |     if v.iter().sum::<usize>()\
    \ > w.try_into().unwrap() {\n   |                                   ++++++++++++++++++++\n\
    \nerror[E0599]: `Vec<isize>` is not an iterator\n   --> /tmp/tmpfbpe8j98.rs:43:19\n\
    \    |\n43  |           if i != v.rev() {\n    |                     ^^^ `Vec<isize>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<isize>: Iterator`\n            which is required by `&mut Vec<isize>:\
    \ Iterator`\n            `[isize]: Iterator`\n            which is required by\
    \ `&mut [isize]: Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976610
- exit_code: 1
  program: "/// Write a function that returns true if the object q will fly, and false\
    \ otherwise.\n/// The object q will fly if it's balanced (it is a palindromic\
    \ vector) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n/// Example:\n/// >>> will_it_fly(vec![1, 2], 5)\n/// false\n///\
    \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n/// >>>\
    \ will_it_fly(vec![3, 2, 3], 1)\n/// false\n/// # it's balanced, but 3+2+3 is\
    \ more than the maximum possible weight.\n/// >>> will_it_fly(vec![3, 2, 3], 9)\n\
    /// true\n/// # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\
    /// >>> will_it_fly(vec![3], 5)\n/// true\n/// # 3 is less than the maximum possible\
    \ weight, and it's balanced.\nfn will_it_fly(q: Vec<isize>, w: isize) -> bool\
    \ {\n    if q.len() == 1 {\n        q.pop();\n    }\n    let mut cur = q[0];\n\
    \    let mut total = 0;\n    while total < w {\n        total += cur;\n      \
    \  cur -= q[q.len() - 2];\n    }\n    cur > 0 && total <= w && cur <= w / 2 &&\
    \ q == q.iter().rev().skip(q.len() - 1).map(|x| x.0).take(q[0]).count() == q.len()\
    \ {\n        true\n    } else {\n        false\n    }\n}\n\nfn main() {\n    let\
    \ candidate = will_it_fly;\n    assert_eq!(candidate(vec![3, 2, 3], 9), true);\n\
    \    assert_eq!(candidate(vec![1, 2], 5), false);\n    assert_eq!(candidate(vec![3],\
    \ 5), true);\n    assert_eq!(candidate(vec![3, 2, 3], 1), false);\n    assert_eq!(candidate(vec![1,\
    \ 2, 3], 6), false);\n    assert_eq!(candidate(vec![5], 5), true);\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmp1f8tfv3a.rs:26:48\n\
    \   |\n26 |     cur > 0 && total <= w && cur <= w / 2 && q == q.iter().rev().skip(q.len()\
    \ - 1).map(|x| x.0).take(q[0]).count() == q.len() {\n   |                    \
    \                            ^^                                              \
    \                    ^^\n   |\nhelp: split the comparison into two\n   |\n26 |\
    \     cur > 0 && total <= w && cur <= w / 2 && q == q.iter().rev().skip(q.len()\
    \ - 1).map(|x| x.0).take(q[0]).count() && q.iter().rev().skip(q.len() - 1).map(|x|\
    \ x.0).take(q[0]).count() == q.len() {\n   |                                 \
    \                                                                            \
    \       +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `{`\n  --> /tmp/tmp1f8tfv3a.rs:26:127\n\
    \   |\n26 |     cur > 0 && total <= w && cur <= w / 2 && q == q.iter().rev().skip(q.len()\
    \ - 1).map(|x| x.0).take(q[0]).count() == q.len() {\n   |                    \
    \                                                                            \
    \                               ^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1659976610
