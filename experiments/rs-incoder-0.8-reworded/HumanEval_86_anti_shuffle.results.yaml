language: rs
name: HumanEval_86_anti_shuffle
results:
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Step 1: Create a map of 'a' to 'z'\n    let mut alphabet:\
    \ HashMap<char, char> = HashMap::new();\n    let mut v: Vec<char> = s.chars().collect();\n\
    \    for a in v.iter() {\n        if !alphabet.contains_key(&a) /* && !alphabet.contains_key(&a.to_ascii_lowercase())\
    \ */{\n            alphabet.insert(a, a);\n        }\n    }\n\n    // Step 2:\
    \ Reverse the map\n    let mut reverse: HashMap<char, char> = HashMap::new();\n\
    \    for (a, v) in alphabet.iter() {\n        reverse.insert(v, a);\n    }\n\n\
    \    // Step 3: Find the index of the first character of the reverse map that\n\
    \    // has a key that is not 'a'\n    let mut start = 0;\n    while start + 1\
    \ < reverse.len() {\n        if !reverse.get_mut(&reverse[start + 1]).is_some()\
    \ {\n            break;\n        }\n        start += 1;\n    }\n\n    // Step\
    \ 4: Swap the first character of the string with that of the last character\n\
    \    // of the reverse map if they're not equal (i.e. swap between 'a' and 'z'\n\
    \    // if reverse map doesn't have a key between 'a' and 'z')\n    if start !=\
    \ 0 {\n        let first_char = s.chars().next().unwrap();\n        if !reverse.get_mut(&first_char).is_some()\
    \ {\n            if !reverse.get_mut(&reverse[start..]).is_some() {\n        \
    \        let last_char = reverse.get_mut(&reverse[start..]).unwrap();\n      \
    \          s.swap(&first_char, &last_char);\n                return s;\n     \
    \       }\n        }\n    }\n\n    // Step 5: A final pass to swap characters\
    \ between 'a' and 'z' that are equal\n    // and between 'A' and 'Z' that are\
    \ equal\n    let mut last_char: char = '\\0';\n    let mut last_char_index = 0;\n\
    \    let mut current_char: char = '\\0';\n    let mut current_char_index = 0;\n\
    \    let mut swap_char: char = '\\0';\n    while current_char_index < s.len()\
    \ - 1 {\n        if current_char_index != last_char_index {\n            last_char\
    \ = current_char;\n            last_char_index = current_char_index;\n       \
    \ }\n        current_char = s.chars().next().unwrap();\n        current_char_index\
    \ += 1;\n\n        if current_char == last_char {\n            swap_char = current_char;\n\
    \        } else {\n            if let Some(ref mut v) = reverse.get_mut(&current_char)\
    \ {\n                if !v.is_some() {\n                    s.swap(&current_char,\
    \ &swap_char);\n                }\n            }\n        }\n    }\n\n    s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp3nbou2gb.rs:15:23\n\
    \   |\n15 |     let mut alphabet: HashMap<char, char> = HashMap::new();\n   |\
    \                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp3nbou2gb.rs:15:45\n\
    \   |\n15 |     let mut alphabet: HashMap<char, char> = HashMap::new();\n   |\
    \                                             ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp3nbou2gb.rs:24:22\n\
    \   |\n24 |     let mut reverse: HashMap<char, char> = HashMap::new();\n   | \
    \                     ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp3nbou2gb.rs:24:44\n\
    \   |\n24 |     let mut reverse: HashMap<char, char> = HashMap::new();\n   | \
    \                                           ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0599]: no method named `swap` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3nbou2gb.rs:47:19\n   |\n47 |                 s.swap(&first_char,\
    \ &last_char);\n   |                   ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp3nbou2gb.rs:73:23\n   |\n73 |                     s.swap(&current_char,\
    \ &swap_char);\n   |                       ^^^^ method not found in `String`\n\
    \nerror: aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_s = String::from(s);\n    for (i, c) in new_s.chars().enumerate()\
    \ {\n        if c != ' ' {\n            new_s.insert((i + 1), c);\n        }\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmp5jhjjkxb.rs:17:26\n\
    \   |\n17 |             new_s.insert((i + 1), c);\n   |                      \
    \    ^     ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n17 -             new_s.insert((i + 1), c);\n17 +  \
    \           new_s.insert(i + 1, c);\n   | \n\nerror[E0502]: cannot borrow `new_s`\
    \ as mutable because it is also borrowed as immutable\n  --> /tmp/tmp5jhjjkxb.rs:17:13\n\
    \   |\n15 |     for (i, c) in new_s.chars().enumerate() {\n   |              \
    \     -------------------------\n   |                   |\n   |              \
    \     immutable borrow occurs here\n   |                   immutable borrow later\
    \ used here\n16 |         if c != ' ' {\n17 |             new_s.insert((i + 1),\
    \ c);\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\n\
    error: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0502`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().enumerate().filter_map(|(i, c)| {\n        let mut\
    \ index = i;\n        loop {\n            index = (index + 1) % s.chars().len();\n\
    \            if s[index] < c {\n                break;\n            }\n      \
    \  }\n        if i == index {\n            Some(c)\n        } else {\n       \
    \     None\n        }\n    })\n    .fold(String::new(), |mut acc, _| {\n     \
    \   let mut r = acc.clone();\n        r.push(s[0]);\n        for i in 1..s.len()\
    \ {\n            r.push(s[i % s.len()]);\n        }\n        r\n    })\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp2vc2wlf_.rs:17:45\n   |\n17 |             index = (index\
    \ + 1) % s.chars().len();\n   |                                             ^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `usize`\n  --> /tmp/tmp2vc2wlf_.rs:18:16\n   |\n18 |            \
    \ if s[index] < c {\n   |                ^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmp2vc2wlf_.rs:30:16\n   |\n30 |         r.push(s[0]);\n   |     \
    \           ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the\
    \ trait `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2vc2wlf_.rs:32:20\n   |\n32 |             r.push(s[i % s.len()]);\n\
    \   |                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<Ra"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_sort_words_and_spaces(s.as_bytes());\n    String::from_utf8(s).unwrap()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_sort_words_and_spaces` in this\
    \ scope\n  --> /tmp/tmpg9tkxnv1.rs:14:5\n   |\n14 |     anti_sort_words_and_spaces(s.as_bytes());\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpg9tkxnv1.rs:15:23\n   |\n15 |     String::from_utf8(s).unwrap()\n\
    \   |                       ^ expected struct `Vec`, found struct `String`\n \
    \  |\n   = note: expected struct `Vec<u8>`\n              found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut builder = String::builder();\n    s.chars().for_each(|c|\
    \ {\n        builder.push(c);\n        builder.pop();\n    });\n    s\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `builder` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp1_9jb5w1.rs:14:31\n   |\n\
    14 |     let mut builder = String::builder();\n   |                          \
    \     ^^^^^^^ function or associated item not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut reverse = String::new();\n    s.chars()\n        .iter()\n\
    \        .filter_map(|c| {\n            if c > ' ' {\n                reverse.push(c);\n\
    \                Some(true)\n            } else {\n                None\n    \
    \        }\n        })\n        .collect();\n    reverse\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpp4xetndg.rs:16:10\n   |\n16 |         .iter()\n   |   \
    \       ^^^^ private field, not a method\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(|x| x).map(|x| x.chars().filter(|&b| b != ' '))\n \
    \       .collect::<Vec<_>>()\n        .sort_by(|a, b| a.cmp(&b));\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo6kp5h05.rs:14:17\n   |\n\
    14 |     s.split(|x| x).map(|x| x.chars().filter(|&b| b != ' '))\n   |       \
    \          ^ expected `bool`, found `char`\n\nerror[E0277]: `&&Filter<Chars<'_>,\
    \ [closure@/tmp/tmpo6kp5h05.rs:14:45: 14:58]>` is not an iterator\n    --> /tmp/tmpo6kp5h05.rs:16:31\n\
    \     |\n16   |         .sort_by(|a, b| a.cmp(&b));\n     |                  \
    \         --- ^^ `&&Filter<Chars<'_>, [closure@/tmp/tmpo6kp5h05.rs:14:45: 14:58]>`\
    \ is not an iterator\n     |                           |\n     |             \
    \              required by a bound introduced by this call\n     |\n     = help:\
    \ the trait `Iterator` is not implemented for `&&Filter<Chars<'_>, [closure@/tmp/tmpo6kp5h05.rs:14:45:\
    \ 14:58]>`\n     = help: the trait `Iterator` is implemented for `Filter<I, P>`\n\
    \     = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&&Filter<Chars<'_>, [closure@/tmp/tmpo6kp5h05.rs:14:45: 14:58]>`\nnote:\
    \ required by a bound in `std::iter::Iterator::cmp`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpo6kp5h05.rs:13:31\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |    ------------               ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    use std::cmp::Ordering;\n    let mut buffer = String::new();\n\
    \    let mut i = 0;\n    let mut pos = 0;\n    let mut s = s.to_lowercase();\n\
    \    s.split(\" \").for_each(|word| {\n        if pos.is_greater(s.len()) {\n\
    \            pos = 0;\n            i += 1;\n        }\n        for _ in 0..word.len()\
    \ {\n            if let Some(ch) = s.get_u8(pos) {\n                buffer.push((*ch\
    \ + 1).to_ascii_lowercase());\n            } else {\n                if i != 0\
    \ {\n                    i += 1;\n                }\n                i += 1;\n\
    \            }\n            pos += 1;\n        }\n    });\n    buffer\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpucktjx7l.rs:14:9\n\
    \   |\n14 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0599]: no method\
    \ named `is_greater` found for type `{integer}` in the current scope\n  --> /tmp/tmpucktjx7l.rs:20:16\n\
    \   |\n20 |         if pos.is_greater(s.len()) {\n   |                ^^^^^^^^^^\
    \ method not found in `{integer}`\n\nerror[E0599]: no method named `get_u8` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpucktjx7l.rs:25:33\n\
    \   |\n25 |             if let Some(ch) = s.get_u8(pos) {\n   |              \
    \                   ^^^^^^ help: there is an associated function with a similar\
    \ name: `get`\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.to_string();\n    s.reserve(s.size());\n    for\
    \ c in s.chars() {\n        let i = c.as_bytes()\n            .iter()\n      \
    \      .enumerate()\n            .filter(|&(_, c)| c != ' ')\n            .map(|(_,\
    \ c)| c.to_ascii_lowercase().unwrap())\n            .min().unwrap();\n       \
    \ if i > 0 {\n            s = s.chars().nth(i).unwrap().to_string().push_str(&c);\n\
    \        } else {\n            s = s.push_str(&c);\n        }\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp_cj75q8c.rs:15:17\n   |\n15 |     s.reserve(s.size());\n\
    \   |                 ^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `as_bytes` found for type `char` in the current scope\n  --> /tmp/tmp_cj75q8c.rs:17:19\n\
    \   |\n17 |         let i = c.as_bytes()\n   |                   ^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_cj75q8c.rs:24:64\n\
    \   |\n24 |             s = s.chars().nth(i).unwrap().to_string().push_str(&c);\n\
    \   |                                                                ^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_cj75q8c.rs:24:17\n\
    \   |\n14 |     let mut s = s.to_string();\n   |                 -------------\
    \ expected due to this value\n...\n24 |             s = s.chars().nth(i).unwrap().to_string().push_str(&c);\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `()`\n   |\nnote: method `push_str` modifies its receiver\
    \ in-place\n  --> /tmp/tmp_cj75q8c.rs:24:55\n   |\n24 |             s = s.chars().nth(i).unwrap().to_string().push_str(&c);\n\
    \   |                 ------------------------------------- ^^^^^^^^ this call\
    \ modifies its receiver in-place\n   |                 |\n   |               \
    \  you probably want to use this value after calling the method...\n   = note:\
    \ ...instead of the `()` output of method `push_str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_cj75q8c.rs:26:28\n   |\n26 |             s = s.push_str(&c);\n\
    \   |                            ^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_cj75q8c.rs:26:17\n   |\n14 |     let mut s\
    \ = s.to_string();\n   |                 ------------- expected due to this value\n\
    ...\n26 |             s = s.push_str(&c);\n   |                 ^^^^^^^^^^^^^^\
    \ expected "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_string = String::from(\"anti shuffled\");\n   \
    \ for c in s.chars() {\n        let ord = c.to_ascii_lowercase();\n        let\
    \ mut new_ord = ord;\n        let mut i = 1;\n        while new_ord != ord &&\
    \ i <= 26 {\n            new_ord = (ord * i) + new_ord;\n            i += 1;\n\
    \        }\n        new_string.push_str(&c.to_ascii_lowercase());\n        new_string.push_str(&new_ord.to_string());\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot multiply `char` by `{integer}`\n  --> /tmp/tmpv_uauvm9.rs:20:28\n\
    \   |\n20 |             new_ord = (ord * i) + new_ord;\n   |                 \
    \       --- ^ - {integer}\n   |                        |\n   |               \
    \         char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpv_uauvm9.rs:23:29\n\
    \   |\n23 |         new_string.push_str(&c.to_ascii_lowercase());\n   |      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(\n        s.chars().enumerate()\n            .filter_map(|(idx,\
    \ ch)| {\n                let mut r = vec![];\n                r.push((*idx).to_ascii_lowercase());\n\
    \                r.push((*idx).to_ascii_uppercase());\n                r.push(ch);\n\
    \                String::from(r)\n            })\n            .collect::<Vec<String>>()\n\
    \            .join(\"!!!\")\n            .to_ascii_lowercase()\n            .into(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `usize` cannot be dereferenced\n  --> /tmp/tmpafigjwx5.rs:18:24\n\
    \   |\n18 |                 r.push((*idx).to_ascii_lowercase());\n   |       \
    \                 ^^^^^^\n\nerror[E0614]: type `usize` cannot be dereferenced\n\
    \  --> /tmp/tmpafigjwx5.rs:19:24\n   |\n19 |                 r.push((*idx).to_ascii_uppercase());\n\
    \   |                        ^^^^^^\n\nerror[E0277]: the trait bound `String:\
    \ From<Vec<char>>` is not satisfied\n  --> /tmp/tmpafigjwx5.rs:21:17\n   |\n21\
    \ |                 String::from(r)\n   |                 ^^^^^^^^^^^^ the trait\
    \ `From<Vec<char>>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpafigjwx5.rs:21:17\n   |\n21 |                 String::from(r)\n\
    \   |                 ^^^^^^^^^^^^^^^ expected enum `Option`, found struct `String`\n\
    \   |\n   = note: expected enum `Option<_>`\n            found struct `String`\n\
    help: try wrapping the expression in `Some`\n   |\n21 |                 Some(String::from(r))\n\
    \   |                 +++++               +\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0614.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(\" \").map(|word| {\n        word.chars().enumerate().filter(|(_,\
    \ c)| c.ascii_uppercase_letter()).map(|(i, _)| {\n            String::from_utf8(word[..i\
    \ + 1]).unwrap().to_string()\n        }).collect()\n    }).collect::<Vec<_>>()\n\
    \        .sorted()\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ascii_uppercase_letter` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp_uj_6dsu.rs:15:52\n   |\n15 |  \
    \       word.chars().enumerate().filter(|(_, c)| c.ascii_uppercase_letter()).map(|(i,\
    \ _)| {\n   |                                                    ^^^^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_uppercase`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp_uj_6dsu.rs:16:31\n   |\n16 |  \
    \           String::from_utf8(word[..i + 1]).unwrap().to_string()\n   |      \
    \                         ^^^^^^^^^^^^^ expected struct `Vec`, found `str`\n \
    \  |\n   = note: expected struct `Vec<u8>`\n                found type `str`\n\
    \nerror[E0599]: no method named `sorted` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmp_uj_6dsu.rs:19:10\n   |\n19 |         .sorted()\n   | \
    \         ^^^^^^ help: there is an associated function with a similar name: `is_sorted`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n\n    if let Some(ref mut s) = s\
    \ {\n        let mut result = String::new();\n        let mut current_letter =\
    \ 0;\n        while !s.is_empty() {\n            let letter = s.as_str()[current_letter];\n\
    \            match letter {\n                c if c !< 32 | c > 122 => {\n   \
    \                 result += match c as u8 {\n                        c => {\n\
    \                            let char_to_replace = c as char;\n              \
    \              let mut char_to_replace_without_case = char_to_replace;\n     \
    \                       char_to_replace_without_case.to_ascii_lowercase();\n \
    \                           char_to_replace_without_case.to_ascii_uppercase();\n\
    \                            char_to_replace_without_case.to_ascii_digit();\n\
    \                            char_to_replace_without_case.to_ascii_punctuation();\n\
    \                            char_to_replace_without_case\n                  \
    \      },\n                        _ => c,\n                    };\n         \
    \       },\n                _ => {\n                    result += &letter;\n \
    \               }\n            }\n            current_letter += 1;\n         \
    \   if current_letter > s.len() {\n                current_letter = 0;\n     \
    \       }\n        }\n        result\n    }\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `(`, `[`, or `{`, found `<`\n  --> /tmp/tmpsgfrtr3z.rs:22:25\n\
    \   |\n22 |                 c if c !< 32 | c > 122 => {\n   |                \
    \         ^ expected one of `(`, `[`, or `{`\n\nwarning: unused import: `std::ascii::AsciiExt`\n\
    \  --> /tmp/tmpsgfrtr3z.rs:14:9\n   |\n14 |     use std::ascii::AsciiExt;\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on\
    \ by default\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`: use inherent\
    \ methods instead\n  --> /tmp/tmpsgfrtr3z.rs:14:21\n   |\n14 |     use std::ascii::AsciiExt;\n\
    \   |                     ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsgfrtr3z.rs:16:12\n\
    \   |\n16 |     if let Some(ref mut s) = s {\n   |            ^^^^^^^^^^^^^^^\
    \   - this expression has type `String`\n   |            |\n   |            expected\
    \ struct `String`, found enum `Option`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Option<_>`\n\nwarning: unreachable statement\n  -->\
    \ /tmp/tmpsgfrtr3z.rs:40:13\n   |\n21 | /             match letter {\n22 | | \
    \                c if c !< 32 | c > 122 => {\n23 | |                     result\
    \ += match c as u8 {\n24 | |                         c => {\n...  |\n38 | |  \
    \               }\n39 | |             }\n   | |_____________- any code following\
    \ this expression is unreachable\n40 |               current_letter += 1;\n  \
    \ |               ^^^^^^^^^^^^^^^^^^^^ unreachable statement\n   |\n   = note:\
    \ `#[warn(unreachable_code)]` on by default\n\nerror: aborting due to 2 previous\
    \ errors; 3 warnings emitted\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_string = s;\n    let mut last_char = 0;\n    let\
    \ mut curr_char = 0;\n    let mut prev_char = 0;\n    let mut words = new_string.splitn(2,\
    \ ' ').collect::<Vec<_>>();\n    for word in words {\n        if curr_char - last_char\
    \ > 3 {\n            new_string = new_string.insert(last_char + 1, ' ');\n   \
    \         last_char += 1;\n        }\n        if word.is_empty() {\n         \
    \   continue;\n        }\n        prev_char = curr_char;\n        curr_char =\
    \ word.chars().count();\n        new_string = new_string.insert(prev_char, word);\n\
    \    }\n    new_string\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhc3fi_w.rs:21:26\n   |\n\
    14 |     let mut new_string = s;\n   |                          - expected due\
    \ to this value\n...\n21 |             new_string = new_string.insert(last_char\
    \ + 1, ' ');\n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `insert` modifies its\
    \ receiver in-place\n  --> /tmp/tmpdhc3fi_w.rs:21:37\n   |\n21 |             new_string\
    \ = new_string.insert(last_char + 1, ' ');\n   |                          ----------\
    \ ^^^^^^ this call modifies `new_string` in-place\n   |                      \
    \    |\n   |                          you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of method `insert`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdhc3fi_w.rs:29:51\n   |\n29 |\
    \         new_string = new_string.insert(prev_char, word);\n   |             \
    \                                      ^^^^ expected `char`, found `&str`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpdhc3fi_w.rs:29:22\n   |\n14 |  \
    \   let mut new_string = s;\n   |                          - expected due to this\
    \ value\n...\n29 |         new_string = new_string.insert(prev_char, word);\n\
    \   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found `()`\n   |\nnote: method `insert` modifies its receiver in-place\n\
    \  --> /tmp/tmpdhc3fi_w.rs:29:33\n   |\n29 |         new_string = new_string.insert(prev_char,\
    \ word);\n   |                      ---------- ^^^^^^ this call modifies `new_string`\
    \ in-place\n   |                      |\n   |                      you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `insert`\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    if s.len() == 0 {\n        return s;\n    }\n    let mut s\
    \ = s;\n    let mut prev: Option<String> = None;\n    for c in s.chars() {\n \
    \       let cur = c.to_ascii_lowercase();\n        if prev.is_some() && cur >\
    \ prev.unwrap().to_ascii_lowercase() {\n            s.replace(prev, cur);\n  \
    \      } else {\n            prev = Some(cur);\n        }\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpk87amvth.rs:21:36\n   |\n\
    21 |         if prev.is_some() && cur > prev.unwrap().to_ascii_lowercase() {\n\
    \   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `char`, found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpk87amvth.rs:22:29\n\
    \   |\n22 |             s.replace(prev, cur);\n   |                          \
    \   ^^^ expected `&str`, found `char`\n\nerror[E0277]: expected a `FnMut<(char,)>`\
    \ closure, found `Option<String>`\n   --> /tmp/tmpk87amvth.rs:22:23\n    |\n22\
    \  |             s.replace(prev, cur);\n    |               ------- ^^^^ expected\
    \ an `FnMut<(char,)>` closure, found `Option<String>`\n    |               |\n\
    \    |               required by a bound introduced by this call\n    |\n    =\
    \ help: the trait `FnMut<(char,)>` is not implemented for `Option<String>`\n \
    \   = help: the following other types implement trait `Pattern<'a>`:\n       \
    \       &'b String\n              &'b [char; N]\n              &'b [char]\n  \
    \            &'b str\n              &'c &'b str\n              [char; N]\n   \
    \           char\n              pattern::MultiCharEqPattern<C>\n    = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `Option<String>`\n\
    note: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpk87amvth.rs:24:25\n   |\n24 |             prev = Some(cur);\n\
    \   |                         ^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                         |\n   |                         expected struct\
    \ `String`, found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Create an array of word characters and sort it in ascending\
    \ order\n    // based on ascii value.\n    let words: Vec<Char> = s.chars().collect();\n\
    \    let mut chars = Vec::new();\n\n    // Collect individual characters from\
    \ a string into a Vec<Char>\n    for word in words {\n        chars.push(Char::from_u32(word.into()));\n\
    \    }\n\n    chars.sort_unstable();\n\n    // Join the sorted Vec<Char> into\
    \ a String and return the result.\n    s.chars()\n        .map(|c| Char::from_u32(c))\n\
    \        .collect::<String>()\n        .to_string()\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpexrvr6is.rs:21:20\n\
    \   |\n21 |         chars.push(Char::from_u32(word.into()));\n   |           \
    \         ^^^^ use of undeclared type `Char`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `Char`\n  --> /tmp/tmpexrvr6is.rs:28:18\n   |\n28 | \
    \        .map(|c| Char::from_u32(c))\n   |                  ^^^^ use of undeclared\
    \ type `Char`\n\nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpexrvr6is.rs:16:20\n\
    \   |\n16 |     let words: Vec<Char> = s.chars().collect();\n   |            \
    \        ^^^^\n   |\nhelp: a builtin type with a similar name exists\n   |\n16\
    \ |     let words: Vec<char> = s.chars().collect();\n   |                    ~~~~\n\
    help: you might be missing a type parameter\n   |\n13 | fn anti_shuffle<Char>(s:\
    \ String) -> String {\n   |                ++++++\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0412, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a,b| a.cmp(b)).collect::<Vec<String>>().join('\
    \ ')\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp9a0_6c4n.rs:14:26\n   |\n14 |     s.split_whitespace().sort_by(|a,b|\
    \ a.cmp(b)).collect::<Vec<String>>().join(' ')\n   |                         \
    \ ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.clone();\n    for c in s.chars() {\n        if\
    \ let Some(old_pos) = s.find(c, 0) {\n            s.insert(old_pos, char::from_u32(c.code()).unwrap());\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \    --> /tmp/tmprkywd3f9.rs:16:34\n     |\n16   |         if let Some(old_pos)\
    \ = s.find(c, 0) {\n     |                                  ^^^^ -  - supplied\
    \ 2 arguments\n     |                                  |\n     |             \
    \                     expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0599]: no method named `code` found for type `char` in the current\
    \ scope\n  --> /tmp/tmprkywd3f9.rs:17:48\n   |\n17 |             s.insert(old_pos,\
    \ char::from_u32(c.code()).unwrap());\n   |                                  \
    \              ^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n\n    // create a map of original\
    \ characters to new characters\n    let mut chars_map = HashMap::new();\n    chars.for_each(|c|\
    \ chars_map.insert(c, c));\n\n    // traverse the string and replace characters\
    \ in the original string\n    // with new characters\n    s.split_whitespace().for_each(|word|\
    \ {\n        word.chars().for_each(|c| chars_map.insert(c, c));\n    });\n\n \
    \   // create a new string from the new characters\n    s.chars().for_each(|c|\
    \ chars_map.insert(c, c));\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpb7y67ht4.rs:17:25\n   |\n17 |     let mut chars_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.split_whitespace();\n    let mut result = String::from(\"\
    \");\n    for (i, c) in s.chars().enumerate() {\n        if i >= 2 {\n       \
    \     let a = s.split_at(i + 1);\n            result.push_str(&a[0].to_string());\n\
    \            result.push(c);\n            result.push_str(&a[1].to_string());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp15ps_s53.rs:16:21\n   |\n16 |     for (i,\
    \ c) in s.chars().enumerate() {\n   |                     ^^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `split_at` found for\
    \ struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp15ps_s53.rs:18:23\n\
    \   |\n18 |             let a = s.split_at(i + 1);\n   |                     \
    \  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut new_s = s.clone();\n    new_s.shuffle();\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `shuffle` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp4ag0hv4o.rs:16:11\n   |\n16 |     new_s.shuffle();\n\
    \   |           ^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = String::new();\n    let mut i = 0;\n    let\
    \ mut j = 0;\n    while i < s.len() {\n        while j + 1 < s.len() && s[i] <=\
    \ s[j] {\n            j += 1\n        }\n        buffer.push_str(&s[i .. j]);\n\
    \        i += j;\n        j = 0;\n        while i + 1 < s.len() && s[i] >= s[j]\
    \ {\n            i += 1;\n        }\n        buffer.push_str(&s[i .. j]);\n  \
    \      i += 1;\n    }\n    buffer\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3mqtdgm3.rs:18:34\n\
    \   |\n18 |         while j + 1 < s.len() && s[i] <= s[j] {\n   |            \
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp3mqtdgm3.rs:18:42\n\
    \   |\n18 |         while j + 1 < s.len() && s[i] <= s[j] {\n   |            \
    \                              ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3mqtdgm3.rs:24:34\n   |\n24 |         while i + 1 < s.len() &&\
    \ s[i] >= s[j] {\n   |                                  ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \      "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars_array = s.chars().collect::<Vec<Char>>();\n \
    \   let mut chars_copy = chars_array.clone();\n    chars_copy.sort_unstable_by_key(|c|\
    \ c.to_ascii_lowercase());\n    let mut result = String::new();\n    chars_copy.iter().for_each(|c|\
    \ {\n        result += c;\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpbwpdiyhs.rs:14:51\n\
    \   |\n14 |     let mut chars_array = s.chars().collect::<Vec<Char>>();\n   |\
    \                                                   ^^^^\n   |\nhelp: a builtin\
    \ type with a similar name exists\n   |\n14 |     let mut chars_array = s.chars().collect::<Vec<char>>();\n\
    \   |                                                   ~~~~\nhelp: you might\
    \ be missing a type parameter\n   |\n13 | fn anti_shuffle<Char>(s: String) ->\
    \ String {\n   |                ++++++\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut map = HashMap::new();\n    for c in s.chars() {\n \
    \       map.insert(c, map.get(c).cloned());\n    }\n    let mut output = Vec::new();\n\
    \    for c in map.keys() {\n        for &(c1, _) in map.iter().filter_map(|(_,\
    \ c2)| c1 < c2) {\n            output.push(c1);\n        }\n    }\n    String::from(output).to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpm5gwkmkp.rs:14:19\n   |\n14 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find value `c1` in this scope\n  --> /tmp/tmpm5gwkmkp.rs:20:57\n   |\n\
    20 |         for &(c1, _) in map.iter().filter_map(|(_, c2)| c1 < c2) {\n   |\
    \                                                         ^^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0277]: the trait bound `String: From<Vec<_>>`\
    \ is not satisfied\n  --> /tmp/tmpm5gwkmkp.rs:24:5\n   |\n24 |     String::from(output).to_string()\n\
    \   |     ^^^^^^^^^^^^ the trait `From<Vec<_>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.split_whitespace();\n    words.sort();\n\
    \    let mut result = String::new();\n    words.for_each(|word| {\n        let\
    \ mut new_word = word;\n        for c in new_word {\n            if c.is_ascii()\
    \ {\n                new_word = new_word.insert(new_word.index(c) + 1, ' ');\n\
    \            }\n        }\n        result.push(new_word);\n    });\n    result\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpazr5e53a.rs:15:11\n   |\n15 |     words.sort();\n\
    \   |           ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0277]:\
    \ `&str` is not an iterator\n  --> /tmp/tmpazr5e53a.rs:19:18\n   |\n19 |     \
    \    for c in new_word {\n   |                  ^^^^^^^^ `&str` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `&str`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&str`\n\nerror[E0599]: no method named `insert`\
    \ found for reference `&str` in the current scope\n  --> /tmp/tmpazr5e53a.rs:21:37\n\
    \   |\n21 |                 new_word = new_word.insert(new_word.index(c) + 1,\
    \ ' ');\n   |                                     ^^^^^^ method not found in `&str`\n\
    \nerror[E0599]: no method named `index` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpazr5e53a.rs:21:53\n   |\n21 |                 new_word\
    \ = new_word.insert(new_word.index(c) + 1, ' ');\n   |                       \
    \                              ^^^^^ method not found in `&str`\n   |\n   = help:\
    \ items from traits can only be used if the trait is in scope\nhelp: the following\
    \ trait is implemented but not in scope; perhaps add a `use` for it:\n   |\n1\
    \  | use std::ops::Index;\n   |\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpazr5e53a.rs:24:21\n\
    \   |\n24 |         result.push(new_word);\n   |                     ^^^^^^^^\
    \ expected `char`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Get words\n    let mut words = s.split_whitespace();\n\n\
    \    // Sort by ascii value\n    words.sort_by_key(|word| word.chars().fold(0,\
    \ |acc, x| acc + x));\n\n    // Replace words according to order\n    words\n\
    \        .iter()\n        .map(|word| word.chars().fold(\"\", |acc, x| acc + x.to_string()))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_ochjynv.rs:18:11\n   |\n18 |     words.sort_by_key(|word|\
    \ word.chars().fold(0, |acc, x| acc + x));\n   |           ^^^^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `iter` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp_ochjynv.rs:22:10\n\
    \   |\n22 |         .iter()\n   |          ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new: String = s.clone();\n    let mut new_words = Vec::with_capacity(s.len());\n\
    \n    let mut i = 0;\n    while i < new.len() {\n        let mut j = i;\n    \
    \    while i + 1 < new.len() && new[i + 1] == ' ' {\n            i += 1;\n   \
    \     }\n\n        let mut j = i;\n        while j + 1 < new.len() && new[j +\
    \ 1] == '.' {\n            j += 1;\n        }\n        let mut j = i;\n      \
    \  while j + 1 < new.len() && new[j + 1] == ' ' {\n            j += 1;\n     \
    \   }\n\n        let mut new1 = new.clone();\n\n        if j > i {\n         \
    \   new1[i - 1] = new[j];\n            new1.swap(i, j);\n        }\n\n       \
    \ new_words.push(new1);\n\n        i += j - i;\n    }\n    new_words.reverse();\n\
    \    new_words.dedup();\n    new_words\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp0mcnqc3w.rs:20:36\n\
    \   |\n20 |         while i + 1 < new.len() && new[i + 1] == ' ' {\n   |     \
    \                               ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0mcnqc3w.rs:25:36\n   |\n25 |         while j + 1 < new.len() &&\
    \ new[j + 1] == '.' {\n   |                                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp0mcnqc3w.rs:29:36\n   |\n29 |         while j + 1 < new.len() &&\
    \ new[j + 1] == ' ' {\n   |                                    ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as I"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().collect::<Vec<_>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpj56q3rvx.rs:14:60\n\
    \   |\n14 |     s.chars().collect::<Vec<_>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                                            ^^^^^^^ `()`\
    \ is not an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut string: String = s;\n    let mut len: usize = 0;\n\
    \    while !string.is_empty() {\n        let mut first: Char = string[0];\n  \
    \      string.swap(0, 1);\n        string.swap(1, 0);\n        if first == ' '\
    \ {\n            len += 1;\n        } else {\n            len += 2;\n        }\n\
    \    }\n    string\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpoq3akfcm.rs:17:24\n\
    \   |\n17 |         let mut first: Char = string[0];\n   |                   \
    \     ^^^^ help: a builtin type with a similar name exists (notice the capitalization):\
    \ `char`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpoq3akfcm.rs:17:31\n   |\n17 |         let mut first: Char = string[0];\n\
    \   |                               ^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpoq3akfcm.rs:18:16\n   |\n18 |         string.swap(0,\
    \ 1);\n   |                ^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpoq3akfcm.rs:19:16\n   |\n19 |         string.swap(1, 0);\n   |     \
    \           ^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0412, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = String::new();\n    let mut blank_spaces =\
    \ String::new();\n    let mut new_word = String::new();\n    let mut ascii_value\
    \ = 0;\n    let mut next_char = 0;\n    let mut ascii_pos = 0;\n    for c in s.chars()\
    \ {\n        ascii_value += c as u32;\n        if ascii_pos == 0 {\n         \
    \   blank_spaces.push(chars::to_string(c));\n        }\n        ascii_pos += 1;\n\
    \        if ascii_pos == 4 && ascii_value >= 65 {\n            ascii_pos += 1;\n\
    \            ascii_value -= 65;\n        }\n        if ascii_pos == 5 && ascii_value\
    \ >= 97 {\n            ascii_pos += 1;\n            ascii_value -= 97;\n     \
    \   }\n        if ascii_pos == 6 && ascii_value >= 102 {\n            ascii_pos\
    \ += 1;\n            ascii_value -= 102;\n        }\n        if ascii_pos == 7\
    \ && ascii_value >= 48 {\n            ascii_pos += 1;\n            ascii_value\
    \ -= 48;\n        }\n        if ascii_pos == 8 && ascii_value >= 58 {\n      \
    \      ascii_pos += 1;\n            ascii_value -= 58;\n        }\n        if\
    \ ascii_pos == 9 && ascii_value >= 49 {\n            ascii_pos += 1;\n       \
    \     ascii_value -= 49;\n        }\n        if ascii_pos == 10 && ascii_value\
    \ >= 51 {\n            ascii_pos += 1;\n            ascii_value -= 51;\n     \
    \   }\n        if ascii_pos == 11 && ascii_value >= 55 {\n            ascii_pos\
    \ += 1;\n            ascii_value -= 55;\n        }\n        if ascii_pos == 12\
    \ && ascii_value >= 91 {\n            ascii_pos += 1;\n            ascii_value\
    \ -= 91;\n        }\n        if ascii_pos == 13 && ascii_value >= 93 {\n     \
    \       ascii_pos += 1;\n            ascii_value -= 93;\n        }\n        if\
    \ ascii_pos == 14 && ascii_value >= 123 {\n            ascii_pos += 1;\n     \
    \       ascii_value -= 123;\n        }\n        if ascii_pos == 15 && ascii_value\
    \ >= 126 {\n            ascii_pos += 1;\n            ascii_value -= 126;\n   \
    \     }\n        if ascii_pos == 16 && ascii_value >= 124 {\n            ascii_pos\
    \ += 1;\n            ascii_value -= 124;\n        }\n        if ascii_pos == 17\
    \ && ascii_value >= 125 {\n            ascii_pos += 1;\n            ascii_value\
    \ -= 125;\n        }\n        if ascii_pos == 18 && ascii_value >= 92 {\n    \
    \        ascii_pos += 1;\n            ascii_value -= 92;\n        }\n        if\
    \ ascii_pos == 19 && ascii_value >= 97 {\n            ascii_po\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp7tyha6fy.rs:99:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n20 |     for c in s.chars() {\n \
    \  |                        - unclosed delimiter\n...\n86 |         if ascii_pos\
    \ == 19 && ascii_value >= 97 {\n   |                                         \
    \        - this delimiter might not be properly closed...\n87 |             ascii_po\n\
    88 | }\n   | - ...as it matches this but it has different indentation\n...\n99\
    \ | }\n   |   ^\n\nerror[E0433]: failed to resolve: use of undeclared crate or\
    \ module `chars`\n  --> /tmp/tmp7tyha6fy.rs:23:31\n   |\n23 |             blank_spaces.push(chars::to_string(c));\n\
    \   |                               ^^^^^ use of undeclared crate or module `chars`\n\
    \nerror[E0425]: cannot find value `ascii_po` in this scope\n  --> /tmp/tmp7tyha6fy.rs:87:13\n\
    \   |\n87 |             ascii_po\n   |             ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `ascii_pos`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7tyha6fy.rs:20:5\n   |\n13 |   fn anti_shuffle(s: String) -> String\
    \ {\n   |                                 ------ expected `String` because of\
    \ return type\n...\n20 | /     for c in s.chars() {\n21 | |         ascii_value\
    \ += c as u32;\n22 | |         if ascii_pos == 0 {\n23 | |             blank_spaces.push(chars::to_string(c));\n\
    ...  |\n98 | |     assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot.\
    \ How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?...\n\
    99 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut output = String::from(s);\n    let mut output_vec =\
    \ Vec::new();\n    for ch in s.chars() {\n        if ch != ' ' {\n           \
    \ output_vec.push(ch);\n        } else {\n            let j = output_vec.len()\
    \ - 1;\n            output_vec.swap(j, j + 1);\n        }\n    }\n    output =\
    \ output_vec.iter().cloned().collect();\n    output\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: value assigned to `output` is never read\n  --> /tmp/tmpqx7eyav5.rs:14:13\n\
    \   |\n14 |     let mut output = String::from(s);\n   |             ^^^^^^\n \
    \  |\n   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe\
    \ it is overwritten before being read?\n\nerror[E0382]: borrow of moved value:\
    \ `s`\n  --> /tmp/tmpqx7eyav5.rs:16:15\n   |\n13 | fn anti_shuffle(s: String)\
    \ -> String {\n   |                 - move occurs because `s` has type `String`,\
    \ which does not implement the `Copy` trait\n14 |     let mut output = String::from(s);\n\
    \   |                                   - value moved here\n15 |     let mut output_vec\
    \ = Vec::new();\n16 |     for ch in s.chars() {\n   |               ^^^^^^^^^\
    \ value borrowed here after move\n   |\n   = note: borrow occurs due to deref\
    \ coercion to `str`\n\nerror: aborting due to previous error; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0382`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a, b| b.cmp(a)).join()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpfyp2ipl2.rs:14:26\n   |\n14 |     s.split_whitespace().sort_by(|a,\
    \ b| b.cmp(a)).join()\n   |                          ^^^^^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.to_lowercase()\n        .split_whitespace()\n        .collect::<Vec<_>>()\n\
    \        .sort();\n\n    s.into_iter().collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmpiq9pw_xq.rs:19:7\n    |\n19\
    \  |       s.into_iter().collect::<String>()\n    |         ^^^^^^^^^\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `String: IntoIterator`\n       \
    \     `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = String::new();\n    for c in s.chars() {\n\
    \        match c {\n            ' ' => buffer.push_str(c),\n            '\\t'\
    \ => buffer.push_str(\"\\t\"),\n            '\\r' => buffer.push_str(\"\\r\"),\n\
    \            '\\n' => buffer.push_str(\"\\n\"),\n            _ => buffer.push_str(c),\n\
    \        }\n    }\n    buffer\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8w_lhjsf.rs:17:36\n   |\n\
    17 |             ' ' => buffer.push_str(c),\n   |                            \
    \        ^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp8w_lhjsf.rs:21:34\n   |\n21 |             _ => buffer.push_str(c),\n\
    \   |                                  ^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::from(\"\");\n    let mut sorted_str =\
    \ s.to_ascii_lowercase();\n    sorted_str.split(\" \").sort().for_each(|word|\
    \ {\n        res.push_str(&word);\n        res.push_str(\"!\");\n    });\n   \
    \ res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpp2qmbvds.rs:16:27\n   |\n16 |     sorted_str.split(\"\
    \ \").sort().for_each(|word| {\n   |                           ^^^^ method not\
    \ found in `std::str::Split<'_, &str>`\n\nerror[E0277]: the size for values of\
    \ type `str` cannot be known at compilation time\n  --> /tmp/tmpp2qmbvds.rs:16:44\n\
    \   |\n16 |     sorted_str.split(\" \").sort().for_each(|word| {\n   |       \
    \                                     ^^^^ doesn't have a size known at compile-time\n\
    \   |\n   = help: the trait `Sized` is not implemented for `str`\nhelp: function\
    \ arguments must have a statically known size, borrowed types always have a known\
    \ size\n   |\n16 |     sorted_str.split(\" \").sort().for_each(|&word| {\n   |\
    \                                            +\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|&x| x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n\
    \    s.sort_by_key(|&x| x.chars().count());\n    s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpcysrrerl.rs:15:7\n   |\n15 |     s.sort_by_key(|&x|\
    \ x.chars().map(|c| c.to_ascii_lowercase()).collect::<Vec<_>>());\n   |      \
    \ ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpcysrrerl.rs:16:7\n\
    \   |\n16 |     s.sort_by_key(|&x| x.chars().count());\n   |       ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 2 previous errors\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().cloned().map(|c| {\n        let d = c as usize;\n\
    \        match d {\n            0 => c,\n            d => d,\n        }\n    }).chain(s.chars().enumerate()).filter(|(i,\
    \ c)| {\n        c as usize == 0\n    }).map(|(i, c)| {\n        (c as char, i)\n\
    \    }).fold(String::new(), |mut acc, pair| {\n        acc.insert_with(|| {\n\
    \            pair.0\n        }).chain(acc.insert_with(|| {\n            pair.1\n\
    \        })).collect();\n        acc\n    });\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp48eav5sa.rs:14:15\n     |\n14   |     s.chars().cloned().map(|c|\
    \ {\n     |               ^^^^^^ expected reference, found `char`\n     |\n  \
    \   = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `map` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmp48eav5sa.rs:14:24\n   |\n14 |       s.chars().cloned().map(|c| {\n \
    \  |                          ^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp48eav5sa.rs:13:31\n   |\n13 |\
    \ fn anti_shuffle(s: String) -> String {\n   |    ------------               ^^^^^^\
    \ expected struct `String`, found `()`\n   |    |\n   |    implicitly returns\
    \ `()` as its body has no tail or `return` expression\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0271, E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result: String = \"\";\n    for c in s.chars() {\n\
    \        let ascii = (c as u32).to_ascii_lowercase();\n        result += &ascii[..];\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg4ci65n9.rs:14:30\n   |\n\
    14 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0599]: no method\
    \ named `to_ascii_lowercase` found for type `u32` in the current scope\n  -->\
    \ /tmp/tmpg4ci65n9.rs:16:32\n   |\n16 |         let ascii = (c as u32).to_ascii_lowercase();\n\
    \   |                                ^^^^^^^^^^^^^^^^^^ method not found in `u32`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c| {\n            if c < ' ' {\n \
    \               c\n            } else {\n                c as char\n         \
    \   }\n        })\n        .sort_by_key(|c| c)\n        .collect()\n        .to_owned()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Map` in the\
    \ current scope\n  --> /tmp/tmp2pwqb4_z.rs:22:10\n   |\n22 |         .sort_by_key(|c|\
    \ c)\n   |          ^^^^^^^^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmp2pwqb4_z.rs:15:14:\
    \ 21:10]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    use std::collections::HashSet;\n    let mut c = HashSet::new();\n\
    \    let mut re = String::new();\n\n    for (i, w) in s.chars().enumerate() {\n\
    \        let c = w.to_ascii_lowercase();\n        if !c.is_ascii_lowercase() {\n\
    \            continue;\n        }\n        c.insert(c);\n\n        let s = &w.to_string();\n\
    \        let r = String::from(\"_\").to_string();\n\n        for r in s.chars()\
    \ {\n            if c.contains(&r) { break; }\n        }\n        re = re.append(&r).unwrap();\n\
    \    }\n\n    re.chars()\n        .cloned()\n        .collect::<Vec<u32>>()\n\
    \        .join(\"\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `insert` found for type `char` in the current\
    \ scope\n  --> /tmp/tmps4tjgoa3.rs:23:11\n   |\n23 |         c.insert(c);\n  \
    \ |           ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `contains` found for type `char` in the current scope\n  --> /tmp/tmps4tjgoa3.rs:29:18\n\
    \   |\n29 |             if c.contains(&r) { break; }\n   |                  ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmps4tjgoa3.rs:31:17\n   |\n\
    31 |         re = re.append(&r).unwrap();\n   |                 ^^^^^^ method\
    \ not found in `String`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as\
    \ Iterator>::Item == &_`\n    --> /tmp/tmps4tjgoa3.rs:35:10\n     |\n35   |  \
    \       .cloned()\n     |          ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmps4tjgoa3.rs:36:10\n   |\n36 |           .collect::<Vec<u32>>()\n\
    \   |            ^^^^^^^ method cannot be called on `Cloned<Chars<'_>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n           which\
    \ is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut counts: Vec<usize> = s.split_whitespace().collect();\n\
    \    for i in (0..s.chars().count() - 1).rev() {\n        let c = s.chars().get_mut(i);\n\
    \        let n = counts[i];\n        counts.swap(i, n - 1);\n        for j in\
    \ (0..n - 1).rev() {\n            let b = counts[j];\n            s.replace(c,\
    \ b, c);\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<usize>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp48d4uvb4.rs:15:55\n     |\n15\
    \   |     let mut counts: Vec<usize> = s.split_whitespace().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<usize>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `get_mut` found for\
    \ struct `Chars` in the current scope\n   --> /tmp/tmp48d4uvb4.rs:17:27\n    |\n\
    17  |         let c = s.chars().get_mut(i);\n    |                           ^^^^^^^\
    \ method not found in `Chars<'_>`\n    |\nhelp: consider wrapping the receiver\
    \ expression with the appropriate type\n    |\n17  |         let c = Pin::new(&mut\
    \ s.chars()).get_mut(i);\n    |                 +++++++++++++          +\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmp48d4uvb4.rs:22:15\n\
    \    |\n22  |             s.replace(c, b, c);\n    |               ^^^^^^^ - \
    \ -  - supplied 3 arguments\n    |               |\n    |               expected\
    \ 2 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0061, E0277,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a, b| a.cmp(b)).collect::<Vec<String>>()\n\
    \        .into_iter()\n        .map(|w| w.chars().collect::<String>().to_string())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpcmwipn90.rs:14:26\n   |\n14 |     s.split_whitespace().sort_by(|a,\
    \ b| a.cmp(b)).collect::<Vec<String>>()\n   |                          ^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buf = [0; s.len()];\n    let mut pos = 0;\n    let\
    \ mut j = s.len();\n    while pos < s.len() {\n        buf[pos] = j;\n       \
    \ pos += 1;\n        while pos < s.len() {\n            if s[pos] == ' ' {\n \
    \               buf[pos] = j;\n                pos += 1;\n            } else {\n\
    \                if buf[pos] < j {\n                    buf[pos] = j;\n      \
    \              pos += 1;\n                } else {\n                    buf[pos]\
    \ = buf[pos] + 1;\n                    pos += 1;\n                }\n        \
    \    }\n        }\n    }\n    s.from_ascii_lowercase(&mut buf[..]);\n    s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpzrseyskj.rs:14:23\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |                 - this would need to be a `const`\n14 |     let mut buf\
    \ = [0; s.len()];\n   |                       ^\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpzrseyskj.rs:21:16\n   |\n21 |  \
    \           if s[pos] == ' ' {\n   |                ^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `from_ascii_lowercase` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpzrseyskj.rs:35:7\n   |\n\
    35 |     s.from_ascii_lowercase(&mut buf[..]);\n   |       ^^^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0435, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().enumerate().flat_map(|(i, c)| {\n        if c !=\
    \ ' ' {\n            vec![i.to_owned(), c]\n        } else {\n            vec![]\n\
    \        }\n    })\n    .collect::<Vec<_>>()\n    .iter()\n    .cloned()\n   \
    \ .sorted()\n    .collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpccvqkywy.rs:16:32\n   |\n\
    16 |             vec![i.to_owned(), c]\n   |                                ^\
    \ expected `usize`, found `char`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // We will store the result here\n    let mut result = String::from(\"\
    \");\n\n    // We will iterate through the string one character at a time\n  \
    \  for i in s.chars().cloned() {\n        // We will check if the current character\
    \ is space or a character\n        // that is between space and non-space.\n \
    \       if i > ' ' && i <'a' {\n            // We will append the character to\
    \ the result\n            result += &s.chars().skip(1).collect::<String>().to_string();\n\
    \        }\n        // We will check if the character is non-space or a character\n\
    \        // that is between non-space and space.\n        if i > 'a' && i < 'z'\
    \ {\n            // We will append the character to the result\n            result\
    \ += &s.chars().skip(1).collect::<String>().to_string();\n        }\n        //\
    \ We will check if the character is non-space or a character\n        // that\
    \ is between non-space and space.\n        if i > 'A' && i < 'Z' {\n         \
    \   // We will append the character to the result\n            result += &s.chars().skip(1).collect::<String>().to_string();\n\
    \        }\n        // We will check if the character is non-space or a character\n\
    \        // that is between non-space and space.\n        if i > '0' && i < '9'\
    \ {\n            // We will append the character to the result\n            result\
    \ += &s.chars().skip(1).collect::<String>().to_string();\n        }\n        //\
    \ We will check if the character is non-space or a character\n        // that\
    \ is between non-space and space.\n        if i > 'a' && i < 'z' {\n         \
    \   // We will append the character to the result\n            result += &s.chars().skip(1).collect::<String>().to_string();\n\
    \        }\n        // We will check if the character is non-space or a character\n\
    \        // that is between non-space and space.\n        if i > 'A' && i < 'Z'\
    \ {\n            // We will append the character to the result\n            result\
    \ += &s.chars().skip(1).collect::<String>().to_string();\n        }\n        //\
    \ We will check if the character is non-space or a character\n        // that\
    \ is between non-space and space.\n        if i > '0' && i < '9' {\n         \
    \   // We will append the character to the result\n            result += &s.chars().skip(1).collect::<String>().to_string();\n\
    \        }\n        // We will check if the character is non-space or a character\n\
    \        // that is between non-space and space.\n        if i > 'A' && i < 'Z'\
    \ {\n            // We will append the character to the result\n            result\
    \ += &s.chars().skip(1).collect::<String>().to_string();\n        }\n        //\
    \ We will check if the character is \n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpbvi6vigo.rs:79:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     for i in s.chars().cloned()\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n68 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n79 | }\n   |   ^\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as\
    \ Iterator>::Item == &_`\n    --> /tmp/tmpbvi6vigo.rs:18:24\n     |\n18   |  \
    \   for i in s.chars().cloned() {\n     |                        ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpbvi6vigo.rs:18:14\n   |\n18 |     for i in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpbvi6vigo.rs:18:14\n   |\n18 |     for\
    \ i in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbvi6vigo.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0271, E0308.\n\
    For more information "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    for &c in s.chars() {\n        let ord_val\
    \ = c.to_ascii_lowercase().unwrap();\n        s.replace(c.unwrap(), ord_val);\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpor0ymr4p.rs:15:9\n   |\n\
    15 |     for &c in s.chars() {\n   |         ^^    --------- this expression has\
    \ type `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.into_iter().map(|c| c.to_ascii_lowercase()).chain(s.chars()).chain(s.word_breaks()).map(|w|\
    \ w.to_string()).collect::<Vec<_>>().into_iter().map(|w| {\n        let mut a\
    \ = w.to_ascii_lowercase();\n        a.sort_unstable();\n        String::from(a)\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp1wxkiied.rs:14:7\n    |\n14\
    \  |       s.into_iter().map(|c| c.to_ascii_lowercase()).chain(s.chars()).chain(s.word_breaks()).map(|w|\
    \ w.to_string()).collect::<Vec<_>>().into...\n    |         ^^^^^^^^^\n    |\n\
    \    = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `String: IntoIterator`\n       \
    \     `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0599]: no method named `word_breaks`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp1wxkiied.rs:14:76\n\
    \   |\n14 |     s.into_iter().map(|c| c.to_ascii_lowercase()).chain(s.chars()).chain(s.word_breaks()).map(|w|\
    \ w.to_string()).collect::<Vec<_>>().into...\n   |                           \
    \                                                 ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().enumerate().filter_map(|(i, c)| (*c > 96 && *c <\
    \ 123)) // Filter all characters that are not a-z, A-Z, 0-9 or special characters\n\
    \        .map(|(i, c)| {\n            if *c == ' ' { // If character is space\n\
    \                s.to_string().to_string().chars().enumerate().filter_map(|(j,\
    \ w)| {\n                    if w == ' ' { // Check if next character is also\
    \ space\n                        i != j // Make sure we are not skipping space\n\
    \                    } else { // If character is not space, return char\n    \
    \                    Some(w)\n                    }\n                }).collect::<Vec<_>>()\n\
    \            } else { // If character is not space, return char\n            \
    \    Some(c)\n            }\n        }).collect::<Vec<_>>()\n        .sort_unstable()\
    \ // Sort\n        .collect::<String>() // Convert to String again\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpbtdx0b4b.rs:14:48\n\
    \   |\n14 |     s.chars().enumerate().filter_map(|(i, c)| (*c > 96 && *c < 123))\
    \ // Filter all characters that are not a-z, A-Z, 0-9 or special chara...\n  \
    \ |                                                ^^\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpbtdx0b4b.rs:14:59\n   |\n14 |     s.chars().enumerate().filter_map(|(i,\
    \ c)| (*c > 96 && *c < 123)) // Filter all characters that are not a-z, A-Z, 0-9\
    \ or special chara...\n   |                                                  \
    \         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbtdx0b4b.rs:14:47\n\
    \   |\n14 |     s.chars().enumerate().filter_map(|(i, c)| (*c > 96 && *c < 123))\
    \ // Filter all characters that are not a-z, A-Z, 0-9 or special chara...\n  \
    \ |                                               ^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n14 |     s.chars().enumerate().filter_map(|(i, c)| Some((*c > 96 && *c\
    \ < 123))) // Filter all characters that are not a-z, A-Z, 0-9 or special characters\n\
    \   |                                               +++++                    \
    \ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbtdx0b4b.rs:19:25\n   |\n\
    19 |                         i != j // Make sure we are not skipping space\n \
    \  |                         ^^^^^^ expected enum `Option`, found `bool`\n   |\n\
    \   = note: expected enum `Option<_>`\n              found type `bool`\nhelp:\
    \ try wrapping the expression in `Some`\n   |\n19 |                         Some(i\
    \ != j) // Make sure we are not skipping space\n   |                         +++++\
    \      +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buf = String::with_capacity(s.len());\n    for c in\
    \ s.chars() {\n        if c.is_ascii() {\n            buf.push(c);\n        }\
    \ else {\n            if buf.is_empty() {\n                buf.push(c);\n    \
    \        } else {\n                buf.push('_');\n                buf.push(c);\n\
    \            }\n        }\n    }\n    buf\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpkua1wid4.rs:33:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    while !chars.next().is_none()\
    \ {\n        let mut buffer = String::with_capacity(s.len());\n        while !chars.next().is_none()\
    \ {\n            buffer.push(chars.next().unwrap().to_string());\n        }\n\
    \        chars = anti_shuffle(chars, &mut buffer);\n    }\n    chars.next()\n\
    \        .expect(\"No characters in the sentence\")\n        .to_string()\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpmeo6ugd1.rs:18:25\n   |\n\
    18 |             buffer.push(chars.next().unwrap().to_string());\n   |       \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0061]: this function takes 1 argument but 2 arguments were\
    \ supplied\n  --> /tmp/tmpmeo6ugd1.rs:20:17\n   |\n20 |         chars = anti_shuffle(chars,\
    \ &mut buffer);\n   |                 ^^^^^^^^^^^^ -----  ----------- supplied\
    \ 2 arguments\n   |                 |\n   |                 expected 1 argument\n\
    \   |\nnote: function defined here\n  --> /tmp/tmpmeo6ugd1.rs:13:4\n   |\n13 |\
    \ fn anti_shuffle(s: String) -> String {\n   |    ^^^^^^^^^^^^ ---------\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpmeo6ugd1.rs:20:17\n   |\n14 |     let mut chars\
    \ = s.chars();\n   |                     --------- expected due to this value\n\
    ...\n20 |         chars = anti_shuffle(chars, &mut buffer);\n   |            \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Chars`, found struct `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c.is_ascii_letter())\n     \
    \   .map(|c| {\n            match c.ascii_digit() {\n                0 => c.to_string(),\n\
    \                other => other\n            }\n        })\n        .collect()\n\
    \        .sort_by_key(|x| x.to_string())\n        .collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp1b9ewj4_.rs:15:23\n   |\n15 |         .filter(|c|\
    \ c.is_ascii_letter())\n   |                       ^^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `is_ascii`\n\nerror[E0599]: no\
    \ method named `ascii_digit` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp1b9ewj4_.rs:17:21\n   |\n17 |             match c.ascii_digit() {\n\
    \   |                     ^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii_digit`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a, b| a.cmp(b)).join().to_string()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpgc91rklm.rs:14:26\n   |\n14 |     s.split_whitespace().sort_by(|a,\
    \ b| a.cmp(b)).join().to_string()\n   |                          ^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n\n    let mut new_chars = Vec::new();\n\
    \    new_chars.extend_from_slice(&mut chars.clone());\n\n    while !new_chars.is_empty()\
    \ {\n        let mut new_char = new_chars.remove(0);\n        let mut previous_char\
    \ = '';\n        let mut new_length = 0;\n        while !new_char.is_empty() {\n\
    \            let char_code = new_char.chars().next().unwrap().to_ascii_lowercase();\n\
    \n            if new_length == 0 {\n                new_chars.insert(new_char,\
    \ new_chars.remove(new_char));\n                new_chars = new_chars.into_iter().map(|x|\
    \ x.to_ascii_lowercase()).collect();\n                new_length = 1;\n      \
    \          continue;\n            } else if previous_char != char_code {\n   \
    \             new_chars.insert(new_char, new_chars.remove(new_char));\n      \
    \          new_chars = new_chars.into_iter().map(|x| x.to_ascii_lowercase()).collect();\n\
    \                new_length = 1;\n            } else {\n                new_chars.insert(new_char,\
    \ new_chars.remove(new_char));\n                new_length += 1;\n           \
    \ }\n            previous_char = char_code;\n        }\n    }\n\n    new_chars.into_iter().map(|x|\
    \ x.to_ascii_lowercase()).collect().to_string()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmpp1gc33wh.rs:21:34\n   |\n\
    21 |         let mut previous_char = '';\n   |                               \
    \   ^ empty character literal\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpp1gc33wh.rs:17:33\n\
    \   |\n17 |     new_chars.extend_from_slice(&mut chars.clone());\n   |       \
    \                          ^^^^^^^^^^^^^^^^^^ expected slice, found struct `Chars`\n\
    \   |\n   = note:      expected reference `&[_]`\n           found mutable reference\
    \ `&mut Chars<'_>`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    let mut i = 0;\n    while i\
    \ < chars.len() {\n        let c = chars[i];\n        // If current char is non\
    \ alphabet char, ignore it\n        if !c.is_alphabetic() {\n            chars.remove(&i);\n\
    \            i += 1;\n            continue;\n        }\n        // Move to the\
    \ next alphabet char\n        let mut j = i;\n        while !chars[j].is_alphabetic()\
    \ {\n            j += 1;\n        }\n        // If current char is alphabet char,\
    \ swap it with alphabet char\n        // above and above char\n        if j >\
    \ i {\n            chars.remove(&i);\n            chars.remove(&j);\n        \
    \    chars.insert(i, j);\n            i += 1;\n            j += 1;\n        }\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmph4y5td4u.rs:16:21\n   |\n16 |     while i < chars.len()\
    \ {\n   |                     ^^^ method not found in `Chars<'_>`\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmph4y5td4u.rs:17:17\n\
    \   |\n17 |         let c = chars[i];\n   |                 ^^^^^^^^\n\nerror[E0599]:\
    \ no method named `remove` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmph4y5td4u.rs:20:19\n   |\n20 |             chars.remove(&i);\n   |  \
    \                 ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0608]: cannot\
    \ index into a value of type `Chars<'_>`\n  --> /tmp/tmph4y5td4u.rs:26:16\n  \
    \ |\n26 |         while !chars[j].is_alphabetic() {\n   |                ^^^^^^^^\n\
    \nerror[E0599]: no method named `remove` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmph4y5td4u.rs:32:19\n   |\n32 |             chars.remove(&i);\n\
    \   |                   ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `remove` found for struct `Chars` in the current scope\n  -->\
    \ /tmp/tmph4y5td4u.rs:33:19\n   |\n33 |             chars.remove(&j);\n   |  \
    \                 ^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method\
    \ named `insert` found for struct `Chars` in the current scope\n  --> /tmp/tmph4y5td4u.rs:34:19\n\
    \   |\n34 |             chars.insert(i, j);\n   |                   ^^^^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to 7 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(\n        \"\"\n        + s\n        .split_whitespace()\n\
    \        .iter()\n        .filter(|x| !x.is_empty())\n        .map(|x| x.chars().collect::<Vec<_>>())\n\
    \        .sort_by_key(|x| x.iter().cloned().map(|x| x.to_ascii_lowercase().unwrap()).collect::<Vec<_>>())\n\
    \        .collect::<String>() + s.chars().collect::<Vec<_>>(),\n    )\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp3_m2_dfw.rs:18:10\n   |\n18 |         .iter()\n\
    \   |          ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.to_owned();\n    let mut res = String::with_capacity(s.len());\n\
    \    let mut alphabet = [0; 26];\n    for i in s.chars() {\n        alphabet[i\
    \ as usize] = alphabet + 1;\n    }\n    for i in alphabet.iter() {\n        res.push((i\
    \ as char).to_string());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `[{integer}; 26]`\n  --> /tmp/tmpcl1gaif6.rs:18:41\n\
    \   |\n18 |         alphabet[i as usize] = alphabet + 1;\n   |               \
    \                 -------- ^ - {integer}\n   |                               \
    \ |\n   |                                [{integer}; 26]\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpcl1gaif6.rs:21:18\n   |\n21 |         res.push((i as char).to_string());\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \nerror[E0606]: casting `&{integer}` as `char` is invalid\n  --> /tmp/tmpcl1gaif6.rs:21:18\n\
    \   |\n21 |         res.push((i as char).to_string());\n   |                 \
    \ ^-^^^^^^^^^\n   |                  ||\n   |                  |help: dereference\
    \ the expression: `*i`\n   |                  cannot cast `&{integer}` as `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0606.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = String::with_capacity(s.size());\n    for\
    \ i in s.char_indices() {\n        let char = i[0];\n        if char <= ' ' {\n\
    \            result.push('_');\n        } else {\n            result.push(char.to_ascii_lowercase());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp90lb70gm.rs:14:46\n   |\n14 |     let mut result = String::with_capacity(s.size());\n\
    \   |                                              ^^^^ method not found in `String`\n\
    \nerror[E0608]: cannot index into a value of type `(usize, char)`\n  --> /tmp/tmp90lb70gm.rs:16:20\n\
    \   |\n16 |         let char = i[0];\n   |                    ^^^^ help: to access\
    \ tuple elements, use: `i.0`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.chars().collect::<Vec<String>>().sort_by(|a,\
    \ b| b.len().cmp(a.len()).reverse()).collect::<String>().join(\" \"))\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmp25tpbyqt.rs:14:28\n     |\n14\
    \   |     String::from(s.chars().collect::<Vec<String>>().sort_by(|a, b| b.len().cmp(a.len()).reverse()).collect::<String>().join(\"\
    \ \"))\n     |                            ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=char>`\n     |\n     = help:\
    \ the trait `FromIterator<char>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp25tpbyqt.rs:14:80\n\
    \   |\n14 |     String::from(s.chars().collect::<Vec<String>>().sort_by(|a, b|\
    \ b.len().cmp(a.len()).reverse()).collect::<String>().join(\" \"))\n   |     \
    \                                                                           ^^^^^^^\n\
    \   |                                                                        \
    \        |\n   |                                                             \
    \                   expected `&usize`, found `usize`\n   |                   \
    \                                                             help: consider borrowing\
    \ here: `&a.len()`\n\nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmp25tpbyqt.rs:14:100\n\
    \   |\n14 |     String::from(s.chars().collect::<Vec<String>>().sort_by(|a, b|\
    \ b.len().cmp(a.len()).reverse()).collect::<String>().join(\" \"))\n   |     \
    \                                                                            \
    \                   ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_shuffle_impl(s, 0).to_string()\n}\n\nfn main() {\n   \
    \ let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_impl` in this scope\n\
    \  --> /tmp/tmphyclcjae.rs:14:5\n   |\n14 |     anti_shuffle_impl(s, 0).to_string()\n\
    \   |     ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from_iter(s.chars().enumerate().map(|(_, c)| {\n  \
    \      if c.is_ascii_whitespace() {\n            c.to_ascii_lowercase()\n    \
    \    } else {\n            c\n        }\n    }).collect())\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `from_iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp_1r7c93j.rs:14:13\n   |\n\
    14 |     String::from_iter(s.chars().enumerate().map(|(_, c)| {\n   |        \
    \     ^^^^^^^^^ function or associated item not found in `String`\n   |\n   =\
    \ help: items from traits can only be used if the trait is in scope\nhelp: the\
    \ following trait is implemented but not in scope; perhaps add a `use` for it:\n\
    \   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated function\
    \ with a similar name\n   |\n14 |     String::from_utf8(s.chars().enumerate().map(|(_,\
    \ c)| {\n   |             ~~~~~~~~~\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.split_whitespace();\n    let mut result =\
    \ String::new();\n    for word in words {\n        if let Some(index) = word.chars().map(|c|\
    \ c.to_ascii_lowercase()).min_by_key(|i| i) {\n            result.push((&word).to_string()[index]);\n\
    \        } else {\n            result.push_str(&word);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `char`\n  --> /tmp/tmpupi8y3wn.rs:18:25\n\
    \   |\n18 |             result.push((&word).to_string()[index]);\n   |       \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `char`\n\
    \   |\n   = help: the trait `Index<char>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.into_lowercase().chars().enumerate().filter(|(i, c)| {\n\
    \        c.is_ascii()\n    }).map(|(i, c)| {\n        let mut c2 = c;\n      \
    \  c2.rotate_left(32);\n        String::from_utf8(c.to_vec()).unwrap().to_string()\n\
    \    }).collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp4ral6lk8.rs:14:7\n   |\n14 |     s.into_lowercase().chars().enumerate().filter(|(i,\
    \ c)| {\n   |       ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_lowercase`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = String::with_capacity(s.len());\n    for c\
    \ in s.chars() {\n        match c {\n            ' ' => continue,\n          \
    \  '.' => result.push_str(\"...\")?;\n            '-' => result.push_str(\"__\"\
    )?;\n            '/' => result.push_str(\"//\")?;\n            '\\\\' => result.push_str(\"\
    \\\\\\\\\")?;\n            '_' => result.push_str(\"__\")?;\n            '\"'\
    \ => result.push_str(\"\\\"\", |c| c)?;\n            '&' => result.push_str(\"\
    &amp;\")?;\n            '<' => result.push_str(\"&lt;\")?;\n            '>' =>\
    \ result.push_str(\"&gt;\")?;\n            '?' => result.push_str(\"&#63;\")?;\n\
    \            '\"' => result.push_str(\"&quot;\", |c| c)?;\n            'A' =>\
    \ result.push_str(\"&#65;\")?;\n            'a' => result.push_str(\"&#971;\"\
    )?;\n            'B' => result.push_str(\"&#66;\")?;\n            'b' => result.push_str(\"\
    &#982;\")?;\n            'C' => result.push_str(\"&#67;\")?;\n            'c'\
    \ => result.push_str(\"&#993;\")?;\n            'D' => result.push_str(\"&#68;\"\
    )?;\n            'd' => result.push_str(\"&#994;\")?;\n            'E' => result.push_str(\"\
    &#69;\")?;\n            'e' => result.push_str(\"&#995;\")?;\n            'F'\
    \ => result.push_str(\"&#70;\")?;\n            'f' => result.push_str(\"&#996;\"\
    )?;\n            'G' => result.push_str(\"&#71;\")?;\n            'g' => result.push_str(\"\
    &#997;\")?;\n            'H' => result.push_str(\"&#72;\")?;\n            'h'\
    \ => result.push_str(\"&#998;\")?;\n            'I' => result.push_str(\"&#73;\"\
    )?;\n            'i' => result.push_str(\"&#999;\")?;\n            'J' => result.push_str(\"\
    &#74;\")?;\n            'j' => result.push_str(\"&#1000;\")?;\n            'K'\
    \ => result.push_str(\"&#75;\")?;\n            'k' => result.push_str(\"&#1001;\"\
    )?;\n            'L' => result.push_str(\"&#76;\")?;\n            'l' => result.push_str(\"\
    &#1002;\")?;\n            'M' => result.push_str(\"&#77;\")?;\n            'm'\
    \ => result.push_str(\"&#1003;\")?;\n            'N' => result.push_str(\"&#78;\"\
    )?;\n\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpobmw7gm6.rs:68:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n14 |     let mut result = String::with_capacity(s.len());\n\
    15 |     for c in s.chars() {\n   |                        - unclosed delimiter\n\
    16 |         match c {\n   |                 - this delimiter might not be properly\
    \ closed...\n...\n57 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n68 | }\n   |   ^\n\nerror: `match` arm body without braces\n  --> /tmp/tmpobmw7gm6.rs:18:20\n\
    \   |\n18 |             '.' => result.push_str(\"...\")?;\n   |              \
    \   -- ^^^^^^^^^^^^^^^^^^^^^^^- help: use a comma to end a `match` arm expression:\
    \ `,`\n   |                 |  |\n   |                 |  this statement is not\
    \ surrounded by a body\n   |                 while parsing the `match` arm starting\
    \ here\n\nerror: `match` arm body without braces\n  --> /tmp/tmpobmw7gm6.rs:19:20\n\
    \   |\n19 |             '-' => result.push_str(\"__\")?;\n   |               \
    \  -- ^^^^^^^^^^^^^^^^^^^^^^- help: use a comma to end a `match` arm expression:\
    \ `,`\n   |                 |  |\n   |                 |  this statement is not\
    \ surrounded by a body\n   |                 while parsing the `match` arm starting\
    \ here\n\nerror: `match` arm body without braces\n  --> /tmp/tmpobmw7gm6.rs:20:20\n\
    \   |\n20 |             '/' => result.push_str(\"//\")?;\n   |               \
    \  -- ^^^^^^^^^^^^^^^^^^^^^^- help: use a comma to end a `match` arm expression:\
    \ `,`\n   |                 |  |\n   |                 |  this statement is not\
    \ surrounded by a body\n   |                 while parsing the `match` arm starting\
    \ here\n\nerror: `match` arm body without braces\n  --> /tmp/tmpobmw7gm6.rs:21:21\n\
    \   |\n21 |             '\\\\' => result.push_str(\"\\\\\\\\\")?;\n   |      \
    \            -- ^^^^^^^^^^^^^^^^^^^^^^^^- help: use a comma to end a `match` arm\
    \ expression: `,`\n   |                  |  |\n   |                  |  this statement\
    \ is not surrounded by a body\n   |                  while parsing the `matc"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Reverse the string\n    let mut reverse = s[..].to_owned();\n\
    \    let mut i = s.len() - 1;\n    while i > 0 {\n        reverse = reverse.chars().collect::<String>().rev().collect::<String>()\
    \ + &s[i];\n        i -= 1;\n    }\n    reverse\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmp_cbrif4i.rs:18:55\n\
    \    |\n18  |           reverse = reverse.chars().collect::<String>().rev().collect::<String>()\
    \ + &s[i];\n    |                                                         ^^^\
    \ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n \
    \   = note: the following trait bounds were not satisfied:\n            `String:\
    \ Iterator`\n            which is required by `&mut String: Iterator`\n      \
    \      `str: Iterator`\n            which is required by `&mut str: Iterator`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_cbrif4i.rs:18:84\n\
    \   |\n18 |         reverse = reverse.chars().collect::<String>().rev().collect::<String>()\
    \ + &s[i];\n   |                                                             \
    \                       ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c| if c < ' ' { c.to_ascii_lowercase()\
    \ } else { c })\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpctsoh0wb.rs:22:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = s.to_string();\n    for ch in buffer.chars().cloned()\
    \ {\n        if ch != ' ' {\n            *buffer = ch + &buffer[ch.len() - 1];\n\
    \        }\n    }\n    String::from(buffer)\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpw9n7u7_b.rs:15:30\n     |\n15   |     for ch in buffer.chars().cloned()\
    \ {\n     |                              ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpw9n7u7_b.rs:15:15\n\
    \   |\n15 |     for ch in buffer.chars().cloned() {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpw9n7u7_b.rs:15:15\n   |\n15 |     for ch in buffer.chars().cloned()\
    \ {\n   |               ^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpw9n7u7_b.rs:17:13\n   |\n17 |             *buffer = ch +\
    \ &buffer[ch.len() - 1];\n   |             ^^^^^^^ doesn't have a size known at\
    \ compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: the left-hand-side of an assignment must have a statically known size\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0277.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    AntiShuffle::new(s)\n        .filter_whitespace()\n       \
    \ .filter_ascii_order()\n        .to_string()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `AntiShuffle`\n\
    \  --> /tmp/tmpx5a2ljpk.rs:14:5\n   |\n14 |     AntiShuffle::new(s)\n   |    \
    \ ^^^^^^^^^^^ use of undeclared type `AntiShuffle`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().cloned()\n        .sort_by(|a, b| b.cmp(a).reverse()).collect()\n\
    \        .iter()\n        .cloned()\n        .join(\" \")\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `str: Clone` is not satisfied\n    --> /tmp/tmpwir36fhz.rs:14:26\n\
    \     |\n14   |     s.split_whitespace().cloned()\n     |                    \
    \      ^^^^^^ the trait `Clone` is not implemented for `str`\n     |\n     = help:\
    \ the trait `Clone` is implemented for `String`\nnote: required by a bound in\
    \ `cloned`\n\nerror[E0599]: no method named `sort_by` found for struct `Cloned`\
    \ in the current scope\n  --> /tmp/tmpwir36fhz.rs:15:10\n   |\n15 |         .sort_by(|a,\
    \ b| b.cmp(a).reverse()).collect()\n   |          ^^^^^^^ method not found in\
    \ `Cloned<SplitWhitespace<'_>>`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().filter_map(|c| {\n        if c.is_whitespace() {\n\
    \            Some(true)\n        } else {\n            Some(c)\n        }\n  \
    \  }).cloned().sort_by(|x, y| x.cmp(y)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi3ou3rp8.rs:18:18\n   |\n\
    18 |             Some(c)\n   |                  ^ expected `bool`, found `char`\n\
    \nerror[E0271]: type mismatch resolving `<[closure@/tmp/tmpi3ou3rp8.rs:14:26:\
    \ 20:6] as FnOnce<(char,)>>::Output == Option<&_>`\n    --> /tmp/tmpi3ou3rp8.rs:20:8\n\
    \     |\n20   |     }).cloned().sort_by(|x, y| x.cmp(y)).collect()\n     |   \
    \     ^^^^^^ expected reference, found `bool`\n     |\n     = note: expected enum\
    \ `Option<&_>`\n                found enum `Option<bool>`\n     = note: required\
    \ because of the requirements on the impl of `Iterator` for `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpi3ou3rp8.rs:14:26: 20:6]>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: no method named `sort_by` found for struct `Cloned` in the current\
    \ scope\n  --> /tmp/tmpi3ou3rp8.rs:20:17\n   |\n20 |     }).cloned().sort_by(|x,\
    \ y| x.cmp(y)).collect()\n   |                 ^^^^^^^ method not found in `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpi3ou3rp8.rs:14:26: 20:6]>>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.split_whitespace();\n    let mut res = String::with_capacity(s.size());\n\
    \    for w in words.iter().rev() {\n        if w.chars().count() != 0 {\n    \
    \        res.push(*w);\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpco0nqded.rs:15:43\n   |\n15 |     let mut res = String::with_capacity(s.size());\n\
    \   |                                           ^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `iter` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpco0nqded.rs:16:20\n   |\n16 |     for w in words.iter().rev()\
    \ {\n   |                    ^^^^ method not found in `SplitWhitespace<'_>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.chars().filter_map(|c| if c.is_whitespace()\
    \ || c.is_ascii() {\n        Some(c)\n    } else {\n        None\n    }).cloned().collect())\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6] as FnOnce<(char,)>>::Output == Option<&_>`\n    --> /tmp/tmpdw009d6a.rs:18:8\n\
    \     |\n18   |     }).cloned().collect())\n     |        ^^^^^^ expected reference,\
    \ found `char`\n     |\n     = note: expected enum `Option<&_>`\n            \
    \    found enum `Option<char>`\n     = note: required because of the requirements\
    \ on the impl of `Iterator` for `FilterMap<Chars<'_>, [closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6]>`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6]>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpdw009d6a.rs:18:17\n\
    \   |\n18 |        }).cloned().collect())\n   |                    ^^^^^^^ method\
    \ cannot be called on `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6]>>` due to unsatisfied trait bounds\n   |\n   = note: the following trait\
    \ bounds were not satisfied:\n           `<FilterMap<Chars<'_>, [closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6]> as Iterator>::Item = &_`\n           which is required by `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpdw009d6a.rs:14:39: 18:6]>>: Iterator`\n           `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmpdw009d6a.rs:14:39: 18:6]>>: Iterator`\n           which is\
    \ required by `&mut Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmpdw009d6a.rs:14:39:\
    \ 18:6]>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut r = String::from(s);\n    for i in (0..s.len()).rev()\
    \ {\n        if !r.contains(&' ') {\n            r.push_str(&s[i .. i + 1]);\n\
    \        }\n    }\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `Fn<(char,)>` closure, found `char`\n    --> /tmp/tmpoy_sveb1.rs:16:24\n\
    \     |\n16   |         if !r.contains(&' ') {\n     |               --------\
    \ ^^^^ expected an `Fn<(char,)>` closure, found `char`\n     |               |\n\
    \     |               required by a bound introduced by this call\n     |\n  \
    \   = help: the trait `Fn<(char,)>` is not implemented for `char`\n     = note:\
    \ required because of the requirements on the impl of `FnOnce<(char,)>` for `&char`\n\
    \     = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&char`\nnote: required by a bound in `core::str::<impl str>::contains`\n\
    help: consider dereferencing here\n     |\n16   |         if !r.contains(*&' ')\
    \ {\n     |                        +\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut map = HashMap::new();\n    s.chars().for_each(|c| map.insert(c,\
    \ 0));\n    let mut result = String::new();\n    map.keys().sorted_by_key(|&k|\
    \ map[k]).for_each(|k| {\n        match map[k] {\n            0 => result.push(k),\n\
    \            x => {\n                while result.len() > x {\n              \
    \      result.push(*result.iter().skip(x).next().unwrap());\n                }\n\
    \            }\n        }\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp3mhx3u97.rs:14:19\n   |\n14 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp3mhx3u97.rs:22:41\n   |\n22 |                     result.push(*result.iter().skip(x).next().unwrap());\n\
    \   |                                         ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n22 |                  \
    \   result.push(*result.chars().skip(x).next().unwrap());\n   |              \
    \                           ~~~~~\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut l = s.chars();\n    let mut result = String::with_capacity(s.len());\n\
    \    while let Some(c) = l.next() {\n        match c {\n            ' ' => {\n\
    \                for i in 1..s.len() {\n                    if s.chars().any(|&c|\
    \ c == i) {\n                        continue;\n                    }\n      \
    \              result += &s[i - 1];\n                }\n                continue;\n\
    \            }\n            '-' => result.push('-'),\n            '_' => result.push('_'),\n\
    \            c => {\n                if c < 'A' {\n                    result.push(c.to_ascii_lowercase());\n\
    \                } else {\n                    result.push(c.to_ascii_uppercase());\n\
    \                }\n            }\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkh50o4mj.rs:20:39\n   |\n\
    20 |                     if s.chars().any(|&c| c == i) {\n   |               \
    \                        ^--\n   |                                       ||\n\
    \   |                                       |expected due to this\n   |      \
    \                                 expected `char`, found reference\n   |     \
    \                                  help: did you mean `c`: `&char`\n   |\n   =\
    \ note:   expected type `char`\n           found reference `&_`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkh50o4mj.rs:23:32\n\
    \   |\n23 |                     result += &s[i - 1];\n   |                   \
    \             ^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut r = s.to_owned();\n    let mut i = 0;\n    while r.len()\
    \ > i {\n        let (l, r) = r.split_at_mut(i);\n        let mut j = 0;\n   \
    \     while l != \"\" {\n            if l < r[j] {\n                r[j] = l;\n\
    \                j += 1;\n            } else {\n                r[j] = r;\n  \
    \          }\n        }\n        i = j;\n    }\n    r\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpfamlrw1w.rs:20:20\n\
    \   |\n20 |             if l < r[j] {\n   |                    ^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpfamlrw1w.rs:21:17\n\
    \   |\n21 |                 r[j] = l;\n   |                 ^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpfamlrw1w.rs:24:17\n\
    \   |\n24 |                 r[j] = r;\n   |                 ^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `{integer}`\n   = note: you can use `.chars().nth()` or `.bytes().nth()`\n\
    \           for more information, see chapter 8 in The Book: <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s1 = s.clone();\n    s1.split_whitespace().sort_by_key(|&x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>().join(\" \")\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp_rqugh1o.rs:15:27\n   |\n15 |     s1.split_whitespace().sort_by_key(|&x|\
    \ x.to_ascii_lowercase()).collect::<Vec<_>>().join(\" \")\n   |              \
    \             ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut ans = s.into_owned();\n    for c in ans {\n       \
    \ if c != ' ' {\n            ans.replace(ans.iter().cloned().skip(ans.iter().enumerate().filter(|(i,\
    \ _)| i == 0).next().unwrap().0).next().unwrap(), c);\n        }\n    }\n    String::from(ans)\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_owned` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpvox57iy_.rs:14:21\n   |\n14 |     let mut ans\
    \ = s.into_owned();\n   |                     ^^^^^^^^^^ method not found in `String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::from(s);\n    let mut words = res.split_whitespace();\n\
    \    while words.len() > 0 {\n        let mut index = words.len() - 1;\n     \
    \   while index >= 0 && index >= words.len() - 1 {\n            index = index\
    \ - 1;\n            res.swap_remove(index);\n        }\n        if words.len()\
    \ > 1 {\n            let last = words.len() - 1;\n            let mid = last /\
    \ 2;\n            let mut new_word = \"\";\n            let mut new_last = 0;\n\
    \            let mut new_mid = 0;\n            for &word in &words {\n       \
    \         if new_last > mid {\n                    new_word += &word[new_mid..new_last].to_string();\n\
    \                    new_mid = 0;\n                }\n                if new_last\
    \ == mid {\n                    new_word += &word[new_mid..new_last].to_string();\n\
    \                    new_mid += 1;\n                }\n                new_last\
    \ += 1;\n            }\n            let mut new_word = new_word.to_owned();\n\
    \            res.replace(new_last, new_word);\n        }\n        if words.len()\
    \ == 1 {\n            break;\n        }\n        let mut new_word = words.remove_by_ref(0);\n\
    \        res.replace(new_word.len(), &new_word);\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpg9u60lrg.rs:16:17\n   |\n16 |     while\
    \ words.len() > 0 {\n   |                 ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpg9u60lrg.rs:17:31\n   |\n17 |         let mut index\
    \ = words.len() - 1;\n   |                               ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpg9u60lrg.rs:18:44\n  \
    \ |\n18 |         while index >= 0 && index >= words.len() - 1 {\n   |       \
    \                                     ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `swap_remove` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpg9u60lrg.rs:20:17\n   |\n20 |             res.swap_remove(index);\n\
    \   |                 ^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `remove`\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpg9u60lrg.rs:22:18\n  \
    \ |\n22 |         if words.len() > 1 {\n   |                  ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpg9u60lrg.rs:23:30\n  \
    \ |\n23 |             let last = words.len() - 1;\n   |                      \
    \        ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0277]: `&SplitWhitespace<'_>`\
    \ is not an iterator\n  --> /tmp/tmpg9u60lrg.rs:28:26\n   |\n28 |            \
    \ for &word in &words {\n   |                          -^^^^^\n   |          \
    \                |\n   |                          `&SplitWhitespace<'_>` is not\
    \ an iterator\n   |                          help: consider removing the leading\
    \ `&`-reference\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&SplitWhitespace<'_>`\n   = note: `Iterator` is implemented for `&mut std::str::SplitWhitespace<'_>`,\
    \ but "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buf = vec![String::new(); s.len()];\n    let mut buf_size\
    \ = s.len();\n    let mut i = 0;\n    let mut j = s.len();\n\n    let mut k =\
    \ s.len();\n    while k > 1 {\n        if i > j {\n            i += 1;\n     \
    \       j /= 2;\n            continue;\n        }\n        if buf[i - 1] <= s[i]\
    \ {\n            buf[i - 1] = s[i];\n            i /= 2;\n        } else {\n \
    \           buf[k] = s[i];\n            k /= 2;\n        }\n    }\n\n    buf.truncate(i);\n\
    \    String::from_utf8_lossy(&buf[..])\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmppzy9thkh.rs:26:26\n\
    \   |\n26 |         if buf[i - 1] <= s[i] {\n   |                          ^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppzy9thkh.rs:27:26\n   |\n27 |             buf[i - 1] = s[i];\n\
    \   |                          ^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmppzy9thkh.rs:30:22\n   |\n30 |             buf[k] = s[i];\n   |\
    \                      ^^^^ `String` cannot be indexed by `usize`\n   |\n   =\
    \ help: the trait `Index<usize>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `Index<Idx>`:\n             <String as\
    \ Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n      \
    \       <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E03"
  stdout: ''
  timestamp: 1659976577
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::from(\"Hi\");\n    let mut i = 0;\n \
    \   for word in s.split_whitespace() {\n        res.push_str(word);\n        res.push_str(&s[i..]);\n\
    \        i += word.len();\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"HiHiHi\"`,\n right: `\"Hi\"`', /tmp/tmploqyyyf8.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.split_whitespace();\n    let mut letters\
    \ = String::new();\n\n    let mut last_letter = Some(s.chars().nth(0).unwrap());\n\
    \    for letter in words.iter() {\n        letters.push_str(&last_letter);\n \
    \       last_letter = Some(letter);\n    }\n    letters.push_str(&last_letter);\n\
    \n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp7dzae99w.rs:18:25\n   |\n18 |     for letter\
    \ in words.iter() {\n   |                         ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7dzae99w.rs:19:26\n   |\n19 |\
    \         letters.push_str(&last_letter);\n   |                          ^^^^^^^^^^^^\
    \ expected `str`, found enum `Option`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&Option<char>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp7dzae99w.rs:22:22\n   |\n22 |     letters.push_str(&last_letter);\n\
    \   |                      ^^^^^^^^^^^^ expected `str`, found enum `Option`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&Option<char>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut c = String::from(*s);\n    let mut r = String::from(*s);\n\
    \    c.chars().filter_map(|c| c > 32).for_each(|c| c.to_ascii_lowercase());\n\
    \    while !r.is_empty() {\n        let c = r.chars().filter(|c| c > 32).max().unwrap();\n\
    \        let s = c.to_ascii_lowercase();\n        if s.len() > r.len() {\n   \
    \         r = r;\n        } else {\n            r = r.into_owned();\n        \
    \    r += s;\n        }\n    }\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmppdh7hlvk.rs:14:30\n    |\n14  |     let mut c = String::from(*s);\n\
    \    |                 ------------ ^^ doesn't have a size known at compile-time\n\
    \    |                 |\n    |                 required by a bound introduced\
    \ by this call\n    |\n    = help: the trait `Sized` is not implemented for `str`\n\
    note: required by a bound in `from`\n\nerror[E0277]: the trait bound `String:\
    \ From<str>` is not satisfied\n  --> /tmp/tmppdh7hlvk.rs:14:17\n   |\n14 |   \
    \  let mut c = String::from(*s);\n   |                 ^^^^^^^^^^^^ the trait\
    \ `From<str>` is not implemented for `String`\n   |\n   = help: the following\
    \ other types implement trait `From<T>`:\n             <String as From<&String>>\n\
    \             <String as From<&mut str>>\n             <String as From<&str>>\n\
    \             <String as From<Box<str>>>\n             <String as From<Cow<'a,\
    \ str>>>\n             <String as From<char>>\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n   --> /tmp/tmppdh7hlvk.rs:15:30\n\
    \    |\n15  |     let mut r = String::from(*s);\n    |                 ------------\
    \ ^^ doesn't have a size known at compile-time\n    |                 |\n    |\
    \                 required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `from`\n\nerror[E0277]: the trait bound `String: From<str>` is not satisfied\n\
    \  --> /tmp/tmppdh7hlvk.rs:15:17\n   |\n15 |     let mut r = String::from(*s);\n\
    \   |                 ^^^^^^^^^^^^ the trait `From<str>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmppdh7hlvk.rs:16:34\n   |\n16 |\
    \     c.chars().filter_map(|c| c > "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().collect::<Vec<_>>().sort_by_key(|c| *c).collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpu1gjb_9a.rs:14:55\n\
    \   |\n14 |     s.chars().collect::<Vec<_>>().sort_by_key(|c| *c).collect()\n\
    \   |                                                       ^^^^^^^ `()` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_string = String::from(\"_\");\n    let mut word_count\
    \ = s.len();\n    while word_count > 0 {\n        let mut i = 0;\n        while\
    \ i < word_count {\n            let c = s.chars().nth(i).unwrap();\n         \
    \   if !c.is_whitespace() {\n                break;\n            }\n         \
    \   i += 1;\n        }\n        let mut j = i;\n        while j + 1 < word_count\
    \ && s.chars().nth(j + 1).unwrap().is_whitespace() {\n            j += 1;\n  \
    \      }\n        let w = s.chars().nth(i).unwrap();\n        let x = s.chars().nth(j).unwrap();\n\
    \        new_string.push_str(w.to_ascii_lowercase());\n        new_string.push_str(x.to_ascii_lowercase());\n\
    \        i += 1;\n        j += 1;\n        word_count -= 1;\n    }\n    new_string\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc6qmdwb9.rs:31:29\n   |\n\
    31 |         new_string.push_str(w.to_ascii_lowercase());\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc6qmdwb9.rs:32:29\n   |\n32 |         new_string.push_str(x.to_ascii_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().enumerate().filter(|(_, c)| !c.is_whitespace()).flat_map(|(i,\
    \ c)| {\n        let mut j = i;\n        let mut k = 0;\n        while j < s.len()\
    \ && k < c.len() && s[k].ascii() < c[k].ascii() {\n            j += 1; k += 1;\n\
    \        }\n        if k == c.len() {\n            return vec![i];\n        }\n\
    \        if j > i {\n            return vec![k, k + 1].into_iter().chain(vec![i\
    \ - 1, i].into_iter());\n        }\n        vec![k, k + 1].into_iter().chain(vec![j,\
    \ j + 1].into_iter()).collect()\n    })\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6tv1io1c.rs:17:36\n   |\n17 |         while j < s.len()\
    \ && k < c.len() && s[k].ascii() < c[k].ascii() {\n   |                      \
    \              ^^^ method not found in `char`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmp6tv1io1c.rs:17:45\n   |\n17\
    \ |         while j < s.len() && k < c.len() && s[k].ascii() < c[k].ascii() {\n\
    \   |                                             ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp6tv1io1c.rs:17:60\n\
    \   |\n17 |         while j < s.len() && k < c.len() && s[k].ascii() < c[k].ascii()\
    \ {\n   |                                                            ^^^^\n\n\
    error[E0599]: no method named `len` found for type `char` in the current scope\n\
    \  --> /tmp/tmp6tv1io1c.rs:20:19\n   |\n20 |         if k == c.len() {\n   | \
    \                  ^^^ method not found in `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6tv1io1c.rs:24:20\n   |\n24 |             return vec![k,\
    \ k + 1].into_iter().chain(vec![i - 1, i].into_iter());\n   |                \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `Vec`, found struct `std::iter::Chain`\n   |\n   = note: expected struct `Vec<usize>`\n\
    \              found struct `std::iter::Chain<std::vec::IntoIter<usize>, std::vec::IntoIter<usize>>`\n\
    note: return type inferred to be `Vec<usize>` here\n  --> /tmp/tmp6tv1io1c.rs:21:20\n\
    \   |\n21 |             return vec![i];\n   |                  "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = s.to_string();\n    let mut words = s.split_whitespace();\n\
    \    while !words.is_empty() {\n        let word = words.next_back();\n      \
    \  let mut new_word = word;\n        while !new_word.is_empty() {\n          \
    \  match new_word.chars().next().unwrap() {\n                'a' => {\n      \
    \              new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'e' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_uppercase();\n\
    \                }\n                'i' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'o' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'u' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_uppercase();\n\
    \                }\n                'A' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'E' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_uppercase();\n\
    \                }\n                'I' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'O' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                'U' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_uppercase();\n\
    \                }\n                '0' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '1' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '2' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '3' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '4' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '5' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '6' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '7' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '8' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                '9' => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n                ch => {\n                    new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \                }\n            }\n        }\n        result = result.insert(result.len()\
    \ - 1, new_word);\n    }\n\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_empty` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpakvfrc_a.rs:16:18\n   |\n16 |     while\
    \ !words.is_empty() {\n   |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `is_empty` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpakvfrc_a.rs:19:25\n   |\n19 |         while !new_word.is_empty()\
    \ {\n   |                         ^^^^^^^^ method not found in `Option<&str>`\n\
    \nerror[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpakvfrc_a.rs:20:28\n   |\n20 |             match new_word.chars().next().unwrap()\
    \ {\n   |                            ^^^^^ method not found in `Option<&str>`\n\
    \nerror[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpakvfrc_a.rs:22:41\n   |\n22 |                     new_word\
    \ = new_word.chars().next().unwrap().to_ascii_lowercase();\n   |             \
    \                            ^^^^^ method not found in `Option<&str>`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpakvfrc_a.rs:25:41\n   |\n25 |                     new_word = new_word.chars().next().unwrap().to_ascii_uppercase();\n\
    \   |                                         ^^^^^ method not found in `Option<&str>`\n\
    \nerror[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpakvfrc_a.rs:28:41\n   |\n28 |                     new_word\
    \ = new_word.chars().next().unwrap().to_ascii_lowercase();\n   |             \
    \                            ^^^^^ method not found in `Option<&str>`\n\nerror[E0599]:\
    \ no method named `chars` found for enum `Option` in the current scope\n  -->\
    \ /tmp/tmpakvfrc_a.rs:31:41\n   |\n31 |                     new_word = new_word.chars().next().unwrap().to_ascii_lowercase();\n\
    \   |                                         ^^^^^ method not found in `Option<&str>`\n\
    \nerror[E0599]: no method named `chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpakvfrc_a.rs:34:41\n   |\n34"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.get_sorted_characters().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_sorted_characters` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp9r7fzv1b.rs:14:7\n   |\n14 |  \
    \   s.get_sorted_characters().collect::<String>()\n   |       ^^^^^^^^^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_shuffle(s.as_slice())\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_slice` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdgl_2nu4.rs:14:20\n   |\n14 |     anti_shuffle(s.as_slice())\n\
    \   |                    ^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(\" \").sort_by_key(|x| x.to_ascii_lowercase()).collect::<String>().join(\"\
    _\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpltzydav0.rs:14:18\n   |\n14 |     s.split(\"\
    \ \").sort_by_key(|x| x.to_ascii_lowercase()).collect::<String>().join(\"_\")\n\
    \   |                  ^^^^^^^^^^^ method not found in `std::str::Split<'_, &str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.iter().map(|c| {\n        // replace each character\
    \ with an index and get its ascii value\n        let index = c.to_ascii_lowercase().chars().enumerate().map(|(i,\
    \ ch)| {\n            (i, ch)\n        }).collect::<Vec<_>>();\n\n        // sort\
    \ index with ascii value and replace chars\n        // by new ordered values\n\
    \        index\n            .iter()\n            .map(|(_, ch)| ch)\n        \
    \    .sorted()\n            .collect::<Vec<_>>()\n            .join()\n    }).collect::<Vec<_>>().join(\"\
    \"))\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpjp4zk897.rs:14:20\n   |\n14 |     String::from(s.iter().map(|c|\
    \ {\n   |                    ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n14 |     String::from(s.chars().map(|c|\
    \ {\n   |                    ~~~~~\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = s.to_string();\n    let mut letters = result.chars();\n\
    \    let mut ascii_order = [0u8; 26];\n    for c in letters {\n        ascii_order[c\
    \ as usize] = ascii_order[c as usize] + 1;\n    }\n    let mut position = 0;\n\
    \    let mut ascii_letters = ascii_order.clone();\n    while position < result.len()\
    \ {\n        position += 1;\n        let pos = ascii_letters.binary_search(&position).unwrap();\n\
    \        if pos == ascii_letters.len() {\n            pos = 0;\n        }\n  \
    \      ascii_letters[pos] = ascii_letters[ascii_letters.len() - 1];\n        ascii_letters.pop_back();\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpvx69yq9g.rs:24:47\n   |\n\
    24 |         let pos = ascii_letters.binary_search(&position).unwrap();\n   |\
    \                                               ^^^^^^^^^ expected `u8`, found\
    \ `usize`\n   |\n   = note: expected reference `&u8`\n              found reference\
    \ `&usize`\n\nerror[E0599]: no method named `pop_back` found for array `[u8; 26]`\
    \ in the current scope\n  --> /tmp/tmpvx69yq9g.rs:29:23\n   |\n29 |         ascii_letters.pop_back();\n\
    \   |                       ^^^^^^^^ method not found in `[u8; 26]`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.replace_indices(\n        &[\n      \
    \      (0, 1),\n            (0, 2),\n            (0, 3),\n            (0, 4),\n\
    \            (0, 5),\n            (0, 6),\n            (0, 7),\n            (0,\
    \ 8),\n            (0, 9),\n            (0, 10),\n            (0, 11),\n     \
    \       (0, 12),\n            (0, 13),\n            (0, 14),\n            (0,\
    \ 15),\n            (0, 16),\n            (0, 17),\n            (0, 18),\n   \
    \         (0, 19),\n            (0, 20),\n            (0, 21),\n            (0,\
    \ 22),\n            (0, 23),\n            (0, 24),\n            (0, 25),\n   \
    \         (0, 26),\n            (0, 27),\n            (0, 28),\n            (0,\
    \ 29),\n            (0, 30),\n            (0, 31),\n            (0, 32),\n   \
    \         (0, 33),\n            (0, 34),\n            (0, 35),\n            (0,\
    \ 36),\n            (0, 37),\n            (0, 38),\n            (0, 39),\n   \
    \         (0, 40),\n            (0, 41),\n            (0, 42),\n            (0,\
    \ 43),\n            (0, 44),\n            (0, 45),\n            (0, 46),\n   \
    \         (0, 47),\n            (0, 48),\n            (0, 49),\n            (0,\
    \ 50),\n            (0, 51),\n            (0, 52),\n            (0, 53),\n   \
    \         (0, 54),\n            (0, 55),\n            (0, 56),\n            (0,\
    \ 57),\n            (0, 58),\n            (0, 59),\n            (0, 60),\n   \
    \         (0, 61),\n            (0, 62),\n            (0, 63),\n            (0,\
    \ 64),\n            (0, 65),\n            (0, 66),\n            (0, 67),\n   \
    \         (0, 68),\n            (0, 69),\n            (0, 70),\n            (0,\
    \ 71),\n            (0, 72),\n            (0, 73),\n            (0, 74),\n   \
    \         (0, 75),\n            (0, 76),\n            (0, 77),\n            (0,\
    \ 78),\n            (0, 79),\n            (0, 80),\n            (0, 81),\n   \
    \         (0, 82),\n            (0, 83),\n            (0, 84),\n            (0,\
    \ 85),\n            (0, 86),\n            (0, 87),\n            (0, 88),\n   \
    \         (0, 89),\n            (0, 90),\n            (0, 91),\n            (0,\
    \ 92),\n            (0, 93),\n            (0, 94),\n            (0, 95),\n   \
    \         (0, 96),\n            (0, 97),\n            (0, 98),\n            (0,\
    \ 99),\n            (0, 100),\n            (0, 101),\n            \n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n   --> /tmp/tmpebj13gdo.rs:16:10\n\
    \    |\n13  | fn anti_shuffle(s: String) -> String {\n    |                  \
    \                    - closing delimiter possibly meant for this\n...\n16  | \
    \        &[\n    |          ^ unclosed delimiter\n...\n119 | }\n    | ^ mismatched\
    \ closing delimiter\n\nerror[E0599]: no method named `replace_indices` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpebj13gdo.rs:15:7\n   |\n\
    15 |     s.replace_indices(\n   |       ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `replacen`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Get list of characters for each word\n    let mut word_chars\
    \ = s.chars().map(|c| c as u8);\n    // Sort characters in each word\n    word_chars.sort_by(|a,\
    \ b| a.partial_cmp(&b));\n    // Create new string with sorted characters for\
    \ each word\n    s.chars().map(|c| c as char).collect::<Vec<_>>().join(\"\")\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpucv9kygt.rs:17:16\n   |\n17 |     word_chars.sort_by(|a,\
    \ b| a.partial_cmp(&b));\n   |                ^^^^^^^ method not found in `Map<Chars<'_>,\
    \ [closure@/tmp/tmpucv9kygt.rs:15:40: 15:51]>`\n\nerror[E0599]: the method `join`\
    \ exists for struct `Vec<char>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpucv9kygt.rs:19:54\n   |\n19 |     s.chars().map(|c| c as char).collect::<Vec<_>>().join(\"\
    \")\n   |                                                      ^^^^ method cannot\
    \ be called on `Vec<char>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `[char]: Join<_>`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(' ').collect::<Vec<_>>().iter().map(|c| {\n       \
    \ match c {\n            'a' => 0,\n            'b' => 1,\n            'c' =>\
    \ 2,\n            'd' => 3,\n            'e' => 4,\n            'f' => 5,\n  \
    \          'g' => 6,\n            'h' => 7,\n            'i' => 8,\n         \
    \   'j' => 9,\n            'k' => 10,\n            'l' => 11,\n            'm'\
    \ => 12,\n            'n' => 13,\n            'o' => 14,\n            'p' => 15,\n\
    \            'q' => 16,\n            'r' => 17,\n            's' => 18,\n    \
    \        't' => 19,\n            'u' => 20,\n            'v' => 21,\n        \
    \    'w' => 22,\n            'x' => 23,\n            'y' => 24,\n            'z'\
    \ => 25,\n            _ => c.to_digit(16).to_string()\n        }\n    }).collect::<String>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:16:13\n   |\n\
    15 |         match c {\n   |               - this expression has type `&&str`\n\
    16 |             'a' => 0,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:17:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n16\
    \ |             'a' => 0,\n17 |             'b' => 1,\n   |             ^^^ expected\
    \ `str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:18:13\n\
    \   |\n15 |         match c {\n   |               - this expression has type `&&str`\n\
    ...\n18 |             'c' => 2,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:19:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    19 |             'd' => 3,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:20:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    20 |             'e' => 4,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:21:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    21 |             'f' => 5,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:22:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    22 |             'g' => 6,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:23:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    23 |             'h' => 7,\n   |             ^^^ expected `str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6nxsai10.rs:24:13\n   |\n15 |\
    \         match c {\n   |               - this expression has type `&&str`\n...\n\
    24 |             'i' => 8,\n   |             ^^^ expected `str`, "
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = String::from(\"\");\n    let mut buffers =\
    \ vec![];\n\n    for word in s.split_whitespace() {\n        let mut buffer =\
    \ String::from(\"\");\n        let mut buffers = vec![];\n        for char in\
    \ word.chars().iter() {\n            let i = char.encode_ascii_value().unwrap();\n\
    \            buffer.push(char.to_string());\n            buffers.push(i);\n  \
    \      }\n\n        if buffer.len() == 0 {\n            continue;\n        }\n\
    \n        if buffers.iter().all(|&i| i <= buffers.iter().last()) {\n         \
    \   buffer.pop();\n        }\n\n        buffers.push(buffer.len());\n        buffer.push_str(&buffer);\n\
    \    }\n\n    buffer\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp8v0vznlt.rs:20:34\n   |\n20 |         for char in word.chars().iter()\
    \ {\n   |                                  ^^^^ private field, not a method\n\n\
    error[E0277]: can't compare `usize` with `Option<&usize>`\n  --> /tmp/tmp8v0vznlt.rs:30:38\n\
    \   |\n30 |         if buffers.iter().all(|&i| i <= buffers.iter().last()) {\n\
    \   |                                      ^^ no implementation for `usize < Option<&usize>`\
    \ and `usize > Option<&usize>`\n   |\n   = help: the trait `PartialOrd<Option<&usize>>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `PartialOrd<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_str = String::from(\"&\");\n    for c in s.chars()\
    \ {\n        let val = c.as_bytes().iter().rev().enumerate().map(|(i, x)| {\n\
    \            let y = x.to_ascii_lowercase().into();\n            (i, y);\n   \
    \     }).collect::<Vec<_>>();\n        new_str.push_str(&val[..]);\n    }\n  \
    \  new_str.trim()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_bytes` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp8nkfy8va.rs:16:21\n   |\n16 |         let val = c.as_bytes().iter().rev().enumerate().map(|(i,\
    \ x)| {\n   |                     ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8nkfy8va.rs:22:5\n   |\n13 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n22 |     new_str.trim()\n   |     ^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut word_list = Vec::new();\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            word_list.push(c.to_string());\n        }\
    \ else {\n            word_list.push(c);\n        }\n    }\n    let mut sorted_list\
    \ = word_list.into_iter().sorted_by_key(|&x| x.len() as i32).collect::<Vec<_>>();\n\
    \    let mut res = String::new();\n    for i in 0..sorted_list.len() {\n     \
    \   res.push_str(&sorted_list[i].to_string());\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr6ju1xzj.rs:19:28\n   |\n\
    19 |             word_list.push(c);\n   |                            ^- help:\
    \ try using a conversion method: `.to_string()`\n   |                        \
    \    |\n   |                            expected struct `String`, found `char`\n\
    \nerror[E0599]: no method named `sorted_by_key` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpr6ju1xzj.rs:22:49\n   |\n22 |     let mut\
    \ sorted_list = word_list.into_iter().sorted_by_key(|&x| x.len() as i32).collect::<Vec<_>>();\n\
    \   |                                                 ^^^^^^^^^^^^^ method not\
    \ found in `std::vec::IntoIter<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut word_chars = vec![String::from(\"\
    \"), String::from(\"\")];\n    let mut space_chars = vec![String::from(\"\"),\
    \ String::from(\"\")];\n    for c in s.chars() {\n        let c: char = c; //\n\
    \        match c {\n            'A'...'Z' => {\n                let mut n = 0;\n\
    \                let mut new_c = c;\n                for n in 2..=3 {\n      \
    \              new_c = ((c - 'A' + n) as char) as char;\n                }\n \
    \               word_chars[n - 1] += &new_c;\n            }\n            'a'...'z'\
    \ => {\n                let mut n = 0;\n                let mut new_c = c;\n \
    \               for n in 2..=3 {\n                    new_c = ((c - 'a' + n) as\
    \ char) as char;\n                }\n                word_chars[n - 1] += &new_c;\n\
    \            }\n            _ => {\n                space_chars[n - 1] += &c;\n\
    \            }\n        }\n    }\n    for i in 0..2 {\n        if word_chars[i].len()\
    \ < word_chars[i + 1].len() {\n            s = s.into_mut().replace(i, i + 1,\
    \ &space_chars[i]);\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `n` in this scope\n  --> /tmp/tmpxtm4ytb7.rs:37:29\n\
    \   |\n37 |                 space_chars[n - 1] += &c;\n   |                  \
    \           ^ help: a local variable with a similar name exists: `c`\n\nwarning:\
    \ `...` range patterns are deprecated\n  --> /tmp/tmpxtm4ytb7.rs:20:16\n   |\n\
    20 |             'A'...'Z' => {\n   |                ^^^ help: use `..=` for an\
    \ inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpxtm4ytb7.rs:28:16\n\
    \   |\n28 |             'a'...'z' => {\n   |                ^^^ help: use `..=`\
    \ for an inclusive range\n   |\n   = warning: this is accepted in the current\
    \ edition (Rust 2015) but is a hard error in Rust 2021!\n   = note: for more information,\
    \ see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpxtm4ytb7.rs:24:33\n\
    \   |\n24 |                     new_c = ((c - 'A' + n) as char) as char;\n   |\
    \                               - ^ --- char\n   |                           \
    \    |\n   |                               char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxtm4ytb7.rs:26:38\n   |\n26 |                 word_chars[n - 1]\
    \ += &new_c;\n   |                                      ^^^^^^ expected `str`,\
    \ found `char`\n   |\n   = note: expected reference `&str`\n              found\
    \ reference `&char`\n\nerror[E0369]: cannot subtract `char` from `char`\n  -->\
    \ /tmp/tmpxtm4ytb7.rs:32:33\n   |\n32 |                     new_c = ((c - 'a'\
    \ + n) as char) as char;\n   |                               - ^ --- char\n  \
    \ |                               |\n   |                               char\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpxtm4ytb7.rs:34:38\n   |\n34 |\
    \                 word_ch"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().map(|c| {\n        c.to_string()\n   \
    \ }).collect::<Vec<_>>().sorted().collect::<String>()\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Vec<String>` in\
    \ the current scope\n  --> /tmp/tmpfrdcnie6.rs:16:28\n   |\n16 |     }).collect::<Vec<_>>().sorted().collect::<String>()\n\
    \   |                            ^^^^^^ help: there is an associated function\
    \ with a similar name: `is_sorted`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().collect::<Vec<_>>().sort_unstable_by_key(|&c| c.to_ascii_lowercase()).collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpy2xwug5o.rs:14:85\n\
    \   |\n14 |     s.chars().collect::<Vec<_>>().sort_unstable_by_key(|&c| c.to_ascii_lowercase()).collect()\n\
    \   |                                                                        \
    \             ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following\
    \ trait bounds were not satisfied:\n           `(): Iterator`\n           which\
    \ is required by `&mut (): Iterator`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.normalize();\n    let mut counter = 0;\n\
    \    let mut last_counter = 0;\n    let mut word_list: Vec<&str> = Vec::new();\n\
    \    for (i, ch) in s.chars().enumerate() {\n        if i % 2 == 0 && ch != '\
    \ ' {\n            last_counter = counter;\n            counter = 0;\n       \
    \ }\n        if i % 2 == 0 && ch != ' ' && counter < last_counter {\n        \
    \    let tmp = ch.to_ascii_lowercase();\n            word_list.push(&tmp);\n \
    \       }\n        if i % 2 == 1 && ch == ' ' && counter < last_counter {\n  \
    \          let tmp = word_list.last().to_ascii_lowercase();\n            word_list.pop();\n\
    \            word_list.push(&tmp);\n        }\n        counter += 1;\n    }\n\
    \    let mut s = String::with_capacity(s.len());\n    for (i, word) in word_list.iter().enumerate()\
    \ {\n        if i % 2 == 1 {\n            s.push(word);\n        } else {\n  \
    \          s.push(&s[i - counter]);\n        }\n    }\n    s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `normalize` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmphrz5g2lc.rs:15:7\n   |\n15 |     s.normalize();\n\
    \   |       ^^^^^^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmphrz5g2lc.rs:26:28\n   |\n26 |             word_list.push(&tmp);\n\
    \   |                            ^^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror[E0599]:\
    \ no method named `to_ascii_lowercase` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmphrz5g2lc.rs:29:40\n   |\n29 |             let tmp = word_list.last().to_ascii_lowercase();\n\
    \   |                                        ^^^^^^^^^^^^^^^^^^ method not found\
    \ in `Option<&&str>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphrz5g2lc.rs:38:20\n\
    \   |\n38 |             s.push(word);\n   |                    ^^^^ expected `char`,\
    \ found `&&str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphrz5g2lc.rs:40:21\n   |\n40 |             s.push(&s[i - counter]);\n\
    \   |                     ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmphrz5g2lc.rs:40:20\n\
    \   |\n40 |             s.push(&s[i - counter]);\n   |                    ^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\nhelp: consider removing the borrow\n   |\n40\
    \ -             s.push(&s[i - counter]);\n40 +             s.push(s[i - counter]);\n\
    \   | \n\nerror: aborting due to 6 previous errors\n\nSome errors have"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut word = String::from(s);\n    while !word.is_empty()\
    \ {\n        let mut first = word.chars().nth(0);\n        let mut rest = word.chars().skip(1);\n\
    \        if rest < first.as_str().as_bytes().iter().rev() {\n            word\
    \ = &first..&*rest;\n        } else {\n            word = &rest..&first;\n   \
    \     }\n    }\n    word\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpzzwl13pn.rs:18:25\n   |\n18 |         if rest < first.as_str().as_bytes().iter().rev()\
    \ {\n   |                         ^^^^^^ method not found in `Option<char>`\n\n\
    error[E0614]: type `Skip<Chars<'_>>` cannot be dereferenced\n  --> /tmp/tmpzzwl13pn.rs:19:29\n\
    \   |\n19 |             word = &first..&*rest;\n   |                         \
    \    ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzwl13pn.rs:19:20\n\
    \   |\n14 |     let mut word = String::from(s);\n   |                    ---------------\
    \ expected due to this value\n...\n19 |             word = &first..&*rest;\n \
    \  |                    ^^^^^^^^^^^^^^ expected struct `String`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected struct `String`\n             \
    \ found struct `std::ops::Range<&Option<char>>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpzzwl13pn.rs:21:27\n   |\n21 |             word = &rest..&first;\n\
    \   |                           ^^^^^^ expected struct `Skip`, found enum `Option`\n\
    \   |\n   = note: expected reference `&Skip<Chars<'_>>`\n              found reference\
    \ `&Option<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzzwl13pn.rs:21:20\n\
    \   |\n14 |     let mut word = String::from(s);\n   |                    ---------------\
    \ expected due to this value\n...\n21 |             word = &rest..&first;\n  \
    \ |                    ^^^^^^^^^^^^^ expected struct `String`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected struct `String`\n              found struct `std::ops::Range<&Skip<Chars<'_>>>`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.to_lowercase();\n    debug_assert!(s.chars().count()\
    \ > 0);\n    s.chars().enumerate().for_each(|(i, c)| {\n        let last = s.chars().last_mut().unwrap();\n\
    \        debug_assert!(last.ascii_lower() < i);\n        debug_assert!(last.ascii_upper()\
    \ > i);\n        s.swap(i, last.ascii_lower());\n    });\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `last_mut` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp3ml13blv.rs:17:30\n   |\n17 |         let last\
    \ = s.chars().last_mut().unwrap();\n   |                              ^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `swap` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmp3ml13blv.rs:20:11\n\
    \   |\n20 |         s.swap(i, last.ascii_lower());\n   |           ^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Store current number of spaces in temporary variable\n \
    \   let mut space_cnt = s.chars().filter(|c| c == ' ').count() as usize;\n   \
    \ let mut new_s = String::with_capacity(s.size());\n    for c in s.chars() {\n\
    \        if c == ' ' {\n            new_s.push(\" \");\n        } else {\n   \
    \         let new_c = if space_cnt > 0 {\n                let mut char_pos = s.chars().position(|&a|\
    \ a == c);\n                let mut cur_ch = String::new();\n                cur_ch.push_str(&s[char_pos]);\n\
    \                while char_pos != s.chars().end() && s[char_pos] == c {\n   \
    \                 cur_ch.push_str(&s[char_pos]);\n                    char_pos\
    \ = s.chars().position(|&a| a == c);\n                }\n                new_c.push_str(cur_ch);\n\
    \            } else {\n                c\n            };\n            new_s.push(new_c);\n\
    \            space_cnt -= 1;\n        }\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `new_c` in this scope\n  --> /tmp/tmproq3v1nz.rs:29:17\n\
    \   |\n29 |                 new_c.push_str(cur_ch);\n   |                 ^^^^^\
    \ help: a local variable with a similar name exists: `new_s`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmproq3v1nz.rs:15:48\n   |\n15\
    \ |     let mut space_cnt = s.chars().filter(|c| c == ' ').count() as usize;\n\
    \   |                                                ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmproq3v1nz.rs:16:45\n   |\n16 |     let mut new_s = String::with_capacity(s.size());\n\
    \   |                                             ^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmproq3v1nz.rs:19:24\n   |\n19 |\
    \             new_s.push(\" \");\n   |                        ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n19 |             new_s.push(' ');\n   |                      \
    \  ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmproq3v1nz.rs:22:56\n  \
    \ |\n22 |                 let mut char_pos = s.chars().position(|&a| a == c);\n\
    \   |                                                        ^--\n   |       \
    \                                                 ||\n   |                   \
    \                                     |expected due to this\n   |            \
    \                                            expected `char`, found reference\n\
    \   |                                                        help: did you mean\
    \ `a`: `&char`\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n\nerror[E0277]: the type `String` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmproq3v1nz.rs:24:34\n   |\n24 |                 cur_ch.push_str(&s[char_pos]);\n\
    \   |                                  ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `Option<usize>`\n   |\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = s.as_bytes().to_vec();\n    buffer.sort_by_key(|&x|\
    \ x.cmp(b'a'));\n    buffer.sort_by_key(|&x| x.cmp(b'A'));\n    String::from_utf8(buffer).unwrap()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_lxj98n0.rs:15:35\n   |\n\
    15 |     buffer.sort_by_key(|&x| x.cmp(b'a'));\n   |                         \
    \          ^^^^\n   |                                   |\n   |              \
    \                     expected `&u8`, found `u8`\n   |                       \
    \            help: consider borrowing here: `&b'a'`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_lxj98n0.rs:16:35\n   |\n16 |     buffer.sort_by_key(|&x|\
    \ x.cmp(b'A'));\n   |                                   ^^^^\n   |           \
    \                        |\n   |                                   expected `&u8`,\
    \ found `u8`\n   |                                   help: consider borrowing\
    \ here: `&b'A'`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut r = String::new();\n    let mut l = String::new();\n\
    \    for i in s.chars() {\n        let t = i as char;\n        if i < 123 {\n\
    \            l.push(t);\n        } else {\n            r.push(t);\n        }\n\
    \    }\n    r += l;\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgh_1ncjh.rs:18:16\n   |\n\
    18 |         if i < 123 {\n   |                ^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgh_1ncjh.rs:24:10\n   |\n24 |\
    \     r += l;\n   |          ^\n   |          |\n   |          expected `&str`,\
    \ found struct `String`\n   |          help: consider borrowing here: `&l`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by(|a, b| a.cmp(b).reverse());\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpy847gk29.rs:15:7\n   |\n15 |     s.sort_by(|a,\
    \ b| a.cmp(b).reverse());\n   |       ^^^^^^^ method not found in `String`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = s.clone();\n    let mut new_buffer: Vec<u8>\
    \ = vec![];\n    for c in buffer.chars() {\n        match c {\n            ' '\
    \ => new_buffer.push(0x20),\n            '_' => new_buffer.push(0x5F),\n     \
    \       '!' => new_buffer.push(0x21),\n            '$' => new_buffer.push(0x24),\n\
    \            '%' => new_buffer.push(0x25),\n            '&' => new_buffer.push(0x26),\n\
    \            '\\'' => new_buffer.push(0x27),\n            '(' | ')' => {\n   \
    \             new_buffer.push(c as u8);\n            }\n            other => {\n\
    \                let i = if other == 0x2E {\n                    new_buffer.len()\n\
    \                } else {\n                    new_buffer.len()\n            \
    \    };\n                new_buffer.push(c);\n                for _ in 0..i {\n\
    \                    new_buffer.push(0x20);\n                }\n            }\n\
    \        }\n    }\n    new_buffer.into_iter().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeel2r2mp.rs:29:37\n   |\n\
    29 |                 let i = if other == 0x2E {\n   |                        \
    \             ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpeel2r2mp.rs:34:33\n   |\n34 |                 new_buffer.push(c);\n\
    \   |                                 ^ expected `u8`, found `char`\n\nerror[E0277]:\
    \ a value of type `String` cannot be built from an iterator over elements of type\
    \ `u8`\n    --> /tmp/tmpeel2r2mp.rs:41:28\n     |\n41   |     new_buffer.into_iter().collect::<String>()\n\
    \     |                            ^^^^^^^ value of type `String` cannot be built\
    \ from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut chars = String::new();\n    for\
    \ c in s.chars().cloned() {\n        chars.push(c); //copy the chars\n    }\n\
    \    let mut new_chars = String::new();\n    while chars.len() > 0 {\n       \
    \ let mut index = chars.len() - 1;\n        while index >= 0 && chars[index] ==\
    \ ' ' {\n            index -= 1;\n        }\n        chars.pop(index);\n     \
    \   let char_index = chars.len() - 1;\n        let mut next_char = chars[char_index];\n\
    \        let mut i = 0;\n        while i < char_index {\n            new_chars.push('\
    \ '); //spaces before the next word\n            new_chars.push(next_char); //copy\
    \ the next char\n            i += 1;\n        }\n        if char_index == 0 {\n\
    \            new_chars.push(' '); //spaces before the end of the string\n    \
    \    }\n        else {\n            new_chars.push(' '); //spaces after the next\
    \ word\n            new_chars.push(chars[char_index - 1]); //copy the char in\
    \ the middle of the string\n        }\n    }\n    s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp_0t0ailj.rs:16:24\n     |\n16   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp_0t0ailj.rs:16:14\n\
    \   |\n16 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp_0t0ailj.rs:16:14\n   |\n16 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp_0t0ailj.rs:22:29\n\
    \   |\n22 |         while index >= 0 && chars[index] == ' ' {\n   |          \
    \                   ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0061]:\
    \ this function takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmp_0t0ailj.r"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.to_lowercase().split_whitespace().dedup().collect::<Vec<_>>().into_iter().map(\n\
    \        |i| {\n            i.chars().enumerate().filter_map(|(idx, c)| {\n  \
    \              if let Some((_, idx)) = idx {\n                    Some(c.to_ascii_lowercase().unwrap().to_lowercase().unwrap())\n\
    \                } else {\n                    None\n                }\n     \
    \       }).collect::<Vec<_>>()\n        },\n    )\n    .collect::<Vec<_>>()\n\
    \    .join().to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `dedup` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp9thuozz7.rs:14:41\n   |\n14 |     s.to_lowercase().split_whitespace().dedup().collect::<Vec<_>>().into_iter().map(\n\
    \   |                                         ^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().sort_by_key(|&x| x as usize)\n        .collect()\n\
    \        .map(|x| x.to_string()).collect()\n        .join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpfn1gj8x1.rs:14:15\n   |\n14 |     s.chars().sort_by_key(|&x|\
    \ x as usize)\n   |               ^^^^^^^^^^^ method not found in `Chars<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a, b| a.chars().zip(b.chars()).last().unwrap())\n\
    \        .to_string()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpmyay7gld.rs:14:26\n   |\n14 |     s.split_whitespace().sort_by(|a,\
    \ b| a.chars().zip(b.chars()).last().unwrap())\n   |                         \
    \ ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    let mut words = chars.split_whitespace();\n\
    \    let mut char_map = [0; 256];\n    while !words.is_empty() {\n        words.sort_by_key(|w|\
    \ w.chars().map(|c| char_map[c]).collect::<Vec<_>>().iter().cloned());\n     \
    \   words.sort_by_key(|w| w.chars().map(|c| char_map[c]).collect::<Vec<_>>().iter().cloned());\n\
    \        char_map.truncate(0);\n        char_map.extend_from_slice(words.into_iter().map(|w|\
    \ w.chars().map(|c| char_map[c]).collect::<Vec<_>>().iter().cloned()).collect::<Vec<_>>());\n\
    \        words.truncate(0);\n        words.extend_from_slice(words.into_iter().map(|w|\
    \ w.chars().map(|c| char_map[c]).collect::<Vec<_>>().iter().cloned()).collect::<Vec<_>>());\n\
    \    }\n    String::from_utf8(words.iter().map(|w| w.to_string()).collect::<Vec<_>>()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_whitespace` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmp3pyqd1vc.rs:15:27\n   |\n15 |     let mut\
    \ words = chars.split_whitespace();\n   |                           ^^^^^^^^^^^^^^^^\
    \ method not found in `Chars<'_>`\n\nerror[E0599]: no method named `truncate`\
    \ found for array `[{integer}; 256]` in the current scope\n  --> /tmp/tmp3pyqd1vc.rs:20:18\n\
    \   |\n20 |         char_map.truncate(0);\n   |                  ^^^^^^^^ method\
    \ not found in `[{integer}; 256]`\n\nerror[E0599]: no method named `extend_from_slice`\
    \ found for array `[{integer}; 256]` in the current scope\n  --> /tmp/tmp3pyqd1vc.rs:21:18\n\
    \   |\n21 | ...   char_map.extend_from_slice(words.into_iter().map(|w| w.chars().map(|c|\
    \ char_map[c]).collect::<Vec<_>>().iter().cloned()).collect::<...\n   |      \
    \          ^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `clone_from_slice`\n\nerror: aborting due to 3 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = s.clone();\n    result.sort_by(|a, b| a.cmp(b));\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfctli6cw.rs:15:12\n   |\n15 |     result.sort_by(|a,\
    \ b| a.cmp(b));\n   |            ^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().enumerate().for_each(|(_, v)| {\n        match v\
    \ {\n            char::FromAscii(c) => {\n                let tmp = c + 32;\n\
    \                if tmp > 96 {\n                    let mut k = c - 65;\n    \
    \                c.to_ascii_lowercase().to_ascii_lowercase();\n              \
    \      c += k;\n                }\n            }\n            char::FromHex(c)\
    \ => {\n                let mut tmp = 0;\n                if c >= '0' {\n    \
    \                tmp = (c as u32) - 48;\n                    if tmp > 9 {\n  \
    \                      tmp -= 8;\n                    }\n                }\n \
    \               c.to_ascii_lowercase().to_ascii_lowercase();\n               \
    \ c += tmp;\n            }\n        }\n    });\n    s\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `FromAscii` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpaz7tl8cc.rs:16:19\n   |\n16 |          \
    \   char::FromAscii(c) => {\n   |                   ^^^^^^^^^ associated item\
    \ not found in `char`\n\nerror[E0599]: no associated item named `FromHex` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpaz7tl8cc.rs:24:19\n   |\n\
    24 |             char::FromHex(c) => {\n   |                   ^^^^^^^ associated\
    \ item not found in `char`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut result: Vec<_> = s.chars().collect();\n\
    \    let mut new_result: Vec<_> = result.clone();\n    let mut last_char = result[0];\n\
    \    for c in &result[1..] {\n        let mut new_c: u8 = c.to_digit(10);\n  \
    \      if new_c > last_char {\n            new_result.push(last_char);\n     \
    \       new_result.push(c);\n        }\n        last_char = new_c;\n    }\n  \
    \  String::from_utf8_lossy(&new_result)\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc_8s29g6.rs:19:29\n   |\n\
    19 |         let mut new_c: u8 = c.to_digit(10);\n   |                       \
    \ --   ^^^^^^^^^^^^^^ expected `u8`, found enum `Option`\n   |               \
    \         |\n   |                        expected due to this\n   |\n   = note:\
    \ expected type `u8`\n              found enum `Option<u32>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc_8s29g6.rs:20:20\n   |\n20 |         if new_c\
    \ > last_char {\n   |                    ^^^^^^^^^ expected `u8`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpc_8s29g6.rs:22:29\n   |\n22 |\
    \             new_result.push(c);\n   |                             ^ expected\
    \ `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n   |\n\
    22 |             new_result.push(*c);\n   |                             +\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpc_8s29g6.rs:24:21\n   |\n17 |  \
    \   let mut last_char = result[0];\n   |                         --------- expected\
    \ due to this value\n...\n24 |         last_char = new_c;\n   |              \
    \       ^^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpc_8s29g6.rs:26:29\n   |\n26 |     String::from_utf8_lossy(&new_result)\n\
    \   |                             ^^^^^^^^^^^ expected slice `[u8]`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&[u8]`\n              found reference\
    \ `&Vec<char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc_8s29g6.rs:26:5\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n26 |     String::from_utf8_lossy(&new_result)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found enum `Cow`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Cow<'_,\
    \ str>`\n\nerror: aborting due to 6 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c| (c as u32).to_string().chars().collect::<Vec<_>>())\n\
    \        .unwrap_or_else(Vec::new)\n        .sort_by(|a, b| a.len() < b.len()).collect::<Vec<_>>()\n\
    \        .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n \
    \   assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or_else` found for struct `Map` in\
    \ the current scope\n  --> /tmp/tmpz27gncyv.rs:16:10\n   |\n16 |         .unwrap_or_else(Vec::new)\n\
    \   |          ^^^^^^^^^^^^^^ method not found in `Map<Chars<'_>, [closure@/tmp/tmpz27gncyv.rs:15:14:\
    \ 15:68]>`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // split into words\n    let mut words = s.split_whitespace();\n\
    \n    // sort each word and append them to the new string\n    let mut new_string\
    \ = String::new();\n\n    for (i, word) in words.iter().enumerate() {\n      \
    \  // split the word into an array\n        let w: Vec<u8> = word.as_bytes().to_vec();\n\
    \n        // get the ascii value of the character\n        let char_ascii: u8\
    \ = w.iter().map(|c| *c).sum();\n\n        // reverse the array\n        let mut\
    \ r = w.iter_mut();\n        r.rev();\n\n        // append the array in ascending\
    \ order based on ascii value\n        new_string.push_str(r.collect::<String>());\n\
    \        new_string.push_str(\" \");\n    }\n    new_string\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp4c_6d2b4.rs:20:28\n   |\n20 |     for (i,\
    \ word) in words.iter().enumerate() {\n   |                            ^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0277]: a value of type `String`\
    \ cannot be built from an iterator over elements of type `&mut u8`\n    --> /tmp/tmp4c_6d2b4.rs:32:31\n\
    \     |\n32   |         new_string.push_str(r.collect::<String>());\n     |  \
    \                             ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=&mut u8>`\n     |\n     = help: the trait `FromIterator<&mut\
    \ u8>` is not implemented for `String`\n     = help: the following other types\
    \ implement trait `FromIterator<A>`:\n               <String as FromIterator<&'a\
    \ char>>\n               <String as FromIterator<&'a str>>\n               <String\
    \ as FromIterator<Box<str>>>\n               <String as FromIterator<Cow<'a, str>>>\n\
    \               <String as FromIterator<String>>\n               <String as FromIterator<char>>\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp4c_6d2b4.rs:32:29\n   |\n32 |         new_string.push_str(r.collect::<String>());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^\n   |                \
    \             |\n   |                             expected `&str`, found struct\
    \ `String`\n   |                             help: consider borrowing here: `&r.collect::<String>()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    let mut rev = String::from(s);\n\
    \    rev.rev();\n    s.split_whitespace().sort_by_key(|c| c.to_ascii_lowercase()).collect();\n\
    \    s.chars().filter(|c| !c.is_whitespace()).collect();\n    rev.chars().filter(|c|\
    \ !c.is_whitespace()).collect();\n    s\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: `String` is not an iterator\n   --> /tmp/tmpo9vez1yu.rs:16:9\n\
    \    |\n16  |       rev.rev();\n    |           ^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `String: Iterator`\n            which\
    \ is required by `&mut String: Iterator`\n            `str: Iterator`\n      \
    \      which is required by `&mut str: Iterator`\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `SplitWhitespace` in the current scope\n  -->\
    \ /tmp/tmpo9vez1yu.rs:17:26\n   |\n17 |     s.split_whitespace().sort_by_key(|c|\
    \ c.to_ascii_lowercase()).collect();\n   |                          ^^^^^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .map(|c| {\n            let ord = c.to_ascii_lowercase();\n\
    \            ord\n        })\n        .collect()\n        .join(\" \")\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpkz7fmqv3.rs:19:10\n\
    \   |\n19 |         .collect()\n   |          ^^^^^^^ cannot infer type for type\
    \ parameter `B` declared on the associated function `collect`\n   |\n   = note:\
    \ type must be known at this point\nhelp: consider specifying the type argument\
    \ in the method call\n   |\n19 |         .collect::<B>()\n   |               \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.get_sorted_words()\n        .iter()\n        .map(|word|\
    \ {\n            word.to_string().chars().enumerate()\n                .map(|(pos,\
    \ c)| if c < ' ' {\n                    c\n                } else {\n        \
    \            let mut nc = c;\n                    while nc.is_ascii() {\n    \
    \                    nc += 1;\n                    }\n                    nc\n\
    \                })\n                .collect::<Vec<_>>()\n                .sort_by_key(|c|\
    \ c)\n                .collect()\n        })\n        .collect::<Vec<_>>()\n \
    \       .join(\"_\")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `get_sorted_words` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpar3ep4hf.rs:14:7\n   |\n14 |     s.get_sorted_words()\n\
    \   |       ^^^^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| !c.is_whitespace())\n      \
    \  .sort_by_key(|c| c.to_ascii_lowercase().unwrap())\n        .collect::<String>()\n\
    \        .clone()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpixo4vlwq.rs:16:10\n   |\n16 |         .sort_by_key(|c|\
    \ c.to_ascii_lowercase().unwrap())\n   |          ^^^^^^^^^^^ method not found\
    \ in `Filter<Chars<'_>, [closure@/tmp/tmpixo4vlwq.rs:15:17: 15:39]>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = String::new();\n    let mut word_count = s.chars().count();\n\
    \    for (i, c) in s.chars().enumerate() {\n        let w = c.to_string();\n \
    \       if !w.is_alphanumeric() {\n            if i > word_count {\n         \
    \       // no more space left in the sentence so break the sentence\n        \
    \        return s;\n            }\n            let mut new_w = w.to_owned();\n\
    \            let mut j = i;\n            while j + 1 < word_count && s[j + 1]\
    \ == ' ' {\n                j += 1;\n            }\n            new_w.swap(w.to_string());\n\
    \            for _ in 0..(j - i) {\n                words.push(' ');\n       \
    \     }\n            words.push(new_w);\n        }\n    }\n    words\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_alphanumeric` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp37ahiqlm.rs:18:15\n   |\n18 |         if\
    \ !w.is_alphanumeric() {\n   |               ^^^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp37ahiqlm.rs:25:41\n   |\n25 |             while j + 1 < word_count\
    \ && s[j + 1] == ' ' {\n   |                                         ^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp37ahiqlm.rs:28:19\n   |\n28 |          \
    \   new_w.swap(w.to_string());\n   |                   ^^^^ method not found in\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp37ahiqlm.rs:32:24\n\
    \   |\n32 |             words.push(new_w);\n   |                        ^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0308, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.chars()\n        .map(|c| match c {\n      \
    \      c if c < ' ' || c > 'z' => (c, c as u8),\n            c if c == ' ' =>\
    \ (c, c as u8),\n            c => (c as u8 - 'a' as u8, c as u8),\n        })\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .sort_by_key(|(_, c)|\
    \ c) // sort by ascii value\n        .collect::<Vec<_>>()\n        .iter()\n \
    \       .map(|c| {\n            if c.0 == c.1 {\n                (c.0 as char,\
    \ c.0 as char) as char\n            } else {\n                c.0 as char + c.1\
    \ as char\n            }\n        })\n        .collect::<String>()\n        .to_owned()\n\
    \    )\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmps0g8hv85.rs:18:18\n\
    \   |\n15 |           .map(|c| match c {\n   |  __________________-\n16 | |  \
    \           c if c < ' ' || c > 'z' => (c, c as u8),\n   | |                 \
    \                       ------------ this is found to be of type `(char, u8)`\n\
    17 | |             c if c == ' ' => (c, c as u8),\n   | |                    \
    \          ------------ this is found to be of type `(char, u8)`\n18 | |     \
    \        c => (c as u8 - 'a' as u8, c as u8),\n   | |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `u8`\n19 | |         })\n   | |_________- `match` arms\
    \ have incompatible types\n   |\n   = note: expected tuple `(char, _)`\n     \
    \         found tuple `(u8, _)`\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `std::slice::Iter` in the current scope\n  --> /tmp/tmps0g8hv85.rs:22:10\n\
    \   |\n22 |         .sort_by_key(|(_, c)| c) // sort by ascii value\n   |    \
    \      ^^^^^^^^^^^ method not found in `std::slice::Iter<'_, _>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut counter = 0;\n    let mut result: String = String::new();\n\
    \    for word in s.split_whitespace() {\n        let word = word.to_lowercase();\n\
    \        if word != \"\" {\n            result.push_str(&word.chars().sorted().collect::<Vec<u16>>());\n\
    \            counter += 1;\n        }\n    }\n    if counter == 0 {\n        result\n\
    \    } else {\n        result\n            .chars()\n            .enumerate()\n\
    \            .map(|(_, index)| {\n                let i = index as u16;\n    \
    \            (result.chars()[i..].collect::<Vec<_>>(), counter)\n            })\n\
    \            .collect::<Vec<_>>()\n            .join()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sorted` found for struct `Chars` in the\
    \ current scope\n  --> /tmp/tmp39_9ra4c.rs:19:43\n   |\n19 |             result.push_str(&word.chars().sorted().collect::<Vec<u16>>());\n\
    \   |                                           ^^^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp39_9ra4c.rs:31:18\n\
    \   |\n31 |                 (result.chars()[i..].collect::<Vec<_>>(), counter)\n\
    \   |                  ^^^^^^^^^^^^^^^^^^^\n\nerror[E0061]: this function takes\
    \ 1 argument but 0 arguments were supplied\n   --> /tmp/tmp39_9ra4c.rs:34:14\n\
    \    |\n34  |             .join()\n    |              ^^^^- supplied 0 arguments\n\
    \    |              |\n    |              expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0599, E0608.\nFor more information about\
    \ an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    let mut new_s = String::new();\n\
    \    let mut new_char = String::new();\n    let mut new_word_char = String::new();\n\
    \    let mut new_word_chars = Vec::new();\n    let mut index = 0;\n    while index\
    \ < s.len() {\n        if chars.last().unwrap() != ' ' {\n            new_s.push('\
    \ ');\n        }\n        new_word_chars.push(chars.last().unwrap());\n      \
    \  chars.next();\n        index += 1\n    }\n    new_s += &new_word_chars\n  \
    \      .into_iter()\n        .chain(new_word_chars.into_iter())\n        .collect();\n\
    \    new_s += \" \";\n    new_s += &new_word_char\n        .into_iter()\n    \
    \    .chain(new_word_char.into_iter())\n        .collect();\n    new_s\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `str` cannot be built from an iterator over\
    \ elements of type `char`\n    --> /tmp/tmptfv7bwba.rs:31:10\n     |\n31   | \
    \        .collect();\n     |          ^^^^^^^ value of type `str` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `str`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror[E0599]: the method `into_iter` exists\
    \ for struct `String`, but its trait bounds were not satisfied\n   --> /tmp/tmptfv7bwba.rs:34:10\n\
    \    |\n34  |           .into_iter()\n    |            ^^^^^^^^^\n    |\n    =\
    \ note: the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `String: IntoIterator`\n            `&String:\
    \ Iterator`\n            which is required by `&String: IntoIterator`\n      \
    \      `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0599]: the method `into_iter`\
    \ exists for struct `String`, but its trait bounds were not satisfied\n   -->\
    \ /tmp/tmptfv7bwba.rs:35:30\n    |\n35  |           .chain(new_word_char.into_iter())\n\
    \    |                                ^^^^^^^^^\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `String: IntoIterator`\n            `&String: Iterat"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Split by spaces\n    let words = s.split_whitespace();\n\
    \n    // Create a sorted map with sorted keys and values\n    let mut sorted_map:\
    \ Vec<(Char, Char)> = words.into_iter().collect();\n\n    // Sort the map based\
    \ on its value\n    sorted_map.sort_by(|&(k, _)| k.chars().count().cmp(&k.chars().count()).reversed());\n\
    \n    // Return the result \n    String::from_iter(sorted_map.iter().map(|(k,\
    \ v)| (k.to_string(), v.to_string())).collect())\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmp4ko8m8ur.rs:18:30\n\
    \   |\n18 |     let mut sorted_map: Vec<(Char, Char)> = words.into_iter().collect();\n\
    \   |                              ^^^^\n   |\nhelp: a builtin type with a similar\
    \ name exists\n   |\n18 |     let mut sorted_map: Vec<(char, Char)> = words.into_iter().collect();\n\
    \   |                              ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n13 | fn anti_shuffle<Char>(s: String) -> String {\n   |               \
    \ ++++++\n\nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmp4ko8m8ur.rs:18:36\n\
    \   |\n18 |     let mut sorted_map: Vec<(Char, Char)> = words.into_iter().collect();\n\
    \   |                                    ^^^^\n   |\nhelp: a builtin type with\
    \ a similar name exists\n   |\n18 |     let mut sorted_map: Vec<(Char, char)>\
    \ = words.into_iter().collect();\n   |                                    ~~~~\n\
    help: you might be missing a type parameter\n   |\n13 | fn anti_shuffle<Char>(s:\
    \ String) -> String {\n   |                ++++++\n\nerror[E0599]: no function\
    \ or associated item named `from_iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4ko8m8ur.rs:24:13\n   |\n24 |     String::from_iter(sorted_map.iter().map(|(k,\
    \ v)| (k.to_string(), v.to_string())).collect())\n   |             ^^^^^^^^^ function\
    \ or associated item not found in `String`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::iter::FromIterator;\n\
    \   |\nhelp: there is an associated function with a similar name\n   |\n24 | \
    \    String::from_utf8(sorted_map.iter().map(|(k, v)| (k.to_string(), v.to_string())).collect())\n\
    \   |             ~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0412, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::with_capacity(s.len());\n    for c in\
    \ s.chars() {\n        if c == ' ' {\n            res.push_str(\"!!\");\n    \
    \    } else {\n            res.push(c);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmp4erg4okq.rs:28:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = vec![];\n    let mut result = String::from(\"\
    \");\n    for (i, c) in s.chars().enumerate() {\n        if i > 0 && c != ' '\
    \ {\n            let prev = words[i - 1];\n            if prev == ' ' {\n    \
    \            words.push(c);\n            } else {\n                words.push(c).unwrap();\n\
    \            }\n        } else if i == 0 {\n            words.push(c);\n     \
    \   } else {\n            result.append(&words);\n            words.clear();\n\
    \        }\n    }\n    result.append(&words);\n    result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for unit type `()` in the\
    \ current scope\n  --> /tmp/tmps162dwnq.rs:22:31\n   |\n22 |                 words.push(c).unwrap();\n\
    \   |                               ^^^^^^ method not found in `()`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmps162dwnq.rs:27:20\n   |\n27 |             result.append(&words);\n \
    \  |                    ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmps162dwnq.rs:31:12\n   |\n31 |     result.append(&words);\n   |     \
    \       ^^^^^^ method not found in `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort().join(\" \")\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpamw43z3v.rs:14:26\n   |\n14 |     s.split_whitespace().sort().join(\"\
    \ \")\n   |                          ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s;\n    }\n    let mut r\
    \ = String::new();\n    let mut buffer = Vec::new();\n    let mut ascii_counts\
    \ = vec![0; 256];\n    for c in s.chars() {\n        buffer.push(c);\n       \
    \ let c = char::from_u32(c).unwrap();\n        ascii_counts[c] += 1;\n    }\n\
    \    for (c, _) in ascii_counts.iter().max_by_key(|(_, count)| *count) {\n   \
    \     if ascii_counts[c] > 1 {\n            let c = char::from_u32(c + 1).unwrap();\n\
    \            buffer.push(c);\n        }\n    }\n    let mut new_buffer = vec![buffer[0];\
    \ buffer.len()];\n    new_buffer.iter_mut().for_each(|c| c.write_ascii_lowercase(&mut\
    \ r));\n    r\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzkbf7frk.rs:22:32\n   |\n\
    22 |         let c = char::from_u32(c).unwrap();\n   |                       \
    \         ^ expected `u32`, found `char`\n   |\nhelp: you can cast a `char` to\
    \ a `u32`, since a `char` always occupies 4 bytes\n   |\n22 |         let c =\
    \ char::from_u32(c as u32).unwrap();\n   |                                  ++++++\n\
    \nerror[E0277]: the type `[{integer}]` cannot be indexed by `char`\n  --> /tmp/tmpzkbf7frk.rs:23:9\n\
    \   |\n23 |         ascii_counts[c] += 1;\n   |         ^^^^^^^^^^^^^^^ slice\
    \ indices are of type `usize` or ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<[{integer}]>` is not implemented for `char`\n   = note: required\
    \ because of the requirements on the impl of `Index<char>` for `Vec<{integer}>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzkbf7frk.rs:25:51\n   |\n25 |\
    \     for (c, _) in ascii_counts.iter().max_by_key(|(_, count)| *count) {\n  \
    \ |                                                   ^^^^^^^^^-\n   |       \
    \                                            |        |\n   |                \
    \                                   |        expected due to this\n   |      \
    \                                             expected integer, found tuple\n\
    \   |\n   = note: expected type `{integer}`\n             found tuple `(_, _)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzkbf7frk.rs:25:9\n   |\n25 | \
    \    for (c, _) in ascii_counts.iter().max_by_key(|(_, count)| *count) {\n   |\
    \         ^^^^^^    --------------------------------------------------- this expression\
    \ has type `Option<&{integer}>`\n   |         |\n   |         expected integer,\
    \ found tuple\n   |\n   = note: expected type `{integer}`\n             found\
    \ tuple `(_, _)`\n\nerror[E0599]: no method named `write_ascii_lowercase` found\
    \ for mutable reference `&mut char` in the current scope\n  --> /tmp/tmpzkbf7frk.rs:32:42\n\
    \   |\n32 |     new_buffer.iter_mut().for_each(|c| c.write_ascii_lowercase(&mut\
    \ r));\n   |                                          ^^^^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a simil"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        if c.is_ascii_letter() {\n   \
    \         if c.ascii_number() > 123 {\n                char::from(c.to_ascii_lowercase());\n\
    \            } else {\n                char::from(c.to_ascii_uppercase());\n \
    \           }\n        } else {\n            char::from(c.to_lowercase());\n \
    \       }\n    }).collect::<String>().into_iter().collect();\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpg5r_pfj_.rs:15:14\n   |\n15 |         if c.is_ascii_letter()\
    \ {\n   |              ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror[E0599]: no method named `ascii_number` found\
    \ for type `char` in the current scope\n  --> /tmp/tmpg5r_pfj_.rs:16:18\n   |\n\
    16 |             if c.ascii_number() > 123 {\n   |                  ^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0277]: the trait bound `char: From<ToLowercase>`\
    \ is not satisfied\n  --> /tmp/tmpg5r_pfj_.rs:22:13\n   |\n22 |             char::from(c.to_lowercase());\n\
    \   |             ^^^^^^^^^^ the trait `From<ToLowercase>` is not implemented\
    \ for `char`\n   |\n   = help: the trait `From<u8>` is implemented for `char`\n\
    \nerror[E0599]: the method `into_iter` exists for struct `String`, but its trait\
    \ bounds were not satisfied\n   --> /tmp/tmpg5r_pfj_.rs:24:28\n    |\n24  |  \
    \     }).collect::<String>().into_iter().collect();\n    |                   \
    \           ^^^^^^^^^\n    |\n    = note: the following trait bounds were not\
    \ satisfied:\n            `String: Iterator`\n            which is required by\
    \ `String: IntoIterator`\n            `&String: Iterator`\n            which is\
    \ required by `&String: IntoIterator`\n            `&mut String: Iterator`\n \
    \           which is required by `&mut String: IntoIterator`\n            `str:\
    \ Sized`\n            which is required by `str: IntoIterator`\n            `str:\
    \ Iterator`\n            which is required by `str: IntoIterator`\n          \
    \  `&str: Iterator`\n            which is required by `&str: IntoIterator`\n \
    \           `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpg5r_pfj_.rs:13:31\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |    ------------     \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to 5 previous e"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.splitn(\" \").collect::<Vec<String>>();\n\
    \    let mut chars_orderd = Vec::new();\n    for word in words {\n        let\
    \ mut chars_ord = Vec::new();\n        for char in word.chars() {\n          \
    \  let ascii = char.ascii();\n            chars_ord.push(ascii);\n        }\n\
    \        chars_orderd.push(chars_ord);\n    }\n    let mut words_ordered = Vec::new();\n\
    \    for chars_ords in chars_orderd {\n        let mut words = Vec::new();\n \
    \       for char_ords in chars_ords {\n            words.push(*char_ords);\n \
    \       }\n        words_ordered.push(words.clone());\n    }\n    String::from_utf8_lossy(&words_ordered)\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpui5vlcge.rs:14:23\n     |\n14   |     let mut words = s.splitn(\"\
    \ \").collect::<Vec<String>>();\n     |                       ^^^^^^ --- supplied\
    \ 1 argument\n     |                       |\n     |                       expected\
    \ 2 arguments\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpui5vlcge.rs:14:35\n     |\n14   |     let mut\
    \ words = s.splitn(\" \").collect::<Vec<String>>();\n     |                  \
    \                 ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `ascii` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpui5vlcge.rs:19:30\n   |\n19 |   \
    \          let ascii = char.ascii();\n   |                              ^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpui5vlcge.rs:32:29\n   |\n32 |     String::from_utf8_lossy(&words_ordered)\n\
    \   |                             ^^^^^^^^^^^^^^ expected slice `[u8]`, found\
    \ struct `Vec`\n   |\n   = note: expected reference `&[u8]`\n              found\
    \ reference `&Vec<Vec<_>>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpui5vlcge.rs:32:5\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n32 |     String::from_utf8_lossy(&words_ordered)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ enum `Cow`\n   |\n   = note: expected struct `String`\n                found\
    \ enum `Cow<'_, str>`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed expl"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.chars().chain(s.chars().enumerate().filter(|&(e,\
    \ _)| e.is_ascii()).rev())\n        .collect::<Vec<_>>()\n        .sort_by(|a,\
    \ b| a.1.cmp(&b.1)).collect::<String>());\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii` found for type `usize` in the\
    \ current scope\n  --> /tmp/tmpdo_jixio.rs:14:75\n   |\n14 |     String::from(s.chars().chain(s.chars().enumerate().filter(|&(e,\
    \ _)| e.is_ascii()).rev())\n   |                                             \
    \                              ^^^^^^^^ method not found in `usize`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n    --> /tmp/tmpdo_jixio.rs:14:87\n\
    \     |\n14   |     String::from(s.chars().chain(s.chars().enumerate().filter(|&(e,\
    \ _)| e.is_ascii()).rev())\n     |                                           \
    \                                            ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\n     = note: 1 redundant requirement hidden\n  \
    \   = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Filter<Enumerate<Chars<'_>>, [closure@/tmp/tmpdo_jixio.rs:14:63: 14:85]>`\n\
    note: required by a bound in `rev`\n\nerror[E0271]: type mismatch resolving `<Rev<Filter<Enumerate<Chars<'_>>,\
    \ [closure@/tmp/tmpdo_jixio.rs:14:63: 14:85]>> as IntoIterator>::Item == char`\n\
    \   --> /tmp/tmpdo_jixio.rs:14:28\n    |\n14  |     String::from(s.chars().chain(s.chars().enumerate().filter(|&(e,\
    \ _)| e.is_ascii()).rev())\n    |                            ^^^^^ expected `char`,\
    \ found tuple\n    |\n    = note: expected type `char`\n              found tuple\
    \ `(usize, char)`\nnote: required by a bound in `std::iter::Iterator::chain`\n\
    \nerror[E0277]: the trait bound `Chars<'_>: ExactSizeIterator` is not satisfied\n\
    \  --> /tmp/tmpdo_jixio.rs:14:34\n   |\n14 |     String"
  stdout: ''
  timestamp: 1659976577
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .filter(|c| c <= ' ' || c == '\\n')\n  \
    \      .collect::<Vec<_>>()\n        .sort_by_key(|c| c.to_ascii_lowercase())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph9e_pt2y.rs:15:26\n   |\n\
    15 |         .filter(|c| c <= ' ' || c == '\\n')\n   |                       \
    \   ^^^\n   |                          |\n   |                          expected\
    \ `&char`, found `char`\n   |                          help: consider borrowing\
    \ here: `&' '`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmph9e_pt2y.rs:15:35\n\
    \   |\n15 |         .filter(|c| c <= ' ' || c == '\\n')\n   |                \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: `()` is not an iterator\n\
    \  --> /tmp/tmph9e_pt2y.rs:18:10\n   |\n18 |         .collect()\n   |        \
    \  ^^^^^^^ `()` is not an iterator\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `(): Iterator`\n           which is required\
    \ by `&mut (): Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut words = vec![];\n\
    \n    s.chars().enumerate().for_each(|(idx, c)| {\n        if !c.is_whitespace()\
    \ {\n            let word = s.chars().nth(idx).unwrap().to_string();\n       \
    \     words.push(word);\n        }\n    });\n\n    for word in words {\n     \
    \   let mut res = String::new();\n        let mut pos = 0;\n        let mut new_word_pos\
    \ = 0;\n        while pos < word.length() {\n            if word[pos] == ' ' {\n\
    \                let new_word = words.swap_removed(new_word_pos);\n          \
    \      let mut new_word_pos = new_word_pos + 1;\n                res = res.push_str(new_word);\n\
    \                pos = pos + 1;\n            } else {\n                res = res.push_str(&word[pos]);\n\
    \                pos = pos + 1;\n            }\n        }\n        res = res.push_str(\"\
    \ \");\n        res = res.push_str(&words[new_word_pos]);\n        res.push_str(&word);\n\
    \    }\n\n    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyzwcqrk4.rs:28:26\n   |\n28 |         while pos\
    \ < word.length() {\n   |                          ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `{integer}`\n  --> /tmp/tmpyzwcqrk4.rs:29:16\n   |\n29 |     \
    \        if word[pos] == ' ' {\n   |                ^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap_removed` found for struct `Vec<String>`\
    \ in the current scope\n  --> /tmp/tmpyzwcqrk4.rs:30:38\n   |\n30 |          \
    \       let new_word = words.swap_removed(new_word_pos);\n   |               \
    \                       ^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `remove`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzwcqrk4.rs:32:23\n\
    \   |\n25 |         let mut res = String::new();\n   |                       -------------\
    \ expected due to this value\n...\n32 |                 res = res.push_str(new_word);\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found\
    \ `()`\n   |\nnote: method `push_str` modifies its receiver in-place\n  --> /tmp/tmpyzwcqrk4.rs:32:27\n\
    \   |\n32 |                 res = res.push_str(new_word);\n   |              \
    \         --- ^^^^^^^^ this call modifies `res` in-place\n   |               \
    \        |\n   |                       you probably want to use this value after\
    \ calling the method...\n   = note: ...instead of the `()` output of method `push_str`\n\
    \nerror[E0277]: the type `String` cann"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut counter = s.chars().enumerate().map(|(_, c)| c).collect::<Vec<_>>();\n\
    \    let mut new_string = String::new();\n\n    for (i, c) in counter {\n    \
    \    if i == 0 || counter[i-1] > c {\n            new_string.push(c);\n      \
    \  } else {\n            new_string.append(&mut counter[i-1]);\n        }\n  \
    \  }\n    new_string\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpo4xnsw4h.rs:17:9\n   |\n\
    17 |     for (i, c) in counter {\n   |         ^^^^^^    ------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ tuple\n   |\n   = note: expected type `char`\n             found tuple `(_,\
    \ _)`\n\nerror[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpo4xnsw4h.rs:21:24\n   |\n21 |             new_string.append(&mut\
    \ counter[i-1]);\n   |                        ^^^^^^ method not found in `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Anti Shuffle\n    let mut output = String::from(\"0\");\n\
    \    let mut new_word = String::from(\"1\");\n\n    // Split sentence into words\n\
    \    let mut words = s.split_whitespace().collect::<Vec<_>>();\n    while words.len()\
    \ > 1 {\n        let mut word_count = words.len();\n        while word_count >\
    \ 1 {\n            // Pick random index\n            let r = rand::random::<usize>();\n\
    \            let word_index = r + rand::random::<usize>(word_count - 2);\n   \
    \         let word = words[word_index];\n            // Swap the random index\
    \ with previous and next\n            words[word_index] = words[word_index - 1];\n\
    \            words[word_index - 1] = word;\n            word_count -= 2;\n   \
    \     }\n        // Output word and increment by one\n        output += &new_word;\n\
    \        new_word = \"1\";\n    }\n\n    // Append last word\n    output += &words[0];\n\
    \n    output\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `rand`\n\
    \  --> /tmp/tmp7y70timk.rs:24:21\n   |\n24 |             let r = rand::random::<usize>();\n\
    \   |                     ^^^^ use of undeclared crate or module `rand`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `rand`\n  --> /tmp/tmp7y70timk.rs:25:34\n\
    \   |\n25 |             let word_index = r + rand::random::<usize>(word_count\
    \ - 2);\n   |                                  ^^^^ use of undeclared crate or\
    \ module `rand`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7y70timk.rs:34:20\n\
    \   |\n16 |     let mut new_word = String::from(\"1\");\n   |                \
    \        ----------------- expected due to this value\n...\n34 |         new_word\
    \ = \"1\";\n   |                    ^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                    |\n   |                    expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::with_capacity(s.len());\n    for i in\
    \ s.chars() {\n        if i != ' ' {\n            res.push_str(&i.to_ascii_lowercase());\n\
    \        } else {\n            res.push_str(\" \");\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpa9hp8uzq.rs:17:26\n   |\n\
    17 |             res.push_str(&i.to_ascii_lowercase());\n   |                \
    \          ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Split sentence in all words to array.\n    let mut splits:\
    \ Vec<String> = s.split_whitespace();\n    // Sort the array in ascending order\
    \ based on ascii value.\n    splits.sort_by(|a, b| a.chars().next().cmp(&b.chars().next()));\n\
    \    // Re-join array and return it.\n    String::from_iter(splits.into_iter().map(|w|\
    \ w.to_string()).collect())\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpewjud01h.rs:15:35\n   |\n\
    15 |     let mut splits: Vec<String> = s.split_whitespace();\n   |           \
    \          -----------   ^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `SplitWhitespace`\n   |                     |\n   |                     expected\
    \ due to this\n   |\n   = note: expected struct `Vec<String>`\n              found\
    \ struct `SplitWhitespace<'_>`\n\nerror[E0599]: no function or associated item\
    \ named `from_iter` found for struct `String` in the current scope\n  --> /tmp/tmpewjud01h.rs:19:13\n\
    \   |\n19 |     String::from_iter(splits.into_iter().map(|w| w.to_string()).collect())\n\
    \   |             ^^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n19 |     String::from_utf8(splits.into_iter().map(|w|\
    \ w.to_string()).collect())\n   |             ~~~~~~~~~\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buffer = s.to_string();\n    let mut permutations =\
    \ vec![0u8; s.len()];\n    for &c in s.as_bytes() {\n        permutations[*c -\
    \ 97] = 1;\n    }\n    let mut i = 1;\n    while i < permutations {\n        for\
    \ &c in s.as_bytes() {\n            if permutations[*c - 97] == 0 {\n        \
    \        permutations[*c - 97] = i;\n                i += 1;\n            }\n\
    \        }\n    }\n    let mut result = String::with_capacity(s.len());\n    let\
    \ mut j = 0;\n    for i in 0..permutations {\n        if i == 0 {\n          \
    \  result.push_str(&s[j..]);\n            j = i + 1;\n        }\n        if i\
    \ != 0 {\n            for &c in s.as_bytes() {\n                if *c - 97 > j\
    \ {\n                    result.push_str(&s[(*c - 97)..(j + 1)]);\n          \
    \          j = i + 1;\n                }\n            }\n        }\n    }\n  \
    \  result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp6pzxdjz5.rs:17:22\n\
    \   |\n17 |         permutations[*c - 97] = 1;\n   |                      ^^\n\
    \nerror[E0277]: can't compare `{integer}` with `Vec<u8>`\n  --> /tmp/tmp6pzxdjz5.rs:20:13\n\
    \   |\n20 |     while i < permutations {\n   |             ^ no implementation\
    \ for `{integer} < Vec<u8>` and `{integer} > Vec<u8>`\n   |\n   = help: the trait\
    \ `PartialOrd<Vec<u8>>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `PartialOrd<Rhs>`:\n             f32\n         \
    \    f64\n             i128\n             i16\n             i32\n            \
    \ i64\n             i8\n             isize\n           and 6 others\n\nerror[E0614]:\
    \ type `u8` cannot be dereferenced\n  --> /tmp/tmp6pzxdjz5.rs:22:29\n   |\n22\
    \ |             if permutations[*c - 97] == 0 {\n   |                        \
    \     ^^\n\nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmp6pzxdjz5.rs:23:30\n\
    \   |\n23 |                 permutations[*c - 97] = i;\n   |                 \
    \             ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6pzxdjz5.rs:30:17\n\
    \   |\n30 |     for i in 0..permutations {\n   |                 ^^^^^^^^^^^^\
    \ expected integer, found struct `Vec`\n   |\n   = note: expected type `{integer}`\n\
    \            found struct `Vec<u8>`\n\nerror[E0614]: type `u8` cannot be dereferenced\n\
    \  --> /tmp/tmp6pzxdjz5.rs:37:20\n   |\n37 |                 if *c - 97 > j {\n\
    \   |                    ^^\n\nerror[E0614]: type `u8` cannot be dereferenced\n\
    \  --> /tmp/tmp6pzxdjz5.rs:38:41\n   |\n38 |                     result.push_str(&s[(*c\
    \ - 97)..(j + 1)]);\n   |                                         ^^\n\nerror:\
    \ aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_shuffle_helper(s.chars().collect(), s.len() as u32, \"\
    \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_helper` in this scope\n\
    \  --> /tmp/tmpj8wiw1p9.rs:14:5\n   |\n14 |     anti_shuffle_helper(s.chars().collect(),\
    \ s.len() as u32, \"\")\n   |     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().filter_map(|c| match c {\n        'A'..='Z' => Some(c.to_string()),\n\
    \        'a'..='z' => Some(c.to_string()),\n        _ => None,\n    }).collect::<Vec<_>>().sort_by(|a,\
    \ b| a.cmp(b)).collect::<String>()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `()` is not an iterator\n  --> /tmp/tmpt639wb9m.rs:18:53\n\
    \   |\n18 |     }).collect::<Vec<_>>().sort_by(|a, b| a.cmp(b)).collect::<String>()\n\
    \   |                                                     ^^^^^^^ `()` is not\
    \ an iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(): Iterator`\n           which is required by `&mut (): Iterator`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    if s.is_empty() {\n        return s\n    }\n    let mut words\
    \ = s.split_whitespace();\n    let mut new_words = Vec::with_capacity(words.len());\n\
    \    let mut new_words = Vec::with_capacity(words.len());\n    let mut new_words\
    \ = Vec::with_capacity(words.len());\n    let mut prev_char: char = 0;\n    let\
    \ mut new_char: char = 0;\n\n    for word in words {\n        prev_char = new_char;\n\
    \        new_char = 0;\n        for c in word.chars() {\n            new_char\
    \ = (c.to_ascii_lowercase() + (c.to_ascii_uppercase() - prev_char));\n       \
    \     new_words.push(String::from_ascii_lowercase(new_char));\n            new_words.push(String::from_ascii_uppercase(new_char));\n\
    \            new_words.push(c);\n        }\n    }\n    new_words.reverse();\n\
    \    String::from(new_words.iter().collect::<String>())\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around assigned value\n  --> /tmp/tmp40rgy57j.rs:28:24\n\
    \   |\n28 |             new_char = (c.to_ascii_lowercase() + (c.to_ascii_uppercase()\
    \ - prev_char));\n   |                        ^                              \
    \                               ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n28 -             new_char\
    \ = (c.to_ascii_lowercase() + (c.to_ascii_uppercase() - prev_char));\n28 +   \
    \          new_char = c.to_ascii_lowercase() + (c.to_ascii_uppercase() - prev_char);\n\
    \   | \n\nerror[E0599]: no method named `len` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp40rgy57j.rs:18:50\n   |\n18 |     let mut\
    \ new_words = Vec::with_capacity(words.len());\n   |                         \
    \                         ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp40rgy57j.rs:19:50\n   |\n19 |     let mut new_words = Vec::with_capacity(words.len());\n\
    \   |                                                  ^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmp40rgy57j.rs:20:50\n  \
    \ |\n20 |     let mut new_words = Vec::with_capacity(words.len());\n   |     \
    \                                             ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp40rgy57j.rs:21:31\n   |\n21 |\
    \     let mut prev_char: char = 0;\n   |                        ----   ^ expected\
    \ `char`, found `u8`\n   |                        |\n   |                    \
    \    expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40rgy57j.rs:22:30\n\
    \   |\n22 |     let mut new_char: char = 0;\n   |                       ---- \
    \  ^ expected `char`, found `u8`\n   |                       |\n   |         \
    \              expected due to this\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp40rgy57j.rs:26:20\n\
    \   |\n22 |     let mut new_char: char = 0;\n   |      "
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    for (i, ch) in s.chars().enumerate()\
    \ {\n        let mut temp = String::from(*s);\n        temp.chars()\n        \
    \    .skip_while(|&c| !c.is_ascii())\n            .take_while(|&c| !c.is_ascii())\n\
    \            .for_each(|c| {\n                *s = temp;\n                i +=\
    \ 1;\n            });\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n   --> /tmp/tmp0c8jjyih.rs:16:37\n    |\n16  |         let mut temp =\
    \ String::from(*s);\n    |                        ------------ ^^ doesn't have\
    \ a size known at compile-time\n    |                        |\n    |        \
    \                required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `from`\n\nerror[E0277]: the trait bound `String: From<str>` is not satisfied\n\
    \  --> /tmp/tmp0c8jjyih.rs:16:24\n   |\n16 |         let mut temp = String::from(*s);\n\
    \   |                        ^^^^^^^^^^^^ the trait `From<str>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp0c8jjyih.rs:21:22\n   |\n21 |\
    \                 *s = temp;\n   |                 --   ^^^^ expected `str`, found\
    \ struct `String`\n   |                 |\n   |                 expected due to\
    \ the type of this binding\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmp0c8jjyih.rs:21:17\n   |\n\
    21 |                 *s = temp;\n   |                 ^^ doesn't have a size known\
    \ at compile-time\n   |\n   = help: the trait `Sized` is not implemented for `str`\n\
    \   = note: the left-hand-side of an assignment must have a statically known size\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    if s.len() == 0 {\n        return s\n    }\n\n    let mut result\
    \ = String::from(\"\");\n    let mut words = vec![];\n\n    for word in s.split_whitespace()\
    \ {\n        words.insert(0, word);\n    }\n\n    for &mut word in words {\n \
    \       if word.len() > 1 {\n            word = word\n                .chars()\n\
    \                .fold(String::from(\"\"), |mut acc, c| {\n                  \
    \  let new_c = match acc.chars().max() {\n                        Some(a) => a,\n\
    \                        None => c,\n                    };\n                \
    \    let mut new_acc = acc;\n                    new_acc.push(new_c);\n      \
    \              new_acc\n                });\n        }\n\n        if word != \"\
    \" {\n            result.push(word);\n        }\n    }\n\n    result\n}\n\nfn\
    \ main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplwhmaya_.rs:25:9\n   |\n\
    25 |     for &mut word in words {\n   |         ^^^^^^^^^    ----- this expression\
    \ has type `Option<&str>`\n   |         |\n   |         types differ in mutability\n\
    \   |         help: you can probably remove the explicit borrow: `word`\n   |\n\
    \   = note:      expected reference `&str`\n           found mutable reference\
    \ `&mut _`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = s.clone();\n    let mut new_string = String::new();\n\
    \    let mut len = result.len();\n    while len > 0 {\n        let pos = len as\
    \ usize;\n        let word = result.split_whitespace().nth(pos as usize);\n  \
    \      let mut new_word = \"\";\n        for (c,char) in word.chars().enumerate()\
    \ {\n            match c {\n                0 => {\n                    new_word.push(char);\n\
    \                }\n                _ => {\n                    new_word.push(match\
    \ char {\n                        'a' => char.offset(1),\n                   \
    \     'b' => char.offset(2),\n                        'c' => char.offset(3),\n\
    \                        'd' => char.offset(4),\n                        'e' =>\
    \ char.offset(5),\n                        'f' => char.offset(6),\n          \
    \              'g' => char.offset(7),\n                        'h' => char.offset(8),\n\
    \                        'i' => char.offset(9),\n                        'j' =>\
    \ char.offset(10),\n                        'k' => char.offset(11),\n        \
    \                'l' => char.offset(12),\n                        'm' => char.offset(13),\n\
    \                        'n' => char.offset(14),\n                        'o'\
    \ => char.offset(15),\n                        'p' => char.offset(16),\n     \
    \                   'q' => char.offset(17),\n                        'r' => char.offset(18),\n\
    \                        's' => char.offset(19),\n                        't'\
    \ => char.offset(20),\n                        'u' => char.offset(21),\n     \
    \                   'v' => char.offset(22),\n                        'w' => char.offset(23),\n\
    \                        'x' => char.offset(24),\n                        'y'\
    \ => char.offset(25),\n                        'z' => char.offset(26),\n     \
    \                   'A' => char.offset(27),\n                        'B' => char.offset(28),\n\
    \                        'C' => char.offset(29),\n                        'D'\
    \ => char.offset(30),\n                        'E' => char.offset(31),\n     \
    \                   'F' => char.offset(32),\n                        'G' => char.offset(33),\n\
    \                        'H' => char.offset(34),\n                        'I'\
    \ => char.offset(35),\n                        'J' => char.offset(36),\n     \
    \                   'K' => char.offset(37),\n                        'L' => char.offset(38),\n\
    \                        'M' => char.offset(39),\n                        'N'\
    \ => char.offset(40),\n                        'O' => char.offset(41),\n     \
    \                   'P' => char.offset(42),\n                        'Q' => char.offset\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpa0tqb0wt.rs:82:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     while len > 0 {\n   |  \
    \                 - unclosed delimiter\n...\n21 |         for (c,char) in word.chars().enumerate()\
    \ {\n   |                                                  - unclosed delimiter\n\
    22 |             match c {\n   |                     - unclosed delimiter\n...\n\
    26 |                 _ => {\n   |                      - unclosed delimiter\n\
    27 |                     new_word.push(match char {\n   |                    \
    \              - unclosed delimiter\n...\n82 | }\n   |   ^\n\nerror: expected\
    \ one of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpa0tqb0wt.rs:73:1\n\
    \   |\n71 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n72\
    \ | \n73 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut alphabet: Vec<(u8, u8)> = s.chars().map(|c|\
    \ c.to_ascii()).collect();\n    let mut num_changes = Vec::new();\n\n    // The\
    \ first character in the alphabet is always replaced with `!`.\n    // After that,\
    \ each consecutive character is replaced with `!` if its\n    // ascii value is\
    \ lower than the previous one, and `?` otherwise.\n    // For example, `h` would\
    \ be replaced with `!?` if its ascii value is `97`.\n    let mut prev_val = (*alphabet).0;\n\
    \    for (i, &val) in alphabet.iter().skip(1).enumerate() {\n        if val <\
    \ prev_val {\n            num_changes.push(i);\n            prev_val = val;\n\
    \        }\n    }\n\n    let mut new_str = \"\";\n    let mut prev_pos = 0;\n\
    \    for i in num_changes {\n        let mut new_val = *alphabet;\n        let\
    \ mut new_pos = i + 1;\n        for _ in 0..num_changes-i {\n            new_val\
    \ -= 1;\n            if new_val < 0 {\n                new_val += 256;\n     \
    \       }\n            new_pos += 1;\n        }\n        new_str += s[prev_pos..new_pos].to_string();\n\
    \        prev_pos = new_pos;\n    }\n    new_str += s[prev_pos..s.len()];\n  \
    \  new_str\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp30ync6eu.rs:15:59\n   |\n15 |     let mut alphabet: Vec<(u8,\
    \ u8)> = s.chars().map(|c| c.to_ascii()).collect();\n   |                    \
    \                                       ^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0609]: no field `0` on type\
    \ `[(u8, u8)]`\n  --> /tmp/tmp30ync6eu.rs:22:36\n   |\n22 |     let mut prev_val\
    \ = (*alphabet).0;\n   |                                    ^\n\nerror[E0277]:\
    \ the size for values of type `[(u8, u8)]` cannot be known at compilation time\n\
    \  --> /tmp/tmp30ync6eu.rs:33:13\n   |\n33 |         let mut new_val = *alphabet;\n\
    \   |             ^^^^^^^^^^^ doesn't have a size known at compile-time\n   |\n\
    \   = help: the trait `Sized` is not implemented for `[(u8, u8)]`\n   = note:\
    \ all local variables must have a statically known size\n   = help: unsized locals\
    \ are gated as an unstable feature\n\nerror[E0369]: cannot subtract `usize` from\
    \ `Vec<usize>`\n  --> /tmp/tmp30ync6eu.rs:35:32\n   |\n35 |         for _ in 0..num_changes-i\
    \ {\n   |                     -----------^- usize\n   |                     |\n\
    \   |                     Vec<usize>\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `[(u8, u8)]`\n  --> /tmp/tmp30ync6eu.rs:36:13\n\
    \   |\n36 |             new_val -= 1;\n   |             -------^^^^^\n   |   \
    \          |\n   |             cannot use `-=` on type `[(u8, u8)]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp30ync6eu.rs:37:26\n   |\n37 |             if\
    \ new_val < 0 {\n   |                          ^ expected slice, found integer\n\
    \   |\n   = note: expected slice `[(u8, u8)]`\n               found type `{integer}`\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `[(u8,\
    \ u8)]`\n  --> /tmp/tmp30ync6eu.rs:38:17\n   |\n38 |                 new_val +=\
    \ 256;\n   |                 -------^^^^^^^\n   |                 |\n   |    \
    \             cannot use `+=` on type `[(u8, u8)]`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied "
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(|c| c != ' ').sort_by(|a, b| a.cmp(b).reverse()).collect::<String>().join(\"\
    \ \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp2qjuqn7m.rs:14:27\n   |\n14 |     s.split(|c|\
    \ c != ' ').sort_by(|a, b| a.cmp(b).reverse()).collect::<String>().join(\" \"\
    )\n   |                           ^^^^^^^ method not found in `std::str::Split<'_,\
    \ [closure@/tmp/tmp2qjuqn7m.rs:14:13: 14:25]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut result = s.to_string();\n    let mut new_s = String::with_capacity(s.len());\n\
    \n    for (i, c) in s.chars().enumerate() {\n        let index = i + 1;\n    \
    \    if c < result.chars().nth(index).unwrap().unwrap() {\n            new_s.push_str(&result);\n\
    \            result.clear();\n        } else {\n            result.push_str(&new_s);\n\
    \            new_s.clear();\n        }\n    }\n\n    result.push_str(&new_s);\n\
    \    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpn1ctw6ee.rs:19:51\n   |\n19 |         if c < result.chars().nth(index).unwrap().unwrap()\
    \ {\n   |                                                   ^^^^^^ method not\
    \ found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    lazy_static! {\n        static ref CHAR_MAP: HashMap<&'static\
    \ str, u32> = HashMap::new();\n    }\n\n    let mut s = s;\n    let mut result\
    \ = String::from(\"_\");\n    s.split_whitespace().sort_by_key(|&word| {\n   \
    \     CHAR_MAP.entry(word).or_insert(CHAR_MAP.len() as u32);\n        CHAR_MAP.get(word)\n\
    \    });\n\n    result.push_str(s);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpkvz85xg5.rs:14:5\n\
    \   |\n14 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `CHAR_MAP` in this scope\n  --> /tmp/tmpkvz85xg5.rs:21:9\n   |\n21 | \
    \        CHAR_MAP.entry(word).or_insert(CHAR_MAP.len() as u32);\n   |        \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `CHAR_MAP`\
    \ in this scope\n  --> /tmp/tmpkvz85xg5.rs:21:40\n   |\n21 |         CHAR_MAP.entry(word).or_insert(CHAR_MAP.len()\
    \ as u32);\n   |                                        ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find value `CHAR_MAP` in this scope\n  -->\
    \ /tmp/tmpkvz85xg5.rs:22:9\n   |\n22 |         CHAR_MAP.get(word)\n   |      \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `sort_by_key`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpkvz85xg5.rs:20:26\n\
    \   |\n20 |     s.split_whitespace().sort_by_key(|&word| {\n   |             \
    \             ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpkvz85xg5.rs:25:21\n   |\n25 |     result.push_str(s);\n\
    \   |                     ^\n   |                     |\n   |                \
    \     expected `&str`, found struct `String`\n   |                     help: consider\
    \ borrowing here: `&s`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut word_str = \"\".to_string();\n    s.split(' ').iter().for_each(|word|{\n\
    \        word_str.push_str(&word.to_owned());\n    });\n    let mut char_str =\
    \ \"\".to_string();\n    s.split(' ').iter().for_each(|word|{\n        for c&\
    \ in word {\n            char_str.push_str(&c.to_ascii_lowercase());\n       \
    \ }\n    });\n    let mut result = word_str.clone();\n    for c& in char_str {\n\
    \        match result {\n            \"\" => result.push_str(&c.to_ascii_lowercase()),\n\
    \            result => result.push_str(&c.to_ascii_lowercase() + &result.to_ascii_lowercase()),\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: missing `in` in `for` loop\n  --> /tmp/tmptzx4f66f.rs:20:14\n  \
    \ |\n20 |         for c& in word {\n   |              ^ help: try adding `in`\
    \ here\n\nerror: expected expression, found keyword `in`\n  --> /tmp/tmptzx4f66f.rs:20:16\n\
    \   |\n20 |         for c& in word {\n   |                ^^ expected expression\n\
    \nerror: missing `in` in `for` loop\n  --> /tmp/tmptzx4f66f.rs:25:10\n   |\n25\
    \ |     for c& in char_str {\n   |          ^ help: try adding `in` here\n\nerror:\
    \ expected expression, found keyword `in`\n  --> /tmp/tmptzx4f66f.rs:25:12\n \
    \  |\n25 |     for c& in char_str {\n   |            ^^ expected expression\n\n\
    error[E0599]: no method named `iter` found for struct `std::str::Split` in the\
    \ current scope\n  --> /tmp/tmptzx4f66f.rs:15:18\n   |\n15 |     s.split(' ').iter().for_each(|word|{\n\
    \   |                  ^^^^ method not found in `std::str::Split<'_, char>`\n\n\
    error[E0599]: no method named `iter` found for struct `std::str::Split` in the\
    \ current scope\n  --> /tmp/tmptzx4f66f.rs:19:18\n   |\n19 |     s.split(' ').iter().for_each(|word|{\n\
    \   |                  ^^^^ method not found in `std::str::Split<'_, char>`\n\n\
    error: aborting due to 6 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .filter_map(|c| if c.is_alphabetic() { 'a'\
    \ } else { c })\n        .collect::<String>()\n        .sort_by(|a, b| a.cmp(b))\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph0rw8yp5.rs:15:48\n   |\n\
    15 |         .filter_map(|c| if c.is_alphabetic() { 'a' } else { c })\n   |  \
    \                                              ^^^ expected enum `Option`, found\
    \ `char`\n   |\n   = note: expected enum `Option<_>`\n              found type\
    \ `char`\nhelp: try wrapping the expression in `Some`\n   |\n15 |         .filter_map(|c|\
    \ if c.is_alphabetic() { Some('a') } else { c })\n   |                       \
    \                         +++++   +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph0rw8yp5.rs:15:61\n\
    \   |\n15 |         .filter_map(|c| if c.is_alphabetic() { 'a' } else { c })\n\
    \   |                                                             ^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n       \
    \       found type `char`\nhelp: try wrapping the expression in `Some`\n   |\n\
    15 |         .filter_map(|c| if c.is_alphabetic() { 'a' } else { Some(c) })\n\
    \   |                                                             +++++ +\n\n\
    error[E0599]: no method named `sort_by` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmph0rw8yp5.rs:17:10\n   |\n17 |         .sort_by(|a, b| a.cmp(b))\n\
    \   |          ^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    let mut l = s.len();\n    let mut result\
    \ = String::new();\n    while l > 0 {\n        loop {\n            let mut idx\
    \ = l;\n            if idx > 0 {\n                idx -= 1;\n                result.push(*s.chars().skip(idx).take(1).collect::<String>().to_lowercase());\n\
    \            }\n            if l > 1 {\n                l -= 1;\n            \
    \    s = s.remove(1);\n                result.push(' ');\n            }\n    \
    \        l += 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm4n3_kta.rs:22:29\n   |\n\
    22 |                 result.push(*s.chars().skip(idx).take(1).collect::<String>().to_lowercase());\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpm4n3_kta.rs:26:21\n\
    \   |\n14 |     let mut s = s;\n   |                 - expected due to this value\n\
    ...\n26 |                 s = s.remove(1);\n   |                     ^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |\n   |                     expected struct `String`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s: String = s;\n    for c in s.chars() {\n        if\
    \ c != ' ' && c != '\\n' && c != '\\t' && c != '\\r' && c != ' ' {\n         \
    \   s.insert(0, 'A' - c as u8);\n        }\n    }\n    s\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `u8` from `char`\n  --> /tmp/tmpv4lihgxr.rs:17:29\n\
    \   |\n17 |             s.insert(0, 'A' - c as u8);\n   |                    \
    \     --- ^ ------- u8\n   |                         |\n   |                 \
    \        char\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().collect::<Vec<(char, char)>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    \        .iter()\n        .map(|(_, c)| c).collect::<String>() + s.chars().collect::<Vec<(char,\
    \ char)>>()\n        .sort_by(|a, b| a.cmp(b)).collect()\n        .iter()\n  \
    \      .map(|(_, c)| c).collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(char, char)>` cannot be built from\
    \ an iterator over elements of type `char`\n    --> /tmp/tmpew2pji7f.rs:14:15\n\
    \     |\n14   |     s.chars().collect::<Vec<(char, char)>>().sort_by(|a, b| a.cmp(b)).collect()\n\
    \     |               ^^^^^^^ value of type `Vec<(char, char)>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<(char, char)>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0599]:\
    \ `()` is not an iterator\n  --> /tmp/tmpew2pji7f.rs:14:71\n   |\n14 |     s.chars().collect::<Vec<(char,\
    \ char)>>().sort_by(|a, b| a.cmp(b)).collect()\n   |                         \
    \                                              ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror[E0277]:\
    \ a value of type `Vec<(char, char)>` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmpew2pji7f.rs:16:58\n     |\n16   |         .map(|(_,\
    \ c)| c).collect::<String>() + s.chars().collect::<Vec<(char, char)>>()\n    \
    \ |                                                          ^^^^^^^ value of\
    \ type `Vec<(char, char)>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<(char,\
    \ char)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: `()` is not an iterator\n\
    \  --> /tmp/tmpew2pji7f.rs:17:35\n   |\n17 |         .sort_by(|a, b| a.cmp(b)).collect()\n\
    \   |                                   ^^^^^^^ `()` is not an iterator\n   |\n\
    \   = note: the following trait bounds were not satisfied:\n           `(): Iterator`\n\
    \           which is required by `&mut (): Iterator`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = s.split_whitespace();\n    let mut order =\
    \ \"abcdefghijklmnopqrstuvwxyz\".to_string();\n    for (i, word) in words.iter().enumerate()\
    \ {\n        for c in word.chars() {\n            order.insert((c + order.len()).to_string(),\
    \ i);\n        }\n    }\n    let mut result = String::new();\n    for word in\
    \ order {\n        result.push_str(word);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpwynk4eh9.rs:16:28\n   |\n16 |     for (i,\
    \ word) in words.iter().enumerate() {\n   |                            ^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpwynk4eh9.rs:22:17\n   |\n22 |     for word in order {\n   |   \
    \              ^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // find each word in the string\n    let mut words = s.split_whitespace();\n\
    \    let mut s = String::from(\"\");\n    while let Some(word) = words.pop() {\n\
    \        s += &word[..].chars().map(|c| c.to_ascii_lowercase()).collect::<String>();\n\
    \    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `pop` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpmqmhp2ga.rs:17:34\n   |\n17 |     while\
    \ let Some(word) = words.pop() {\n   |                                  ^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s.chars();\n    let mut w = \"\";\n    let mut\
    \ current_word = \"\";\n    for c in s.into_iter() {\n        if c == ' ' {\n\
    \            if current_word.len() > 0 {\n                w = &current_word[..current_word.len()\
    \ - 1];\n            }\n            current_word = \"\";\n        } else {\n \
    \           current_word += c.to_string();\n        }\n    }\n    if current_word.len()\
    \ > 0 {\n        w = &current_word[..current_word.len() - 1];\n    }\n    let\
    \ mut s = String::new();\n    let mut i = 0;\n    for c in s.chars() {\n     \
    \   if i == 0 {\n            s += c.to_string();\n        } else {\n         \
    \   s += &w[i / 2];\n        }\n        i += 1;\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpizdjeobm.rs:24:13\n   |\n24 |             current_word\
    \ += c.to_string();\n   |             ------------^--^^^^^^^^^^^^^^\n   |    \
    \         |            |\n   |             |            `+` cannot be used to\
    \ concatenate a `&str` with a `String`\n   |             cannot use `+=` on type\
    \ `&str`\n   |\n   = note: string concatenation requires an owned `String` on\
    \ the left\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpizdjeobm.rs:34:18\n\
    \   |\n34 |             s += c.to_string();\n   |                  ^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  expected `&str`, found struct\
    \ `String`\n   |                  help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `{integer}`\n  --> /tmp/tmpizdjeobm.rs:36:19\n\
    \   |\n36 |             s += &w[i / 2];\n   |                   ^^^^^^^^ string\
    \ indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `{integer}`\n   = note: you can use `.chars().nth()`\
    \ or `.bytes().nth()`\n           for more information, see chapter 8 in The Book:\
    \ <https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings>\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<{integer}>` for `str`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0368.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().sort_by(|a, b| b.len_without_ascii_case(a.as_bytes())).join('')\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmpx0wjx4rt.rs:14:87\n   |\n\
    14 |     s.split_whitespace().sort_by(|a, b| b.len_without_ascii_case(a.as_bytes())).join('')\n\
    \   |                                                                        \
    \               ^ empty character literal\n\nerror[E0599]: no method named `sort_by`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpx0wjx4rt.rs:14:26\n\
    \   |\n14 |     s.split_whitespace().sort_by(|a, b| b.len_without_ascii_case(a.as_bytes())).join('')\n\
    \   |                          ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    String::from(s.chars().collect::<Vec<_>>().sort_by(|a, b| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()).unwrap()).collect())\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for enum `std::cmp::Ordering`\
    \ in the current scope\n  --> /tmp/tmpuwayte16.rs:14:115\n   |\n14 |     String::from(s.chars().collect::<Vec<_>>().sort_by(|a,\
    \ b| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()).unwrap()).collect())\n\
    \   |                                                                        \
    \                                           ^^^^^^ method not found in `std::cmp::Ordering`\n\
    \nerror[E0599]: `()` is not an iterator\n  --> /tmp/tmpuwayte16.rs:14:125\n  \
    \ |\n14 |     String::from(s.chars().collect::<Vec<_>>().sort_by(|a, b| a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()).unwrap()).collect())\n\
    \   |                                                                        \
    \                                                     ^^^^^^^ `()` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `():\
    \ Iterator`\n           which is required by `&mut (): Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.into_lowercase().chars().filter(|c| c.is_whitespace()).collect::<Vec<_>>()\n\
    \        .sort();\n    s.chars().filter(|c| c.is_whitespace()).collect::<Vec<_>>().join();\n\
    \    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `into_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpqyh8mt7m.rs:15:7\n   |\n15 |     s.into_lowercase().chars().filter(|c|\
    \ c.is_whitespace()).collect::<Vec<_>>()\n   |       ^^^^^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<char>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpqyh8mt7m.rs:17:65\n   |\n17 |     s.chars().filter(|c|\
    \ c.is_whitespace()).collect::<Vec<_>>().join();\n   |                       \
    \                                          ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Step 1: Replace all spaces with new word\n    let mut s\
    \ = s.replace(\" \", \"_\");\n    // Step 2: Replace all new words with spaces\n\
    \    let mut s = s.replace(\" \", \"_\");\n    // Step 3: Replace all underscores\
    \ with space\n    s = s.replace(\"_\", \" \");\n    // Step 4: Replace all spaces\
    \ with new word\n    s = s.replace(\"_\", \" \");\n    // Step 5: Replace all\
    \ new words with spaces\n    s = s.replace(\"_\", \" \");\n    s\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hello\"`,\n right: `\"ehllo\"`', /tmp/tmpsxv8zhdf.rs:30:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut l = s.chars().enumerate().collect::<Vec<_>>();\n  \
    \  l.sort_by(|a, b| b.1.cmp(a.1).reverse());\n    s.chars().rev().enumerate().map(|(b,\
    \ e)| {\n        match l {\n            vec![(b, e)] if b.1 == e.1 => {\n    \
    \            let mut j = b.1;\n                let mut k = e.1;\n            \
    \    while l {\n                    if b.1 == e.1 {\n                        break;\n\
    \                    }\n                    if j > b.1 {\n                   \
    \     let c = s.chars().nth(j).unwrap();\n                        s = s.replace(0..itoa::<u8,\
    \ char>(c, 2));\n                        j = b.1;\n                    } else\
    \ if k < e.1 {\n                        let c = s.chars().nth(k).unwrap();\n \
    \                       s = s.insert(0..itoa::<u8, char>(c, 2), ' ');\n      \
    \                  k = e.1;\n                    } else {\n                  \
    \      break;\n                    }\n                }\n                s.replace(0..itoa::<u8,\
    \ char>(s.chars().nth(j).unwrap(), 2));\n            }\n            _ => s.replace(0..itoa::<u8,\
    \ char>(s.chars().nth(b.1).unwrap(), 2)),\n        }\n    }).collect()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `itoa` in this scope\n  --> /tmp/tmpucn_f_gu.rs:27:42\n\
    \   |\n27 |                         s = s.replace(0..itoa::<u8, char>(c, 2));\n\
    \   |                                          ^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `itoa` in this scope\n  --> /tmp/tmpucn_f_gu.rs:31:41\n\
    \   |\n31 |                         s = s.insert(0..itoa::<u8, char>(c, 2), '\
    \ ');\n   |                                         ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `itoa` in this scope\n  --> /tmp/tmpucn_f_gu.rs:37:30\n\
    \   |\n37 |                 s.replace(0..itoa::<u8, char>(s.chars().nth(j).unwrap(),\
    \ 2));\n   |                              ^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `itoa` in this scope\n  --> /tmp/tmpucn_f_gu.rs:39:31\n\
    \   |\n39 |             _ => s.replace(0..itoa::<u8, char>(s.chars().nth(b.1).unwrap(),\
    \ 2)),\n   |                               ^^^^ not found in this scope\n\nerror:\
    \ arbitrary expressions aren't allowed in patterns\n  --> /tmp/tmpucn_f_gu.rs:18:13\n\
    \   |\n18 |             vec![(b, e)] if b.1 == e.1 => {\n   |             ^^^^^^^^^^^^\n\
    \   |\n   = note: this error originates in the macro `vec` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpucn_f_gu.rs:15:30\n   |\n15 |     l.sort_by(|a, b| b.1.cmp(a.1).reverse());\n\
    \   |                              ^^^\n   |                              |\n\
    \   |                              expected `&char`, found `char`\n   |      \
    \                        help: consider borrowing here: `&a.1`\n\nerror[E0610]:\
    \ `usize` is a primitive type and therefore doesn't have fields\n  --> /tmp/tmpucn_f_gu.rs:18:31\n\
    \   |\n18 |             vec![(b, e)] if b.1 == e.1 => {\n   |                \
    \               ^\n\nerror[E0610]: `char` is a primitive type and therefore doesn't\
    \ have fields\n  --> /tmp/tmpucn_f_gu.rs:18:38\n   |\n18 |             vec![(b,\
    \ e)] if b.1 == e.1 => {\n   |                                      ^\n\nerror[E0610]:\
    \ `usize` is a primitive type and there"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n    let mut s = s.as_bytes();\n\
    \    let mut output: Vec<u8> = Vec::new();\n    for i in s.bytes().rposition(|&b|\
    \ b == b' ') {\n        output.push(b'a' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'a') {\n        output.push(b'z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'z') {\n        output.push(b'A' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n        output.push(b'Z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'Z') {\n        output.push(b'a' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'z') {\n        output.push(b'A' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n        output.push(b'Z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'Z') {\n        output.push(b'a' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b' ') {\n        output.push(b'z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'z') {\n        output.push(b'A' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n        output.push(b'Z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'Z') {\n        output.push(b'z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b' ') {\n        output.push(b'A' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n        output.push(b'Z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'Z') {\n        output.push(b'A' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b' ') {\n        output.push(b'a' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'a') {\n        output.push(b'Z' as u8);\n    }\n    for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n        output.push\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpd8mrn_of.rs:81:3\n\
    \   |\n13 | fn anti_shuffle(s: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n68 |     for i in s.bytes().rposition(|&b|\
    \ b == b'A') {\n   |                                                  - this delimiter\
    \ might not be properly closed...\n69 |         output.push\n70 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n81 | }\n   |   ^\n\n\
    warning: unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmpd8mrn_of.rs:14:9\n\
    \   |\n14 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: use of deprecated\
    \ trait `std::ascii::AsciiExt`: use inherent methods instead\n  --> /tmp/tmpd8mrn_of.rs:14:21\n\
    \   |\n14 |     use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror[E0599]: no method\
    \ named `bytes` found for reference `&[u8]` in the current scope\n  --> /tmp/tmpd8mrn_of.rs:17:16\n\
    \   |\n17 |     for i in s.bytes().rposition(|&b| b == b' ') {\n   |         \
    \       ^^^^^ method not found in `&[u8]`\n   |\n   = help: items from traits\
    \ can only be used if the trait is in scope\nhelp: the following trait is implemented\
    \ but not in scope; perhaps add a `use` for it:\n   |\n1  | use std::io::Read;\n\
    \   |\n\nerror[E0599]: no method named `bytes` found for reference `&[u8]` in\
    \ the current scope\n  --> /tmp/tmpd8mrn_of.rs:20:16\n   |\n20 |     for i in\
    \ s.bytes().rposition(|&b| b == b'a') {\n   |                ^^^^^ method not\
    \ found in `&[u8]`\n   |\n   = help: items from traits can only be used if the\
    \ trait is in scope\nhelp: the following trait is implemented but not in scope;\
    \ perhaps add a `use` for it:\n   |\n1  | use std::io::Read;\n   |\n\nerror[E0599]:\
    \ no method named `bytes` found for reference `&[u8]` in the current scope\n \
    \ --> /tmp/tmpd8mrn_of.rs:23:16\n   |\n23 |     for i in s.bytes().rposition(|&b|\
    \ b == b'z') {\n   |                ^^^^^ method not found in `&[u8]`\n   |\n\
    \   = help: items from "
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_shuffle_inner(s)\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_inner` in this scope\n\
    \  --> /tmp/tmpbdteot2x.rs:14:5\n   |\n14 |     anti_shuffle_inner(s)\n   |  \
    \   ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_s = String::from(s);\n    new_s.chars()\n     \
    \   .filter_map(|c| if c == '.' { return None } else { Some(c.to_ascii_uppercase())\
    \ })\n        .for_each(|c| new_s.replace_range(c..c.to_ascii_lowercase(), c.to_string()));\n\
    \    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `std::ops::Range<char>: RangeBounds<usize>`\
    \ is not satisfied\n    --> /tmp/tmpus7yel19.rs:17:29\n     |\n17   |        \
    \ .for_each(|c| new_s.replace_range(c..c.to_ascii_lowercase(), c.to_string()));\n\
    \     |                             ^^^^^^^^^^^^^ the trait `RangeBounds<usize>`\
    \ is not implemented for `std::ops::Range<char>`\n     |\n     = help: the following\
    \ other types implement trait `RangeBounds<T>`:\n               std::ops::Range<&T>\n\
    \               std::ops::Range<T>\nnote: required by a bound in `String::replace_range`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpus7yel19.rs:17:70\n   |\n17 |\
    \         .for_each(|c| new_s.replace_range(c..c.to_ascii_lowercase(), c.to_string()));\n\
    \   |                                                                      ^^^^^^^^^^^^^\n\
    \   |                                                                      |\n\
    \   |                                                                      expected\
    \ `&str`, found struct `String`\n   |                                        \
    \                              help: consider borrowing here: `&c.to_string()`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words: Vec<_> = s.split_whitespace().collect();\n \
    \   let mut output: Vec<_> = words.iter().map(|word| {\n        if word.len()\
    \ > 2 {\n            word.chars()\n                .filter_map(|x| x.to_ascii_lowercase())\n\
    \                .collect()\n        } else {\n            word\n        }\n \
    \   }).collect();\n    output.rev_sort_unstable();\n    String::from(output)\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdqqp05ln.rs:18:33\n   |\n\
    18 |                 .filter_map(|x| x.to_ascii_lowercase())\n   |           \
    \                      ^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found `char`\n\
    \   |\n   = note: expected enum `Option<_>`\n              found type `char`\n\
    help: try wrapping the expression in `Some`\n   |\n18 |                 .filter_map(|x|\
    \ Some(x.to_ascii_lowercase()))\n   |                                 +++++  \
    \                    +\n\nerror[E0277]: a value of type `&&str` cannot be built\
    \ from an iterator over elements of type `_`\n    --> /tmp/tmpdqqp05ln.rs:19:18\n\
    \     |\n19   |                 .collect()\n     |                  ^^^^^^^ value\
    \ of type `&&str` cannot be built from `std::iter::Iterator<Item=_>`\n     |\n\
    \     = help: the trait `FromIterator<_>` is not implemented for `&&str`\n   \
    \  = help: the following other types implement trait `FromIterator<A>`:\n    \
    \           <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0599]: no method named `rev_sort_unstable` found for struct `Vec<&&str>`\
    \ in the current scope\n  --> /tmp/tmpdqqp05ln.rs:24:12\n   |\n24 |     output.rev_sort_unstable();\n\
    \   |            ^^^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `sort_unstable`\n\nerror[E0277]: the trait bound `String: From<Vec<&&str>>`\
    \ is not satisfied\n  --> /tmp/tmpdqqp05ln.rs:25:5\n   |\n25 |     String::from(output)\n\
    \   |     ^^^^^^^^^^^^ the trait `From<Vec<&&str>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String a"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = String::from(s);\n    let mut new_s = String::from(s);\n\
    \    \n    let mut buffer = String::new();\n    \n    for i in 0..s.len() {\n\
    \        let mut temp_buffer = String::new();\n        let mut j = 0;\n      \
    \  for c in s.chars() {\n            temp_buffer.push(c);\n            if j ==\
    \ i {\n                let mut temp_buffer = temp_buffer.chars().collect::<Vec<_>>();\n\
    \                temp_buffer.sort();\n                temp_buffer.reverse();\n\
    \                temp_buffer.push(0);\n                new_s.push_str(temp_buffer.iter().collect::<String>());\n\
    \                break;\n            }\n            j += 1;\n        }\n     \
    \   \n        temp_buffer.push(0);\n        new_s.push_str(temp_buffer.iter().collect::<String>());\n\
    \    }\n    \n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2cujqbp_.rs:28:34\n   |\n\
    28 |                 temp_buffer.push(0);\n   |                              \
    \    ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2cujqbp_.rs:29:32\n\
    \   |\n29 |                 new_s.push_str(temp_buffer.iter().collect::<String>());\n\
    \   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                                |\n   |                                expected\
    \ `&str`, found struct `String`\n   |                                help: consider\
    \ borrowing here: `&temp_buffer.iter().collect::<String>()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp2cujqbp_.rs:35:26\n   |\n35 |         temp_buffer.push(0);\n\
    \   |                          ^ expected `char`, found `u8`\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp2cujqbp_.rs:36:36\n   |\n36 |         new_s.push_str(temp_buffer.iter().collect::<String>());\n\
    \   |                                    ^^^^ method not found in `String`\n \
    \  |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n36 |         new_s.push_str(temp_buffer.chars().collect::<String>());\n\
    \   |                                    ~~~~~\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.shrink_to_fit();\n    let mut result\
    \ = String::with_capacity(s.len());\n    let mut current_word = \"\";\n    for\
    \ c in s.as_bytes() {\n        if c == ' ' {\n            if current_word.len()\
    \ != 0 {\n                result.push_string(current_word);\n                current_word\
    \ = \"\";\n            }\n        } else {\n            let ord = c.to_ascii_lowercase().unwrap();\n\
    \            current_word.push(ord);\n        }\n    }\n    if current_word.len()\
    \ != 0 {\n        result.push_string(current_word);\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9pc60g7v.rs:19:17\n   |\n\
    19 |         if c == ' ' {\n   |                 ^^^ expected `u8`, found `char`\n\
    \nerror[E0277]: can't compare `&u8` with `char`\n  --> /tmp/tmp9pc60g7v.rs:19:14\n\
    \   |\n19 |         if c == ' ' {\n   |              ^^ no implementation for\
    \ `&u8 == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&u8`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             f32\n             f64\n             i128\n             i16\n   \
    \          i32\n             i64\n             i8\n             isize\n      \
    \     and 6 others\n\nerror[E0599]: no method named `push_string` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp9pc60g7v.rs:21:24\n   |\n21 | \
    \                result.push_string(current_word);\n   |                     \
    \   ^^^^^^^^^^^ help: there is an associated function with a similar name: `push_str`\n\
    \nerror[E0599]: no method named `unwrap` found for type `u8` in the current scope\n\
    \  --> /tmp/tmp9pc60g7v.rs:25:46\n   |\n25 |             let ord = c.to_ascii_lowercase().unwrap();\n\
    \   |                                              ^^^^^^ method not found in\
    \ `u8`\n\nerror[E0599]: no method named `push` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmp9pc60g7v.rs:26:26\n   |\n26 |             current_word.push(ord);\n\
    \   |                          ^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `push_string` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp9pc60g7v.rs:30:16\n   |\n30 |         result.push_string(current_word);\n\
    \   |                ^^^^^^^^^^^ help: there is an associated function with a\
    \ similar name: `push_str`\n\nerror: aborting due to 6 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n\n    s.push_str(&String::from(\"\"));\n\n\
    \    let mut new_s = s;\n    let mut new_s_len = s.len();\n    let mut new_s_cap\
    \ = new_s_len.to_ascii_lowercase();\n\n    while new_s_len > 0 {\n        let\
    \ mut new_s_len = new_s_len / 2;\n        let mut new_s_cap = new_s_cap.split_ascii_lowercase();\n\
    \n        for i in 0..new_s_len {\n            new_s.push_str(&new_s_cap[i]);\n\
    \            new_s.pop();\n        }\n\n        new_s_len = new_s_cap.len();\n\
    \        new_s_cap = new_s_cap.split_ascii_lowercase();\n    }\n\n    new_s\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for type `usize`\
    \ in the current scope\n  --> /tmp/tmpbc9c8hj4.rs:20:35\n   |\n20 |     let mut\
    \ new_s_cap = new_s_len.to_ascii_lowercase();\n   |                          \
    \         ^^^^^^^^^^^^^^^^^^ method not found in `usize`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.into_iter().map(|c| c.to_ascii_lowercase()).collect()\n \
    \       .iter()\n        .map(|c| c.to_string()).collect()\n        .fold(s.to_string(),\
    \ |s, c| s.replace(c, \"!\").into());\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: the method `into_iter` exists for struct `String`, but its\
    \ trait bounds were not satisfied\n   --> /tmp/tmp_rqn17ii.rs:14:7\n    |\n14\
    \  |       s.into_iter().map(|c| c.to_ascii_lowercase()).collect()\n    |    \
    \     ^^^^^^^^^\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `String: IntoIterator`\n\
    \            `&String: Iterator`\n            which is required by `&String: IntoIterator`\n\
    \            `&mut String: Iterator`\n            which is required by `&mut String:\
    \ IntoIterator`\n            `str: Sized`\n            which is required by `str:\
    \ IntoIterator`\n            `str: Iterator`\n            which is required by\
    \ `str: IntoIterator`\n            `&str: Iterator`\n            which is required\
    \ by `&str: IntoIterator`\n            `&mut str: Iterator`\n            which\
    \ is required by `&mut str: IntoIterator`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_rqn17ii.rs:13:31\n   |\n13 | fn anti_shuffle(s: String) -> String\
    \ {\n   |    ------------               ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Create a list of all words from string\n    let mut words:\
    \ Vec<String> = s.split_whitespace().collect();\n    // Sort all words based on\
    \ their ascii value\n    words.push(\"\".to_string());\n    words.push(\"\".to_string());\n\
    \    words.push(\"\".to_string());\n    words.sort_by(|a, b| a.cmp(b));\n    let\
    \ mut ans = String::new();\n    // For each word in the list\n    for (i, word)\
    \ in words.into_iter().enumerate() {\n        // If word is not blank\n      \
    \  if !word.chars().all(|c| c.is_whitespace()) {\n            // Append word with\
    \ space after it\n            ans.append(&word[..i]).append(\" \");\n        \
    \    // Append word with space before it\n            ans.append(&word[i..])\n\
    \        } else {\n            // Append word with blank after it\n          \
    \  ans.append(&word[..i]).append(\"  \");\n            // Append word with blank\
    \ before it\n            ans.append(&word[i..]).append(\" \")\n        }\n   \
    \ }\n    ans\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpanwyyv53.rs:15:55\n     |\n15\
    \   |     let mut words: Vec<String> = s.split_whitespace().collect();\n     |\
    \                                                       ^^^^^^^ value of type\
    \ `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n\
    \     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpanwyyv53.rs:27:17\n   |\n\
    27 |             ans.append(&word[..i]).append(\" \");\n   |                 ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpanwyyv53.rs:29:17\n\
    \   |\n29 |             ans.append(&word[i..])\n   |                 ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpanwyyv53.rs:32:17\n   |\n32 | \
    \            ans.append(&word[..i]).append(\"  \");\n   |                 ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpanwyyv53.rs:34:17\n\
    \   |\n34 |             ans.append(&word[i..]).append(\" \")\n   |           \
    \      ^^^^^^ method not found in `String`\n\nerror: aborting due to 5 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(\" \").sort_by(|a, b| b.cmp(a)).join(\"_\")\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp767e0iyz.rs:14:18\n   |\n14 |     s.split(\"\
    \ \").sort_by(|a, b| b.cmp(a)).join(\"_\")\n   |                  ^^^^^^^ method\
    \ not found in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split_whitespace().map(|s| anti_shuffle_replace(s, &String::from)).join()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `anti_shuffle_replace` in this scope\n\
    \  --> /tmp/tmpno1ny9qk.rs:14:34\n   |\n14 |     s.split_whitespace().map(|s|\
    \ anti_shuffle_replace(s, &String::from)).join()\n   |                       \
    \           ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `join` found for struct `Map` in the current scope\n  --> /tmp/tmpno1ny9qk.rs:14:74\n\
    \   |\n14 |     s.split_whitespace().map(|s| anti_shuffle_replace(s, &String::from)).join()\n\
    \   |                                                                        \
    \  ^^^^ method not found in `Map<SplitWhitespace<'_>, _>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_s = String::from(s);\n    let mut words = s.split(\"\
    \ \").collect::<Vec<_>>();\n    words.sort_by(|a, b| a.cmp(b));\n    for word\
    \ in words {\n        new_s = new_s.replace(\"$word$\", String::from(word));\n\
    \    }\n    new_s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1ruc3_vy.rs:18:41\n   |\n\
    18 |         new_s = new_s.replace(\"$word$\", String::from(word));\n   |    \
    \                                     ^^^^^^^^^^^^^^^^^^\n   |               \
    \                          |\n   |                                         expected\
    \ `&str`, found struct `String`\n   |                                        \
    \ help: consider borrowing here: `&String::from(word)`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.sort_by_key(|c| c.chars().map(|c| c.unwrap()).sum());\n\
    \    s.into_owned()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n   \
    \ assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpwq1hqe5t.rs:15:7\n   |\n15 |     s.sort_by_key(|c|\
    \ c.chars().map(|c| c.unwrap()).sum());\n   |       ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `into_owned` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpwq1hqe5t.rs:16:7\n   |\n16 |     s.into_owned()\n\
    \   |       ^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // TODO: Implement anti_shuffle\n    let mut s = s.to_string();\n\
    \    s.chars().for_each(|c| {\n        let mut index = s.char_indices().nth(s.chars().count()\
    \ - 1).unwrap().0;\n        match c {\n            'a' | _ | 'b' | _ | 'c' | _\
    \ | 'd' | _ | 'e' | _ | 'f' | _ | 'g' | _ | 'h' | _ | 'i' | _ | 'j' | _ | 'k'\
    \ | _ | 'l' | _ | 'm' | _ | 'n' | _ | 'o' | _ | 'p' | _ | 'q' | _ | 'r' | _ |\
    \ 's' | _ | 't' | _ | 'u' | _ | 'v' | _ | 'w' | _ | 'x' | _ | 'y' | _ | 'z' |\
    \ _ | 'A' | _ | 'B' | _ | 'C' | _ | 'D' | _ | 'E' | _ | 'F' | _ | 'G' | _ | 'H'\
    \ | _ | 'I' | _ | 'J' | _ | 'K' | _ | 'L' | _ | 'M' | _ | 'N' | _ | 'O' | _ |\
    \ 'P' | _ | 'Q' | _ | 'R' | _ | 'S' | _ | 'T' | _ | 'U' | _ | 'V' | _ | 'W' |\
    \ _ | 'X' | _ | 'Y' | _ | 'Z' | _ => {\n                if c != 'z' {\n      \
    \              index -= 1;\n                }\n                if index >= s.len()\
    \ {\n                    index -= 1;\n                }\n                s.chars()[index]\
    \ = c;\n            }\n            _ => {\n                if c != 'z' {\n   \
    \                 index += 1;\n                }\n                if index < 0\
    \ {\n                    index += 1;\n                }\n                s.chars()[index]\
    \ = c;\n            }\n        }\n    });\n    s\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp02jny0wh.rs:26:17\n\
    \   |\n26 |                 s.chars()[index] = c;\n   |                 ^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp02jny0wh.rs:35:17\n\
    \   |\n35 |                 s.chars()[index] = c;\n   |                 ^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_string = String::from(s);\n    let mut word_list\
    \ = s.split_whitespace();\n    word_list.sort_by(|a, b| a.cmp(b));\n    new_string.replace(word_list.len(),\
    \ word_list.len(), word_list.to_vec());\n    new_string\n}\n\nfn main() {\n  \
    \  let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpwovfbrei.rs:16:15\n   |\n16 |     word_list.sort_by(|a,\
    \ b| a.cmp(b));\n   |               ^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `len` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpwovfbrei.rs:17:34\n   |\n17 |     new_string.replace(word_list.len(),\
    \ word_list.len(), word_list.to_vec());\n   |                                \
    \  ^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpwovfbrei.rs:17:51\n\
    \   |\n17 |     new_string.replace(word_list.len(), word_list.len(), word_list.to_vec());\n\
    \   |                                                   ^^^ method not found in\
    \ `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `to_vec` found for struct\
    \ `SplitWhitespace` in the current scope\n  --> /tmp/tmpwovfbrei.rs:17:68\n  \
    \ |\n17 |     new_string.replace(word_list.len(), word_list.len(), word_list.to_vec());\n\
    \   |                                                                    ^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0061]: this function takes\
    \ 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpwovfbrei.rs:17:16\n\
    \    |\n17  |     new_string.replace(word_list.len(), word_list.len(), word_list.to_vec());\n\
    \    |                ^^^^^^^ ---------------  ---------------  ------------------\
    \ supplied 3 arguments\n    |                |\n    |                expected\
    \ 2 arguments\n    |\nnote: associated function defined here\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut res = String::from(s);\n    let mut order = String::from(\"\
    \");\n    for i in 0..s.len() {\n        if order[s.len() - 1 - i].is_ascii_alphanumeric()\
    \ {\n            continue;\n        }\n        order[s.len() - 1 - i] = s.chars().nth(i).unwrap();\n\
    \    }\n    let mut new_order = \"\";\n    for i in 0..order.len() {\n       \
    \ new_order += order.chars().nth(i).unwrap().to_ascii_lowercase();\n    }\n  \
    \  res.replace(new_order.chars().collect::<String>(), new_order.len(), \"\");\n\
    \    res\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphdh19ewp.rs:17:12\n\
    \   |\n17 |         if order[s.len() - 1 - i].is_ascii_alphanumeric() {\n   |\
    \            ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphdh19ewp.rs:20:9\n   |\n20 |         order[s.len() - 1 - i] = s.chars().nth(i).unwrap();\n\
    \   |         ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n \
    \  |\n   = help: the trait `Index<usize>` is not implemented for `String`\n  \
    \ = help: the following other types implement trait `Index<Idx>`:\n          \
    \   <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `&str`\n  --> /tmp/tmphdh19ewp.rs:24:9\n   |\n24 |         new_order\
    \ += order.chars().nth(i).unwrap().to_ascii_lowercase();\n   |         ---------^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `&str`\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmphdh19ewp.rs:26:9\n\
    \    |\n26  |     res.replace(new_order.chars().collect::<String>(), new_order.len(),\
    \ \"\");\n    |         ^^^^^^^ -------------------------------------  ---------------\
    \  -- supplied 3 ar"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words: Vec<_> = s\n        .split_whitespace()\n  \
    \      .map(|s| s.to_lowercase())\n        .collect();\n    words.sort();\n  \
    \  let mut new_word = \"\";\n    for i in 0..words.len() {\n        new_word +=\
    \ if words[i] == \" \" {\n            \"!\"\n        } else {\n            String::from(words[i])\n\
    \        };\n    }\n    new_word\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n\
    \    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: `if` and `else` have incompatible types\n  --> /tmp/tmp23cl2lct.rs:24:13\n\
    \   |\n21 |           new_word += if words[i] == \" \" {\n   |  _____________________-\n\
    22 | |             \"!\"\n   | |             --- expected because of this\n23\
    \ | |         } else {\n24 | |             String::from(words[i])\n   | |    \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct `String`\n25 |\
    \ |         };\n   | |_________- `if` and `else` have incompatible types\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp23cl2lct.rs:27:5\n   |\n13 | fn anti_shuffle(s:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n27 |     new_word\n   |     ^^^^^^^^- help: try\
    \ using a conversion method: `.to_string()`\n   |     |\n   |     expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Get word boundaries\n    let mut word_boundaries = s.split_whitespace();\n\
    \    word_boundaries.sort_by_key(|&word| {\n        // Get ascii value\n     \
    \   word.chars().enumerate().map(|(index, c)| c.value()).collect()\n    });\n\
    \    // Get the new words\n    let mut new_words = word_boundaries.into_iter().map(|word|\
    \ {\n        let mut new_word = word;\n        // Swap each char\n        for\
    \ c in word.chars() {\n            match c {\n                c @ b'a' as b| new_word.insert(c.index,\
    \ b'z'),\n                c @ b'z' as b| new_word.insert(c.index, b'a'),\n   \
    \             _ => {}\n            }\n        }\n        new_word\n    });\n \
    \   // Get the new string\n    new_words.collect::<String>()\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpzef13h49.rs:26:26\n   |\n26 |                 c @ b'a' as\
    \ b| new_word.insert(c.index, b'z'),\n   |                          ^^ expected\
    \ one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `SplitWhitespace` in the current scope\n  -->\
    \ /tmp/tmpzef13h49.rs:16:21\n   |\n16 |     word_boundaries.sort_by_key(|&word|\
    \ {\n   |                     ^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut chars = s.chars();\n    chars.sort_unstable_by_key(|c|\
    \ c.as_bytes().to_ascii_lowercase().cmp(&c.as_bytes().to_ascii_lowercase().rev()));\n\
    \    s.from_chars(chars.collect::<Vec<Char>>())\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmphqs61m19.rs:16:38\n\
    \   |\n16 |     s.from_chars(chars.collect::<Vec<Char>>())\n   |             \
    \                         ^^^^\n   |\nhelp: a builtin type with a similar name\
    \ exists\n   |\n16 |     s.from_chars(chars.collect::<Vec<char>>())\n   |    \
    \                                  ~~~~\nhelp: you might be missing a type parameter\n\
    \   |\n13 | fn anti_shuffle<Char>(s: String) -> String {\n   |               \
    \ ++++++\n\nerror[E0599]: no method named `sort_unstable_by_key` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmphqs61m19.rs:15:11\n   |\n15 |  \
    \   chars.sort_unstable_by_key(|c| c.as_bytes().to_ascii_lowercase().cmp(&c.as_bytes().to_ascii_lowercase().rev()));\n\
    \   |           ^^^^^^^^^^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `from_chars` found for struct `String` in the current scope\n\
    \  --> /tmp/tmphqs61m19.rs:16:7\n   |\n16 |     s.from_chars(chars.collect::<Vec<Char>>())\n\
    \   |       ^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `chars`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut new_s = s.to_string();\n    let mut words = new_s.chars().collect::<Vec<&str>>();\n\
    \    words.sort();\n    for word in words {\n        new_s.replace(word.chars().collect::<String>(),\
    \ word.chars().collect::<String>().rev());\n    }\n    new_s\n}\n\nfn main() {\n\
    \    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<&str>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpgvt488cv.rs:15:35\n     |\n15\
    \   |     let mut words = new_s.chars().collect::<Vec<&str>>();\n     |      \
    \                             ^^^^^^^ value of type `Vec<&str>` cannot be built\
    \ from `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<&str>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `String`\n   --> /tmp/tmpgvt488cv.rs:18:15\n\
    \    |\n18  |         new_s.replace(word.chars().collect::<String>(), word.chars().collect::<String>().rev());\n\
    \    |               ^^^^^^^ expected an `FnMut<(char,)>` closure, found `String`\n\
    \    |\n    = help: the trait `FnMut<(char,)>` is not implemented for `String`\n\
    \    = help: the following other types implement trait `Pattern<'a>`:\n      \
    \        &'b String\n              &'b str\n              &'c &'b str\n    = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `str::<impl str>::replace`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpgvt488cv.rs:18:90\n    |\n18  |         \
    \  new_s.replace(word.chars().collect::<String>(), word.chars().collect::<String>().rev());\n\
    \    |                                                                       \
    \                     ^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `String: Iterator`\n            which is required by `&mut String:\
    \ Iterator`\n            `str: Iterator`\n            which is required by `&mut\
    \ str: Iterator`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    anti_shuffle(String::from(s));\n}\n\nfn main() {\n    let candidate\
    \ = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0mdfhmvc.rs:13:31\n   |\n\
    13 | fn anti_shuffle(s: String) -> String {\n   |    ------------            \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n14 |     anti_shuffle(String::from(s));\n\
    \   |                                  - help: remove this semicolon\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Split the sentence on spaces.\n    let mut words = s.split_whitespace();\n\
    \    words.remove(0);\n\n    // Create a map of characters to their ascii value.\n\
    \    let mut ascii_map = HashMap::new();\n    for word in words {\n        for\
    \ char in word.chars() {\n            ascii_map.insert(char, 0);\n        }\n\
    \    }\n\n    // Sort the map by value.\n    ascii_map.iter().sort_by_key(|(_,\
    \ v)| v).collect::<Vec<_>>()\n        .iter()\n        .cloned()\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp5grj0od7.rs:19:25\n   |\n19 |     let mut ascii_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `remove` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp5grj0od7.rs:16:11\n   |\n16 |     words.remove(0);\n   |      \
    \     ^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut r = s.to_string();\n    let mut ans = String::new();\n\
    \    let mut blank_space_count = 0;\n    for c in r {\n        if c.is_ascii_whitespace()\
    \ {\n            if blank_space_count != 0 {\n                ans.push_str(\"\
    \   \");\n            }\n            blank_space_count = 1;\n        } else {\n\
    \            if blank_space_count != 1 {\n                ans.push(c);\n     \
    \       }\n            blank_space_count = 0;\n        }\n    }\n    ans.push_str(\"\
    \   \");\n    ans\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmplrlrbexj.rs:17:14\n\
    \   |\n17 |     for c in r {\n   |              ^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s: String = s.clone();\n    for (i, c) in s.chars().enumerate()\
    \ {\n        if i > 0 {\n            let j = i - 1;\n            let mut c = s.chars().nth(i).unwrap();\n\
    \            for k in 0..i + 1 {\n                let mut new_c = c;\n       \
    \         let mut b = 1;\n                let mut a = 1;\n                for\
    \ j in 0..k {\n                    let mut c = s.chars().nth(j).unwrap();\n  \
    \                  if let Some(d) = c == ' ' {\n                        a = 1;\n\
    \                    } else if let Some(e) = c == ' ' || c == new_c {\n      \
    \                  a += 2;\n                    } else if let Some(f) = c == new_c\
    \ || c == new_c + b {\n                        a += 2;\n                     \
    \   b += 2;\n                    } else if let Some(g) = c == new_c + b {\n  \
    \                      b += 2;\n                    } else {\n               \
    \         new_c = c;\n                        b += 2;\n                    }\n\
    \                }\n                let s = &s[..i + 1] + &[new_c + b] + '!' +\
    \ &s[i + 1 + k..];\n                s = s\n                    .rev()\n      \
    \              .iter()\n                    .map(|c| c.to_ascii_lowercase().to_string())\n\
    \                    .join(\"\");\n            }\n            s = s;\n       \
    \ }\n    }\n    s\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found statement (`let`)\n  --> /tmp/tmpzc5x8q8d.rs:29:31\n\
    \   |\n29 |                     } else if let Some(f) = c == new_c || c == new_c\
    \ + b {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n \
    \  = note: variable declaration using `let` is a statement\n\nerror: expected\
    \ expression, found statement (`let`)\n  --> /tmp/tmpzc5x8q8d.rs:27:31\n   |\n\
    27 |                     } else if let Some(e) = c == ' ' || c == new_c {\n  \
    \ |                               ^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: variable\
    \ declaration using `let` is a statement\n\nerror[E0658]: `let` expressions in\
    \ this position are unstable\n  --> /tmp/tmpzc5x8q8d.rs:27:31\n   |\n27 |    \
    \                 } else if let Some(e) = c == ' ' || c == new_c {\n   |     \
    \                          ^^^^^^^^^^^^^^^^^^^^^^\n   |\n   = note: see issue\
    \ #53667 <https://github.com/rust-lang/rust/issues/53667> for more information\n\
    \nerror[E0658]: `let` expressions in this position are unstable\n  --> /tmp/tmpzc5x8q8d.rs:29:31\n\
    \   |\n29 |                     } else if let Some(f) = c == new_c || c == new_c\
    \ + b {\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^\n   |\n \
    \  = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667> for\
    \ more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzc5x8q8d.rs:25:28\n\
    \   |\n25 |                     if let Some(d) = c == ' ' {\n   |            \
    \                ^^^^^^^   -------- this expression has type `bool`\n   |    \
    \                        |\n   |                            expected `bool`, found\
    \ enum `Option`\n   |\n   = note: expected type `bool`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzc5x8q8d.rs:27:35\n\
    \   |\n27 |                     } else if let Some(e) = c == ' ' || c == new_c\
    \ {\n   |                                   ^^^^^^^   -------- this expression\
    \ has type `bool`\n   |                                   |\n   |            \
    \                       expected `bool`, found enum `Option`\n   |\n   = note:\
    \ expected type `bool`\n              found en"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().map(|c| {\n        // We need to check `c.is_whitespace()`\
    \ so that \"a!b\" is untouched.\n        if c.is_whitespace() {\n            c\n\
    \        } else {\n            // We need to handle ascii value here. This means\
    \ that we need to convert all `c`\n            // to ascii value and make sure\
    \ that the ascending ordering is maintained.\n            // For ex. \"Hello\"\
    \ becomes \"65 66 67 68 69 70 71 72\"\n            c.to_ascii_lower().unwrap()\n\
    \        }\n    }).collect::<String>().sort_unstable().collect::<String>().clone()\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lower` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpf3jkm60v.rs:22:15\n   |\n22 |             c.to_ascii_lower().unwrap()\n\
    \   |               ^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `to_ascii_lowercase`\n\nerror[E0599]: no method named `sort_unstable`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpf3jkm60v.rs:24:28\n\
    \   |\n24 |     }).collect::<String>().sort_unstable().collect::<String>().clone()\n\
    \   |                            ^^^^^^^^^^^^^ method not found in `String`\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut string = s.clone();\n    string.remove_indices();\n\
    \    for word in string.split_whitespace() {\n        let mut s = word.to_string();\n\
    \        s.sort_by_key(|c| c.to_ascii_lower());\n        string.insert_range(s.len()\
    \ - 1, s.as_str());\n    }\n    string\n}\n\nfn main() {\n    let candidate =\
    \ anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_indices` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmphuztjquo.rs:15:12\n   |\n15 |     string.remove_indices();\n\
    \   |            ^^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `sort_by_key` found for struct `String` in the current scope\n\
    \  --> /tmp/tmphuztjquo.rs:18:11\n   |\n18 |         s.sort_by_key(|c| c.to_ascii_lower());\n\
    \   |           ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `insert_range` found for struct `String` in the current scope\n  --> /tmp/tmphuztjquo.rs:19:16\n\
    \   |\n19 |         string.insert_range(s.len() - 1, s.as_str());\n   |      \
    \          ^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `insert`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut buf: StringBuilder = StringBuilder::new();\n\n    for\
    \ (i, c) in s.chars().enumerate() {\n        if i > 0 && s.chars()[i-1] == c {\n\
    \            continue;\n        }\n        if i > 0 && c < s.chars()[i-1] {\n\
    \            buf.push(s.chars()[i-1]);\n        }\n        buf.push(c);\n    }\n\
    \n    buf.to_owned()\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n  \
    \  assert_eq!(candidate(String::from(\"Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"\
    hello\")), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"\
    number\")), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"\
    abcd\")), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello\
    \ World!!!\")), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `StringBuilder`\n\
    \  --> /tmp/tmp56jkjomd.rs:14:34\n   |\n14 |     let mut buf: StringBuilder =\
    \ StringBuilder::new();\n   |                                  ^^^^^^^^^^^^^ use\
    \ of undeclared type `StringBuilder`\n\nerror[E0412]: cannot find type `StringBuilder`\
    \ in this scope\n  --> /tmp/tmp56jkjomd.rs:14:18\n   |\n14 |     let mut buf:\
    \ StringBuilder = StringBuilder::new();\n   |                  ^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0608]: cannot index into a value of type `Chars<'_>`\n\
    \  --> /tmp/tmp56jkjomd.rs:17:21\n   |\n17 |         if i > 0 && s.chars()[i-1]\
    \ == c {\n   |                     ^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index\
    \ into a value of type `Chars<'_>`\n  --> /tmp/tmp56jkjomd.rs:20:25\n   |\n20\
    \ |         if i > 0 && c < s.chars()[i-1] {\n   |                         ^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp56jkjomd.rs:21:22\n\
    \   |\n21 |             buf.push(s.chars()[i-1]);\n   |                      ^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0412, E0433, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0412`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars()\n        .cloned()\n        .filter(|c| *c != ' ')\n\
    \        .sort_by_key(|c| *c)\n        .collect()\n        .to_owned()\n}\n\n\
    fn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpehllwt7n.rs:15:10\n     |\n15   |         .cloned()\n \
    \    |          ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror[E0599]: the method `filter` exists for struct\
    \ `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  --> /tmp/tmpehllwt7n.rs:16:10\n\
    \   |\n16 |           .filter(|c| *c != ' ')\n   |            ^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    &s\n        .split_whitespace()\n        .chain(s.chars())\n\
    \        .filter(|x| !x.is_ascii_whitespace())\n        .map(|x| {\n         \
    \   x.to_ascii_uppercase()\n        })\n        .chain(s.chars())\n        .filter(|x|\
    \ x.is_ascii_whitespace())\n        .collect::<String>()\n}\n\nfn main() {\n \
    \   let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\"\
    )), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")),\
    \ String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as IntoIterator>::Item\
    \ == &str`\n   --> /tmp/tmp3ubytlc_.rs:16:10\n    |\n16  |         .chain(s.chars())\n\
    \    |          ^^^^^ expected `&str`, found `char`\n    |\nnote: required by\
    \ a bound in `std::iter::Iterator::chain`\n\nerror[E0599]: the method `filter`\
    \ exists for struct `std::iter::Chain<SplitWhitespace<'_>, Chars<'_>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmp3ubytlc_.rs:17:10\n   |\n17 |\
    \            .filter(|x| !x.is_ascii_whitespace())\n   |             ^^^^^^ method\
    \ cannot be called on `std::iter::Chain<SplitWhitespace<'_>, Chars<'_>>` due to\
    \ unsatisfied trait bounds\n   |\n   = note: the following trait bounds were not\
    \ satisfied:\n           `<Chars<'_> as Iterator>::Item = &str`\n           which\
    \ is required by `std::iter::Chain<SplitWhitespace<'_>, Chars<'_>>: Iterator`\n\
    \           `std::iter::Chain<SplitWhitespace<'_>, Chars<'_>>: Iterator`\n   \
    \        which is required by `&mut std::iter::Chain<SplitWhitespace<'_>, Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Anti-shuffle\n    let mut words = s.chars().collect::<Vec<_>>();\n\
    \    words.sort_by(|a, b| a.cmp(b));\n    let mut buf = String::new();\n    let\
    \ mut i = 0;\n    for word in words {\n        if i != 0 {\n            buf.push('_');\n\
    \        }\n        buf.push_str(&word.to_string());\n        i += 1;\n    }\n\
    \    buf\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"H_i\"`,\n right: `\"Hi\"`', /tmp/tmpf89c4yqs.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 101
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    use std::cmp::Ordering;\n    let mut s: Vec<char> = s.chars().collect();\n\
    \    s.sort_unstable();\n    let mut result = String::new();\n    for c in s.into_iter().rev()\
    \ {\n        if !c.is_whitespace() {\n            result.push(c);\n        } else\
    \ {\n            result.push(' ');\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"iH\"`,\n right: `\"Hi\"`', /tmp/tmps4u6jxrg.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.split(\" \").sort_by(|a, b| a.compare(b))\n        .iter()\n\
    \        .map(|c| c.to_ascii_lowercase())\n        .collect::<String>()\n    \
    \    .join(\" \")\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp4glbp0ta.rs:14:18\n   |\n14 |     s.split(\"\
    \ \").sort_by(|a, b| a.compare(b))\n   |                  ^^^^^^^ method not found\
    \ in `std::str::Split<'_, &str>`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut words = [String::new(); s.len()];\n    let mut space_pos\
    \ = 0;\n\n    for (i, c) in s.chars().enumerate() {\n        if c == ' ' {\n \
    \           words[space_pos].push_str(&c.to_string());\n        } else {\n   \
    \         words[i].push_str(&c.to_string());\n        }\n    }\n\n    let mut\
    \ buffer = String::with_capacity(s.len());\n    for (i, w) in words.iter().enumerate()\
    \ {\n        buffer.push_str(&w);\n        if i != words.len() - 1 {\n       \
    \     buffer.push(' ');\n        }\n    }\n    buffer\n}\n\nfn main() {\n    let\
    \ candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"Hi\")), String::from(\"\
    Hi\"));\n    assert_eq!(candidate(String::from(\"hello\")), String::from(\"ehllo\"\
    ));\n    assert_eq!(candidate(String::from(\"number\")), String::from(\"bemnru\"\
    ));\n    assert_eq!(candidate(String::from(\"abcd\")), String::from(\"abcd\"));\n\
    \    assert_eq!(candidate(String::from(\"Hello World!!!\")), String::from(\"Hello\
    \ !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"Hi. My name is Mister Robot. How\
    \ are you?\")), String::from(\".Hi My aemn is Meirst .Rboot How aer ?ouy\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpp7iql6l_.rs:14:37\n   |\n13 | fn anti_shuffle(s: String) -> String {\n\
    \   |                 - this would need to be a `const`\n14 |     let mut words\
    \ = [String::new(); s.len()];\n   |                                     ^\n\n\
    error[E0277]: the trait bound `String: Copy` is not satisfied\n  --> /tmp/tmpp7iql6l_.rs:14:22\n\
    \   |\n14 |     let mut words = [String::new(); s.len()];\n   |              \
    \        ^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n   |\n\
    \   = note: the `Copy` trait is required because this value will be copied for\
    \ each element of the array\n   = help: consider creating a new `const` item and\
    \ initializing it with the result of the function call to be used in the repeat\
    \ position, like `const VAL: Type = const_fn();` and `let x = [VAL; 42];`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0435.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    s.chars().fold1((s, mut chars)|{\n        if chars.is_empty()\
    \ {\n            return (s, chars.clone());\n        }\n\n        let mut res\
    \ = chars.clone();\n        let mut next = chars.clone();\n        next.sort_by(|a,\
    \ b| a.cmp(b));\n\n        if next.len() == 1 {\n            let mut char = next.remove(0);\n\
    \            chars.push(char);\n            return (s, chars);\n        }\n\n\
    \        loop {\n            let mut char = next.remove(0);\n            chars.push(char);\n\
    \            if next.len() == 0 {\n                break;\n            }\n   \
    \         next = next.clone();\n            let mut next = chars.clone();\n  \
    \          next.sort_by(|a, b| a.cmp(b));\n        }\n        (s, chars)\n   \
    \ })\n}\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found keyword `mut`\n  --> /tmp/tmp9yd4_gr3.rs:14:25\n\
    \   |\n14 |     s.chars().fold1((s, mut chars)|{\n   |                       \
    \  ^^^ expected expression\n\nerror[E0425]: cannot find value `chars` in this\
    \ scope\n  --> /tmp/tmp9yd4_gr3.rs:15:12\n   |\n15 |         if chars.is_empty()\
    \ {\n   |            ^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `chars` in this scope\n  --> /tmp/tmp9yd4_gr3.rs:16:24\n   |\n16 |   \
    \          return (s, chars.clone());\n   |                        ^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `chars` in this scope\n  -->\
    \ /tmp/tmp9yd4_gr3.rs:19:23\n   |\n19 |         let mut res = chars.clone();\n\
    \   |                       ^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `chars` in this scope\n  --> /tmp/tmp9yd4_gr3.rs:20:24\n   |\n20\
    \ |         let mut next = chars.clone();\n   |                        ^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `chars` in this scope\n\
    \  --> /tmp/tmp9yd4_gr3.rs:25:13\n   |\n25 |             chars.push(char);\n \
    \  |             ^^^^^ help: a local variable with a similar name exists: `char`\n\
    \nerror[E0425]: cannot find value `chars` in this scope\n  --> /tmp/tmp9yd4_gr3.rs:26:24\n\
    \   |\n26 |             return (s, chars);\n   |                        ^^^^^\
    \ help: a local variable with a similar name exists: `char`\n\nerror[E0425]: cannot\
    \ find value `chars` in this scope\n  --> /tmp/tmp9yd4_gr3.rs:31:13\n   |\n31\
    \ |             chars.push(char);\n   |             ^^^^^ help: a local variable\
    \ with a similar name exists: `char`\n\nerror[E0425]: cannot find value `chars`\
    \ in this scope\n  --> /tmp/tmp9yd4_gr3.rs:36:28\n   |\n36 |             let mut\
    \ next = chars.clone();\n   |                            ^^^^^ help: a local variable\
    \ with a similar name exists: `char`\n\nerror[E0425]: cannot find value `chars`\
    \ in this scope\n  --> /tmp/tmp9yd4_gr3.rs:39:13\n   |\n39 |         (s, chars)\n\
    \   |             ^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `fold1` found for struct `Chars` in the current scop"
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    let mut s = s;\n    s.chars().cloned()\n        .for_each(|&c|\
    \ {\n            if c == ' ' {\n                let _iter = s.chars().enumerate();\n\
    \                let (prev_c, prev_i) = std::mem::replace(&mut (_iter.next()),\
    \ (0, 0));\n                let (next_c, next_i) = std::mem::replace(&mut (_iter.next()),\
    \ (0, 0));\n                if prev_i < next_i {\n                    s = &s[0..(prev_i)];\n\
    \                } else {\n                    s = &s[(prev_i..)..(next_i + 1)];\n\
    \                }\n            }\n        })\n        .collect();\n    s\n}\n\
    \nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpnkzbv71_.rs:15:15\n     |\n15   |     s.chars().cloned()\n\
    \     |               ^^^^^^ expected reference, found `char`\n     |\n     =\
    \ note: expected reference `&_`\n                     found type `char`\nnote:\
    \ required by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpnkzbv71_.rs:16:10\n   |\n16 |           .for_each(|&c| {\n   |     \
    \       ^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `<Chars<'_> as Iterator>::Item = &_`\n           which is required\
    \ by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n\
    \           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpnkzbv71_.rs:19:79\n   |\n19 |              \
    \   let (prev_c, prev_i) = std::mem::replace(&mut (_iter.next()), (0, 0));\n \
    \  |                                                                         \
    \      ^^^^^^ expected enum `Option`, found tuple\n   |\n   = note: expected enum\
    \ `Option<(usize, char)>`\n             found tuple `({integer}, {integer})`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpnkzbv71_.rs:19:21\n   |\n19 |\
    \                 let (prev_c, prev_i) = std::mem::replace(&mut (_iter.next()),\
    \ (0, 0));\n   |                     ^^^^^^^^^^^^^^^^   ----------------------------------------------\
    \ this expression has type `Option<(usize, char)>`\n   |                     |\n\
    \   |                     expected enum `Option`, found tuple\n   |\n   = note:\
    \ expected enum `Option<(usize, char)>`\n             found tuple `(_, _)`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpnkzbv71_.rs:20:79\n   |\n20 |  \
    \               let (next_c, next_i) = std::mem::replace(&mut (_iter.next()),\
    \ (0, 0));\n   |                                                             \
    \                  ^^^^^^ expected enum `Option`, found "
  stdout: ''
  timestamp: 1659976578
- exit_code: 1
  program: "/// Write a function that takes a string and returns an ordered version\
    \ of it.\n/// Ordered version of string, is a string where all words (separated\
    \ by space)\n/// are replaced by a new word where all the characters arranged\
    \ in\n/// ascending order based on ascii value.\n/// Note: You should keep the\
    \ order of words and blank spaces in the sentence.\n/// For example:\n/// >>>\
    \ anti_shuffle(String::from(\"Hi\"))\n/// String::from(\"Hi\")\n/// >>> anti_shuffle(String::from(\"\
    hello\"))\n/// String::from(\"ehllo\")\n/// >>> anti_shuffle(String::from(\"Hello\
    \ World!!!\"))\n/// String::from(\"Hello !!!Wdlor\")\nfn anti_shuffle(s: String)\
    \ -> String {\n    // Split the string by space\n    let mut words = s.split_whitespace();\n\
    \n    // Split all the words by character\n    let mut chars_split: Vec<Vec<char>>\
    \ = words.chars().collect();\n    // Store the length of all the characters\n\
    \    let mut length_chars = chars_split.iter().map(|c| c.len()).sum();\n    //\
    \ Sort the characters by length from small to big\n    let mut sorted_chars_split\
    \ = chars_split.iter().cloned().sorted_by_key(|&a| a.len());\n\n    // Create\
    \ the new string with the sorted characters\n    String::from(sorted_chars_split.collect::<String>())\n\
    }\n\nfn main() {\n    let candidate = anti_shuffle;\n    assert_eq!(candidate(String::from(\"\
    Hi\")), String::from(\"Hi\"));\n    assert_eq!(candidate(String::from(\"hello\"\
    )), String::from(\"ehllo\"));\n    assert_eq!(candidate(String::from(\"number\"\
    )), String::from(\"bemnru\"));\n    assert_eq!(candidate(String::from(\"abcd\"\
    )), String::from(\"abcd\"));\n    assert_eq!(candidate(String::from(\"Hello World!!!\"\
    )), String::from(\"Hello !!!Wdlor\"));\n    assert_eq!(candidate(String::from(\"\
    \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hi. My name\
    \ is Mister Robot. How are you?\")), String::from(\".Hi My aemn is Meirst .Rboot\
    \ How aer ?ouy\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpw8gbltb4.rs:18:49\n   |\n18 |     let mut\
    \ chars_split: Vec<Vec<char>> = words.chars().collect();\n   |               \
    \                                  ^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `sorted_by_key` found for struct `Cloned` in the\
    \ current scope\n  --> /tmp/tmpw8gbltb4.rs:22:62\n   |\n22 |     let mut sorted_chars_split\
    \ = chars_split.iter().cloned().sorted_by_key(|&a| a.len());\n   |           \
    \                                                   ^^^^^^^^^^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, Vec<char>>>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976578
