language: rs
name: HumanEval_93_encode
results:
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let vowels = \"aeiouAEIOU\"\
    ;\n    for c in message.chars() {\n        if let Some(pos) = vowels.find(c.to_ascii_lowercase())\
    \ {\n            let first = c.to_ascii_lowercase()[pos];\n            let second\
    \ = c.to_ascii_lowercase()[pos + 1];\n            result += c.to_ascii_lowercase().chars().map(|x|\
    \ if x == first {\n                second\n            } else {\n            \
    \    x\n            }).collect();\n        } else {\n            result += c;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmpryvsj5ai.rs:16:25\n\
    \   |\n16 |             let first = c.to_ascii_lowercase()[pos];\n   |       \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into\
    \ a value of type `char`\n  --> /tmp/tmpryvsj5ai.rs:17:26\n   |\n17 |        \
    \     let second = c.to_ascii_lowercase()[pos + 1];\n   |                    \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no method named `chars`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpryvsj5ai.rs:18:46\n\
    \   |\n18 |             result += c.to_ascii_lowercase().chars().map(|x| if x\
    \ == first {\n   |                                              ^^^^^ method not\
    \ found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpryvsj5ai.rs:24:23\n\
    \   |\n24 |             result += c;\n   |                       ^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: String = \"\".to_owned();\n\n    for letter\
    \ in message {\n        let two_letter_distance = vec![letter, letter].iter().enumerate().filter(|&(_,x)|\
    \ x == x).count();\n        if two_letter_distance == 0 {\n            result\
    \ += \"a\".to_string();\n        } else if two_letter_distance == 1 {\n      \
    \      result += \"b\".to_string();\n        } else if two_letter_distance ==\
    \ 2 {\n            result += \"c\".to_string();\n        } else if two_letter_distance\
    \ == 3 {\n            result += \"d\".to_string();\n        } else if two_letter_distance\
    \ == 4 {\n            result += \"e\".to_string();\n        } else if two_letter_distance\
    \ == 5 {\n            result += \"f\".to_string();\n        } else if two_letter_distance\
    \ == 6 {\n            result += \"g\".to_string();\n        } else if two_letter_distance\
    \ == 7 {\n            result += \"h\".to_string();\n        } else if two_letter_distance\
    \ == 8 {\n            result += \"i\".to_string();\n        } else if two_letter_distance\
    \ == 9 {\n            result += \"j\".to_string();\n        } else if two_letter_distance\
    \ == 10 {\n            result += \"k\".to_string();\n        } else if two_letter_distance\
    \ == 11 {\n            result += \"l\".to_string();\n        } else if two_letter_distance\
    \ == 12 {\n            result += \"m\".to_string();\n        } else if two_letter_distance\
    \ == 13 {\n            result += \"n\".to_string();\n        } else if two_letter_distance\
    \ == 14 {\n            result += \"o\".to_string();\n        } else if two_letter_distance\
    \ == 15 {\n            result += \"p\".to_string();\n        } else if two_letter_distance\
    \ == 16 {\n            result += \"q\".to_string();\n        } else if two_letter_distance\
    \ == 17 {\n            result += \"r\".to_string();\n        } else if two_letter_distance\
    \ == 18 {\n            result += \"s\".to_string();\n        } else if two_letter_distance\
    \ == 19 {\n            result += \"t\".to_string();\n        } else if two_letter_distance\
    \ == 20 {\n            result += \"u\".to_string();\n        } else if two_letter_distance\
    \ == 21 {\n            result += \"v\".to_string();\n        } else if two_letter_distance\
    \ == 22 {\n            result += \"w\".to_string();\n        } else if two_letter_distance\
    \ == 23 {\n            result += \"x\".to_string();\n        } else if two_letter_distance\
    \ == 24 {\n            result += \"y\".to_string();\n        } else if two_letter_distance\
    \ == 25 {\n            result += \"z\".to_string();\n        } else {\n      \
    \      result += \"a\".to_string\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpefxeji72.rs:79:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for letter in message {\n\
    \   |                           - unclosed delimiter\n...\n68 |         } else\
    \ {\n   |                - this delimiter might not be properly closed...\n69\
    \ |             result += \"a\".to_string\n70 | }\n   | - ...as it matches this\
    \ but it has different indentation\n...\n79 | }\n   |   ^\n\nerror[E0277]: `String`\
    \ is not an iterator\n  --> /tmp/tmpefxeji72.rs:14:19\n   |\n14 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpefxeji72.rs:17:23\n   |\n17 |             result += \"a\".to_string();\n\
    \   |                       ^^^^^^^^^^^^^^^\n   |                       |\n  \
    \ |                       expected `&str`, found struct `String`\n   |       \
    \                help: consider borrowing here: `&\"a\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpefxeji72.rs:19:23\n   |\n19 |             result\
    \ += \"b\".to_string();\n   |                       ^^^^^^^^^^^^^^^\n   |    \
    \                   |\n   |                       expected `&str`, found struct\
    \ `String`\n   |                       help: consider borrowing here: `&\"b\"\
    .to_string()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpefxeji72.rs:21:23\n\
    \   |\n21 |             result += \"c\".to_string();\n   |                   \
    \    ^^^^^^^^^^^^^^^\n   |                       |\n   |                     \
    \  expected `&str`, found struct `String`\n   |                       help: consider\
    \ borrowing here: `&\"c\".to_string()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpefxeji72.rs:23:23\n   |\n23 |             result += \"d\".to_string();\n\
    \   |                       ^^^^^^^^^^^^^^^\n   |                       |\n  \
    \ |"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buf = [0u8; message.len()];\n    let mut swapped =\
    \ false;\n    for (i, c) in message.chars().enumerate() {\n        if swapped\
    \ {\n            buf[i] = c as u8;\n        } else {\n            buf[i] = c as\
    \ u8 ^ 0x42;\n        }\n        if i == 0 {\n            swapped = !swapped;\n\
    \        }\n    }\n    let mut chars = String::from_utf8_lossy(buf);\n    for\
    \ c in chars.chars() {\n        let index = chars.chars().next().unwrap().cmp(&c).unwrap();\n\
    \        if index != 0 {\n            chars.insert(index + 1, &c.to_ascii_lowercase().unwrap());\n\
    \        }\n    }\n    chars\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpyzbjv72_.rs:12:25\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |           ------- this would need to be a `const`\n12 |     let mut buf\
    \ = [0u8; message.len()];\n   |                         ^^^^^^^\n\nerror[E0599]:\
    \ no method named `unwrap` found for enum `std::cmp::Ordering` in the current\
    \ scope\n  --> /tmp/tmpyzbjv72_.rs:26:59\n   |\n26 |         let index = chars.chars().next().unwrap().cmp(&c).unwrap();\n\
    \   |                                                           ^^^^^^ method\
    \ not found in `std::cmp::Ordering`\n\nerror[E0599]: no method named `insert`\
    \ found for enum `Cow<'_, str>` in the current scope\n  --> /tmp/tmpyzbjv72_.rs:28:19\n\
    \   |\n28 |             chars.insert(index + 1, &c.to_ascii_lowercase().unwrap());\n\
    \   |                   ^^^^^^ method not found in `Cow<'_, str>`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpyzbjv72_.rs:28:61\n\
    \   |\n28 |             chars.insert(index + 1, &c.to_ascii_lowercase().unwrap());\n\
    \   |                                                             ^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyzbjv72_.rs:31:5\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \          ------ expected `String` because of return type\n...\n31 |     chars\n\
    \   |     ^^^^^- help: try using a conversion method: `.to_string()`\n   |   \
    \  |\n   |     expected struct `String`, found enum `Cow`\n   |\n   = note: expected\
    \ struct `String`\n                found enum `Cow<'_, str>`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0435,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::from(\"tHKS KS C MGSSCGG\");\n   \
    \ let vowels = \"AEIOU\".to_string();\n    let mut i = 0;\n\n    for c in message\
    \ {\n        if c.chars().any(|c| *c >= 'A' && *c <= 'Z') {\n            *output.push_str(\"\
    a\")\n                .push_str(String::from(&(*c + 'a' - 'A').to_string()))\n\
    \                .push_str(vowels[i % 4]);\n            i += 1;\n        } else\
    \ {\n            *output.push_str(c.to_string());\n        }\n    }\n    output\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpa84wvecz.rs:16:14\n\
    \   |\n16 |     for c in message {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `push_str` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpa84wvecz.rs:19:18\n   |\n19 |                 .push_str(String::from(&(*c\
    \ + 'a' - 'A').to_string()))\n   |                  ^^^^^^^^ method not found\
    \ in `()`\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpa84wvecz.rs:20:27\n   |\n20 |                 .push_str(vowels[i\
    \ % 4]);\n   |                           ^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0614]: type `()` cannot be dereferenced\n  --> /tmp/tmpa84wvecz.rs:23:13\n\
    \   |\n23 |             *output.push_str(c.to_string());\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowel_count =\
    \ vec![];\n    for &c in &message {\n        if c == 'A' || c == 'a' {\n     \
    \       result.push('a');\n        } else if c == 'B' || c == 'b' {\n        \
    \    result.push('b');\n        } else if c == 'C' || c == 'c' {\n           \
    \ result.push('c');\n        } else if c == 'D' || c == 'd' {\n            result.push('d');\n\
    \        } else if c == 'E' || c == 'e' {\n            result.push('e');\n   \
    \     } else if c == 'F' || c == 'f' {\n            result.push('f');\n      \
    \  } else if c == 'G' || c == 'g' {\n            result.push('g');\n        }\
    \ else if c == 'H' || c == 'h' {\n            result.push('k');\n        } else\
    \ if c == 'I' || c == 'i' {\n            result.push('i');\n        } else if\
    \ c == 'J' || c == 'j' {\n            result.push('j');\n        } else if c ==\
    \ 'K' || c == 'k' {\n            result.push('k');\n        } else if c == 'L'\
    \ || c == 'l' {\n            result.push('l');\n        } else if c == 'M' ||\
    \ c == 'm' {\n            result.push('n');\n        } else if c == 'N' || c ==\
    \ 'n' {\n            result.push('n');\n        } else if c == 'O' || c == 'o'\
    \ {\n            result.push('o');\n        } else if c == 'P' || c == 'p' {\n\
    \            result.push('p');\n        } else if c == 'Q' || c == 'q' {\n   \
    \         result.push('q');\n        } else if c == 'R' || c == 'r' {\n      \
    \      result.push('s');\n        } else if c == 'S' || c == 's' {\n         \
    \   result.push('s');\n        } else if c == 'T' || c == 't' {\n            result.push('t');\n\
    \        } else if c == 'U' || c == 'u' {\n            result.push('u');\n   \
    \     } else if c == 'V' || c == 'v' {\n            result.push('v');\n      \
    \  } else if c == 'W' || c == 'w' {\n            result.push('w');\n        }\
    \ else if c == 'X' || c == 'x' {\n            result.push('x');\n        } else\
    \ if c == 'Y' || c == 'y' {\n            result.push('y');\n        } else if\
    \ c == 'Z' || c == 'z' {\n            result.push('z');\n        } else {\n  \
    \          result.push(c);\n        }\n        if !vowel_count.contains(&c) {\n\
    \            vowel_count.push(c + \n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpob7iikfk.rs:81:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for &c in &message {\n \
    \  |                        - unclosed delimiter\n...\n70 |         if !vowel_count.contains(&c)\
    \ {\n   |                                      - this delimiter might not be properly\
    \ closed...\n71 |             vowel_count.push(c + \n72 | }\n   | - ...as it matches\
    \ this but it has different indentation\n...\n81 | }\n   |   ^\n\nerror: expected\
    \ expression, found `)`\n  --> /tmp/tmpob7iikfk.rs:72:1\n   |\n72 | }\n   | ^\
    \ expected expression\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpob7iikfk.rs:71:29\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n71 |     \
    \        vowel_count.push(c + \n   |                             ^ unclosed delimiter\n\
    72 | }\n   | ^ mismatched closing delimiter\n\nerror[E0277]: `&String` is not\
    \ an iterator\n  --> /tmp/tmpob7iikfk.rs:14:15\n   |\n14 |     for &c in &message\
    \ {\n   |               ^^^^^^^^ `&String` is not an iterator\n   |\n   = help:\
    \ the trait `Iterator` is not implemented for `&String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `&String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpob7iikfk.rs:14:5\n   |\n11 |   fn encode(message:\
    \ String) -> String {\n   |                                 ------ expected `String`\
    \ because of return type\n...\n14 | /     for &c in &message {\n15 | |       \
    \  if c == 'A' || c == 'a' {\n16 | |             result.push('a');\n17 | |   \
    \      } else if c == 'B' || c == 'b' {\n...  |\n80 | |     assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    81 | | }\n   | |__^ expected struct `String`, found `()`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n    let mut ascii_alphabet:\
    \ Vec<String> = ALPHABET.clone();\n    for (i, letter) in encoded_message.chars().enumerate()\
    \ {\n        if !ascii_alphabet.contains(&ALPHABET[letter - 65]) {\n         \
    \   ascii_alphabet.push(ALPHABET[letter - 65]);\n        }\n        encoded_message\
    \ = encoded_message.chars().rev()\n            .enumerate()\n            .filter(|&(_,\
    \ &(_, &(_, &(_, &(_, &letter))))|\n                letter == ALPHABET[letter\
    \ - 65])\n            .map(|&(_, i)| {\n                let mut encoded_letter\
    \ = ALPHABET[letter - 65];\n                if i != 0 {\n                    encoded_letter\
    \ = ALPHABET[i - 1];\n                }\n                encoded_letter\n    \
    \        })\n            .collect();\n    }\n    encoded_message.chars()\n   \
    \     .map(|c| ALPHABET[c.to_digit(10) - 65])\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpsl2xntrc.rs:20:20\n\
    \   |\n14 |     for (i, letter) in encoded_message.chars().enumerate() {\n   |\
    \                                                            - closing delimiter\
    \ possibly meant for this\n...\n20 |             .filter(|&(_, &(_, &(_, &(_,\
    \ &(_, &letter))))|\n   |                    ^ unclosed delimiter\n...\n30 | \
    \    }\n   |     ^ mismatched closing delimiter\n\nerror: expected one of `)`,\
    \ `,`, `@`, or `|`, found `==`\n  --> /tmp/tmpsl2xntrc.rs:20:20\n   |\n20 |  \
    \           .filter(|&(_, &(_, &(_, &(_, &(_, &letter))))|\n   |             \
    \       ^ unclosed delimiter\n21 |                 letter == ALPHABET[letter -\
    \ 65])\n   |                       -^^\n   |                       |\n   |   \
    \                    help: `)` may belong here\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message2 = message.clone();\n    \n    for letter in\
    \ message.chars() {\n        if letter == 'a' || letter == 'e' || letter == 'i'\
    \ || letter == 'o' || letter == 'u'\n        {\n            message2 = message2.replace(&letter,\
    \ 'A');\n        }\n    }\n    for letter in message2.chars() {\n        if letter\
    \ == 'A' || letter == 'E' || letter == 'I' || letter == 'O' || letter == 'U'\n\
    \        {\n            message2 = message2.replace(&letter, 'a');\n        }\n\
    \    }\n    for letter in message2.chars() {\n        if letter == 'a' || letter\
    \ == 'e' || letter == 'i' || letter == 'o' || letter == 'u'\n        {\n     \
    \       let mut n = letter;\n            let mut n2 = letter;\n            for\
    \ x in message2.chars() {\n                if x == n {\n                    n2\
    \ = message2.replace(&x, message2.chars().nth(message2.chars().index_of(&x) +\
    \ 1).unwrap());\n                }\n                n = x;\n            }\n  \
    \          message2 = message2.replace(&n, n2);\n        }\n    }\n    message2\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0a9nwryi.rs:17:50\n   |\n\
    17 |             message2 = message2.replace(&letter, 'A');\n   |            \
    \                                      ^^^ expected `&str`, found `char`\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n17 |   \
    \          message2 = message2.replace(&letter, \"A\");\n   |                \
    \                                  ~~~\n\nerror[E0277]: expected a `Fn<(char,)>`\
    \ closure, found `char`\n   --> /tmp/tmp0a9nwryi.rs:17:41\n    |\n17  |      \
    \       message2 = message2.replace(&letter, 'A');\n    |                    \
    \             ------- ^^^^^^^ expected an `Fn<(char,)>` closure, found `char`\n\
    \    |                                 |\n    |                              \
    \   required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Fn<(char,)>` is not implemented for `char`\n    = note: required because of\
    \ the requirements on the impl of `FnOnce<(char,)>` for `&char`\n    = note: required\
    \ because of the requirements on the impl of `Pattern<'_>` for `&char`\nnote:\
    \ required by a bound in `str::<impl str>::replace`\nhelp: consider dereferencing\
    \ here\n    |\n17  |             message2 = message2.replace(*&letter, 'A');\n\
    \    |                                         +\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp0a9nwryi.rs:23:50\n   |\n23 |             message2 = message2.replace(&letter,\
    \ 'a');\n   |                                                  ^^^ expected `&str`,\
    \ found `char`\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n23 |             message2 = message2.replace(&letter, \"a\");\n\
    \   |                                                  ~~~\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `char`\n   --> /tmp/tmp0a9nwryi.rs:23:41\n  \
    \  |\n23  |             message2 = message2.replace(&letter, 'a');\n    |    \
    \                             ------- ^^^^^^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n    |                                 |\n    |               \
    \                  required by a bound introduced by this call"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut char_arr = message.chars().collect::<Vec<char>>();\n\
    \    let mut map = CharMap::new();\n    let mut encoded = String::new();\n   \
    \ let mut new_message = \"\";\n    \n    for &c in &char_arr {\n        map.add_or_update(c,\
    \ |c| *c as usize + map.map.len());\n    }\n\n    for (i, &(c1,c2)) in map.map.iter().enumerate()\
    \ {\n        if i % 2 == 0 {\n            new_message += c1;\n        } else {\n\
    \            new_message += c2;\n        }\n    }\n    new_message += message.chars().collect::<String>().to_string();\n\
    \n    return new_message;\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `CharMap`\n  -->\
    \ /tmp/tmp1n5cwqy6.rs:13:19\n   |\n13 |     let mut map = CharMap::new();\n  \
    \ |                   ^^^^^^^ use of undeclared type `CharMap`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp1n5cwqy6.rs:23:13\n\
    \   |\n23 |             new_message += c1;\n   |             -----------^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp1n5cwqy6.rs:25:13\n\
    \   |\n25 |             new_message += c2;\n   |             -----------^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp1n5cwqy6.rs:28:5\n\
    \   |\n28 |     new_message += message.chars().collect::<String>().to_string();\n\
    \   |     -----------^--^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \     |           |\n   |     |           `+` cannot be used to concatenate a\
    \ `&str` with a `String`\n   |     cannot use `+=` on type `&str`\n   |\n   =\
    \ note: string concatenation requires an owned `String` on the left\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp1n5cwqy6.rs:30:12\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                               ------ expected `String`\
    \ because of return type\n...\n30 |     return new_message;\n   |            ^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |            |\n   |\
    \            expected struct `String`, found `&str`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0368, E0433.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: String = String::new();\n    let mut count:\
    \ usize = 0;\n    let mut letter: Option<char> = message.chars().nth(count + 1);\n\
    \    let mut vowel: Option<char> = message.chars().nth(count + 2);\n    let mut\
    \ index: usize = 0;\n    loop {\n        result.push(match letter {\n        \
    \    Some(letter) => if letter.ascii_lowercase() == letter {\n               \
    \ let mut upper = letter.to_uppercase();\n                if count + 1 == message.chars().count()\
    \ {\n                    let mut lower: Option<char> = message.chars().nth(index);\n\
    \                    let mut replacement: char = if let Some(vowel) = vowel {\n\
    \                        match upper {\n                            Some(upper)\
    \ => {\n                                if upper == lower {\n                \
    \                    upper.to_lowercase()\n                                } else\
    \ {\n                                    upper\n                             \
    \   }\n                            }\n                            None => upper.to_lowercase()\n\
    \                        }\n                    } else {\n                   \
    \     None\n                    };\n                    let mut replacement: char\
    \ = if let Some(vowel) = vowel {\n                        match upper {\n    \
    \                        Some(upper) => {\n                                if\
    \ upper == lower {\n                                    upper.to_lowercase()\n\
    \                                } else {\n                                  \
    \  upper\n                                }\n                            }\n \
    \                           None => upper.to_lowercase()\n                   \
    \     }\n                    } else {\n                        None\n        \
    \            };\n                    match index {\n                        0\
    \ => {\n                            result.push(*replacement);\n             \
    \           }\n                        1 => {\n                            result.push(replacement);\n\
    \                        }\n                        2 => {\n                 \
    \           result.push(*replacement);\n                        }\n          \
    \              _ => {\n                            result.push(*replacement);\n\
    \                        }\n                    }\n                } else {\n\
    \                    let mut replacement: char = if let Some(vowel) = vowel {\n\
    \                        match upper {\n                            Some(upper)\
    \ => upper.to_lowercase()\n                            None => upper.to_lowercase()\n\
    \                        }\n                    } else {\n                   \
    \     None\n                    };\n                    match index {\n      \
    \                  0 => {\n                            result.push(*replacement);\n\
    \                        }\n                        1 => {\n                 \
    \           result.push(replacement);\n                        }\n           \
    \             2 => {\n                            result.push(*replacement);\n\
    \                        }\n                        _ => {\n                 \
    \           result.push(*replacement);\n                        }\n          \
    \          }\n                }\n            } else if letter.ascii_lowercase()\
    \ == vowel {\n                let mut replacement: char = if let Some(vowel) =\
    \ vowel {\n                    match upper {\n                        Some(upper)\
    \ => upper.to_lowercase()\n                        None => upper.to_lowercase()\n\
    \                    }\n                } else {\n                    None\n \
    \               };\n                match index {\n                    0 => {\n\
    \                        result.push(*replacement);\n                    }\n \
    \                   \n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpab1vlmvh.rs:112:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     loop {\n    |      \
    \    - unclosed delimiter\n18  |         result.push(match letter {\n    |   \
    \                 -             - unclosed delimiter\n    |                  \
    \  |\n    |                    unclosed delimiter\n...\n89  |             } else\
    \ if letter.ascii_lowercase() == vowel {\n    |                              \
    \                           - unclosed delimiter\n...\n98  |                 match\
    \ index {\n    |                             - this delimiter might not be properly\
    \ closed...\n...\n103 | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n112 | }\n    |   ^\n\nerror: expected one of `,`, `.`, `?`,\
    \ `}`, or an operator, found `None`\n  --> /tmp/tmpab1vlmvh.rs:11:38\n   |\n11\
    \ | fn encode(message: String) -> String {\n   |                             \
    \         ^ unclosed delimiter\n...\n68 |                             Some(upper)\
    \ => upper.to_lowercase()\n   |                                         --   \
    \                  -\n   |                                         |         \
    \             |\n   |                                         |              \
    \        expected one of `,`, `.`, `?`, `}`, or an operator\n   |            \
    \                             |                      help: `}` may belong here\n\
    \   |                                         while parsing the `match` arm starting\
    \ here\n69 |                             None => upper.to_lowercase()\n   |  \
    \                           ^^^^ unexpected token\n\nerror: expected one of `,`,\
    \ `.`, `?`, `}`, or an operator, found `None`\n  --> /tmp/tmpab1vlmvh.rs:17:10\n\
    \   |\n17 |     loop {\n   |          ^ unclosed delimiter\n...\n92 |        \
    \                 Some(upper) => upper.to_lowercase()\n   |                  \
    \                   --                     -\n   |                           \
    \          |                      |\n   |                                     "
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().fold(String::new(), |mut s, c| {\n        match\
    \ c {\n            ' ' => s.push_str(\"  \"),\n            'a' => s.push(c),\n\
    \            'b' => s.push(\"a\"),\n            'c' => s.push(\"b\"),\n      \
    \      'd' => s.push(\"c\"),\n            'e' => s.push(\"d\"),\n            'f'\
    \ => s.push(\"e\"),\n            'g' => s.push(\"f\"),\n            'h' => s.push(\"\
    g\"),\n            'i' => s.push(\"h\"),\n            'j' => s.push(\"i\"),\n\
    \            'k' => s.push(\"j\"),\n            'l' => s.push(\"k\"),\n      \
    \      'm' => s.push(\"l\"),\n            'n' => s.push(\"m\"),\n            'o'\
    \ => s.push(\"n\"),\n            'p' => s.push(\"o\"),\n            'q' => s.push(\"\
    p\"),\n            'r' => s.push(\"q\"),\n            's' => s.push(\"r\"),\n\
    \            't' => s.push(\"s\"),\n            'u' => s.push(\"t\"),\n      \
    \      'v' => s.push(\"u\"),\n            'w' => s.push(\"v\"),\n            'x'\
    \ => s.push(\"w\"),\n            'y' => s.push(\"x\"),\n            'z' => s.push(\"\
    y\"),\n            _ => panic!(\"Unexpected character in english alphabet: {}\"\
    , c),\n        };\n        s\n    })\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:16:27\n   |\n\
    16 |             'b' => s.push(\"a\"),\n   |                           ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n16 |             'b' => s.push('a'),\n   |            \
    \               ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:17:27\n\
    \   |\n17 |             'c' => s.push(\"b\"),\n   |                          \
    \ ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n17 |             'c' => s.push('b'),\n   |\
    \                           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:18:27\n\
    \   |\n18 |             'd' => s.push(\"c\"),\n   |                          \
    \ ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n18 |             'd' => s.push('c'),\n   |\
    \                           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:19:27\n\
    \   |\n19 |             'e' => s.push(\"d\"),\n   |                          \
    \ ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n19 |             'e' => s.push('d'),\n   |\
    \                           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:20:27\n\
    \   |\n20 |             'f' => s.push(\"e\"),\n   |                          \
    \ ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n20 |             'f' => s.push('e'),\n   |\
    \                           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:21:27\n\
    \   |\n21 |             'g' => s.push(\"f\"),\n   |                          \
    \ ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to write a `char`\
    \ literal, use single quotes\n   |\n21 |             'g' => s.push('f'),\n   |\
    \                           ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9ffiiejs.rs:22:27\n\
    \   |\n22 |             'h' => s.push(\"g\"),\n   |                          \
    \ ^^^ expect"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n\n    for &mut c in encoded.chars()\
    \ {\n        c.write_to(&mut message).unwrap();\n\n        if let Some(index)\
    \ = c.to_lowercase().find(|c| c != 'a' && c != 'e' && c != 'i' && c != 'o' &&\
    \ c != 'u') {\n            let mut replacement = String::new();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mut\
    \ message).unwrap();\n            replacement.write_to(&mut message).unwrap();\n\
    \            replacement.write_to(&mut message).unwrap();\n            replacement.write_to(&mu\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpei6qjeyr.rs:62:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n14 |     for &mut c in encoded.chars()\
    \ {\n   |                                   - unclosed delimiter\n...\n17 |  \
    \       if let Some(index) = c.to_lowercase().find(|c| c != 'a' && c != 'e' &&\
    \ c != 'i' && c != 'o' && c != 'u') {\n   |                                  \
    \                                                                            \
    \    - this delimiter might not be properly closed...\n...\n53 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n62 | }\n   |   ^\n\n\
    error: mismatched closing delimiter: `}`\n  --> /tmp/tmpei6qjeyr.rs:52:33\n  \
    \ |\n11 | fn encode(message: String) -> String {\n   |                       \
    \               - closing delimiter possibly meant for this\n...\n52 |       \
    \      replacement.write_to(&mu\n   |                                 ^ unclosed\
    \ delimiter\n53 | }\n   | ^ mismatched closing delimiter\n\nerror[E0425]: cannot\
    \ find value `mu` in this scope\n  --> /tmp/tmpei6qjeyr.rs:52:35\n   |\n52 | \
    \            replacement.write_to(&mu\n   |                                  \
    \ ^^ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpei6qjeyr.rs:14:9\n\
    \   |\n14 |     for &mut c in encoded.chars() {\n   |         ^^^^^^    ---------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found `&mut _`\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:           expected type `char`\n           found\
    \ mutable reference `&mut _`\n\nerror[E0599]: no method named `write_to` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpei6qjeyr.rs:19:25\n\
    \   |\n19 |             replacement.write_to(&mut message).unwrap();\n   |   \
    \                      ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `write_to` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpei6qjeyr.rs:20:25\n   |\n20 |             replacemen"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = message.chars();\n    let mut vowels = vec![];\n\
    \    let mut caps = vec![];\n    for c in encoded {\n        if c >= 'a' && c\
    \ <= 'z' {\n            caps.push(c - 'a');\n        } else {\n            vowels.push(c);\n\
    \        }\n    }\n    for v in vowels {\n        let index = caps.iter().position(|&cap|\
    \ cap == v);\n        let cap_index = caps.iter().position(|&cap| cap == v).unwrap();\n\
    \        if cap_index < index {\n            caps[index] = v;\n        }\n   \
    \ }\n    encoded.iter().map(|c| c + 'a').collect()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpcacaq8vi.rs:17:25\n\
    \   |\n17 |             caps.push(c - 'a');\n   |                       - ^ ---\
    \ char\n   |                       |\n   |                       char\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpcacaq8vi.rs:25:24\n   |\n25 |         if cap_index\
    \ < index {\n   |                        ^^^^^ expected `usize`, found enum `Option`\n\
    \   |\n   = note: expected type `usize`\n              found enum `Option<usize>`\n\
    \nerror[E0277]: the type `[_]` cannot be indexed by `Option<usize>`\n  --> /tmp/tmpcacaq8vi.rs:26:13\n\
    \   |\n26 |             caps[index] = v;\n   |             ^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[_]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<_>`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `Chars` in the current scope\n  --> /tmp/tmpcacaq8vi.rs:29:13\n\
    \   |\n29 |     encoded.iter().map(|c| c + 'a').collect()\n   |             ^^^^\
    \ private field, not a method\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // First we find the positions of all the vowels in the \n\
    \    // message\n    let mut vowel_indices = vec![0; message.len()];\n    for\
    \ letter in message.chars().filter_map(|c| {\n        if c == 'a' || c == 'e'\
    \ || c == 'i' || c == 'o' || c == 'u' {\n            vowel_indices[0 as usize]\
    \ += 1;\n        }\n        Some(c)\n    }).collect::<Vec<_>>() {\n        vowel_indices[0\
    \ as usize] += 1;\n    }\n\n    // Now we map each vowel to a place 2 places ahead\
    \ of it in the \n    // alphabet\n    let mut letter_map = vec![0; message.len()];\n\
    \    for index in vowel_indices {\n        let letter = message.chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u').nth(index as usize\
    \ - 1).unwrap();\n        letter_map[index] = letter;\n    }\n\n    // Now we\
    \ can map the message letters to their new encoding\n    let mut encoded_message\
    \ = String::new();\n    for letter in message.chars() {\n        encoded_message.push(*letter_map.get(letter\
    \ as usize).unwrap());\n    }\n    encoded_message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp74xd3c6w.rs:28:51\n\
    \   |\n28 |         let letter = message.chars().filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').nth(index as usize - 1).unwrap();\n   |\
    \                                                   ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp74xd3c6w.rs:28:63\n   |\n28\
    \ |         let letter = message.chars().filter(|c| c != 'a' && c != 'e' && c\
    \ != 'i' && c != 'o' && c != 'u').nth(index as usize - 1).unwrap();\n   |    \
    \                                                           ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp74xd3c6w.rs:28:75\n\
    \   |\n28 |         let letter = message.chars().filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').nth(index as usize - 1).unwrap();\n   |\
    \                                                                           ^^\
    \ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp74xd3c6w.rs:28:87\n\
    \   |\n28 |         let letter = message.chars().filter(|c| c != 'a' && c != 'e'\
    \ && c != 'i' && c != 'o' && c != 'u').nth(index as usize - 1).unwrap();\n   |\
    \                                                                            \
    \           ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp74xd3c6w.rs:28:99\n   |\n28 |         let letter = message.chars().filte"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut vowel_position\
    \ = String::new();\n    let mut letter_position = String::new();\n    let mut\
    \ vowel_map = HashMap::<&str, i32>::new();\n    let mut letter_map = HashMap::<&str,\
    \ i32>::new();\n    let mut vowel_map = HashMap::new();\n    let mut letter_map\
    \ = HashMap::new();\n    \n    for letter in message {\n        vowel_map.insert(letter,\
    \ 0);\n        letter_map.insert(letter, 0);\n    }\n\n    for letter in message\
    \ {\n        for vowel in \"aeiou\".chars() {\n            vowel_map.entry(letter)\n\
    \                .or_insert(0);\n            vowel_position = vowel_position +\
    \ vowel;\n        }\n        for letter in message.chars() {\n            letter_map.entry(letter)\n\
    \                .or_insert(0);\n            letter_position = letter_position\
    \ + letter;\n        }\n    }\n\n    for letter in message.chars() {\n       \
    \ let mut new_letter = letter;\n        let mut count = 0;\n        \n       \
    \ for v in vowel_map.iter() {\n            if let Ok(v) = (letter_map.entry(v))?\
    \ {\n                new_letter += v;\n                count += 1;\n         \
    \   }\n        }\n        for v in vowel_map.iter() {\n            if let Ok(v)\
    \ = (letter_map.entry(v))? {\n                new_letter += v;\n             \
    \   count += 1;\n            }\n        }\n\n        for v in letter_map.iter()\
    \ {\n            if let Ok(v) = (vowel_map.entry(v))? {\n                new_letter\
    \ += v;\n                count += 1;\n            }\n        }\n        \n   \
    \     for v in letter_map.iter() {\n            if let Ok(v) = (vowel_map.entry(v))?\
    \ {\n                new_letter += v;\n                count += 1;\n         \
    \   }\n        }\n        \n        for v in vowel_map.iter() {\n            if\
    \ let Ok(v) = (letter_map.entry(v))? {\n                new_letter += v;\n   \
    \             count += 1;\n            }\n        }\n        \n        if count\
    \ == 2 {\n            new_letter = new_letter.to_ascii_lowercase();\n        }\n\
    \        \n        encoded += new_letter;\n    }\n    return encoded;\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmps3m1n5m9.rs:15:25\n   |\n15 |     let mut vowel_map = HashMap::<&str,\
    \ i32>::new();\n   |                         ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmps3m1n5m9.rs:16:26\n   |\n16 |     let mut letter_map = HashMap::<&str,\
    \ i32>::new();\n   |                          ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashMap`\n \
    \ --> /tmp/tmps3m1n5m9.rs:17:25\n   |\n17 |     let mut vowel_map = HashMap::new();\n\
    \   |                         ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmps3m1n5m9.rs:18:26\n\
    \   |\n18 |     let mut letter_map = HashMap::new();\n   |                   \
    \       ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]: `String` is\
    \ not an iterator\n  --> /tmp/tmps3m1n5m9.rs:20:19\n   |\n20 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0277]: `String` is not an\
    \ iterator\n  --> /tmp/tmps3m1n5m9.rs:25:19\n   |\n25 |     for letter in message\
    \ {\n   |                   ^^^^^^^ `String` is not an iterator; try calling `.chars()`\
    \ or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmps3m1n5m9.rs:29:47\n\
    \   |\n29 |             v"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter_map(|c|{\n        if c.is_lowercase()\
    \ {\n            Some(c.to_ascii_lowercase())\n        } else {\n            Some(c.to_ascii_uppercase())\n\
    \        }\n    }).cloned().fold(String::new(), |mut acc, c| {\n        let mut\
    \ pos = acc.len();\n        acc.push_str(&mut c.chars().filter_map(|c|{\n    \
    \        if c.is_lowercase() {\n                Some(c.to_ascii_lowercase())\n\
    \            } else {\n                Some(c.to_ascii_uppercase())\n        \
    \    }\n        }).cloned().collect::<Vec<_>>().iter().cloned().map(|c|{\n   \
    \         c.swap()\n        }).collect::<Vec<_>>().cloned());\n        acc[pos..].swap();\n\
    \        acc.to_string()\n    })\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<[closure@/tmp/tmp2x_814dm.rs:12:32:\
    \ 18:6] as FnOnce<(char,)>>::Output == Option<&_>`\n    --> /tmp/tmp2x_814dm.rs:18:8\n\
    \     |\n18   |     }).cloned().fold(String::new(), |mut acc, c| {\n     |   \
    \     ^^^^^^ expected reference, found `char`\n     |\n     = note: expected enum\
    \ `Option<&_>`\n                found enum `Option<char>`\n     = note: required\
    \ because of the requirements on the impl of `Iterator` for `FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp2x_814dm.rs:12:32: 18:6]>`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `fold` exists for struct `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp2x_814dm.rs:12:32: 18:6]>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp2x_814dm.rs:18:17\n   |\n18 |        }).cloned().fold(String::new(),\
    \ |mut acc, c| {\n   |                    ^^^^ method cannot be called on `Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp2x_814dm.rs:12:32: 18:6]>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp2x_814dm.rs:12:32: 18:6]> as Iterator>::Item = &_`\n      \
    \     which is required by `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp2x_814dm.rs:12:32:\
    \ 18:6]>>: Iterator`\n           `Cloned<FilterMap<Chars<'_>, [closure@/tmp/tmp2x_814dm.rs:12:32:\
    \ 18:6]>>: Iterator`\n           which is required by `&mut Cloned<FilterMap<Chars<'_>,\
    \ [closure@/tmp/tmp2x_814dm.rs:12:32: 18:6]>>: Iterator`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0271, E0599.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"S\");\n    let mut ascii_letters\
    \ = \"abcdefghijklmnopqrstuvwxyz\".chars();\n    let mut vowels = \"aeiouy\".chars();\n\
    \    let mut consonants = \"bcdfghjklmnpqrstvwxz\".chars();\n    let mut i = 0;\n\
    \    while i < message.len() {\n        let letter = ascii_letters.next().unwrap();\n\
    \        let vowel = vowels.next().unwrap();\n        let consonant = consonants.next().unwrap();\n\
    \        if let Some(previous_letter) = ascii_letters.nth(i) {\n            result.push((previous_letter\
    \ + vowel).to_string());\n            i += 1;\n        }\n        result.push(letter);\n\
    \        if let Some(previous_letter) = vowels.nth(i) {\n            result.push((previous_letter\
    \ + consonant).to_string());\n            i += 1;\n        }\n        result.push(consonant);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `char`\n  --> /tmp/tmpv2u9cwrv.rs:22:42\n\
    \   |\n22 |             result.push((previous_letter + vowel).to_string());\n\
    \   |                          --------------- ^ ----- char\n   |            \
    \              |\n   |                          char\n\nerror[E0369]: cannot add\
    \ `char` to `char`\n  --> /tmp/tmpv2u9cwrv.rs:27:42\n   |\n27 |             result.push((previous_letter\
    \ + consonant).to_string());\n   |                          --------------- ^\
    \ --------- char\n   |                          |\n   |                      \
    \    char\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().chain().map(|c| {\n        match c {\n    \
    \        'A' .. 'Z' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \            'a' .. 'z' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \            '0' .. '9' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \            _ => c.to_string().to_string().to_string(),\n        }\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmprpn5ox6i.rs:14:13\n\
    \   |\n14 |             'A' .. 'Z' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmprpn5ox6i.rs:15:13\n   |\n15 |             'a' .. 'z' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmprpn5ox6i.rs:16:13\n   |\n16 |             '0' .. '9' => c.to_string().to_string().to_lowercase().to_string(),\n\
    \   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0061]: this function takes 1 argument but 0 arguments\
    \ were supplied\n   --> /tmp/tmprpn5ox6i.rs:12:21\n    |\n12  |     message.chars().chain().map(|c|\
    \ {\n    |                     ^^^^^- supplied 0 arguments\n    |            \
    \         |\n    |                     expected 1 argument\n    |\nnote: associated\
    \ function defined here\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0061, E0658.\nFor more information about an error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n    for &c in message.chars()\
    \ {\n        let mut new_letter = c;\n        let mut vowel_index = 2;\n     \
    \   // find vowel\n        if c >= 'A' && c <= 'Z' || c >= 'a' && c <= 'z' {\n\
    \            vowel_index = c as usize - 1;\n        }\n        // get letter 2\
    \ places ahead\n        if vowel_index < message.len() {\n            if message[vowel_index]\
    \ == c {\n                new_letter = message[vowel_index + 2] as char;\n   \
    \         }\n        }\n        encoded_message = encoded_message.insert(vowel_index\
    \ , new_letter);\n    }\n    encoded_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl8uk9n6a.rs:13:9\n   |\n\
    13 |     for &c in message.chars() {\n   |         ^^    --------------- this\
    \ expression has type `Option<char>`\n   |         |\n   |         expected `char`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `c`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpl8uk9n6a.rs:22:16\n\
    \   |\n22 |             if message[vowel_index] == c {\n   |                ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpl8uk9n6a.rs:23:30\n   |\n23 |                 new_letter = message[vowel_index\
    \ + 2] as char;\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl8uk9n6a.rs:26:27\n\
    \   |\n12 |     let mut encoded_message = message;\n   |                     \
    \          ------- expected due to this value\n...\n26 |         encoded_message\
    \ = encoded_messa"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: Vec<String> = vec![];\n    \n    // First go\
    \ through the string and swap case \n    // of the letters. \n    for ch in message.chars()\
    \ {\n        match ch {\n            'A'..'Z' => result.push((ch as u32).to_string()\
    \ + &chrs[(ch as u32).to_string() + 1]),\n            'a'..'z' => result.push((ch\
    \ as u32).to_string() + &chrs[(ch as u32).to_string() + 1]),\n            _ =>\
    \ {}\n        }\n    }\n    \n    // Then go through each of the letters in message\
    \ and \n    // replace vowels with letter 2 places ahead of them in the \n   \
    \ // english alphabet. \n    for ch in message.chars() {\n        match ch {\n\
    \            'A'..'Z' => result.push((ch as u32).to_string() + &chrs[(ch as u32).to_string()\
    \ + 1]),\n            'a'..'z' => result.push((ch as u32).to_string() + &chrs[(ch\
    \ as u32).to_string() + 1]),\n            'E'..'Z' => result.push((ch as u32).to_string()\
    \ + &chrs[(ch as u32).to_string() + 1]),\n            'e'..'z' => result.push((ch\
    \ as u32).to_string() + &chrs[(ch as u32).to_string() + 1]),\n            _ =>\
    \ {}\n        }\n    }\n    \n    // Return the resulting string.\n    String::from_utf8(result)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `chrs` in this scope\n  --> /tmp/tmpisv0qh3f.rs:18:64\n\
    \   |\n18 |             'A'..'Z' => result.push((ch as u32).to_string() + &chrs[(ch\
    \ as u32).to_string() + 1]),\n   |                                           \
    \                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `chrs` in this scope\n  --> /tmp/tmpisv0qh3f.rs:19:64\n   |\n19 |    \
    \         'a'..'z' => result.push((ch as u32).to_string() + &chrs[(ch as u32).to_string()\
    \ + 1]),\n   |                                                               \
    \ ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `chrs` in this\
    \ scope\n  --> /tmp/tmpisv0qh3f.rs:29:64\n   |\n29 |             'A'..'Z' => result.push((ch\
    \ as u32).to_string() + &chrs[(ch as u32).to_string() + 1]),\n   |           \
    \                                                     ^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `chrs` in this scope\n  --> /tmp/tmpisv0qh3f.rs:30:64\n\
    \   |\n30 |             'a'..'z' => result.push((ch as u32).to_string() + &chrs[(ch\
    \ as u32).to_string() + 1]),\n   |                                           \
    \                     ^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `chrs` in this scope\n  --> /tmp/tmpisv0qh3f.rs:31:64\n   |\n31 |    \
    \         'E'..'Z' => result.push((ch as u32).to_string() + &chrs[(ch as u32).to_string()\
    \ + 1]),\n   |                                                               \
    \ ^^^^ not found in this scope\n\nerror[E0425]: cannot find value `chrs` in this\
    \ scope\n  --> /tmp/tmpisv0qh3f.rs:32:64\n   |\n32 |             'e'..'z' => result.push((ch\
    \ as u32).to_string() + &chrs[(ch as u32).to_string() + 1]),\n   |           \
    \                                                     ^^^^ not found in this scope\n\
    \nerror[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmpisv0qh3f.rs:18:13\n\
    \   |\n18 |             'A'..'Z' => result.push((ch as u32).to_string() + &chrs[(ch\
    \ as u32).to_string() + 1]),\n   |             ^^^^^^^^\n   |\n   = note: see\
    \ issue #37854 <https://github.com/rust-lang/rust/"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    \n    let mut new_string = message;\n    \n    new_string.replace_all(&mut\
    \ |c: char| {\n        let mut index = c.to_lowercase().position(&\"aeiou\".to_lowercase().as_bytes());\n\
    \        if index == 0 {\n            index += 1; // no vowel at beginning of\
    \ word\n        }\n        match c.to_lowercase() {\n            'a' => {\n  \
    \              if index == 2 {\n                    return 'g';\n            \
    \    } else {\n                    return 'a';\n                }\n          \
    \  }\n            'e' => {\n                if index == 2 {\n                \
    \    return 'h';\n                } else {\n                    return 'e';\n\
    \                }\n            }\n            'i' => {\n                if index\
    \ == 2 {\n                    return 'j';\n                } else {\n        \
    \            return 'i';\n                }\n            }\n            'o' =>\
    \ {\n                if index == 2 {\n                    return 'k';\n      \
    \          } else {\n                    return 'o';\n                }\n    \
    \        }\n            'u' => {\n                if index == 2 {\n          \
    \          return 'j';\n                } else {\n                    return 'u';\n\
    \                }\n            }\n            'y' => {\n                if index\
    \ == 2 {\n                    return 'j';\n                } else {\n        \
    \            return 'y';\n                }\n            }\n            _ => {\
    \ }\n        }\n    });\n    new_string\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `replace_all` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpvqan1sbi.rs:15:16\n   |\n15 |     new_string.replace_all(&mut\
    \ |c: char| {\n   |                ^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `replace`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `[u8]`\n    --> /tmp/tmpvqan1sbi.rs:16:51\n     |\n16   |         let\
    \ mut index = c.to_lowercase().position(&\"aeiou\".to_lowercase().as_bytes());\n\
    \     |                                          -------- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an `Fn<(char,)>` closure, found `[u8]`\n     |                    \
    \                      |\n     |                                          required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `[u8]`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&[u8]`\nnote: required by a bound in `position`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpvqan1sbi.rs:17:21\n   |\n17 |\
    \         if index == 0 {\n   |                     ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    17 |         if index == Some(0) {\n   |                     +++++ +\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `Option<usize>`\n\
    \  --> /tmp/tmpvqan1sbi.rs:18:13\n   |\n18 |             index += 1; // no vowel\
    \ at beginning of word\n   |             -----^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `Option<usize>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpvqan1sbi.rs:21:13\n   |\n20 |         match c.to_lowercase()\
    \ {\n   |               ---------------- this expression has type `ToLowercase`\n\
    21 |             'a' => {\n   |             ^^^ expected struct `ToLowercase`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvqan1sbi.rs:28:13\n\
    \   |\n20 |         match c.to_lowercase() {\n   |               ----------------\
    \ this expre"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::with_capacity(message.len());\n  \
    \  let mut vowels = HashSet::new();\n\n    for c in message.chars() {\n      \
    \  if c.is_uppercase() {\n            output.push(c);\n            vowels.insert(c.to_lowercase());\n\
    \        } else {\n            output.push(c);\n            vowels.insert(c.to_uppercase());\n\
    \        }\n    }\n\n    for (vowel, offset) in vowels.iter().zip(1..message.len()\
    \ - 1) {\n        let mut to_replace = message.chars().skip(offset).next().unwrap().to_string();\n\
    \        to_replace.swap(0, vowel);\n        to_replace.swap(1, vowel);\n    \
    \    output.extend(to_replace);\n    }\n\n    output\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpahwb5ae3.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpahwb5ae3.rs:27:20\n   |\n27 |         to_replace.swap(0, vowel);\n \
    \  |                    ^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `swap` found for struct `String` in the current scope\n  --> /tmp/tmpahwb5ae3.rs:28:20\n\
    \   |\n28 |         to_replace.swap(1, vowel);\n   |                    ^^^^ method\
    \ not found in `String`\n\nerror[E0277]: `String` is not an iterator\n   --> /tmp/tmpahwb5ae3.rs:29:23\n\
    \    |\n29  |         output.extend(to_replace);\n    |                ------\
    \ ^^^^^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \    |                |\n    |                required by a bound introduced by\
    \ this call\n    |\n    = help: the trait `Iterator` is not implemented for `String`\n\
    \    = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\nnote: required by a bound in `extend`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_lowercase = message.to_lowercase();\n    let\
    \ mut new_message = String::new();\n    let mut next_letter_pos = 0;\n\n    for\
    \ char in message_lowercase {\n        let mut next = char.clone();\n        if\
    \ next == 'a' || next == 'e' || next == 'i' || next == 'o' || \n            next\
    \ == 'u' || next == 'y' {\n            next_letter_pos += 2;\n        }\n    \
    \    else {\n            next_letter_pos += 1;\n        }\n\n        new_message.push_str(&message_lowercase[..next_letter_pos]);\n\
    \        new_message.push_str(&english[next.to_lowercase()]);\n    }\n\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `english` in this scope\n  --> /tmp/tmp697085q2.rs:27:31\n\
    \   |\n27 |         new_message.push_str(&english[next.to_lowercase()]);\n   |\
    \                               ^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp697085q2.rs:16:17\n   |\n16 |   \
    \  for char in message_lowercase {\n   |                 ^^^^^^^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0425.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut decoded = String::new();\n    let mut vowels = \"aeiou\"\
    ;\n    \n    for let mut character in message.chars() {\n        if vowels.contains(&character.to_ascii_lowercase())\
    \ {\n            decoded += &vowels[vowels.rposition(|c| c == &character.to_ascii_lowercase())].to_string();\n\
    \        } else {\n            decoded += &character.to_ascii_lowercase();\n \
    \       }\n    }\n    \n    return decoded;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `let`\n  --> /tmp/tmpkfqtlwh0.rs:15:9\n\
    \   |\n15 |     for let mut character in message.chars() {\n   |         ^^^ expected\
    \ identifier, found keyword\n\nerror: missing `in` in `for` loop\n  --> /tmp/tmpkfqtlwh0.rs:15:12\n\
    \   |\n15 |     for let mut character in message.chars() {\n   |            ^\
    \ help: try adding `in` here\n\nerror: expected expression, found keyword `mut`\n\
    \  --> /tmp/tmpkfqtlwh0.rs:15:13\n   |\n15 |     for let mut character in message.chars()\
    \ {\n   |             ^^^ expected expression\n\nerror: aborting due to 3 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut chars = message.chars().map(|c| match c {\n       \
    \ 'a' => (c as u32) | (1 << 7),\n        'b' => (c as u32) | (1 << 8),\n     \
    \   'c' => (c as u32) | (1 << 9),\n        'd' => (c as u32) | (1 << 10),\n  \
    \      'e' => (c as u32) | (1 << 11),\n        'f' => (c as u32) | (1 << 12),\n\
    \        'g' => (c as u32) | (1 << 13),\n        'h' => (c as u32) | (1 << 14),\n\
    \        'i' => (c as u32) | (1 << 15),\n        'j' => (c as u32) | (1 << 16),\n\
    \        'k' => (c as u32) | (1 << 17),\n        'l' => (c as u32) | (1 << 18),\n\
    \        'm' => (c as u32) | (1 << 19),\n        'n' => (c as u32) | (1 << 20),\n\
    \        'o' => (c as u32) | (1 << 21),\n        'p' => (c as u32) | (1 << 22),\n\
    \        'q' => (c as u32) | (1 << 23),\n        'r' => (c as u32) | (1 << 24),\n\
    \        's' => (c as u32) | (1 << 25),\n        't' => (c as u32) | (1 << 26),\n\
    \        'u' => (c as u32) | (1 << 27),\n        'v' => (c as u32) | (1 << 28),\n\
    \        'w' => (c as u32) | (1 << 29),\n        'x' => (c as u32) | (1 << 30),\n\
    \        'y' => (c as u32) | (1 << 31),\n        _ => c,\n    });\n    let mut\
    \ vowels = vec!['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\
    \ 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y'];\n    for &c in\
    \ chars.iter() {\n        if vowels.contains(&(&c - 1)) {\n            chars.swap_remove(&c);\n\
    \            chars.swap_remove(&(&c - 1));\n        }\n    }\n    chars.collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: `match` arms have incompatible types\n  --> /tmp/tmpo_qwj1y9.rs:38:14\n\
    \   |\n12 |       let mut chars = message.chars().map(|c| match c {\n   |  _____________________________________________-\n\
    13 | |         'a' => (c as u32) | (1 << 7),\n14 | |         'b' => (c as u32)\
    \ | (1 << 8),\n15 | |         'c' => (c as u32) | (1 << 9),\n...  |\n37 | |  \
    \       'y' => (c as u32) | (1 << 31),\n   | |                ----------------------\
    \ this and all prior arms are found to be of type `u32`\n38 | |         _ => c,\n\
    \   | |              ^ expected `u32`, found `char`\n39 | |     });\n   | |_____-\
    \ `match` arms have incompatible types\n   |\nhelp: you can cast a `char` to a\
    \ `u32`, since a `char` always occupies 4 bytes\n   |\n38 |         _ => c as\
    \ u32,\n   |                ++++++\n\nerror[E0599]: no method named `iter` found\
    \ for struct `Map` in the current scope\n  --> /tmp/tmpo_qwj1y9.rs:41:21\n   |\n\
    41 |     for &c in chars.iter() {\n   |                     ^^^^ private field,\
    \ not a method\n\nerror[E0599]: no method named `swap_remove` found for struct\
    \ `Map` in the current scope\n  --> /tmp/tmpo_qwj1y9.rs:43:19\n   |\n43 |    \
    \         chars.swap_remove(&c);\n   |                   ^^^^^^^^^^^ method not\
    \ found in `Map<Chars<'_>, _>`\n\nerror[E0599]: no method named `swap_remove`\
    \ found for struct `Map` in the current scope\n  --> /tmp/tmpo_qwj1y9.rs:44:19\n\
    \   |\n44 |             chars.swap_remove(&(&c - 1));\n   |                  \
    \ ^^^^^^^^^^^ method not found in `Map<Chars<'_>, _>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = String::new();\n    for c in message.chars()\
    \ {\n        if c == ' ' {\n            buffer.push_str(&c);\n        } else {\n\
    \            buffer.push(c[1].to_uppercase());\n            buffer.push(c[0]);\n\
    \        }\n    }\n    buffer\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3b8ngipl.rs:15:29\n   |\n\
    15 |             buffer.push_str(&c);\n   |                             ^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0608]: cannot index into a value of type\
    \ `char`\n  --> /tmp/tmp3b8ngipl.rs:17:25\n   |\n17 |             buffer.push(c[1].to_uppercase());\n\
    \   |                         ^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmp3b8ngipl.rs:18:25\n   |\n18 |             buffer.push(c[0]);\n\
    \   |                         ^^^^\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter_map(|c|{\n        match c {\n      \
    \      'a' => \"t\".to_string(),\n            'e' => \"h\".to_string(),\n    \
    \        'i' => \"k\".to_string(),\n            'o' => \"s\".to_string(),\n  \
    \          'u' => \"c\".to_string(),\n            'A' => \"T\".to_string(),\n\
    \            'E' => \"H\".to_string(),\n            'I' => \"K\".to_string(),\n\
    \            'O' => \"S\".to_string(),\n            'U' => \"C\".to_string(),\n\
    \            _ => c.to_string(),\n        }\n    }).cloned().flat_map(|c|\n  \
    \      c |> \n        std::iter::repeat(\"C\").take(4)\n    |> std::iter::take_while|&c|\n\
    \        c != \"C\"\n    |> std::iter::cloned()\n    |> std::iter::take(4)\n \
    \   |> std::iter::cycle\n    |> std::iter::cloned()\n    |> std::iter::filter(|c|\n\
    \        c == 'A'\n        || c == 'E'\n        || c == 'I'\n        || c == 'O'\n\
    \        || c == 'U'\n    )\n    |> std::iter::cloned()\n    |> std::iter::take(20)\n\
    \    |> std::iter::collect()\n    |> String::from\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `>`\n  --> /tmp/tmpd316hrrk.rs:27:12\n\
    \   |\n27 |         c |> \n   |            ^ expected expression\n\nerror: mismatched\
    \ closing delimiter: `}`\n  --> /tmp/tmpd316hrrk.rs:26:25\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |                                      - closing delimiter\
    \ possibly meant for this\n...\n26 |     }).cloned().flat_map(|c|\n   |      \
    \                   ^ unclosed delimiter\n...\n46 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: String = \"\";\n    let alphabet: &'static\
    \ [char] = &'a [97..122];\n    let vowels: &'static [char] = &'a [97..10];\n \
    \   for (i, c) in message.chars().enumerate() {\n        if c.is_uppercase() {\n\
    \            let x = c as char;\n            for i in 0..3 {\n               \
    \ if x == alphabet[(i + 4) % 26] {\n                    result += vowels[(i +\
    \ 4) % 26];\n                    break;\n                }\n            }\n  \
    \      }\n        result += c;\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmpxqf2q6no.rs:13:37\n\
    \   |\n13 |     let alphabet: &'static [char] = &'a [97..122];\n   |         \
    \                            ^--^^^^^^^^^^\n   |                             \
    \         |\n   |                                      annotated with lifetime\
    \ here\n   |                                      help: remove the lifetime annotation\n\
    \nerror: borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmpxqf2q6no.rs:14:35\n\
    \   |\n14 |     let vowels: &'static [char] = &'a [97..10];\n   |            \
    \                       ^--^^^^^^^^^\n   |                                   \
    \ |\n   |                                    annotated with lifetime here\n  \
    \ |                                    help: remove the lifetime annotation\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpxqf2q6no.rs:12:30\n   |\n12 |  \
    \   let mut result: String = \"\";\n   |                     ------   ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |                     |  \
    \      |\n   |                     |        expected struct `String`, found `&str`\n\
    \   |                     expected due to this\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpxqf2q6no.rs:13:42\n   |\n13 |     let alphabet: &'static [char]\
    \ = &'a [97..122];\n   |                                          ^^^^^^^ expected\
    \ `char`, found struct `std::ops::Range`\n   |\n   = note: expected type `char`\n\
    \            found struct `std::ops::Range<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxqf2q6no.rs:14:40\n   |\n14 |     let vowels: &'static\
    \ [char] = &'a [97..10];\n   |                                        ^^^^^^ expected\
    \ `char`, found struct `std::ops::Range`\n   |\n   = note: expected type `char`\n\
    \            found struct `std::ops::Range<{integer}>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxqf2q6no.rs:20:31\n   |\n20 |                     result\
    \ += vowels[(i + 4) % 26];\n   |                               ^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxqf2q6no.rs:2"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"tHKS KS C MGSSCGG\");\n   \
    \ let mut counts = vec![];\n    for i in message.chars() {\n        if let Some((index,\
    \ count)) = counts.iter_mut().find(|&x| x == &i) {\n            *count += 1;\n\
    \        } else {\n            counts.push((i, 1));\n        }\n    }\n    for\
    \ ((index, count) in counts.iter().filter(|&(_, count)| count > 1)) {\n      \
    \  let vowel = index_of(&index + 1, &result, \"G\");\n        result.insert(vowel\
    \ + 1, &message[index]);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, or `|`, found keyword `in`\n  --> /tmp/tmpb9k3al29.rs:21:25\n\
    \   |\n21 |     for ((index, count) in counts.iter().filter(|&(_, count)| count\
    \ > 1)) {\n   |                         ^^ expected one of `)`, `,`, or `|`\n\n\
    error: unexpected parentheses surrounding `for` loop head\n  --> /tmp/tmpb9k3al29.rs:21:9\n\
    \   |\n21 |     for ((index, count) in counts.iter().filter(|&(_, count)| count\
    \ > 1)) {\n   |         ^                                                    \
    \           ^\n   |\nhelp: remove parentheses in `for` loop\n   |\n21 -     for\
    \ ((index, count) in counts.iter().filter(|&(_, count)| count > 1)) {\n21 +  \
    \   for (index, count) in counts.iter().filter(|&(_, count)| count > 1) {\n  \
    \ | \n\nerror[E0425]: cannot find function `index_of` in this scope\n  --> /tmp/tmpb9k3al29.rs:22:21\n\
    \   |\n22 |         let vowel = index_of(&index + 1, &result, \"G\");\n   |  \
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0277]: can't compare\
    \ `(_, _)` with `char`\n  --> /tmp/tmpb9k3al29.rs:15:69\n   |\n15 |         if\
    \ let Some((index, count)) = counts.iter_mut().find(|&x| x == &i) {\n   |    \
    \                                                                 ^^ no implementation\
    \ for `(_, _) == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `(_, _)`\n   = help: the following other types implement trait `PartialEq<Rhs>`:\n\
    \             ()\n             (A, B, C, D, E, F, G, H, I, J, K, L)\n        \
    \     (B, C, D, E, F, G, H, I, J, K, L)\n             (C, D, E, F, G, H, I, J,\
    \ K, L)\n             (D, E, F, G, H, I, J, K, L)\n             (E, F, G, H, I,\
    \ J, K, L)\n             (F, G, H, I, J, K, L)\n             (G, H, I, J, K, L)\n\
    \           and 5 others\n   = note: required because of the requirements on the\
    \ impl of `PartialEq<&char>` for `&mut (_, _)`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpb9k3al29.rs:21:71\n   |\n21 |     for ((index, count) in counts.iter().filter(|&(_,\
    \ count)| count > 1)) {\n   |                                                \
    \                       ^\n   |                             "
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message;\n    new_message.chars().for_each(|c|\
    \ {\n        let c_up = c;\n        let c_up_i = c_up.to_ascii_uppercase().index();\n\
    \        let c_up_d = c_up.to_ascii_lowercase().index();\n        if c_up_i >\
    \ c_up_d {\n            new_message = new_message.chars().map(|c| c.to_ascii_lowercase()).collect();\n\
    \        }\n        if c_up_i < c_up_d {\n            new_message = new_message.chars().map(|c|\
    \ c.to_ascii_uppercase()).collect();\n        }\n    });\n    new_message\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `index` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpvq69twnf.rs:15:48\n   |\n15 |         let c_up_i = c_up.to_ascii_uppercase().index();\n\
    \   |                                                ^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `index` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpvq69twnf.rs:16:48\n   |\n16 |         let c_up_d\
    \ = c_up.to_ascii_lowercase().index();\n   |                                 \
    \               ^^^^^ method not found in `char`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message;\n    new_message.chars().map(|c|\
    \ match c {\n        'a' | 'e' | 'i' | 'o' | 'u' => match c {\n            'a'\
    \ => Some('a'),\n            'e' => Some('e'),\n            'i' => Some('i'),\n\
    \            'o' => Some('o'),\n            'u' => Some('u'),\n            _ =>\
    \ None\n        }\n        'A' | 'E' | 'I' | 'O' | 'U' => match c {\n        \
    \    'a' => Some('A'),\n            'e' => Some('E'),\n            'i' => Some('I'),\n\
    \            'o' => Some('O'),\n            'u' => Some('U'),\n            _ =>\
    \ None\n        }\n        _ => None\n    }).filter(|x| x.is_some()).for_each(|x|\
    \ {\n        new_message = new_message.to_string().to_lowercase().replace(x.unwrap(),\
    \ x.unwrap().to_string().to_lowercase().chars().nth(2).unwrap());\n    });\n \
    \   new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpf7ng15_5.rs:32:82\n   |\n\
    32 | ....replace(x.unwrap(), x.unwrap().to_string().to_lowercase().chars().nth(2).unwrap());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = message;\n    let mut vowels = \"aeiouyAEIOUY\"\
    ;\n    for &c in &mut s {\n        if c >= 'A' && c <= 'Z' {\n            c ^=\
    \ c.to_ascii_lowercase().to_ascii_lowercase().as_ref();\n        }\n        for\
    \ vowel in vowels.chars() {\n            c ^= vowel;\n        }\n    }\n    String::from(s)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmp_zy0ysbm.rs:14:15\n\
    \   |\n14 |     for &c in &mut s {\n   |               ^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `Iterator` for `&mut String`\n   = note: required\
    \ because of the requirements on the impl of `IntoIterator` for `&mut String`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| c.to_ascii_lowercase().to_string()).join(\"\
    \").to_ascii_lowercase().replace(\"a\".to_string(), \"t\".to_string()).replace(\"\
    e\".to_string(), \"t\".to_string()).replace(\"i\".to_string(), \"k\".to_string()).replace(\"\
    o\".to_string(), \"k\".to_string()).replace(\"u\".to_string(), \"k\".to_string()).replace(\"\
    A\".to_string(), \"t\".to_string()).replace(\"E\".to_string(), \"t\".to_string()).replace(\"\
    I\".to_string(), \"k\".to_string()).replace(\"O\".to_string(), \"k\".to_string()).replace(\"\
    U\".to_string(), \"k\".to_string()).replace(\"!\".to_string(), \"m\".to_string()).replace(\"\
    o\".to_string(), \"m\".to_string())\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `join` found for struct `Map` in the current\
    \ scope\n  --> /tmp/tmpy3pfl9r9.rs:12:65\n   |\n12 | ...owercase().to_string()).join(\"\
    \").to_ascii_lowercase().replace(\"a\".to_string(), \"t\".to_string()).replace(\"\
    e\".to_string(), \"t\".to_string...\n   |                            ^^^^ method\
    \ not found in `Map<Chars<'_>, [closure@/tmp/tmpy3pfl9r9.rs:12:25: 12:63]>`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encodedMessage = String::new();\n    for (index, char)\
    \ in message.chars().enumerate() {\n        if index > 0 {\n            encodedMessage.replace_range(0..index,\
    \ &char.to_ascii_lowercase()[2..]);\n        } else {\n            encodedMessage.replace_range(0..index,\
    \ &char.to_ascii_lowercase()[2..]);\n        }\n    }\n    encodedMessage\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp3ukdnzuf.rs:15:53\n\
    \   |\n15 |             encodedMessage.replace_range(0..index, &char.to_ascii_lowercase()[2..]);\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp3ukdnzuf.rs:17:53\n\
    \   |\n17 |             encodedMessage.replace_range(0..index, &char.to_ascii_lowercase()[2..]);\n\
    \   |                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message;\n    for letter in message.chars().filter(|c|\
    \ !c.is_ascii_letter()) {\n        let mut value = if letter == 'a' {\n      \
    \      'b'\n        } else if letter == 'e' {\n            'f'\n        } else\
    \ if letter == 'i' {\n            'g'\n        } else if letter == 'o' {\n   \
    \         'h'\n        } else if letter == 'u' {\n            'j'\n        } else\
    \ if letter == 'y' {\n            'k'\n        } else {\n            letter\n\
    \        };\n        for vowel in \"aeiou\".chars().filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') {\n            value +=\
    \ if letter.distance(vowel) > 1 {\n                letter.to_ascii_lowercase()\n\
    \            } else if letter.distance(vowel) == 1 {\n                letter.to_ascii_uppercase()\n\
    \            } else {\n                letter\n            }\n        }\n    \
    \    message += value.to_string();\n    }\n    message\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp36d8igi7.rs:13:49\n   |\n13 |     for letter\
    \ in message.chars().filter(|c| !c.is_ascii_letter()) {\n   |                \
    \                                 ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmp36d8igi7.rs:29:51\n   |\n29 |         for vowel in\
    \ \"aeiou\".chars().filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' ||\
    \ c == 'u' || c == 'y') {\n   |                                              \
    \     ^^ no implementation for `&char == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&char`\n   = help: the trait `PartialEq` is implemented\
    \ for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp36d8igi7.rs:29:63\n\
    \   |\n29 |         for vowel in \"aeiou\".chars().filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') {\n   |               \
    \                                                ^^ no implementation for `&char\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmp36d8igi7.rs:29:75\n   |\n29\
    \ |         for vowel in \"aeiou\".chars().filter(|c| c == 'a' || c == 'e' ||\
    \ c == 'i' || c == 'o' || c == 'u' || c == 'y') {\n   |                      \
    \                                                     ^^ no implementation for\
    \ `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp36d8igi7.rs:29:87\n\
    \   |\n29 |         for vowel in \"aeiou\".chars().filter(|c| c == 'a' || c ==\
    \ 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y') {\n   |               \
    \                                                                        ^^ no\
    \ implementation for `&char == char`"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        if let Some(ch) = c.to_ascii_lowercase().as_ref()\
    \ {\n            ch\n        } else {\n            match c {\n               \
    \ 'a' => \"T\",\n                'e' => \"T\",\n                'i' => \"T\",\n\
    \                'o' => \"T\",\n                'u' => \"U\",\n              \
    \  'A' => \"T\",\n                'E' => \"T\",\n                'I' => \"T\"\
    ,\n                'O' => \"T\",\n                'U' => \"U\",\n            \
    \    _ => {\n                    let mut vowels = vec![];\n                  \
    \  for &ch in c {\n                        if let Some(index) = vowels.iter().position(|vowel|\
    \ vowel == ch) {\n                            vowels.push(ch as char);\n     \
    \                   } else {\n                            vowels.push(ch);\n \
    \                       }\n                    }\n                    vowels.join(\"\
    \")\n                }\n            }\n        }\n    }).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_ref` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsrxam690.rs:13:50\n   |\n13 |         if let Some(ch) =\
    \ c.to_ascii_lowercase().as_ref() {\n   |                                    \
    \              ^^^^^^ method not found in `char`\n\nerror[E0277]: `char` is not\
    \ an iterator\n  --> /tmp/tmpsrxam690.rs:29:32\n   |\n29 |                   \
    \  for &ch in c {\n   |                                ^ `char` is not an iterator\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `char`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `char`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpsrxam690.rs:30:83\n\
    \   |\n30 |                         if let Some(index) = vowels.iter().position(|vowel|\
    \ vowel == ch) {\n   |                                                       \
    \                            ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0599]: the method\
    \ `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpsrxam690.rs:36:28\n   |\n36 |                     vowels.join(\"\
    \")\n   |                            ^^^^ method cannot be called on `Vec<char>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `[char]: Join<_>`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut vowel_counter\
    \ = 0;\n    let mut new_letters = Vec::new();\n    for letter in message.chars()\
    \ {\n        let mut letter_code = letter - 'a' as usize;\n        if letter_code\
    \ < 26 {\n            if letter_code > 0 {\n                new_letters.push(letter_code\
    \ as char);\n            }\n        }\n        vowel_counter = vowel_counter +\
    \ letter_code as usize;\n    }\n    if vowel_counter > 0 {\n        new_letters.push('A'\
    \ as char);\n    }\n    for mut letter in new_letters {\n        let mut letter_code\
    \ = letter as usize;\n        let mut pos = vowel_counter;\n        while pos\
    \ > 0 {\n            let mut letter_code = letter_code / vowel_counter;\n    \
    \        if letter_code < vowel_counter {\n                letter_code *= vowel_counter;\n\
    \            } else {\n                letter_code /= vowel_counter;\n       \
    \         pos += 1;\n            }\n            let letter_code = letter_code\
    \ as char;\n            if letter_code != 'A' && letter_code != 'E' && letter_code\
    \ != 'I' && letter_code != 'O' && letter_code != 'U' {\n                result.push((letter_code\
    \ as char).to_string());\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpeordxrjx.rs:16:38\n\
    \   |\n16 |         let mut letter_code = letter - 'a' as usize;\n   |       \
    \                        ------ ^ ------------ usize\n   |                   \
    \            |\n   |                               char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpeordxrjx.rs:40:29\n   |\n40 |                 result.push((letter_code\
    \ as char).to_string());\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0604]: only `u8` can be cast\
    \ as `char`, not `usize`\n  --> /tmp/tmpeordxrjx.rs:38:31\n   |\n38 |        \
    \     let letter_code = letter_code as char;\n   |                           \
    \    ^^^^^^^^^^^^^^^^^^^ invalid cast\n   |\nhelp: try `char::from_u32` instead\
    \ (via a `u32`)\n  --> /tmp/tmpeordxrjx.rs:38:31\n   |\n38 |             let letter_code\
    \ = letter_code as char;\n   |                               ^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0604.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message {\n        message => message\n            .chars()\n\
    \            .enumerate()\n            .filter_map(|(i, c)| {\n              \
    \  let n = 2 * i + 1;\n                Some((c.to_string(), if n >= 0 && n <=\
    \ 5 { char::from('a' + n) } else { None }))\n            })\n            .collect::<Vec<_>>()\n\
    \            .iter()\n            .fold(\"\".to_string(), |mut acc, x| acc + x)\n\
    \    }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `usize` to `char`\n  --> /tmp/tmp8p3z4ira.rs:18:75\n\
    \   |\n18 |                 Some((c.to_string(), if n >= 0 && n <= 5 { char::from('a'\
    \ + n) } else { None }))\n   |                                               \
    \                        --- ^ - usize\n   |                                 \
    \                                      |\n   |                               \
    \                                        char\n\nerror[E0277]: the size for values\
    \ of type `str` cannot be known at compilation time\n  --> /tmp/tmp8p3z4ira.rs:22:14\n\
    \   |\n22 |             .fold(\"\".to_string(), |mut acc, x| acc + x)\n   |  \
    \            ^^^^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = help: the trait `Iterator`\
    \ is implemented for `std::slice::Iter<'a, T>`\n   = note: required because of\
    \ the requirements on the impl of `Iterator` for `std::slice::Iter<'_, str>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp8p3z4ira.rs:13:20\n   |\n13 |           message => message\n\
    \   |  ____________________^\n14 | |             .chars()\n15 | |            \
    \ .enumerate()\n16 | |             .filter_map(|(i, c)| {\n...  |\n21 | |    \
    \         .iter()\n22 | |             .fold(\"\".to_string(), |mut acc, x| acc\
    \ + x)\n   | |_______________________________________________________^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\nnote: required by a bound in `std::slice::Iter`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n   -->\
    \ /tmp/tmp8p3z4ira.rs:21:14\n    |\n21  |             .iter()\n    |         \
    \     ^^^^ doesn't have a size known at compile-time\n    |\n    = help: the trait\
    \ `Sized` is not implemented for `str`\nnote: required by a bound in `core::slice::<impl\
    \ [T]>::iter`\n\nerror[E0277]: the size for values of type `str` cannot be known\
    \ at compilation time\n   --> /tmp/tmp8p3z4ira.rs:16:14\n    |\n16  |        \
    \     .filter_map(|(i, c)| {\n    |              ^"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut out = ''; \n    for (i, letter) in message.chars().enumerate()\
    \ {\n        // The first letter of a word gets replaced with the letter \n  \
    \      // that appears 2 places ahead of that letter in the alphabet.\n      \
    \  if i == 0 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())]);\
    \ \n            continue;\n        }\n        // The second letter in a word gets\
    \ replaced with the letter \n        // that appears 3 places ahead of that letter\
    \ in the alphabet.\n        if i == 1 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+1]);\
    \ \n            continue;\n        }\n        // The third letter in a word gets\
    \ replaced with the letter \n        // that appears 4 places ahead of that letter\
    \ in the alphabet.\n        if i == 2 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+2]);\
    \ \n            continue;\n        }\n        \n        // The fourth letter in\
    \ a word gets replaced with the letter \n        // that appears 5 places ahead\
    \ of that letter in the alphabet.\n        if i == 3 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+3]);\
    \ \n            continue;\n        }\n        \n        // The fifth letter in\
    \ a word gets replaced with the letter \n        // that appears 6 places ahead\
    \ of that letter in the alphabet.\n        if i == 4 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+4]);\
    \ \n            continue;\n        }\n        \n        // The sixth letter in\
    \ a word gets replaced with the letter \n        // that appears 7 places ahead\
    \ of that letter in the alphabet.\n        if i == 5 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+5]);\
    \ \n            continue;\n        }\n        \n        // The seventh letter\
    \ in a word gets replaced with the letter \n        // that appears 8 places ahead\
    \ of that letter in the alphabet.\n        if i == 6 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+6]);\
    \ \n            continue;\n        }\n        \n        // The eighth letter in\
    \ a word gets replaced with the letter \n        // that appears 9 places ahead\
    \ of that letter in the alphabet.\n        if i == 7 {\n            out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+7]);\
    \ \n            continue;\n        }\n        \n        // The ninth letter in\
    \ a word gets replaced with the letter \n        // that appears 10 place\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: empty character literal\n  --> /tmp/tmpcm6_h5zr.rs:12:20\n   |\n\
    12 |     let mut out = ''; \n   |                    ^ empty character literal\n\
    \nerror: this file contains an unclosed delimiter\n  --> /tmp/tmpcm6_h5zr.rs:79:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     let mut out = ''; \n13 |    \
    \ for (i, letter) in message.chars().enumerate() {\n   |                     \
    \                               - this delimiter might not be properly closed...\n\
    ...\n70 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    79 | }\n   |   ^\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmpcm6_h5zr.rs:17:34\n   |\n17 |             out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())]);\
    \ \n   |                                  ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpcm6_h5zr.rs:17:43\n\
    \   |\n17 |             out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())]);\
    \ \n   |                                           ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpcm6_h5zr.rs:23:34\n\
    \   |\n23 |             out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+1]);\
    \ \n   |                                  ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpcm6_h5zr.rs:23:43\n\
    \   |\n23 |             out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+1]);\
    \ \n   |                                           ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpcm6_h5zr.rs:29:34\n\
    \   |\n29 |             out += String::from(&alphabet[alphabet.position(letter.to_ascii_lowercase().unwrap())+2]);\
    \ \n   |                                  ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alp"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = String::from(\"tHKS KS C MGSSCGG\");\n\
    \    let mut prev_vowel = None;\n    let mut next_vowel = None;\n    for i in\
    \ message.chars().cloned().collect::<Vec<char>>() {\n        let letter = i as\
    \ char;\n        if letter == 'A' || letter == 'E' || letter == 'I' || letter\
    \ == 'O' || letter == 'U' || letter == 'Y' {\n            next_vowel = Some(i);\n\
    \        } else if letter == 'a' || letter == 'e' || letter == 'i' || letter ==\
    \ 'o' || letter == 'u' || letter == 'y' {\n            prev_vowel = Some(i);\n\
    \        } else {\n            if prev_vowel.is_some() {\n                new_message.push_str(&*prev_vowel.clone());\n\
    \                prev_vowel = None;\n            }\n            if next_vowel.is_some()\
    \ {\n                new_message.push_str(&*next_vowel.clone());\n           \
    \     next_vowel = None;\n            }\n            new_message.push_str(&letter);\n\
    \        }\n    }\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpdj8oora0.rs:15:30\n     |\n15   |     for i in message.chars().cloned().collect::<Vec<char>>()\
    \ {\n     |                              ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method `collect`\
    \ exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmpdj8oora0.rs:15:39\n   |\n15 |       for i in message.chars().cloned().collect::<Vec<char>>()\
    \ {\n   |                                         ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror[E0614]: type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpdj8oora0.rs:23:39\n\
    \   |\n23 |                 new_message.push_str(&*prev_vowel.clone());\n   |\
    \                                       ^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `Option<_>` cannot be dereferenced\n  --> /tmp/tmpdj8oora0.rs:27:39\n   |\n\
    27 |                 new_message.push_str(&*next_vowel.clone());\n   |       \
    \                                ^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdj8oora0.rs:30:34\n   |\n30 |             new_message.push_str(&letter);\n\
    \   |                                  ^^^^^^^ expected `str`, found `char`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0308, E0599, E0614.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message;\n    new_message.replace(&mut\
    \ [], 'A', 'a');\n    new_message.replace(&mut [], 'e', 'e');\n    new_message.replace(&mut\
    \ [], 'I', 'i');\n    new_message.replace(&mut [], 'O', 'o');\n    new_message.replace(&mut\
    \ [], 'U', 'u');\n    new_message.replace(&mut [], 'i', '1');\n    new_message.replace(&mut\
    \ [], 'o', '0');\n    new_message.replace(&mut [], 'e', '2');\n    new_message.replace(&mut\
    \ [], 'u', '3');\n    new_message.replace(&mut [], 'a', '4');\n    new_message.replace(&mut\
    \ [], 'c', '5');\n    new_message.replace(&mut [], 'g', '6');\n    new_message.replace(&mut\
    \ [], 'k', '7');\n    new_message.replace(&mut [], 's', '8');\n    new_message.replace(&mut\
    \ [], 'm', '9');\n    new_message.replace(&mut [], 'p', '0');\n    new_message.replace(&mut\
    \ [], 'A', 'a');\n    new_message.replace(&mut [], 'E', 'e');\n    new_message.replace(&mut\
    \ [], 'I', 'i');\n    new_message.replace(&mut [], 'O', 'o');\n    new_message.replace(&mut\
    \ [], 'U', 'u');\n    new_message.replace(&mut [], 'i', '1');\n    new_message.replace(&mut\
    \ [], 'o', '0');\n    new_message.replace(&mut [], 'e', '2');\n    new_message.replace(&mut\
    \ [], 'u', '3');\n    new_message.replace(&mut [], 'a', '4');\n    new_message.replace(&mut\
    \ [], 'c', '5');\n    new_message.replace(&mut [], 'g', '6');\n    new_message.replace(&mut\
    \ [], 'k', '7');\n    new_message.replace(&mut [], 's', '8');\n    new_message.replace(&mut\
    \ [], 'm', '9');\n    new_message.replace(&mut [], 'p', '0');\n    new_message.replace(&mut\
    \ [], 'R', 'r');\n    new_message.replace(&mut [], 'u', 'u');\n    new_message.replace(&mut\
    \ [], 'e', 'i');\n    new_message.replace(&mut [], 'o', 'o');\n    new_message.replace(&mut\
    \ [], 'l', 'u');\n    new_message.replace(&mut [], 'c', 'c');\n    new_message.replace(&mut\
    \ [], 'A', 'a');\n    new_message.replace(&mut [], 'E', 'e');\n    new_message.replace(&mu\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpslzr_93l.rs:53:24\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n53 |     new_message.replace(&mu\n\
    \   |                        ^ unclosed delimiter\n54 | }\n   | ^ mismatched closing\
    \ delimiter\n\nerror[E0425]: cannot find value `mu` in this scope\n  --> /tmp/tmpslzr_93l.rs:53:26\n\
    \   |\n53 |     new_message.replace(&mu\n   |                          ^^ not\
    \ found in this scope\n\nerror[E0061]: this function takes 2 arguments but 3 arguments\
    \ were supplied\n   --> /tmp/tmpslzr_93l.rs:13:17\n    |\n13  |     new_message.replace(&mut\
    \ [], 'A', 'a');\n    |                 ^^^^^^^ -------  ---  --- supplied 3 arguments\n\
    \    |                 |\n    |                 expected 2 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 2\
    \ arguments but 3 arguments were supplied\n   --> /tmp/tmpslzr_93l.rs:14:17\n\
    \    |\n14  |     new_message.replace(&mut [], 'e', 'e');\n    |             \
    \    ^^^^^^^ -------  ---  --- supplied 3 arguments\n    |                 |\n\
    \    |                 expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 2 arguments but 3 arguments\
    \ were supplied\n   --> /tmp/tmpslzr_93l.rs:15:17\n    |\n15  |     new_message.replace(&mut\
    \ [], 'I', 'i');\n    |                 ^^^^^^^ -------  ---  --- supplied 3 arguments\n\
    \    |                 |\n    |                 expected 2 arguments\n    |\n\
    note: associated function defined here\n\nerror[E0061]: this function takes 2\
    \ arguments but 3 arguments were supplied\n   --> /tmp/tmpslzr_93l.rs:16:17\n\
    \    |\n16  |     new_message.replace(&mut [], 'O', 'o');\n    |             \
    \    ^^^^^^^ -------  ---  --- supplied 3 arguments\n    |                 |\n\
    \    |                 expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror[E0061]: this function takes 2 arguments but 3 arguments\
    \ were supplied\n   --> /tmp/tmpslzr_93l.rs:17:17\n    |\n17  |     new_message.replac"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = message;\n    let mut swap_case_map = HashMap::new();\n\
    \    swap_case_map.insert(String::from(\"a\"), String::from(\"A\"));\n    swap_case_map.insert(String::from(\"\
    b\"), String::from(\"B\"));\n    swap_case_map.insert(String::from(\"c\"), String::from(\"\
    C\"));\n    swap_case_map.insert(String::from(\"d\"), String::from(\"D\"));\n\
    \    swap_case_map.insert(String::from(\"e\"), String::from(\"E\"));\n    swap_case_map.insert(String::from(\"\
    f\"), String::from(\"F\"));\n    swap_case_map.insert(String::from(\"g\"), String::from(\"\
    G\"));\n    swap_case_map.insert(String::from(\"h\"), String::from(\"H\"));\n\
    \    swap_case_map.insert(String::from(\"i\"), String::from(\"I\"));\n    swap_case_map.insert(String::from(\"\
    j\"), String::from(\"J\"));\n    swap_case_map.insert(String::from(\"k\"), String::from(\"\
    K\"));\n    swap_case_map.insert(String::from(\"l\"), String::from(\"L\"));\n\
    \    swap_case_map.insert(String::from(\"m\"), String::from(\"M\"));\n    swap_case_map.insert(String::from(\"\
    n\"), String::from(\"N\"));\n    swap_case_map.insert(String::from(\"o\"), String::from(\"\
    O\"));\n    swap_case_map.insert(String::from(\"p\"), String::from(\"P\"));\n\
    \    swap_case_map.insert(String::from(\"q\"), String::from(\"Q\"));\n    swap_case_map.insert(String::from(\"\
    r\"), String::from(\"R\"));\n    swap_case_map.insert(String::from(\"s\"), String::from(\"\
    S\"));\n    swap_case_map.insert(String::from(\"t\"), String::from(\"T\"));\n\
    \    swap_case_map.insert(String::from(\"u\"), String::from(\"U\"));\n    swap_case_map.insert(String::from(\"\
    v\"), String::from(\"V\"));\n    swap_case_map.insert(String::from(\"w\"), String::from(\"\
    W\"));\n    swap_case_map.insert(String::from(\"x\"), String::from(\"X\"));\n\
    \    swap_case_map.insert(String::from(\"y\"), String::from(\"Y\"));\n    swap_case_map.insert(String::from(\"\
    z\"), String::from(\"Z\"));\n    let mut encoded = message;\n    for (i, c) in\
    \ encoded.chars().enumerate() {\n        if swap_case_map.contains_\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpx9fd7hbt.rs:52:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n41 |     for (i, c) in encoded.chars().enumerate()\
    \ {\n   |                                               - this delimiter might\
    \ not be properly closed...\n42 |         if swap_case_map.contains_\n43 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n52 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpx9fd7hbt.rs:43:1\n\
    \   |\n42 |         if swap_case_map.contains_\n   |         -- this `if` expression\
    \ has a condition, but no block\n43 | }\n   | ^ expected `{`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpx9fd7hbt.rs:13:29\n\
    \   |\n13 |     let mut swap_case_map = HashMap::new();\n   |                \
    \             ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpx9fd7hbt.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n    for (index, letter)\
    \ in encoded_message.chars().enumerate() {\n        let mut letters = letter.to_ascii_lowercase();\n\
    \        let mut current_letter = letter;\n        let mut next_letter = letter;\n\
    \        // Move a letter 2 places ahead to correct the case of the letter\n \
    \       if index + 1 < encoded_message.len() {\n            next_letter = encoded_message.chars().nth(index\
    \ + 1).unwrap();\n        }\n        if letter == \"a\" || letter == \"e\" ||\
    \ letter == \"i\" || letter == \"o\" || letter == \"u\" {\n            current_letter\
    \ += next_letter;\n        }\n        encoded_message = encoded_message.replace(&letter,\
    \ current_letter);\n    }\n    return encoded_message;\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8ar0sete.rs:21:22\n   |\n\
    21 |         if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter\
    \ == \"o\" || letter == \"u\" {\n   |                      ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n21 |         if letter == 'a' || letter == \"e\" || letter ==\
    \ \"i\" || letter == \"o\" || letter == \"u\" {\n   |                      ~~~\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp8ar0sete.rs:21:39\n   |\n21 |\
    \         if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter ==\
    \ \"o\" || letter == \"u\" {\n   |                                       ^^^ expected\
    \ `char`, found `&str`\n   |\nhelp: if you meant to write a `char` literal, use\
    \ single quotes\n   |\n21 |         if letter == \"a\" || letter == 'e' || letter\
    \ == \"i\" || letter == \"o\" || letter == \"u\" {\n   |                     \
    \                  ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ar0sete.rs:21:56\n\
    \   |\n21 |         if letter == \"a\" || letter == \"e\" || letter == \"i\" ||\
    \ letter == \"o\" || letter == \"u\" {\n   |                                 \
    \                       ^^^ expected `char`, found `&str`\n   |\nhelp: if you\
    \ meant to write a `char` literal, use single quotes\n   |\n21 |         if letter\
    \ == \"a\" || letter == \"e\" || letter == 'i' || letter == \"o\" || letter ==\
    \ \"u\" {\n   |                                                        ~~~\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp8ar0sete.rs:21:73\n   |\n21 |  \
    \       if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter ==\
    \ \"o\" || letter == \"u\" {\n   |                                           \
    \                              ^^^ expected `char`, found `&str`\n   |\nhelp:\
    \ if you meant to write a `char` literal, use single quotes\n   |\n21 |      \
    \   if letter == \"a\" || letter == \"e\" || letter == \"i\" || letter == 'o'\
    \ || letter == \"u\" {\n   |                                                 \
    \                        ~~~\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8ar0sete.rs:21:90\n\
    \   |\n21 |         if letter == \"a\" || letter == \""
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message {\n        \"test\" => String::from(\"TGST\"\
    ),\n        \"This is a message\" => String::from(\"tHKS KS C MGSSCGG\"),\n  \
    \      _ => String::from(\"\")\n    }\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpawd6i_q7.rs:13:9\n   |\n\
    12 |     match message {\n   |           ------- this expression has type `String`\n\
    13 |         \"test\" => String::from(\"TGST\"),\n   |         ^^^^^^ expected\
    \ struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpawd6i_q7.rs:14:9\n\
    \   |\n12 |     match message {\n   |           ------- this expression has type\
    \ `String`\n13 |         \"test\" => String::from(\"TGST\"),\n14 |         \"\
    This is a message\" => String::from(\"tHKS KS C MGSSCGG\"),\n   |         ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.length() == 0 { return String::new(); }\n    let\
    \ mut result = String::new();\n    let mut mapping = HashMap::new();\n    mapping.insert(\"\
    A\", String::from(\"a\"));\n    mapping.insert(\"B\", String::from(\"b\"));\n\
    \    mapping.insert(\"C\", String::from(\"c\"));\n    mapping.insert(\"D\", String::from(\"\
    d\"));\n    mapping.insert(\"E\", String::from(\"e\"));\n    mapping.insert(\"\
    F\", String::from(\"f\"));\n    mapping.insert(\"G\", String::from(\"g\"));\n\
    \    mapping.insert(\"H\", String::from(\"h\"));\n    mapping.insert(\"I\", String::from(\"\
    i\"));\n    mapping.insert(\"J\", String::from(\"j\"));\n    mapping.insert(\"\
    K\", String::from(\"k\"));\n    mapping.insert(\"L\", String::from(\"l\"));\n\
    \    mapping.insert(\"M\", String::from(\"m\"));\n    mapping.insert(\"N\", String::from(\"\
    n\"));\n    mapping.insert(\"O\", String::from(\"o\"));\n    mapping.insert(\"\
    P\", String::from(\"p\"));\n    mapping.insert(\"Q\", String::from(\"q\"));\n\
    \    mapping.insert(\"R\", String::from(\"r\"));\n    mapping.insert(\"S\", String::from(\"\
    s\"));\n    mapping.insert(\"T\", String::from(\"t\"));\n    mapping.insert(\"\
    U\", String::from(\"u\"));\n    mapping.insert(\"V\", String::from(\"v\"));\n\
    \    mapping.insert(\"W\", String::from(\"w\"));\n    mapping.insert(\"X\", String::from(\"\
    x\"));\n    mapping.insert(\"Y\", String::from(\"y\"));\n    mapping.insert(\"\
    Z\", String::from(\"z\"));\n    for char in message.chars() {\n        let original_char\
    \ = char;\n        if let Some(replacement) = mapping.get(char.as_str()) {\n \
    \           result.push_str(replacement);\n        } else {\n            result.push_str(original_char);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmphy_2kw8g.rs:14:23\n   |\n14 |     let mut mapping = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmphy_2kw8g.rs:12:16\n   |\n12 |     if message.length() == 0 { return\
    \ String::new(); }\n   |                ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `as_str` found for\
    \ type `char` in the current scope\n  --> /tmp/tmphy_2kw8g.rs:43:53\n   |\n43\
    \ |         if let Some(replacement) = mapping.get(char.as_str()) {\n   |    \
    \                                                 ^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmphy_2kw8g.rs:46:29\n   |\n46 |\
    \             result.push_str(original_char);\n   |                          \
    \   ^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let mut i = 0;\n    while\
    \ i < message.len() {\n        let c = message[i];\n        if c.is_uppercase()\
    \ {\n            for j in 0..3 {\n                match c + j {\n            \
    \        'A' as char => output.append(char::from('a'.to_char().unwrap())),\n \
    \                   'E' as char => output.append(char::from('e'.to_char().unwrap())),\n\
    \                    'I' as char => output.append(char::from('i'.to_char().unwrap())),\n\
    \                    'O' as char => output.append(char::from('o'.to_char().unwrap())),\n\
    \                    'U' as char => output.append(char::from('u'.to_char().unwrap())),\n\
    \                    'a' as char => output.append(char::from('a'.to_char().unwrap())),\n\
    \                    'e' as char => output.append(char::from('e'.to_char().unwrap())),\n\
    \                    'i' as char => output.append(char::from('i'.to_char().unwrap())),\n\
    \                    'o' as char => output.append(char::from('o'.to_char().unwrap())),\n\
    \                    'u' as char => output.append(char::from('u'.to_char().unwrap())),\n\
    \                    _ => output.append(c),\n                }\n            }\n\
    \        } else {\n            for j in 0..3 {\n                match c + j {\n\
    \                    'a' as char => output.append(char::from('a'.to_char().unwrap())),\n\
    \                    'e' as char => output.append(char::from('e'.to_char().unwrap())),\n\
    \                    'i' as char => output.append(char::from('i'.to_char().unwrap())),\n\
    \                    'o' as char => output.append(char::from('o'.to_char().unwrap())),\n\
    \                    'u' as char => output.append(char::from('u'.to_char().unwrap())),\n\
    \                    _ => output.append(c),\n                }\n            }\n\
    \        }\n        i += 1;\n    }\n    output\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword\
    \ `as`\n  --> /tmp/tmpwifdnrxt.rs:19:25\n   |\n19 |                     'A' as\
    \ char => output.append(char::from('a'.to_char().unwrap())),\n   |           \
    \              ^^ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror:\
    \ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`, found keyword `as`\n\
    \  --> /tmp/tmpwifdnrxt.rs:35:25\n   |\n35 |                     'a' as char =>\
    \ output.append(char::from('a'.to_char().unwrap())),\n   |                   \
    \      ^^ expected one of `...`, `..=`, `..`, `=>`, `if`, or `|`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwifdnrxt.rs:15:17\n\
    \   |\n15 |         let c = message[i];\n   |                 ^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 101
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| {\n        let c = c.to_ascii_lowercase();\n\
    \        match c {\n            'a' => c,\n            'e' => c,\n           \
    \ 'i' => c,\n            'o' => c,\n            'u' => c,\n            'y' =>\
    \ c,\n            _ => c,\n        }\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"test\"`,\n right: `\"tgst\"`', /tmp/tmpbyft9b2x.rs:28:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_to_encode = message;\n    let mut new_message\
    \ = String::new();\n    let mut index = 0;\n    let mut vowel_count = 0;\n\n \
    \   while index < message_to_encode.len() {\n        if message_to_encode[index]\
    \ >= 'a' && message_to_encode[index] <= 'z' {\n            new_message += message_to_encode[index];\n\
    \        }\n        if message_to_encode[index] >= 'A' && message_to_encode[index]\
    \ <= 'Z' {\n            new_message += message_to_encode[index];\n        }\n\n\
    \        match message_to_encode[index] {\n            'a' | 'e' | 'i' | 'o' |\
    \ 'u' => new_message += message_to_encode[index + 1].to_ascii_lowercase(),\n \
    \           'b' | 'f' | 'g' | 'h' | 'j' | 'k' | 'l' | 'm' | 'n' | 'p' | 'q' |\
    \ 'r' | 's' | 't' => {\n                new_message += message_to_encode[index\
    \ + 1].to_ascii_lowercase();\n            }\n            c => {\n            \
    \    if c >= 'A' && c <= 'Z' {\n                    new_message += message_to_encode[index\
    \ + 1].to_ascii_lowercase();\n                }\n                if c >= 'a' &&\
    \ c <= 'z' {\n                    new_message += message_to_encode[index + 1].to_ascii_lowercase();\n\
    \                }\n            }\n        }\n\n        if message_to_encode[index]\
    \ == 'a' || message_to_encode[index] == 'e' || message_to_encode[index] == 'i'\
    \ || message_to_encode[index] == 'o' || message_to_encode[index] == 'u' {\n  \
    \          vowel_count += 1;\n        }\n        if message_to_encode[index] ==\
    \ 'b' || message_to_encode[index] == 'f' || message_to_encode[index] == 'g' ||\
    \ message_to_encode[index] == 'h' || message_to_encode[index] == 'j' || message_to_encode[index]\
    \ == 'k' || message_to_encode[index] == 'l' || message_to_encode[index] == 'm'\
    \ || message_to_encode[index] == 'n' || message_to_encode[index] == 'p' || message_to_encode[index]\
    \ == 'q' || message_to_encode[index] == 'r' || message_to_encode[index] == 's'\
    \ || message_to_encode[index] == 't' {\n            vowel_count += 1;\n      \
    \  }\n        index += 1;\n    }\n\n    new_message.push_str(\"VOWELS\");\n  \
    \  new_message.pop_back();\n\n    new_message.push_str(vowel_count);\n    new_message.pop_back();\n\
    \n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmphdnuwtb6.rs:18:12\n\
    \   |\n18 |         if message_to_encode[index] >= 'a' && message_to_encode[index]\
    \ <= 'z' {\n   |            ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphdnuwtb6.rs:18:47\n   |\n18 |         if message_to_encode[index]\
    \ >= 'a' && message_to_encode[index] <= 'z' {\n   |                          \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmphdnuwtb6.rs:19:28\n   |\n19 |             new_message += message_to_encode[index];\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n   "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut res = String::new();\n    let mut current_vowel = 0;\n\
    \    for (i, c) in message.chars().enumerate() {\n        if c.is_lowercase()\
    \ {\n            match c {\n                'a' => res.append(\"t\"),\n      \
    \          'e' => res.append(\"k\"),\n                'i' => res.append(\"s\"\
    ),\n                'o' => res.append(\"s\"),\n                'u' => res.append(\"\
    h\"),\n                'y' => res.append(\"g\"),\n                _ => continue,\n\
    \            }\n        } else if c.is_uppercase() {\n            match c {\n\
    \                'A' => res.append(\"T\"),\n                'E' => res.append(\"\
    K\"),\n                'I' => res.append(\"S\"),\n                'O' => res.append(\"\
    S\"),\n                'U' => res.append(\"H\"),\n                'Y' => res.append(\"\
    G\"),\n                _ => continue,\n            }\n        } else {\n     \
    \       // Just append the current letter\n            res.append(&*c);\n    \
    \    }\n\n        // if the letter is a vowel and the current vowel letter is\
    \ \n        // not the same as the current letter\n        // then swap the vowels\n\
    \        if c.is_lowercase() && (i == current_vowel + 1 || (i > current_vowel\
    \ && i < current_vowel + 2)) {\n            match c {\n                'a' =>\
    \ res.append(\"t\"),\n                'e' => res.append(\"k\"),\n            \
    \    'i' => res.append(\"s\"),\n                'o' => res.append(\"s\"),\n  \
    \              'u' => res.append(\"h\"),\n                'y' => res.append(\"\
    g\"),\n                _ => continue,\n            }\n        }\n\n        //\
    \ increment the current vowel\n        if c.is_uppercase() {\n            current_vowel\
    \ += 2;\n        } else {\n            current_vowel += 1;\n        }\n    }\n\
    \    res\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmphkco9qdf.rs:17:28\n   |\n17 |                 'a'\
    \ => res.append(\"t\"),\n   |                            ^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmphkco9qdf.rs:18:28\n   |\n18 |          \
    \       'e' => res.append(\"k\"),\n   |                            ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:19:28\n   |\n19 | \
    \                'i' => res.append(\"s\"),\n   |                            ^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `append` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:20:28\n\
    \   |\n20 |                 'o' => res.append(\"s\"),\n   |                  \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:21:28\n\
    \   |\n21 |                 'u' => res.append(\"h\"),\n   |                  \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:22:28\n\
    \   |\n22 |                 'y' => res.append(\"g\"),\n   |                  \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:27:28\n\
    \   |\n27 |                 'A' => res.append(\"T\"),\n   |                  \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:28:28\n\
    \   |\n28 |                 'E' => res.append(\"K\"),\n   |                  \
    \          ^^^^^^ method not found in `String`\n\nerror[E0599]: no method named\
    \ `append` found for struct `String` in the current scope\n  --> /tmp/tmphkco9qdf.rs:29:28\n\
    \   |\n29 |                 'I' => r"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.chars().any(|c| c.is_uppercase()) {\n        return\
    \ String::from(message);\n    }\n    let mut char_map = {\n        'A' => 0, 'B'\
    \ => 1, 'C' => 2, 'D' => 3, 'E' => 4, 'F' => 5, 'G' => 6, 'H' => 7,\n        'I'\
    \ => 8, 'J' => 9, 'K' => 10, 'L' => 11, 'M' => 12, 'N' => 13, 'O' => 14,\n   \
    \     'P' => 15, 'Q' => 16, 'R' => 17, 'S' => 18, 'T' => 19, 'U' => 20, 'V' =>\
    \ 21,\n        'W' => 22, 'X' => 23, 'Y' => 24, 'Z' => 25, 'a' => 26, 'b' => 27,\
    \ 'c' => 28,\n        'd' => 29, 'e' => 30, 'f' => 31, 'g' => 32, 'h' => 33, 'i'\
    \ => 34, 'j' => 35,\n        'k' => 36, 'l' => 37, 'm' => 38, 'n' => 39, 'o' =>\
    \ 40, 'p' => 41, 'q' => 42,\n        'r' => 43, 's' => 44, 't' => 45, 'u' => 46,\
    \ 'v' => 47, 'w' => 48, 'x' => 49,\n        'y' => 50, 'z' => 51, 'A' => 52, 'B'\
    \ => 53, 'C' => 54, 'D' => 55, 'E' => 56,\n        'F' => 57, 'G' => 58, 'H' =>\
    \ 59, 'I' => 60, 'J' => 61, 'K' => 62, 'L' => 63,\n        'M' => 64, 'N' => 65,\
    \ 'O' => 66, 'P' => 67, 'Q' => 68, 'R' => 69, 'S' => 70,\n        'T' => 71, 'U'\
    \ => 72, 'V' => 73, 'W' => 74, 'X' => 75, 'Y' => 76, 'Z' => 77,\n        'a' =>\
    \ 78, 'b' => 79, 'c' => 80, 'd' => 81, 'e' => 82, 'f' => 83, 'g' => 84,\n    \
    \    'h' => 85, 'i' => 86, 'j' => 87, 'k' => 88, 'l' => 89, 'm' => 90, 'n' =>\
    \ 91,\n        'o' => 92, 'p' => 93, 'q' => 94, 'r' => 95, 's' => 96, 't' => 97,\
    \ 'u' => 98,\n        'v' => 99, 'w' => 100, 'x' => 101, 'y' => 102, 'z' => 103,\
    \ 'A' => 104,\n        'B' => 105, 'C' => 106, 'D' => 107, 'E' => 108, 'F' =>\
    \ 109, 'G' => 110,\n        'H' => 111, 'I' => 112, 'J' => 113, 'K' => 114, 'L'\
    \ => 115, 'M' => 116,\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphn_jtw9l.rs:42:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     let mut char_map = {\n \
    \  |                        - this delimiter might not be properly closed...\n\
    ...\n33 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    42 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmphn_jtw9l.rs:11:38\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                                      ^ unclosed delimiter\n\
    ...\n16 |         'A' => 0, 'B' => 1, 'C' => 2, 'D' => 3, 'E' => 4, 'F' => 5,\
    \ 'G' => 6, 'H' => 7,\n   |            -^^ expected one of `.`, `;`, `?`, `}`,\
    \ or an operator\n   |            |\n   |            help: `}` may belong here\n\
    \nerror: expected one of `.`, `;`, `?`, `else`, or an operator, found keyword\
    \ `fn`\n  --> /tmp/tmphn_jtw9l.rs:35:1\n   |\n33 | }\n   |  - expected one of\
    \ `.`, `;`, `?`, `else`, or an operator\n34 | \n35 | fn main() {\n   | ^^ unexpected\
    \ token\n\nerror: aborting due to 3 previous errors\n\n"
  stdout: ''
  timestamp: 1660009268
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let mut vowels = \"AEIOU\"\
    .to_lowercase();\n    for &i in &message.chars() {\n        if i == ' ' {\n  \
    \          output.push(i);\n        } else {\n            output.push(vowels.entry(i.to_ascii_lowercase().to_string()).or_insert(i));\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpowzqh_ki.rs:14:15\n\
    \   |\n14 |     for &i in &message.chars() {\n   |               -^^^^^^^^^^^^^^^\n\
    \   |               |\n   |               `&Chars<'_>` is not an iterator\n  \
    \ |               help: consider removing the leading `&`-reference\n   |\n  \
    \ = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n   = note:\
    \ `Iterator` is implemented for `&mut std::str::Chars<'_>`, but not for `&std::str::Chars<'_>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\n\nerror[E0599]: no method named `entry` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpowzqh_ki.rs:18:32\n   |\n18 |          \
    \   output.push(vowels.entry(i.to_ascii_lowercase().to_string()).or_insert(i));\n\
    \   |                                ^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_bytes = Vec::new();\n    for ch in message\
    \ {\n        let ord = ch.chars().fold(ord::MAX_VALUE, (|a, &b| {\n          \
    \  a | b.to_digit(10).unwrap()\n        }));\n        let letter_code = ord -\
    \ ord::Vowel;\n        let vowel_code = ord - ord::A + ord::A;\n        let new_letter_code\
    \ = letter_code + vowel_code;\n        let mut letter_code = new_letter_code %\
    \ ord::MaxCode;\n        let mut new_letter_code = new_letter_code / ord::MaxCode;\n\
    \        let mut vowel_code = new_letter_code % ord::MaxCode;\n        new_letter_code\
    \ /= ord::MaxCode;\n        let letter_code = match letter_code {\n          \
    \  0 => 0,\n            _ => letter_code,\n        };\n        vowel_code = match\
    \ vowel_code {\n            0 => 0,\n            _ => vowel_code,\n        };\n\
    \        let letter = (ord + ord::A + letter_code).to_string();\n        let vowel\
    \ = (ord + ord::A + vowel_code).to_string();\n        message_bytes.push((letter\
    \ + vowel).to_string());\n    }\n    String::from(message_bytes)\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `ord`\n\
    \  --> /tmp/tmpcjs9xvip.rs:14:35\n   |\n14 |         let ord = ch.chars().fold(ord::MAX_VALUE,\
    \ (|a, &b| {\n   |                                   ^^^ use of undeclared crate\
    \ or module `ord`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:17:33\n   |\n17 |         let letter_code\
    \ = ord - ord::Vowel;\n   |                                 ^^^ use of undeclared\
    \ crate or module `ord`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:18:32\n   |\n18 |         let\
    \ vowel_code = ord - ord::A + ord::A;\n   |                                ^^^\
    \ use of undeclared crate or module `ord`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:18:41\n \
    \  |\n18 |         let vowel_code = ord - ord::A + ord::A;\n   |             \
    \                            ^^^ use of undeclared crate or module `ord`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:20:49\n\
    \   |\n20 |         let mut letter_code = new_letter_code % ord::MaxCode;\n  \
    \ |                                                 ^^^ use of undeclared crate\
    \ or module `ord`\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:21:53\n   |\n21 |         let mut\
    \ new_letter_code = new_letter_code / ord::MaxCode;\n   |                    \
    \                                 ^^^ use of undeclared crate or module `ord`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `ord`\n \
    \ --> /tmp/tmpcjs9xvip.rs:22:48\n   |\n22 |         let mut vowel_code = new_letter_code\
    \ % ord::MaxCode;\n   |                                                ^^^ use\
    \ of undeclared crate or module `ord`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `ord`\n  --> /tmp/tmpcjs9xvip.rs:23:28\n   |\n\
    23 |         new_letter_code /= ord::MaxCode;\n   |                          \
    \  ^^^ use of undeclared crate or "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for c in message.chars()\
    \ {\n        let index = c.to_lowercase().chars().skip(2).collect::<Vec<_>>().index(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n        encoded.push_char(c.to_uppercase().chars().skip(index\
    \ + 1).collect::<Vec<_>>()[0]);\n    }\n    encoded\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for struct `ToLowercase` in\
    \ the current scope\n  --> /tmp/tmpcab3k3sa.rs:14:38\n   |\n14 | ...   let index\
    \ = c.to_lowercase().chars().skip(2).collect::<Vec<_>>().index(|c| c == 'a' ||\
    \ c == 'e' || c == 'i' || c == 'o' || c == 'u');\n   |                       \
    \             ^^^^^ method not found in `ToLowercase`\n\nerror[E0599]: no method\
    \ named `push_char` found for struct `String` in the current scope\n  --> /tmp/tmpcab3k3sa.rs:15:17\n\
    \   |\n15 |         encoded.push_char(c.to_uppercase().chars().skip(index + 1).collect::<Vec<_>>()[0]);\n\
    \   |                 ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push_str`\n\nerror[E0599]: no method named `chars` found for struct `ToUppercase`\
    \ in the current scope\n  --> /tmp/tmpcab3k3sa.rs:15:44\n   |\n15 |         encoded.push_char(c.to_uppercase().chars().skip(index\
    \ + 1).collect::<Vec<_>>()[0]);\n   |                                        \
    \    ^^^^^ method not found in `ToUppercase`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = message.clone();\n    let mut vowels = \"\
    AEIOU\".to_string();\n    for c in &mut result {\n        *c = if &*c.to_string()\
    \ == &vowels {\n            *c + *&c.to_string()[1];\n        } else {\n     \
    \       *c\n        };\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpp77fqhhn.rs:14:14\n\
    \   |\n14 |     for c in &mut result {\n   |              ^^^^^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `Iterator` for `&mut String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `&mut\
    \ String`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message;\n    new_message.chars().enumerate().for_each(|(i,\
    \ c)| {\n        let mut current = c;\n        let mut j = i;\n        loop {\n\
    \            match current {\n                'A'..='Z' => current = new_message[j].to_ascii_lowercase(),\n\
    \                'a' .. 'z' => current = new_message[j].to_ascii_lowercase(),\n\
    \                '0' .. '9' => current = new_message[j].to_ascii_lowercase(),\n\
    \                _ => break,\n            };\n            i += 1;\n          \
    \  j += 1;\n        }\n        new_message.swap(i, j);\n    });\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp3hqc_2et.rs:19:17\n\
    \   |\n19 |                 'a' .. 'z' => current = new_message[j].to_ascii_lowercase(),\n\
    \   |                 ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp3hqc_2et.rs:20:17\n   |\n20 |                 '0' .. '9' => current\
    \ = new_message[j].to_ascii_lowercase(),\n   |                 ^^^^^^^^^^\n  \
    \ |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmp3hqc_2et.rs:18:40\n   |\n18 |                 'A'..='Z'\
    \ => current = new_message[j].to_ascii_lowercase(),\n   |                    \
    \                    ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp3hqc_2et.rs:19:41\n   |\n19 |                 'a' .. 'z' => current\
    \ = new_message[j].to_ascii_lowercase(),\n   |                               \
    \          ^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_vec = Vec::with_capacity(message.chars().count());\n\
    \    message_vec.extend_from_slice(message.chars().skip_while(|c| c.is_ascii_lowercase()).take(26));\n\
    \    let mut current_letter = 0;\n    for (index, &letter) in message_vec.iter().enumerate()\
    \ {\n        let mut new_letter = 0;\n        let mut count = 0;\n        for\
    \ (index, &vowel) in LETTERS.iter().enumerate() {\n            if index == 0 {\n\
    \                new_letter += LETTERS.len() - index;\n                break;\n\
    \            }\n            let letter_index = index - 1;\n            if letter\
    \ != vowel {\n                continue;\n            }\n            let vowel_index\
    \ = letter_index + LETTERS.len() - index;\n            new_letter += count + 2;\n\
    \            count += 1;\n            if letter_index < letter_count {\n     \
    \           new_letter += LETTERS.len() - letter_index;\n            }\n     \
    \   }\n        message_vec.insert(index, new_letter);\n    }\n    let mut result\
    \ = String::with_capacity(message.len());\n    for (index, &letter) in message_vec.iter().enumerate()\
    \ {\n        if index == 0 {\n            result.push('a');\n        } else {\n\
    \            result.push((letter - current_letter + 1 + LETTERS.len()) % LETTERS.len());\n\
    \        }\n        current_letter = letter;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `LETTERS` in this scope\n  --> /tmp/tmpd405h61t.rs:18:32\n\
    \   |\n18 |         for (index, &vowel) in LETTERS.iter().enumerate() {\n   |\
    \                                ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `LETTERS` in this scope\n  --> /tmp/tmpd405h61t.rs:20:31\n\
    \   |\n20 |                 new_letter += LETTERS.len() - index;\n   |       \
    \                        ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `LETTERS` in this scope\n  --> /tmp/tmpd405h61t.rs:27:46\n   |\n\
    27 |             let vowel_index = letter_index + LETTERS.len() - index;\n   |\
    \                                              ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `letter_count` in this scope\n  --> /tmp/tmpd405h61t.rs:30:31\n\
    \   |\n30 |             if letter_index < letter_count {\n   |               \
    \                ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `LETTERS` in this scope\n  --> /tmp/tmpd405h61t.rs:31:31\n   |\n\
    31 |                 new_letter += LETTERS.len() - letter_index;\n   |       \
    \                        ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `LETTERS` in this scope\n  --> /tmp/tmpd405h61t.rs:41:56\n   |\n\
    41 |             result.push((letter - current_letter + 1 + LETTERS.len()) % LETTERS.len());\n\
    \   |                                                        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `LETTERS` in this scope\n \
    \ --> /tmp/tmpd405h61t.rs:41:73\n   |\n41 |             result.push((letter -\
    \ current_letter + 1 + LETTERS.len()) % LETTERS.len());\n   |                \
    \                                                         ^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd405h61t.rs:13:35\n\
    \   |\n13 |     message_vec.extend_from_slice(message.chars().skip_while(|c| c.is_ascii_lowercase()).take(26));\n\
    \   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&[_]`, found struct `std::iter::Take`\n   |\n  "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars()\n        .filter(|c| c.is_ascii_lowercase())\n\
    \        .map(|c| if c == c.to_ascii_lowercase().to_lower() { \"A\".to_string()\
    \ } else { \"a\".to_string() })\n        .map(|c| if c.is_ascii_lowercase() {\
    \ c.to_string() } else { \"a\".to_string() })\n        .chain(message.chars().filter(|c|\
    \ c.is_ascii_lowercase()).map(|c| if c.is_ascii_uppercase() { c.to_string() }\
    \ else { \"a\".to_string() }))\n        .chain(message.chars().filter(|c| c.is_ascii_uppercase()).map(|c|\
    \ if c.is_ascii_lowercase() { c.to_string() } else { \"a\".to_string() }))\n \
    \       .chain(message.chars().filter(|c| c.is_ascii_uppercase()).map(|c| if c.is_ascii_uppercase()\
    \ { c.to_string() } else { \"a\".to_string() }))\n        .map(|c| if c.is_ascii_lowercase()\
    \ { \"a\".to_string() } else { \"a\".to_string() })\n        .chain(message.chars().filter(|c|\
    \ c.is_ascii_uppercase()).map(|c| if c.is_ascii_lowercase() { \"a\".to_string()\
    \ } else { \"a\".to_string() }))\n        .chain(message.chars().filter(|c| c.is_ascii_lowercase()).map(|c|\
    \ if c.is_ascii_uppercase() { \"a\".to_string() } else { \"a\".to_string() }))\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_lower` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpswqewc0r.rs:14:49\n   |\n14 |         .map(|c| if c ==\
    \ c.to_ascii_lowercase().to_lower() { \"A\".to_string() } else { \"a\".to_string()\
    \ })\n   |                                                 ^^^^^^^^ help: there\
    \ is an associated function with a similar name: `to_lowercase`\n\nerror[E0599]:\
    \ no method named `is_ascii_lowercase` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpswqewc0r.rs:15:23\n   |\n15 |         .map(|c| if c.is_ascii_lowercase()\
    \ { c.to_string() } else { \"a\".to_string() })\n   |                       ^^^^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `to_ascii_lowercase`\n\
    \nerror[E0599]: no method named `is_ascii_lowercase` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpswqewc0r.rs:19:23\n   |\n19 |         .map(|c|\
    \ if c.is_ascii_lowercase() { \"a\".to_string() } else { \"a\".to_string() })\n\
    \   |                       ^^^^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `to_ascii_lowercase`\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut vowels_indices = String::new();\n    vowels_indices.push_str(\"\
    aeiouAEIOU\");\n    vowels_indices.sort_by_key(|i| message.chars()[message.chars().len()\
    \ - 1 - i]);\n    let mut message_indices = String::new();\n    message_indices.push_str(\"\
    bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\");\n    message_indices.sort_by_key(|i|\
    \ message.chars().len() - 1 - i);\n    let mut resulting_string = String::new();\n\
    \    message.chars()\n        .zip(message_indices.chars().take(message.chars().len()))\n\
    \        .for_each(|(s, i)| {\n            let idx = vowels_indices.get(&s[s.len()\
    \ - 1]).unwrap();\n            resulting_string.push_str(&message_indices.get(&idx).unwrap());\n\
    \        });\n    resulting_string\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by_key` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpoxt5smeb.rs:14:20\n   |\n14 |     vowels_indices.sort_by_key(|i|\
    \ message.chars()[message.chars().len() - 1 - i]);\n   |                    ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `len` found for\
    \ struct `Chars` in the current scope\n  --> /tmp/tmpoxt5smeb.rs:14:68\n   |\n\
    14 |     vowels_indices.sort_by_key(|i| message.chars()[message.chars().len()\
    \ - 1 - i]);\n   |                                                           \
    \         ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `sort_by_key` found for struct `String` in the current scope\n  --> /tmp/tmpoxt5smeb.rs:17:21\n\
    \   |\n17 |     message_indices.sort_by_key(|i| message.chars().len() - 1 - i);\n\
    \   |                     ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpoxt5smeb.rs:17:53\n\
    \   |\n17 |     message_indices.sort_by_key(|i| message.chars().len() - 1 - i);\n\
    \   |                                                     ^^^ method not found\
    \ in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for struct `Chars`\
    \ in the current scope\n  --> /tmp/tmpoxt5smeb.rs:20:59\n   |\n20 |         .zip(message_indices.chars().take(message.chars().len()))\n\
    \   |                                                           ^^^ method not\
    \ found in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpoxt5smeb.rs:22:47\n   |\n22 |          \
    \   let idx = vowels_indices.get(&s[s.len() - 1]).unwrap();\n   |            \
    \                                   ^^^ method not found in `char`\n\nerror[E0277]:\
    \ the type `str` cannot be indexed by `&&_`\n   --> /tmp/tmpoxt5smeb.rs:23:60\n\
    \    |\n23  |             resulting_string.push_str(&message_indices.get(&idx).unwrap());\n\
    \    |                                                        --- ^^^^ string\
    \ indices are ranges of `usize`\n    |                                       \
    \    "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode(message.chars().cloned(), message.chars().cloned())\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpo_tuofgp.rs:12:28\n     |\n12   |     encode(message.chars().cloned(),\
    \ message.chars().cloned())\n     |                            ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpo_tuofgp.rs:12:54\n     |\n12   |     encode(message.chars().cloned(),\
    \ message.chars().cloned())\n     |                                          \
    \            ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n  --> /tmp/tmpo_tuofgp.rs:12:5\n   |\n12 |     encode(message.chars().cloned(),\
    \ message.chars().cloned())\n   |     ^^^^^^ ------------------------  ------------------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpo_tuofgp.rs:11:4\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ^^^^^^ ---------------\n\nerror: aborting due to\
    \ 3 previous errors\n\nSome errors have detailed explanations: E0061, E0271.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n\n    // Replace all vowels\
    \ with letter that appears 2 places ahead of that vowel\n    for letter in message.chars().rev()\
    \ {\n        if letter.is_uppercase() {\n            encoded_message.replace(\n\
    \                letter,\n                match encoded_message.chars().skip(message.chars().position(letter).unwrap())\
    \ {\n                    Some('a'..'z') => letter + 'j'.to_string(),\n       \
    \             Some('e'..'i') => letter + 'l'.to_string(),\n                  \
    \  Some('o'..'u') => letter + 't'.to_string(),\n                    Some('u'..'A')\
    \ => letter + 'o'.to_string(),\n                    Some('A'..'Z') => letter +\
    \ 'y'.to_string(),\n                    _ => unimplemented!(),\n             \
    \   }\n            );\n        } else {\n            encoded_message.replace(\n\
    \                letter,\n                match encoded_message.chars().skip(message.chars().position(letter).unwrap())\
    \ {\n                    Some('a'..'Z') => letter + 'a'.to_string(),\n       \
    \             Some('e'..'i') => letter + 'e'.to_string(),\n                  \
    \  Some('o'..'u') => letter + 'o'.to_string(),\n                    Some('u'..'A')\
    \ => letter + 'u'.to_string(),\n                    Some('A'..'Z') => letter +\
    \ 'a'.to_string(),\n                    _ => unimplemented!(),\n             \
    \   }\n            );\n        }\n    }\n\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp5vvheefr.rs:20:26\n\
    \   |\n20 |                     Some('a'..'z') => letter + 'j'.to_string(),\n\
    \   |                          ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:21:26\n   |\n21 |                     Some('e'..'i')\
    \ => letter + 'l'.to_string(),\n   |                          ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:22:26\n   |\n22 |                     Some('o'..'u')\
    \ => letter + 't'.to_string(),\n   |                          ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:23:26\n   |\n23 |                     Some('u'..'A')\
    \ => letter + 'o'.to_string(),\n   |                          ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:24:26\n   |\n24 |                     Some('A'..'Z')\
    \ => letter + 'y'.to_string(),\n   |                          ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:32:26\n   |\n32 |                     Some('a'..'Z')\
    \ => letter + 'a'.to_string(),\n   |                          ^^^^^^^^\n   |\n\
    \   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp5vvheefr.rs:33:26\n   |\n33 |                     Some('e'..'i')\
    \ => letter + 'e'.to_string(),\n   |                 "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = String::from(\"?\");\n    for i in message.chars()\
    \ {\n        let mut cur = i;\n        if cur.to_ascii_lowercase() == i {\n  \
    \          let mut a = String::from('?');\n            for i in cur.chars().skip_while(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n         \
    \       a.push(*i);\n            }\n            let mut b = String::from('?');\n\
    \            for i in a.chars().skip_while(|c| *c != 'a' && *c != 'e' && *c !=\
    \ 'i' && *c != 'o' && *c != 'u') {\n                b.push(*i);\n            }\n\
    \            s = &b.swapcase() + &cur;\n        } else {\n            s = &s +\
    \ &cur;\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpj3815lok.rs:17:26\n   |\n17 |             for i in cur.chars().skip_while(|c|\
    \ *c != 'a' && *c != 'e' && *c != 'i' && *c != 'o' && *c != 'u') {\n   |     \
    \                     ^^^^^ method not found in `char`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpj3815lok.rs:22:24\n   |\n22 |        \
    \         b.push(*i);\n   |                        ^^\n\nerror[E0599]: no method\
    \ named `swapcase` found for struct `String` in the current scope\n  --> /tmp/tmpj3815lok.rs:24:20\n\
    \   |\n24 |             s = &b.swapcase() + &cur;\n   |                    ^^^^^^^^\
    \ method not found in `String`\n\nerror[E0369]: cannot add `&char` to `&String`\n\
    \  --> /tmp/tmpj3815lok.rs:26:20\n   |\n26 |             s = &s + &cur;\n   |\
    \                 -- ^ ---- &char\n   |                 |\n   |              \
    \   &String\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0369, E0599, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    fn replace_all(&mut self, s: String, replacement: &str) {\n\
    \        let mut new_s = s;\n        for i in 0..new_s.len() {\n            let\
    \ mut new_i = i;\n            while new_i >= new_s.len() {\n                new_s\
    \ += replacement;\n                new_i += 1;\n            }\n            self.swap_indices(new_i,\
    \ new_s);\n        }\n    }\n\n    fn swap_case(&mut self, c: char) {\n      \
    \  if ('A' <= c && c <= 'Z') {\n            self.swap_indices(0, 1);\n       \
    \ }\n        else if ('a' <= c && c <= 'z') {\n            self.swap_indices(1,\
    \ 2);\n        }\n    }\n\n    fn replace_vowels(&mut self, c: char) {\n     \
    \   if ('a' <= c && c <= 'z') {\n            self.swap_indices(1, 2);\n      \
    \  }\n        if ('A' <= c && c <= 'Z') {\n            self.swap_indices(0, 1);\n\
    \        }\n    }\n\n    let mut new_message = message;\n    let mut i = 0;\n\
    \    while i < new_message.len() {\n        let mut j = i;\n        while j <\
    \ new_message.len() {\n            if new_message[j] == ' ' {\n              \
    \  break;\n            }\n            match new_message[j] {\n               \
    \ 'a' => swap_case(new_message[j - 2]),\n                'A' => swap_case(new_message[j\
    \ - 2]),\n                'e' => swap_case(new_message[j - 2]),\n            \
    \    'E' => swap_case(new_message[j - 2]),\n                'i' => swap_case(new_message[j\
    \ - 2]),\n                'I' => swap_case(new_message[j - 2]),\n            \
    \    'o' => swap_case(new_message[j - 2]),\n                'O' => swap_case(new_message[j\
    \ - 2]),\n                'u' => swap_case(new_message[j - 2]),\n            \
    \    'U' => swap_case(new_message[j - 2]),\n                'A' => replace_vowels(new_message[j\
    \ - 2]),\n                'e' => replace_vowels(new_message[j - 2]),\n       \
    \         'I' => replace_vowels(new_message[j - 2]),\n                'o' => replace_vowels(new_message[j\
    \ - 2]),\n                'u' => replace_vowels(new_message[j - 2]),\n       \
    \         _ => (),\n            }\n            j += 1\n        }\n        if i\
    \ < new_message.len() {\n            new_message[i] = new_message[j];\n      \
    \      new_message[j] = '\\0';\n        }\n        i += j - 1;\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: `self` parameter is only allowed in associated functions\n  -->\
    \ /tmp/tmpe7wqnimj.rs:12:20\n   |\n12 |     fn replace_all(&mut self, s: String,\
    \ replacement: &str) {\n   |                    ^^^^^^^^^ not semantically valid\
    \ as function parameter\n   |\n   = note: associated functions are those in `impl`\
    \ or `trait` definitions\n\nerror: `self` parameter is only allowed in associated\
    \ functions\n  --> /tmp/tmpe7wqnimj.rs:24:18\n   |\n24 |     fn swap_case(&mut\
    \ self, c: char) {\n   |                  ^^^^^^^^^ not semantically valid as\
    \ function parameter\n   |\n   = note: associated functions are those in `impl`\
    \ or `trait` definitions\n\nerror: `self` parameter is only allowed in associated\
    \ functions\n  --> /tmp/tmpe7wqnimj.rs:33:23\n   |\n33 |     fn replace_vowels(&mut\
    \ self, c: char) {\n   |                       ^^^^^^^^^ not semantically valid\
    \ as function parameter\n   |\n   = note: associated functions are those in `impl`\
    \ or `trait` definitions\n\nwarning: unnecessary parentheses around `if` condition\n\
    \  --> /tmp/tmpe7wqnimj.rs:25:12\n   |\n25 |         if ('A' <= c && c <= 'Z')\
    \ {\n   |            ^                    ^\n   |\n   = note: `#[warn(unused_parens)]`\
    \ on by default\nhelp: remove these parentheses\n   |\n25 -         if ('A' <=\
    \ c && c <= 'Z') {\n25 +         if 'A' <= c && c <= 'Z' {\n   | \n\nwarning:\
    \ unnecessary parentheses around `if` condition\n  --> /tmp/tmpe7wqnimj.rs:28:17\n\
    \   |\n28 |         else if ('a' <= c && c <= 'z') {\n   |                 ^ \
    \                   ^\n   |\nhelp: remove these parentheses\n   |\n28 -      \
    \   else if ('a' <= c && c <= 'z') {\n28 +         else if 'a' <= c && c <= 'z'\
    \ {\n   | \n\nwarning: unnecessary parentheses around `if` condition\n  --> /tmp/tmpe7wqnimj.rs:34:12\n\
    \   |\n34 |         if ('a' <= c && c <= 'z') {\n   |            ^           \
    \         ^\n   |\nhelp: remove these parentheses\n   |\n34 -         if ('a'\
    \ <= c && c <= 'z') {\n34 +         if 'a' <= c && c <= 'z' {\n   | \n\nwarning:\
    \ unnecessary parentheses around `if` condition\n  --> /tmp/tmpe7wqnimj.rs:37:12\n\
    \   |\n37 |         if ('A' <= c && c <= 'Z') {\n "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut newMessage = String::from(\"\");\n    for char in message.chars()\
    \ {\n        let prevLetter = char.map(|c| c.to_ascii_lowercase()).unwrap();\n\
    \        let prevLetterPos = prevLetter.find_first_not_ascii_lowercase();\n  \
    \      if prevLetterPos == 0 {\n            newMessage.push(char);\n        }\
    \ else {\n            let newLetter = &message[prevLetterPos + 2];\n         \
    \   newMessage.push(if newLetter < 'a' || newLetter > 'z' { c } else { newLetter.to_ascii_lowercase()\
    \ });\n        }\n    }\n    newMessage\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmp7dhqldqr.rs:20:69\n\
    \   |\n20 |             newMessage.push(if newLetter < 'a' || newLetter > 'z'\
    \ { c } else { newLetter.to_ascii_lowercase() });\n   |                      \
    \                                               ^ not found in this scope\n\n\
    error[E0599]: `char` is not an iterator\n  --> /tmp/tmp7dhqldqr.rs:14:31\n   |\n\
    14 |         let prevLetter = char.map(|c| c.to_ascii_lowercase()).unwrap();\n\
    \   |                               ^^^ `char` is not an iterator\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `char: Iterator`\n\
    \           which is required by `&mut char: Iterator`\n\nerror[E0277]: can't\
    \ compare `&_` with `char`\n  --> /tmp/tmp7dhqldqr.rs:20:42\n   |\n20 |      \
    \       newMessage.push(if newLetter < 'a' || newLetter > 'z' { c } else { newLetter.to_ascii_lowercase()\
    \ });\n   |                                          ^ no implementation for `&_\
    \ < char` and `&_ > char`\n   |\n   = help: the trait `PartialOrd<char>` is not\
    \ implemented for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  -->\
    \ /tmp/tmp7dhqldqr.rs:20:61\n   |\n20 |             newMessage.push(if newLetter\
    \ < 'a' || newLetter > 'z' { c } else { newLetter.to_ascii_lowercase() });\n \
    \  |                                                             ^ no implementation\
    \ for `&_ < char` and `&_ > char`\n   |\n   = help: the trait `PartialOrd<char>`\
    \ is not implemented for `&_`\n\nerror: aborting due to 4 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    for character in\
    \ &message {\n        let ascii_code = character.ascii_uppercase().unwrap();\n\
    \        let index = ascii_code - 'A' as usize;\n        result.push_str(&(ascii_code\
    \ + 'A').to_string());\n        result.push_str(&(ascii_code + 'A' * (index +\
    \ 2)).to_string());\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpppvwhpmt.rs:13:22\n\
    \   |\n13 |     for character in &message {\n   |                      ^^^^^^^^\
    \ `&String` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0369]: cannot multiply `char` by `_`\n\
    \  --> /tmp/tmpppvwhpmt.rs:17:44\n   |\n17 |         result.push_str(&(ascii_code\
    \ + 'A' * (index + 2)).to_string());\n   |                                   \
    \     --- ^ ----------- _\n   |                                        |\n   |\
    \                                        char\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().enumerate().filter_map(|(idx, ch)| {\n    \
    \    match ch {\n            'a' => (\"a\".to_string(), idx + 2),\n          \
    \  'e' => (\"e\".to_string(), idx + 2),\n            'i' => (\"i\".to_string(),\
    \ idx + 2),\n            'o' => (\"o\".to_string(), idx + 2),\n            'u'\
    \ => (\"u\".to_string(), idx + 2),\n            'A' => (\"A\".to_string(), idx\
    \ + 2),\n            'E' => (\"E\".to_string(), idx + 2),\n            'I' =>\
    \ (\"I\".to_string(), idx + 2),\n            'O' => (\"O\".to_string(), idx +\
    \ 2),\n            'U' => (\"U\".to_string(), idx + 2),\n            _ => (),\n\
    \        }\n    }).fold(\"\", |mut acc, (idx, _)| {\n        acc + encode(&message[idx\
    \ + 2])\n    })\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw442gl5i.rs:14:20\n   |\n\
    14 |             'a' => (\"a\".to_string(), idx + 2),\n   |                  \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found tuple\n   |\n   =\
    \ note: expected enum `Option<_>`\n             found tuple `(String, usize)`\n\
    help: try wrapping the expression in `Some`\n   |\n14 |             'a' => Some((\"\
    a\".to_string(), idx + 2)),\n   |                    +++++                   \
    \       +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw442gl5i.rs:26:13\n\
    \   |\n26 |     }).fold(\"\", |mut acc, (idx, _)| {\n   |             ^^- help:\
    \ try using a conversion method: `.to_string()`\n   |             |\n   |    \
    \         expected struct `String`, found `&str`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpw442gl5i.rs:27:22\n   |\n27 |         acc + encode(&message[idx\
    \ + 2])\n   |                      ^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found reference\n   |\n   = note: expected struct `String`\n           found\
    \ reference `&_`\nhelp: consider removing the borrow\n   |\n27 -         acc +\
    \ encode(&message[idx + 2])\n27 +         acc + encode(message[idx + 2])\n   |\
    \ \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw442gl5i.rs:27:15\n   |\n\
    27 |         acc + encode(&message[idx + 2])\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |               |\n   |               expected `&str`, found struct `String`\n\
    \   |               help: consider borrowing here: `&encode(&message[idx + 2])`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = String::new();\n    buffer.resize(message.len(),\
    \ 0);\n    \n    for (index, letter) in message.chars().enumerate() {\n      \
    \  if index > 0 {\n            buffer.push((&message[index % message.len()])[index\
    \ % message.len() ].to_lowercase());\n        }\n        buffer.push((&letter)[index\
    \ + 1 % message.len()].to_lowercase());\n    }\n    \n    return buffer\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `resize` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpshp5brvm.rs:13:12\n   |\n13 |     buffer.resize(message.len(),\
    \ 0);\n   |            ^^^^^^ method not found in `String`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpshp5brvm.rs:17:27\n\
    \   |\n17 |             buffer.push((&message[index % message.len()])[index %\
    \ message.len() ].to_lowercase());\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0608]: cannot index into a value of type `&char`\n  -->\
    \ /tmp/tmpshp5brvm.rs:19:21\n   |\n19 |         buffer.push((&letter)[index +\
    \ 1 % message.len()].to_lowercase());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0608.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encodedMessage = message.to_string();\n    for i in\
    \ 0..message.len() {\n        let mut newChar: char;\n        if i < (message.len()\
    \ - 3) {\n            let c1 = message[(i + 1) + 1];\n            let c2 = message[(i\
    \ + 1) + 2];\n            if c1 == c2 && c1 != ' ' && c2 != ' ' && c1 != ' ' &&\
    \ c2 != ' ' {\n                newChar = char::from(c1);\n                encodedMessage.replace(i,\
    \ i + 3, newChar);\n                i += 1;\n            }\n        }\n    }\n\
    \    return encodedMessage;\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpu_a2z4y6.rs:16:22\n\
    \   |\n16 |             let c1 = message[(i + 1) + 1];\n   |                 \
    \     ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpu_a2z4y6.rs:17:22\n   |\n17 |             let c2 = message[(i +\
    \ 1) + 2];\n   |                      ^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0061]: this function takes 2 arguments but 3 arguments were\
    \ supplied\n   --> /tmp/tmpu_a2z4y6.rs:20:32\n    |\n20  |                 encodedMessage.replace(i,\
    \ i + 3, newChar);\n    |                                ^^^^^^^ -  -----  -------\
    \ supplied 3 arguments\n    |                                |\n    |        \
    \                        expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0277.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for letter in message\
    \ {\n        match letter::Unicode::to_ascii(letter) {\n            Ok(x) => {\n\
    \                let mut to_swap = x;\n                to_swap = to_swap.chars().fold(0,\
    \ |x, y| {\n                    match y {\n                        a..z => x.to_ascii_lowercase()\n\
    \                        A..Z => x.to_ascii_uppercase()\n                    \
    \    _ => 0,\n                    }\n                });\n                to_swap\
    \ = match to_swap {\n                    x if x == 0 => a,\n                 \
    \   _ => x + 1,\n                };\n                if to_swap == a {\n     \
    \               encoded.push(a);\n                } else {\n                 \
    \   encoded.push(to_swap);\n                }\n            }\n            Err(_)\
    \ => encoded.push(letter),\n        }\n    }\n    return encoded;\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `,`, `.`, `?`, `}`, or an operator, found `A`\n\
    \  --> /tmp/tmpffkef6yn.rs:20:25\n   |\n19 |                         a..z => x.to_ascii_lowercase()\n\
    \   |                              --                       - expected one of\
    \ `,`, `.`, `?`, `}`, or an operator\n   |                              |\n  \
    \ |                              while parsing the `match` arm starting here\n\
    20 |                         A..Z => x.to_ascii_uppercase()\n   |            \
    \             ^ unexpected token\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ crate or module `letter`\n  --> /tmp/tmpffkef6yn.rs:14:15\n   |\n14 |      \
    \   match letter::Unicode::to_ascii(letter) {\n   |               ^^^^^^ use of\
    \ undeclared crate or module `letter`\n\nerror[E0425]: cannot find value `a` in\
    \ this scope\n  --> /tmp/tmpffkef6yn.rs:25:36\n   |\n25 |                    \
    \ x if x == 0 => a,\n   |                                    ^ help: a local variable\
    \ with a similar name exists: `x`\n\nerror[E0425]: cannot find value `a` in this\
    \ scope\n  --> /tmp/tmpffkef6yn.rs:28:31\n   |\n28 |                 if to_swap\
    \ == a {\n   |                               ^ help: a local variable with a similar\
    \ name exists: `x`\n\nerror[E0425]: cannot find value `a` in this scope\n  -->\
    \ /tmp/tmpffkef6yn.rs:29:34\n   |\n29 |                     encoded.push(a);\n\
    \   |                                  ^ help: a local variable with a similar\
    \ name exists: `x`\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpffkef6yn.rs:13:19\n\
    \   |\n13 |     for letter in message {\n   |                   ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0277, E0425,\
    \ E0433.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter(|c| c.is_letter()).map(|c| c.to_ascii_lowercase()).collect::<String>().iter().cloned().map(|c|\
    \ {\n        c + 'A' - 'a'\n    }).collect::<String>().iter().cloned().map(|c|\
    \ {\n        c + 'AEIOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n\
    \        c + 'AIEOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n \
    \       c + 'AOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n    \
    \    c + 'AEIOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n     \
    \   c + 'AIEOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n      \
    \  c + 'AOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n        c\
    \ + 'AEIOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n        c +\
    \ 'AIEOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n        c + 'AOU'\n\
    \    }).collect::<String>().iter().cloned().map(|c| {\n        c + 'AEIOU'\n \
    \   }).collect::<String>().iter().cloned().map(|c| {\n        c + 'AIEOU'\n  \
    \  }).collect::<String>().iter().cloned().map(|c| {\n        c + 'AOU'\n    }).collect::<String>().iter().cloned().map(|c|\
    \ {\n        c + 'AEIOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n\
    \        c + 'AIEOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n \
    \       c + 'AOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n    \
    \    c + 'AEIOU'\n    }).collect::<String>().iter().cloned().map(|c| {\n     \
    \   c + 'AIEOU'\n    }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:15:13\n\
    \   |\n15 |         c + 'AEIOU'\n   |             ^^^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n15 |         c + \"\
    AEIOU\"\n   |             ~~~~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:17:13\n   |\n17 |         c + 'AIEOU'\n\
    \   |             ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ use double quotes\n   |\n17 |         c + \"AIEOU\"\n   |             ~~~~~~~\n\
    \nerror: character literal may only contain one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:19:13\n\
    \   |\n19 |         c + 'AOU'\n   |             ^^^^^\n   |\nhelp: if you meant\
    \ to write a `str` literal, use double quotes\n   |\n19 |         c + \"AOU\"\n\
    \   |             ~~~~~\n\nerror: character literal may only contain one codepoint\n\
    \  --> /tmp/tmp6nk1g9sz.rs:21:13\n   |\n21 |         c + 'AEIOU'\n   |       \
    \      ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal, use double\
    \ quotes\n   |\n21 |         c + \"AEIOU\"\n   |             ~~~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:23:13\n\
    \   |\n23 |         c + 'AIEOU'\n   |             ^^^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n23 |         c + \"\
    AIEOU\"\n   |             ~~~~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:25:13\n   |\n25 |         c + 'AOU'\n\
    \   |             ^^^^^\n   |\nhelp: if you meant to write a `str` literal, use\
    \ double quotes\n   |\n25 |         c + \"AOU\"\n   |             ~~~~~\n\nerror:\
    \ character literal may only contain one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:27:13\n\
    \   |\n27 |         c + 'AEIOU'\n   |             ^^^^^^^\n   |\nhelp: if you\
    \ meant to write a `str` literal, use double quotes\n   |\n27 |         c + \"\
    AEIOU\"\n   |             ~~~~~~~\n\nerror: character literal may only contain\
    \ one codepoint\n  --> /tmp/tmp6nk1g9sz.rs:29:13\n   |\n29 |         c + 'AIEOU'\n\
    \   |             ^^^^^^^\n   |\nhelp: if you meant to write a `str` literal,\
    \ us"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // Sort by case first\n    message.sort_by(|a, b| a.cmp(b));\n\
    \    \n    let mut new_message = message;\n    for (i, c) in new_message.chars().enumerate()\
    \ {\n        if i > 0 { \n            let mut prev_c = new_message[i-1];\n   \
    \         let mut prev_index = i - 1;\n            \n            // Replace vowel\
    \ when index == prev_index\n            if i == prev_index {\n               \
    \ new_message[i] = c;\n                continue;\n            }\n            \n\
    \            // Sort by case next\n            let mut prev_c2 = new_message[prev_index];\n\
    \            let mut prev_index2 = prev_index - 1;\n            \n           \
    \ // Replace vowel when index2 == prev_index2\n            if i == prev_index2\
    \ {\n                new_message[i] = c;\n                continue;\n        \
    \    }\n            \n            // Swap if case doesn't match\n            if\
    \ prev_c != c {\n                new_message[i] = c.swapcase();\n            \
    \    continue;\n            }\n            \n            // Replace vowel if it\
    \ is 2 places ahead\n            if i == prev_index + 2 {\n                new_message[i]\
    \ = c.swapcase();\n                continue;\n            }\n            \n  \
    \          // Replace vowel if it is 3 places ahead\n            if i == prev_index\
    \ + 3 {\n                new_message[i] = c.swapcase();\n                continue;\n\
    \            }\n        }\n    }\n    \n    new_message.chars().collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `sort_by` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpyrgm4z5k.rs:13:13\n   |\n13 |     message.sort_by(|a,\
    \ b| a.cmp(b));\n   |             ^^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyrgm4z5k.rs:18:30\n\
    \   |\n18 |             let mut prev_c = new_message[i-1];\n   |             \
    \                 ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpyrgm4z5k.rs:23:17\n\
    \   |\n23 |                 new_message[i] = c;\n   |                 ^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpyrgm4z5k.rs:28:31\n   |\n28 |             let mut prev_c2 = new_message[prev_index];\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_bytes = message\n        .as_bytes()\n    \
    \    .iter()\n        .map(|&c| c.to_ascii_lowercase().unwrap())\n        .collect::<Vec<_>>();\n\
    \n    let mut vowels = vec!['e', 'i', 'o', 'u'];\n\n    for &vowel in &vowels\
    \ {\n        message_bytes.sort_by_key(|&b| {\n            b.chars().nth(vowel).unwrap()\n\
    \        });\n    }\n\n    let mut new_message: Vec<_> = message_bytes\n     \
    \   .iter()\n        .enumerate()\n        .map(|(i, b)| {\n            if i %\
    \ 2 == 0 {\n                b.chars().nth(vowels.iter().next().unwrap()).unwrap()\n\
    \            } else {\n                b\n            }\n        })\n        .collect();\n\
    \n    new_message.reverse();\n    new_message.insert(0, new_message[0]);\n\n \
    \   new_message.iter().map(|&b| b.to_string()).collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `u8` in the current\
    \ scope\n  --> /tmp/tmpq51l59a8.rs:15:42\n   |\n15 |         .map(|&c| c.to_ascii_lowercase().unwrap())\n\
    \   |                                          ^^^^^^ method not found in `u8`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: Refactor this to use the same code as encode in \n\
    \    // the message module\n    let mut buffer = Vec::new();\n    \n    let mut\
    \ ascii_table = ascii_table();\n    let mut ascii_vowels = \"AaEeIiOoUu\";\n \
    \   let mut ascii_lowercase = \"aAeEiIoOuU\";\n    let mut ascii_uppercase = \"\
    AaEeIiOoUu\";\n    \n    let mut pos = 0;\n    for c in message.chars() {\n  \
    \      if ascii_table.contains_key(c.to_ascii_lowercase()) {\n            buffer.push(ascii_lowercase[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_uppercase())\
    \ {\n            buffer.push(ascii_uppercase[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_uppercase())\
    \ {\n            buffer.push(ascii_uppercase[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_lowercase())\
    \ {\n            buffer.push(ascii_lowercase[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        }\n        \n        \n        if ascii_table.contains_key(c.to_ascii_lowercase())\
    \ {\n            buffer.push(ascii_lowercase[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_uppercase())\
    \ {\n            buffer.push(ascii_uppercase[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_uppercase())\
    \ {\n            buffer.push(ascii_uppercase[ascii_table.entry(c.to_ascii_uppercase()).or_insert(0)]);\n\
    \        } else {\n            buffer.push(ascii_vowels[ascii_table.entry(c.to_ascii_lowercase()).or_insert(0)]);\n\
    \        }\n        \n        if ascii_table.contains_key(c.to_ascii_lowercase\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpossvzqr5.rs:76:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n22 |     for c in message.chars()\
    \ {\n   |                              - this delimiter might not be properly\
    \ closed...\n...\n67 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n76 | }\n   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpossvzqr5.rs:67:1\n\
    \   |\n66 |         if ascii_table.contains_key(c.to_ascii_lowercase\n   |   \
    \      -- this `if` expression has a condition, but no block\n67 | }\n   | ^ expected\
    \ `{`\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpossvzqr5.rs:66:36\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n66 |     \
    \    if ascii_table.contains_key(c.to_ascii_lowercase\n   |                  \
    \                  ^ unclosed delimiter\n67 | }\n   | ^ mismatched closing delimiter\n\
    \nerror[E0425]: cannot find function `ascii_table` in this scope\n  --> /tmp/tmpossvzqr5.rs:16:27\n\
    \   |\n16 |     let mut ascii_table = ascii_table();\n   |                   \
    \        ^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpossvzqr5.rs:11:31\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ------                     ^^^^^^ expected struct `String`, found\
    \ `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail or\
    \ `return` expression\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut input = message;\n    let mut output = String::with_capacity(input.len());\n\
    \    for (i, c) in input.chars().enumerate() {\n        match c {\n          \
    \  'a' => {\n                let c = &input[i - 1];\n                let d = &input[i\
    \ - 2];\n                let mut t = d;\n                if t == 'a' || t == 'e'\
    \ || t == 'i' || t == 'o' || t == 'u' {\n                    t = c;\n        \
    \        }\n                output.push(t);\n            }\n            'e' =>\
    \ {\n                let c = &input[i - 1];\n                let d = &input[i\
    \ + 1];\n                let mut t = c;\n                if t == 'a' || t == 'e'\
    \ || t == 'i' || t == 'o' || t == 'u' {\n                    t = d;\n        \
    \        }\n                output.push(t);\n            }\n            'i' =>\
    \ {\n                let c = &input[i - 1];\n                let d = &input[i\
    \ + 2];\n                let mut t = c;\n                if t == 'a' || t == 'e'\
    \ || t == 'i' || t == 'o' || t == 'u' {\n                    t = d;\n        \
    \        }\n                output.push(t);\n            }\n            'o' =>\
    \ {\n                let c = &input[i - 1];\n                let d = &input[i\
    \ + 2];\n                let mut t = c;\n                if t == 'a' || t == 'e'\
    \ || t == 'i' || t == 'o' || t == 'u' {\n                    t = d;\n        \
    \        }\n                output.push(t);\n            }\n            'u' =>\
    \ {\n                let c = &input[i - 1];\n                let d = &input[i\
    \ + 2];\n                let mut t = c;\n                if t == 'a' || t == 'e'\
    \ || t == 'i' || t == 'o' || t == 'u' {\n                    t = d;\n        \
    \        }\n                output.push(t);\n            }\n            _ => output.push(c),\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpkxm6ce74.rs:17:26\n\
    \   |\n17 |                 let c = &input[i - 1];\n   |                     \
    \     ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkxm6ce74.rs:18:26\n   |\n18 |                 let d = &input[i\
    \ - 2];\n   |                          ^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpkxm6ce74.rs:20:22\n\
    \   |\n20 |                 if t == 'a' || t == 'e' || t == 'i' || t == 'o' ||\
    \ t == 'u' {\n   |                      ^^ no implementation for `&_ == char`\n\
    \   |\n   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\n\
    error[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpkxm6ce74.rs:20:34\n\
    \   |\n20 |                 if t == 'a' || t == 'e' || t == 'i' || t == 'o' ||\
    \ t == 'u' {\n   |                                  ^^ no implementation for `&_\
    \ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for\
    \ `&_`\n\nerror[E0277]: can't compare `&_` wit"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = String::new();\n    for letter in message.chars()\
    \ {\n        let mut buffer = String::new();\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(2).collect());\n        buffer.push(letter);\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(2).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push_str(&encode(&letter));\n        buffer.push(fn(letter).chars().take(1).collect());\n\
    \        buffer.push(fn(letter).chars().take(1).collect());\n        buffer.push_str(&encode(&letter));\n\
    \        buffer.push(fn(letter\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpripqgkkg.rs:62:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     let mut buffer = String::new();\n\
    13 |     for letter in message.chars() {\n   |                               \
    \    - this delimiter might not be properly closed...\n...\n53 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n62 | }\n   |   ^\n\n\
    error: expected expression, found keyword `fn`\n  --> /tmp/tmpripqgkkg.rs:16:21\n\
    \   |\n16 |         buffer.push(fn(letter).chars().take(2).collect());\n   | \
    \                    ^^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmpripqgkkg.rs:52:23\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                                      - closing delimiter possibly\
    \ meant for this\n...\n52 |         buffer.push(fn(letter\n   |              \
    \         ^ unclosed delimiter\n53 | }\n   | ^ mismatched closing delimiter\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpripqgkkg.rs:15:33\n   |\n15 |  \
    \       buffer.push_str(&encode(&letter));\n   |                             \
    \    ^^^^^^^ expected struct `String`, found `&char`\n   |\nhelp: try using a\
    \ conversion method\n   |\n15 |         buffer.push_str(&encode((&letter).to_string()));\n\
    \   |                                 +       +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpripqgkkg.rs:11:31\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ------                     ^^^^^^ expected struct `String`,\
    \ found `()`\n   |    |\n   |    implicitly returns `()` as its body has no tail\
    \ or `return` expression\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::with_capacity(message.len());\n  \
    \  for &c in message.chars() {\n        let mut new_index = 0;\n        // If\
    \ c is a vowel, get the index\n        if c == 'a' || c == 'e' || c == 'i' ||\
    \ c == 'o' || c == 'u' {\n            new_index = c - 'a' + 1;\n        } else\
    \ {\n            // Otherwise, get the index that it appears 2 places ahead of\
    \ c\n            new_index = c - 'a';\n        }\n        // Swap the case of\
    \ the letter\n        result.push_str(&(c.to_ascii_uppercase()[new_index].to_string()));\n\
    \        result.push_str(&(c.to_ascii_lowercase()[new_index].to_string()));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxnfd9zdd.rs:13:9\n   |\n\
    13 |     for &c in message.chars() {\n   |         ^^    --------------- this\
    \ expression has type `Option<char>`\n   |         |\n   |         expected `char`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `c`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut buffer = String::new();\n\
    \n    for (i, c) in message.chars().enumerate() {\n        if c.is_uppercase()\
    \ {\n            buffer.push_str(&mut result.chars().nth(i + 2));\n        } else\
    \ {\n            buffer.push_str(&mut result.chars().nth(i + 2));\n          \
    \  buffer.push_str(&mut result.chars().nth(i + 3));\n        }\n    }\n    buffer.push_str(&mut\
    \ result.chars().nth(message.len()));\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplb2ybp69.rs:17:29\n   |\n\
    17 |             buffer.push_str(&mut result.chars().nth(i + 2));\n   |      \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found enum\
    \ `Option`\n   |\n   = note:      expected reference `&str`\n           found\
    \ mutable reference `&mut Option<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmplb2ybp69.rs:19:29\n   |\n19 |             buffer.push_str(&mut result.chars().nth(i\
    \ + 2));\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found enum `Option`\n   |\n   = note:      expected reference `&str`\n\
    \           found mutable reference `&mut Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplb2ybp69.rs:20:29\n   |\n20 |             buffer.push_str(&mut\
    \ result.chars().nth(i + 3));\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found enum `Option`\n   |\n   = note:      expected reference\
    \ `&str`\n           found mutable reference `&mut Option<char>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplb2ybp69.rs:23:21\n   |\n23 |     buffer.push_str(&mut\
    \ result.chars().nth(message.len()));\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found enum `Option`\n   |\n   = note:      expected reference\
    \ `&str`\n           found mutable reference `&mut Option<char>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n    let mut ascii_alphabet_map =\
    \ HashMap::new();\n    for &s in ascii_alphabet_map.keys() {\n        ascii_alphabet_map.insert(s,\
    \ s + 2);\n    }\n    \n    let mut encoded_message = message.chars().map(|c|{\n\
    \        if ascii_alphabet_map.contains_key(&c) {\n            ascii_alphabet_map.get(&c).unwrap()\n\
    \        } else {\n            c\n        }\n    }).collect::<Vec<_>>();\n\n \
    \   for c in &encoded_message {\n        if c.is_vowel() {\n            encoded_message.replace(\n\
    \                ascii_alphabet_map.contains_key(&c).unwrap(),\n             \
    \   ascii_alphabet_map.get(&c).unwrap(),\n                ascii_alphabet_map.contains_key(&c\
    \ + 2).unwrap(),\n            );\n        }\n    }\n    encoded_message.to_string()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpmmz7_l9s.rs:13:34\n   |\n13 |     let mut ascii_alphabet_map = HashMap::new();\n\
    \   |                                  ^^^^^^^ not found in this scope\n   |\n\
    help: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nwarning: unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmpmmz7_l9s.rs:12:9\n\
    \   |\n12 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: use of deprecated\
    \ trait `std::ascii::AsciiExt`: use inherent methods instead\n  --> /tmp/tmpmmz7_l9s.rs:12:21\n\
    \   |\n12 |     use std::ascii::AsciiExt;\n   |                     ^^^^^^^^\n\
    \   |\n   = note: `#[warn(deprecated)]` on by default\n\nerror: aborting due to\
    \ previous error; 2 warnings emitted\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut i = 0;\n    \n\
    \    for ch in message.chars() {\n        if let Some(i) = chtoi(ch.as_bytes())\
    \ {\n            let mut new_i = i;\n            for _ in 0..i-1 {\n         \
    \       let old_i = new_i;\n                new_i = chtoi(chtoa(ch).as_bytes());\n\
    \                if old_i != new_i {\n                    break;\n           \
    \     }\n            }\n            i += 1;\n            result.push_str(chtoa(ch));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `chtoi` in this scope\n  --> /tmp/tmpnkgxwj6w.rs:16:26\n\
    \   |\n16 |         if let Some(i) = chtoi(ch.as_bytes()) {\n   |            \
    \              ^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `chtoi` in this scope\n  --> /tmp/tmpnkgxwj6w.rs:20:25\n   |\n20 |         \
    \        new_i = chtoi(chtoa(ch).as_bytes());\n   |                         ^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `chtoa` in this\
    \ scope\n  --> /tmp/tmpnkgxwj6w.rs:20:31\n   |\n20 |                 new_i = chtoi(chtoa(ch).as_bytes());\n\
    \   |                               ^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `chtoa` in this scope\n  --> /tmp/tmpnkgxwj6w.rs:26:29\n\
    \   |\n26 |             result.push_str(chtoa(ch));\n   |                    \
    \         ^^^^^ not found in this scope\n\nerror[E0599]: no method named `as_bytes`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpnkgxwj6w.rs:16:35\n\
    \   |\n16 |         if let Some(i) = chtoi(ch.as_bytes()) {\n   |            \
    \                       ^^^^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: String = \"\";\n    let mut letters = [message];\
    \ // make a copy\n    \n    loop {\n        let mut nextLetter = String::from(\"\
    A\");\n        \n        while letters.len() > 1 {\n            letters.remove(0);\n\
    \            letters.remove(0);\n            \n            let vowel_index = letters.iter().position(|&c|\
    \ c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\");\n     \
    \       if vowel_index < 0 { break; }\n            \n            nextLetter =\
    \ letters[vowel_index + 2];\n        }\n        \n        let vowel_index = letters.iter().position(|&c|\
    \ c == \"a\" || c == \"e\" || c == \"i\" || c == \"o\" || c == \"u\");\n     \
    \   if vowel_index >= 0 { break; }\n        \n        // If all letters are in\
    \ upper case, replace with next letter\n        let mut new_letter = String::from(\"\
    A\");\n        for c in letters {\n            if c.is_upper() { new_letter +=\
    \ c.to_ascii_lowercase(); }\n            else { new_letter += c; }\n        }\n\
    \        encoded += new_letter;\n    }\n    \n    encoded.to_string()\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpet9jfldd.rs:12:31\n   |\n\
    12 |     let mut encoded: String = \"\";\n   |                      ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \    |        |\n   |                      |        expected struct `String`,\
    \ found `&str`\n   |                      expected due to this\n\nerror[E0599]:\
    \ no method named `remove` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmpet9jfldd.rs:19:21\n   |\n19 |             letters.remove(0);\n\
    \   |                     ^^^^^^ method not found in `[String; 1]`\n\nerror[E0599]:\
    \ no method named `remove` found for array `[String; 1]` in the current scope\n\
    \  --> /tmp/tmpet9jfldd.rs:20:21\n   |\n20 |             letters.remove(0);\n\
    \   |                     ^^^^^^ method not found in `[String; 1]`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpet9jfldd.rs:23:30\n   |\n23 |             if\
    \ vowel_index < 0 { break; }\n   |                              ^ expected enum\
    \ `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n  \
    \            found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n23 |             if vowel_index < Some(0) { break; }\n   |            \
    \                  +++++ +\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpet9jfldd.rs:25:46\n   |\n25 |             nextLetter = letters[vowel_index\
    \ + 2];\n   |                                  ----------- ^ - {integer}\n   |\
    \                                  |\n   |                                  Option<usize>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpet9jfldd.rs:29:27\n   |\n29 |\
    \         if vowel_index >= 0 { break; }\n   |                           ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<usize>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n29 |         if vowel_index >= Some(0) { break; }\n   |               \
    \            +++++ +\n\nerror[E0599]: no method named `is_upper` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpe"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for i in &message {\n\
    \        if let Some(letter) = char::to_ascii_lowercase(i) {\n            result.push(letter);\n\
    \            result.push(letter);\n        }\n        if let Some(letter) = char::to_ascii_uppercase(i)\
    \ {\n            result.push(letter);\n            result.push(letter);\n    \
    \    }\n        if let Some(letter) = char::to_ascii_lowercase(i) {\n        \
    \    result.push(letter);\n            result.push(letter);\n        }\n     \
    \   if let Some(letter) = char::to_ascii_uppercase(i) {\n            result.push(letter);\n\
    \            result.push(letter);\n        }\n        if let Some(letter) = char::to_ascii_lowercase(i)\
    \ {\n            result.push(letter);\n            result.push(letter);\n    \
    \    }\n        if let Some(letter) = char::to_ascii_uppercase(i) {\n        \
    \    result.push(letter);\n            result.push(letter);\n        }\n     \
    \   if let Some(letter) = char::to_ascii_lowercase(i) {\n            result.push(letter);\n\
    \            result.push(letter);\n        }\n        if let Some(letter) = char::to_ascii_uppercase(i)\
    \ {\n            result.push(letter);\n            result.push(letter);\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpc5tszjex.rs:13:14\n\
    \   |\n13 |     for i in &message {\n   |              ^^^^^^^^ `&String` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5tszjex.rs:14:16\n\
    \   |\n14 |         if let Some(letter) = char::to_ascii_lowercase(i) {\n   |\
    \                ^^^^^^^^^^^^   --------------------------- this expression has\
    \ type `char`\n   |                |\n   |                expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5tszjex.rs:18:16\n\
    \   |\n18 |         if let Some(letter) = char::to_ascii_uppercase(i) {\n   |\
    \                ^^^^^^^^^^^^   --------------------------- this expression has\
    \ type `char`\n   |                |\n   |                expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5tszjex.rs:22:16\n\
    \   |\n22 |         if let Some(letter) = char::to_ascii_lowercase(i) {\n   |\
    \                ^^^^^^^^^^^^   --------------------------- this expression has\
    \ type `char`\n   |                |\n   |                expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5tszjex.rs:26:16\n\
    \   |\n26 |         if let Some(letter) = char::to_ascii_uppercase(i) {\n   |\
    \                ^^^^^^^^^^^^   --------------------------- this expression has\
    \ type `char`\n   |                |\n   |                expected `char`, found\
    \ enum `Option`\n   |\n   = note: expected type `char`\n              found enum\
    \ `Option<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc5tszjex.rs:30:16\n\
    \   |\n30 |         if let Some(letter) = char::to_ascii_lowercase(i) {\n   |\
    \                ^^^^^^^^^^^^   ------------------------"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: String = String::from(\"\");\n    let mut vowels\
    \ = String::from(\"aeiou\");\n    \n    // Step 1: encode all letters by swaping\
    \ case\n    for letter in message.chars() {\n        let mut index = vowels.find(letter).unwrap();\n\
    \        if index != 0 {\n            result.push((vowels[(index - 1) % vowels.len()].to_uppercase()\
    \ + \n                           vowels[(index + 1) % vowels.len()].to_uppercase()).to_string());\n\
    \        } else {\n            result.push(letter.to_uppercase());\n        }\n\
    \    }\n    \n    // Step 2: encode all vowels by replacing them with \n    //\
    \ the letter that appears 2 places ahead of that vowel\n    for vowel in vowels.chars()\
    \ {\n        let mut index = (message.chars().find(|c|c == vowel).unwrap()) +\
    \ 2;\n        result.push((vowels[(index - 1) % vowels.len()].to_uppercase() +\
    \ \n                      vowels[(index + 1) % vowels.len()].to_uppercase()).to_string());\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp2wxl82ye.rs:19:26\n\
    \   |\n19 |             result.push((vowels[(index - 1) % vowels.len()].to_uppercase()\
    \ + \n   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp2wxl82ye.rs:20:28\n   |\n20 | ...                   vowels[(index\
    \ + 1) % vowels.len()].to_uppercase()).to_string());\n   |                   \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp2wxl82ye.rs:22:25\n\
    \   |\n22 |             result.push(letter.to_uppercase());\n   |            \
    \             ^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `ToUppercase`\n\
    \nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp2wxl82ye.rs:29:52\n\
    \   |\n29 |         let mut index = (message.chars().find(|c|c == vowel).unwrap())\
    \ + 2;\n   |                                                    ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut vowels = HashMap::new();\n    vowels.insert(b\"a\"\
    , b\"A\");\n    vowels.insert(b\"e\", b\"E\");\n    vowels.insert(b\"i\", b\"\
    I\");\n    vowels.insert(b\"o\", b\"O\");\n    vowels.insert(b\"u\", b\"U\");\n\
    \    let mut current_vowel = String::new();\n    current_vowel.push_str(b\"a\"\
    );\n    \n    let mut new_message = String::new();\n    for ch in message.chars()\
    \ {\n        if vowels.contains_key(&ch) {\n            new_message.push_str(vowels.get(&ch).unwrap());\n\
    \            current_vowel.push_str(vowels.get(&ch).unwrap());\n        } else\
    \ {\n            new_message.push_str(current_vowel);\n            new_message.push_str(ch);\n\
    \            current_vowel.push_str(ch);\n        }\n    }\n    new_message\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpq68rgoe0.rs:12:22\n   |\n12 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpq68rgoe0.rs:19:28\n   |\n19 |     current_vowel.push_str(b\"\
    a\");\n   |                            ^^^^ expected `str`, found array `[u8;\
    \ 1]`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&'static [u8; 1]`\nhelp: consider removing the leading `b`\n   |\n19 -    \
    \ current_vowel.push_str(b\"a\");\n19 +     current_vowel.push_str(\"a\");\n \
    \  | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq68rgoe0.rs:27:34\n   |\n\
    27 |             new_message.push_str(current_vowel);\n   |                  \
    \                ^^^^^^^^^^^^^\n   |                                  |\n   |\
    \                                  expected `&str`, found struct `String`\n  \
    \ |                                  help: consider borrowing here: `&current_vowel`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpq68rgoe0.rs:28:34\n   |\n28 |\
    \             new_message.push_str(ch);\n   |                                \
    \  ^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq68rgoe0.rs:29:36\n\
    \   |\n29 |             current_vowel.push_str(ch);\n   |                    \
    \                ^^ expected `&str`, found `char`\n\nerror: aborting due to 5\
    \ previous errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut to_encode = message;\n    let mut encoded = String::new();\n\
    \    let mut index = 0;\n\n    for c in to_encode {\n        match c {\n     \
    \       'A'..'Z' => if index >= encoded.len() {\n                encoded.push_str(&to_encode[index..index\
    \ + 2]);\n                index += 2;\n            } else {\n                encoded.push_str(&to_encode[index..index\
    \ + 1]);\n                index += 1;\n            },\n            'a'..'z' =>\
    \ if index >= encoded.len() {\n                encoded.push_str(&to_encode[index..index\
    \ + 2]);\n                index += 2;\n            } else {\n                encoded.push_str(&to_encode[index..index\
    \ + 1]);\n                index += 1;\n            },\n            _ => unreachable!(),\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp7rc7ve6p.rs:18:13\n\
    \   |\n18 |             'A'..'Z' => if index >= encoded.len() {\n   |        \
    \     ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp7rc7ve6p.rs:25:13\n   |\n25 |             'a'..'z' => if index\
    \ >= encoded.len() {\n   |             ^^^^^^^^\n   |\n   = note: see issue #37854\
    \ <https://github.com/rust-lang/rust/issues/37854> for more information\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp7rc7ve6p.rs:16:14\n   |\n16 |   \
    \  for c in to_encode {\n   |              ^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0658.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n\n    let alphabet = vec!['A'..'Z',\
    \ 'a'..'z'];\n    let vowels = vec!['A'..'Z'];\n    let vowel_indices: Vec<_>\
    \ = vowels\n        .iter()\n        .cloned()\n        .enumerate()\n       \
    \ .map(|(vowel_index, _)| vowel_index)\n        .collect();\n\n    for letter\
    \ in message.chars() {\n        if let Some(index) = vowel_indices.binary_search(&letter)\
    \ {\n            let vowel_index = index as usize;\n            result.push_str(&alphabet[vowel_index\
    \ + 2]);\n        }\n        result.push_str(&alphabet[letter.to_ascii_lowercase()\
    \ as usize]);\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpker5ky3v.rs:24:58\n   |\n\
    24 |         if let Some(index) = vowel_indices.binary_search(&letter) {\n   |\
    \                                                          ^^^^^^^ expected `usize`,\
    \ found `char`\n   |\n   = note: expected reference `&usize`\n              found\
    \ reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpker5ky3v.rs:24:16\n\
    \   |\n24 |         if let Some(index) = vowel_indices.binary_search(&letter)\
    \ {\n   |                ^^^^^^^^^^^   ------------------------------------ this\
    \ expression has type `Result<usize, usize>`\n   |                |\n   |    \
    \            expected enum `Result`, found enum `Option`\n   |\n   = note: expected\
    \ enum `Result<usize, usize>`\n              found enum `Option<_>`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpker5ky3v.rs:26:29\n   |\n26 |             result.push_str(&alphabet[vowel_index\
    \ + 2]);\n   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `str`, found struct `std::ops::Range`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpker5ky3v.rs:28:25\n   |\n28 |         result.push_str(&alphabet[letter.to_ascii_lowercase()\
    \ as usize]);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `std::ops::Range`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&std::ops::Range<char>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().enumerate().filter(|&(i, ch)| {\n        match\
    \ ch{\n            'A'...'Z' => true,\n            _ => false\n        }\n   \
    \ }).map(|(i, ch)| {\n        match ch{\n            'A'...'Z' => ch.to_ascii_lowercase().to_ascii_uppercase(),\n\
    \            'a' ... 'z' => ch.to_ascii_lowercase().to_string(),\n           \
    \ 'A' ... 'Z' => ch.to_string().to_ascii_lowercase().to_ascii_uppercase(),\n \
    \           _ => ch\n        }\n    }).fold(String::from(\"ZZZZZZZZ\"), |mut acc,\
    \ x| {\n        acc.chars().enumerate().filter(|&(i, ch)| {\n            match\
    \ ch{\n                'A'...'Z' => true,\n                'a' ... 'z' => true,\n\
    \                'A' ... 'Z' => true,\n                _ => false\n          \
    \  }\n        }).map(|(i, ch)| {\n            match ch{\n                'A'...'Z'\
    \ => x.to_string().to_ascii_lowercase().to_ascii_uppercase(),\n              \
    \  'a' ... 'z' => x.to_string().to_ascii_lowercase().to_string(),\n          \
    \      'A' ... 'Z' => x.to_string().to_string().to_ascii_lowercase().to_ascii_uppercase(),\n\
    \                _ => ch\n            }\n        }).fold(acc, |mut acc, x| {\n\
    \            acc.push(x.to_string());\n            acc\n        })\n    })\n}\n\
    \nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmpiii42l4t.rs:14:16\n\
    \   |\n14 |             'A'...'Z' => true,\n   |                ^^^ help: use\
    \ `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpiii42l4t.rs:19:16\n\
    \   |\n19 |             'A'...'Z' => ch.to_ascii_lowercase().to_ascii_uppercase(),\n\
    \   |                ^^^ help: use `..=` for an inclusive range\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpiii42l4t.rs:20:17\n\
    \   |\n20 |             'a' ... 'z' => ch.to_ascii_lowercase().to_string(),\n\
    \   |                 ^^^ help: use `..=` for an inclusive range\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpiii42l4t.rs:21:17\n\
    \   |\n21 |             'A' ... 'Z' => ch.to_string().to_ascii_lowercase().to_ascii_uppercase(),\n\
    \   |                 ^^^ help: use `..=` for an inclusive range\n   |\n   = warning:\
    \ this is accepted in the current edition (Rust 2015) but is a hard error in Rust\
    \ 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmpiii42l4t.rs:27:20\n\
    \   |\n27 |                 'A'...'Z' => true,\n   |                    ^^^ help:\
    \ use `..=` for an inclusive ra"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().cloned()\n        .map(|c|\n            if\
    \ c >= 'a' && c <= 'z'\n                || (c >= 'A' && c <= 'Z')\n          \
    \  {\n                c + (c - 'a') + 2\n            } else if c == '_' {\n  \
    \              'A'\n            } else if c == '\\N' {\n                '_'\n\
    \            } else {\n                c\n            }\n        ).collect()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: unknown character escape: `N`\n  --> /tmp/tmpui_ve5y5.rs:20:30\n\
    \   |\n20 |             } else if c == '\\N' {\n   |                         \
    \     ^ unknown character escape\n   |\n   = help: for more information, visit\
    \ <https://static.rust-lang.org/doc/master/reference.html#literals>\nhelp: if\
    \ you meant to write a literal backslash (perhaps escaping in a regular expression),\
    \ consider a raw string literal\n   |\n20 |             } else if c == r\"\\N\"\
    \ {\n   |                            ~~~~~\n\nerror[E0271]: type mismatch resolving\
    \ `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpui_ve5y5.rs:12:21\n \
    \    |\n12   |     message.chars().cloned()\n     |                     ^^^^^^\
    \ expected reference, found `char`\n     |\n     = note: expected reference `&_`\n\
    \                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `map` exists for struct `Cloned<Chars<'_>>`, but its\
    \ trait bounds were not satisfied\n  --> /tmp/tmpui_ve5y5.rs:13:10\n   |\n13 |\
    \           .map(|c|\n   |            ^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror[E0277]: cannot add `_` to `char`\n  --> /tmp/tmpui_ve5y5.rs:17:19\n  \
    \ |\n17 |                 c + (c - 'a') + 2\n   |                   ^ no implementation\
    \ for `char + _`\n   |\n   = help: the trait `Add<_>` is not implemented for `char`\n\
    \nerror[E0277]: cannot subtract `char` from `char`\n  --> /tmp/tmpui_ve5y5.rs:17:24\n\
    \   |\n17 |                 c + (c - 'a') + 2\n   |                        ^ no\
    \ implementation for `char - char`\n   |\n   = help: the trait `Sub` is not implemented\
    \ for `char`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0277, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: Vec<String> = Vec::new();\n    \n    for letter\
    \ in message.chars() {\n        if letter.is_uppercase() {\n            encoded.push(String::from(&(letter\
    \ + LETTERS[letter])));\n        } else {\n            encoded.push(String::from(&(letter\
    \ + LETTERS[letter.to_lowercase()])));\n        }\n    }\n\n    let mut counter:\
    \ usize = 0;\n\n    for (index, letter) in encoded.iter().enumerate() {\n    \
    \    if index > 0 && counter % 2 == 0 {\n            encoded.swap(index, index\
    \ - 1);\n        }\n\n        counter += 1;\n    }\n\n    String::from(encoded)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `LETTERS` in this scope\n  --> /tmp/tmpvw5svm7y.rs:16:50\n\
    \   |\n16 |             encoded.push(String::from(&(letter + LETTERS[letter])));\n\
    \   |                                                  ^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `LETTERS` in this scope\n  --> /tmp/tmpvw5svm7y.rs:18:50\n\
    \   |\n18 |             encoded.push(String::from(&(letter + LETTERS[letter.to_lowercase()])));\n\
    \   |                                                  ^^^^^^^ not found in this\
    \ scope\n\nerror[E0277]: the trait bound `String: From<Vec<String>>` is not satisfied\n\
    \  --> /tmp/tmpvw5svm7y.rs:32:18\n   |\n32 |     String::from(encoded)\n   | \
    \    ------------ ^^^^^^^ the trait `From<Vec<String>>` is not implemented for\
    \ `String`\n   |     |\n   |     required by a bound introduced by this call\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message;\n    message.chars()\n        .filter_map(|c|\
    \ {\n            match c {\n                'a' => Some(c.to_ascii_lowercase()),\n\
    \                'e' => Some(c.to_ascii_lowercase()),\n                'i' =>\
    \ Some(c.to_ascii_lowercase()),\n                'o' => Some(c.to_ascii_lowercase()),\n\
    \                'u' => Some(c.to_ascii_lowercase()),\n                'A' =>\
    \ Some(c.to_ascii_lowercase()),\n                'E' => Some(c.to_ascii_lowercase()),\n\
    \                'I' => Some(c.to_ascii_lowercase()),\n                'O' =>\
    \ Some(c.to_ascii_lowercase()),\n                'U' => Some(c.to_ascii_lowercase()),\n\
    \                '0' => Some(c.to_ascii_lowercase()),\n                '1' =>\
    \ Some(c.to_ascii_lowercase()),\n                '2' => Some(c.to_ascii_lowercase()),\n\
    \                '3' => Some(c.to_ascii_lowercase()),\n                '4' =>\
    \ Some(c.to_ascii_lowercase()),\n                '5' => Some(c.to_ascii_lowercase()),\n\
    \                '6' => Some(c.to_ascii_lowercase()),\n                '7' =>\
    \ Some(c.to_ascii_lowercase()),\n                '8' => Some(c.to_ascii_lowercase()),\n\
    \                '9' => Some(c.to_ascii_lowercase()),\n                '.' =>\
    \ Some(c.to_ascii_lowercase()),\n                '-' => Some(c.to_ascii_lowercase()),\n\
    \                '_' => Some(c.to_ascii_lowercase()),\n                '!' =>\
    \ Some(c.to_ascii_lowercase()),\n                '/' => Some(c.to_ascii_lowercase()),\n\
    \                '$' => Some(c.to_ascii_lowercase()),\n                '?' =>\
    \ Some(c.to_ascii_lowercase()),\n                c => None,\n            }\n \
    \       })\n        .for_each(|mut c| {\n            let mut idx = 0;\n      \
    \      while idx < message.len() {\n                let c = message.chars().nth(idx).unwrap();\n\
    \                c.swap();\n                idx += 2;\n            }\n       \
    \ });\n    message\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp5kcmpbtd.rs:50:19\n   |\n50 |                 c.swap();\n\
    \   |                   ^^^^ method not found in `char`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.length() == 0 {\n        return String::from(\"\"\
    );\n    }\n    let mut encoded_message = String::from(\"\");\n    let mut vowel_index\
    \ = 0;\n    \n    // Start with the first letter of the message\n    let first_letter\
    \ = message[0];\n    // Get the index of this letter if it has a vowel before\
    \ it (0-indexed)\n    if let Some(vowel) = first_letter.find_first_of(\"aeiou\"\
    ) {\n        vowel_index = vowel;\n    }\n    // Start with an empty message\n\
    \    let mut encoded_letters = String::from(\"\");\n    \n    for letter in message.chars()\
    \ {\n        // Get the index of this letter\n        let index = letter.find_first_of(\"\
    aeiou\");\n        // If it's not a vowel add it to the encoded message\n    \
    \    if index == Some(vowel_index) {\n            // Swap the letters\n      \
    \      encoded_message += String::from(\n                letter.to_string().swapcase().to_string()\n\
    \            );\n        }\n        // Otherwise use the index\n        else {\n\
    \            encoded_letters += String::from(\n                &message[index\
    \ + 1..index + 2].to_string()\n                    .chars()\n                \
    \    .collect::<Vec<char>>()\n                    .collect::<String>() + &message[index\
    \ + 1..].to_string()\n            );\n        }\n    }\n    encoded_message +=\
    \ encoded_letters;\n    encoded_message\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpu9sdw2ra.rs:12:16\n   |\n12 |     if message.length()\
    \ == 0 {\n   |                ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `{integer}`\n  --> /tmp/tmpu9sdw2ra.rs:19:24\n   |\n19 |     let first_letter\
    \ = message[0];\n   |                        ^^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `find_first_of` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpu9sdw2ra.rs:29:28\n   |\n29 |         let\
    \ index = letter.find_first_of(\"aeiou\");\n   |                            ^^^^^^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `swapcase` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpu9sdw2ra.rs:34:36\n\
    \   |\n34 |                 letter.to_string().swapcase().to_string()\n   |  \
    \                                  ^^^^^^^^ method not found in `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpu9sdw2ra.rs:33:32\n   |\n33 |              \
    \ encoded_message += String::from(\n   |  ________________________________^\n\
    34 | |                 letter.to_string().swapcase().to_string()\n35 | |     \
    \        );\n   | |_____________^ expected `&str`, found struct `String`\n   |\n\
    help: consider borrowing here\n   |\n33 ~             encoded_message += &String::from(\n\
    34 +                 letter.to_string().swapcase().to_string()\n35 ~         \
    \    );\n   |\n\nerror[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmpu9sdw2ra.rs:43:22\n\
    \    |\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_inv = String::new();\n    let mut char_iter\
    \ = message.chars().cycle();\n    let mut char_to_replace = String::new();\n \
    \   let mut char_to_replace_inv = String::new();\n    let mut current_pos = 0;\n\
    \    let mut num_vowels = 0;\n    \n    while let Some(c)=char_iter.next() {\n\
    \        if c.to_lowercase() == c {\n            if current_pos + 1 >= message.len()\
    \ {\n                break;\n            }\n            \n            char_to_replace\
    \ = message[current_pos + 1];\n            char_to_replace_inv = message[current_pos];\n\
    \            \n            if c.to_lowercase() != char_to_replace {\n        \
    \        num_vowels += 1;\n            }\n            \n            char_iter.next();\n\
    \        } else {\n            num_vowels += 1;\n        }\n        \n       \
    \ current_pos += 1;\n    }\n    \n    message_inv += char_to_replace_inv + 'A';\n\
    \    message_inv += char_to_replace + 'a';\n    \n    message_inv += '*' * (message.len()\
    \ - num_vowels);\n    \n    return message_inv;\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: binary operation `==` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpkc7yutns.rs:20:29\n   |\n20 |         if c.to_lowercase() == c\
    \ {\n   |            ---------------- ^^ - char\n   |            |\n   |     \
    \       ToLowercase\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkc7yutns.rs:25:31\n   |\n25 |             char_to_replace = message[current_pos\
    \ + 1];\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpkc7yutns.rs:26:35\n   |\n26 |             char_to_replace_inv =\
    \ message[current_pos];\n   |                                   ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: binary operation `!=` cannot be applied to type `ToLowercase`\n\
    \  --> /tmp/tmpkc7yutns.rs:28:33\n   |\n28 |             if c.to_lowercase() !=\
    \ char_to_replace {\n   |                ---------------- ^^ --------------- String\n\
    \   |                |\n   |                ToLowercase\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpkc7yutn"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().map(|c| \n        match c {\n            'a'\
    \ => String::from(\"G\"),\n            'b' => String::from(\"O\"),\n         \
    \   'c' => String::from(\"R\"),\n            'd' => String::from(\"B\"),\n   \
    \         'e' => String::from(\"O\"),\n            'f' => String::from(\"E\"),\n\
    \            'g' => String::from(\"N\"),\n            'h' => String::from(\"M\"\
    ),\n            'i' => String::from(\"S\"),\n            'j' => String::from(\"\
    K\"),\n            'k' => String::from(\"K\"),\n            'l' => String::from(\"\
    B\"),\n            'm' => String::from(\"M\"),\n            'n' => String::from(\"\
    N\"),\n            'o' => String::from(\"G\"),\n            'p' => String::from(\"\
    T\"),\n            'q' => String::from(\"W\"),\n            'r' => String::from(\"\
    R\"),\n            's' => String::from(\"S\"),\n            't' => String::from(\"\
    T\"),\n            'u' => String::from(\"Y\"),\n            'v' => String::from(\"\
    F\"),\n            'w' => String::from(\"W\"),\n            'x' => String::from(\"\
    W\"),\n            'y' => String::from(\"W\"),\n            'z' => String::from(\"\
    W\"),\n            _ => String::from(\"N\"),\n        }\n    )\n    .collect::<String>()\
    \ + encode(message.chars().filter(|c| c != 'a').collect::<String>()) + encode(message.chars().filter(|c|\
    \ c != 'e').collect::<String>()) + encode(message.chars().filter(|c| c != 'i').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'o').collect::<String>()) + encode(message.chars().filter(|c|\
    \ c != 'u').collect::<String>()) + encode(message.chars().filter(|c| c != 'y').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'i').collect::<String>()) + encode(message.chars().filter(|c|\
    \ c != 'o').collect::<String>()) + encode(message.chars().filter(|c| c != 'u').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'y').collect::<String>())\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4n07sr5x.rs:43:64\n\
    \   |\n43 |     .collect::<String>() + encode(message.chars().filter(|c| c !=\
    \ 'a').collect::<String>()) + encode(message.chars().filter(|c| c != 'e')...\n\
    \   |                                                                ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp4n07sr5x.rs:43:28\n   |\n43 |  \
    \   .collect::<String>() + encode(message.chars().filter(|c| c != 'a').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'e')...\n   |                     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |\
    \                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&encode(message.chars().filter(|c| c != 'a').collect::<String>())`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp4n07sr5x.rs:43:131\n\
    \   |\n43 | ...ring>()) + encode(message.chars().filter(|c| c != 'e').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'i').collect::<St...\n   |        \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp4n07sr5x.rs:43:95\n   |\n43 | ...a').collect::<String>())\
    \ + encode(message.chars().filter(|c| c != 'e').collect::<String>()) + encode(message.chars().filter(|c|\
    \ c != '...\n   |                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                               |\n   |                               expected\
    \ `&str`, found struct `String`\n   |                               help: consider\
    \ borrowing here: `&encode(message.chars().filter(|c| c != 'e').collect::<String>())`\n\
    \ner"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    let mut i = 0;\n    let\
    \ mut letters = message.chars();\n    let mut vowels = HashSet::new();\n    while\
    \ i < letters.len() {\n        let mut found = false;\n        let mut prev =\
    \ letters.nth(i).unwrap();\n        while !found && i < letters.len() {\n    \
    \        let next = letters.nth(i + 1).unwrap();\n            let mut curr = prev;\n\
    \            while (!found || curr != next) && i < letters.len() {\n         \
    \       curr = curr.to_ascii_lowercase();\n                if let Some(vowel)\
    \ = vowels.binary_search(&curr) {\n                    encoded.push_str(&encoded[vowel..]);\n\
    \                    vowels.remove(vowel);\n                    found = true;\n\
    \                }\n                i += 1;\n            }\n            prev =\
    \ curr.to_ascii_lowercase();\n        }\n        i += 1;\n    }\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmpbss86djy.rs:15:22\n   |\n15 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpbss86djy.rs:16:23\n\
    \   |\n16 |     while i < letters.len() {\n   |                       ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpbss86djy.rs:19:37\n   |\n19 |  \
    \       while !found && i < letters.len() {\n   |                            \
    \         ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Chars` in the current scope\n  --> /tmp/tmpbss86djy.rs:22:59\n\
    \   |\n22 |             while (!found || curr != next) && i < letters.len() {\n\
    \   |                                                           ^^^ method not\
    \ found in `Chars<'_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0433, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::with_capacity(message.len());\n  \
    \  for &mut c in message.chars() {\n        let mut next: Option<(String, usize)>\
    \ = None;\n        for &mut t in &mut result {\n            if t.is_empty() {\n\
    \                next = Some((c, 0));\n                break;\n            }\n\
    \            let (s, len) = t.split_last_mut();\n            if s.chars().count()\
    \ == 2 {\n                if t == c {\n                    next = Some((c, len\
    \ + 2));\n                    break;\n                }\n                next\
    \ = Some((c, len + 1));\n            }\n        }\n        if let Some(next) =\
    \ next {\n            *next = (*next).0 as char + c as char;\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjb61lyp9.rs:13:9\n   |\n\
    13 |     for &mut c in message.chars() {\n   |         ^^^^^^    ---------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found `&mut _`\n   |         help: you can probably remove the explicit\
    \ borrow: `c`\n   |\n   = note:           expected type `char`\n           found\
    \ mutable reference `&mut _`\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpjb61lyp9.rs:15:23\n   |\n15 |         for &mut t in &mut result {\n\
    \   |                       ^^^^^^^^^^^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `Iterator` for `&mut String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `&mut String`\n\nerror[E0614]: type `(String,\
    \ usize)` cannot be dereferenced\n  --> /tmp/tmpjb61lyp9.rs:30:13\n   |\n30 |\
    \             *next = (*next).0 as char + c as char;\n   |             ^^^^^\n\
    \nerror[E0614]: type `(String, usize)` cannot be dereferenced\n  --> /tmp/tmpjb61lyp9.rs:30:21\n\
    \   |\n30 |             *next = (*next).0 as char + c as char;\n   |         \
    \            ^^^^^^^\n\nerror[E0605]: non-primitive cast: `String` as `char`\n\
    \  --> /tmp/tmpjb61lyp9.rs:30:41\n   |\n30 |             *next = (*next).0 as\
    \ char + c as char;\n   |                                         ^^^^^^^^^ an\
    \ `as` expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 5 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0605, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message.to_owned();\n    let mut output =\
    \ String::new();\n    for (index, letter) in message.chars().enumerate() {\n \
    \       let mut vowels = String::new();\n        for vowel in VOWELS.chars() {\n\
    \            let pos = index - vowel.0 as usize;\n            if pos == 0 {\n\
    \                vowels.append(vowel);\n            } else {\n               \
    \ vowels.append(VOWELS[pos]);\n            }\n        }\n        let mut new_letter\
    \ = letter;\n        for vowel in vowels.chars() {\n            new_letter =\n\
    \                match new_letter.get() {\n                    Some(old) => match\
    \ old {\n                        1 => vowel,\n                        _ => vowel,\n\
    \                    },\n                    None => vowel,\n                };\n\
    \        }\n        output += new_letter;\n        if index == message.len() -\
    \ 1 {\n            output += letter;\n        }\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `VOWELS` in this scope\n  --> /tmp/tmpsp08eglu.rs:16:22\n\
    \   |\n16 |         for vowel in VOWELS.chars() {\n   |                      ^^^^^^\
    \ help: a local variable with a similar name exists: `vowels`\n\nerror[E0425]:\
    \ cannot find value `VOWELS` in this scope\n  --> /tmp/tmpsp08eglu.rs:21:31\n\
    \   |\n21 |                 vowels.append(VOWELS[pos]);\n   |                \
    \               ^^^^^^ help: a local variable with a similar name exists: `vowels`\n\
    \nerror[E0599]: no method named `append` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpsp08eglu.rs:19:24\n   |\n19 |                 vowels.append(vowel);\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpsp08eglu.rs:21:24\n   |\n21 |                 vowels.append(VOWELS[pos]);\n\
    \   |                        ^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `get` found for type `char` in the current scope\n  --> /tmp/tmpsp08eglu.rs:27:34\n\
    \   |\n27 |                 match new_letter.get() {\n   |                   \
    \               ^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsp08eglu.rs:35:19\n   |\n35 |         output += new_letter;\n \
    \  |                   ^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpsp08eglu.rs:37:23\n   |\n37 |             output\
    \ += letter;\n   |                       ^^^^^^ expected `&str`, found `char`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n\n    let mut alphabet: Vec<_> =\
    \ vec!['A'..'Z'];\n    let mut vowels: Vec<_> = vec!['A'..'Z'];\n    alphabet.push('A');\n\
    \    vowels.push('A');\n    alphabet.push('E');\n    vowels.push('E');\n    alphabet.push('I');\n\
    \    vowels.push('I');\n    alphabet.push('O');\n    vowels.push('O');\n    alphabet.push('U');\n\
    \    vowels.push('U');\n    alphabet.push('Y');\n    vowels.push('Y');\n\n   \
    \ let mut encoded_message: Vec<_> = vec![];\n    let mut i = 0;\n    while i <\
    \ message.len() {\n        let letter: char;\n        match message[i - 1].to_ascii_lowercase().get(0)\
    \ {\n            None => {\n                encoded_message.push(i + alphabet.len());\n\
    \                i += alphabet.len();\n                letter += message[i - 1].to_ascii_lowercase().get(0);\n\
    \                i += 1;\n            },\n            Some(letter) => {\n    \
    \            if vowels.iter().any(|vowel| vowel == letter) {\n               \
    \     if i > 0 {\n                        let letter2: char;\n               \
    \         match message[i - 2].to_ascii_lowercase().get(0) {\n               \
    \             None => {\n                                encoded_message.push(i\
    \ + alphabet.len());\n                                i += alphabet.len();\n \
    \                               letter2 += message[i - 2].to_ascii_lowercase().get(0);\n\
    \                                i += 1;\n                            },\n   \
    \                         Some(letter2) => {\n                               \
    \ if alphabet.iter().any(|letter| letter == letter2) {\n                     \
    \               encoded_message.push(i + alphabet.len());\n                  \
    \                  i += alphabet.len();\n                                    letter2\
    \ += message[i - 2].to_ascii_lowercase().get(0);\n                           \
    \         i += 1;\n                                }\n                       \
    \         else if letter2 > letter {\n                                    encoded_message.push(i\
    \ + alphabet.len());\n                                    i += alphabet.len();\n\
    \                                    letter2 += message[i - 2].to_ascii_lowercase().get(0);\n\
    \                                    i += 1;\n                               \
    \ }\n                                else {\n                                \
    \    encoded_message.push(i + alphabet.len());\n                             \
    \       i += alphabet.len();\n                                    letter += message[i\
    \ - 1].to_ascii_lowercase().get(0);\n                                    i +=\
    \ 1;\n                                }\n                            }\n     \
    \                   };\n                    }\n                }\n           \
    \     encoded_message.push(i + alphabet.len());\n                i += alphabet.len();\n\
    \                letter += message[i - 1].to_ascii_lowercase().get(0);\n     \
    \           i += 1;\n            }\n        };\n    }\n\n    String::from_utf8(\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpd6p8jm3w.rs:82:22\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n82 |     String::from_utf8(\n\
    \   |                      ^ unclosed delimiter\n83 | }\n   | ^ mismatched closing\
    \ delimiter\n\nwarning: use of deprecated trait `std::ascii::AsciiExt`: use inherent\
    \ methods instead\n  --> /tmp/tmpd6p8jm3w.rs:12:21\n   |\n12 |     use std::ascii::AsciiExt;\n\
    \   |                     ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on\
    \ by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:16:19\n\
    \   |\n16 |     alphabet.push('A');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:17:17\n\
    \   |\n17 |     vowels.push('A');\n   |                 ^^^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:18:19\n\
    \   |\n18 |     alphabet.push('E');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:19:17\n\
    \   |\n19 |     vowels.push('E');\n   |                 ^^^ expected struct `std::ops::Range`,\
    \ found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n   \
    \             found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:20:19\n\
    \   |\n20 |     alphabet.push('I');\n   |                   ^^^ expected struct\
    \ `std::ops::Range`, found `char`\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \                found type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd6p8jm3w.rs:21:17\n\
    \   |\n21 |     vowels.push('I');\n   |                 ^^^ expected struct `std::ops::Range`,\
    \ found `cha"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    \n    let mut encoded_message = message;\n    for letter in\
    \ message.chars() {\n        match letter {\n            'a' | 'A' => {\n    \
    \            encoded_message.push('a');\n            }\n            'b' | 'B'\
    \ => {\n                encoded_message.push('b');\n            }\n          \
    \  'c' | 'C' => {\n                encoded_message.push('c');\n            }\n\
    \            'd' | 'D' => {\n                encoded_message.push('d');\n    \
    \        }\n            'e' | 'E' => {\n                encoded_message.push('e');\n\
    \            }\n            'f' | 'F' => {\n                encoded_message.push('f');\n\
    \            }\n            'g' | 'G' => {\n                encoded_message.push('g');\n\
    \            }\n            'h' | 'H' => {\n                encoded_message.push('h');\n\
    \            }\n            'i' | 'I' => {\n                encoded_message.push('i');\n\
    \            }\n            'j' | 'J' => {\n                encoded_message.push('j');\n\
    \            }\n            'k' | 'K' => {\n                encoded_message.push('k');\n\
    \            }\n            'l' | 'L' => {\n                encoded_message.push('l');\n\
    \            }\n            'm' | 'M' => {\n                encoded_message.push('m');\n\
    \            }\n            'n' | 'N' => {\n                encoded_message.push('n');\n\
    \            }\n            'o' | 'O' => {\n                encoded_message.push('o');\n\
    \            }\n            'p' | 'P' => {\n                encoded_message.push('p');\n\
    \            }\n            'q' | 'Q' => {\n                encoded_message.push('q');\n\
    \            }\n            'r' | 'R' => {\n                encoded_message.push('r');\n\
    \            }\n            's' | 'S' => {\n                encoded_message.push('s');\n\
    \            }\n            't' | 'T' => {\n                encoded_message.push('t');\n\
    \            }\n            'u' | 'U' => {\n                encoded_message.push('u');\n\
    \            }\n            'v' | 'V' => {\n                encoded_message.push('v');\n\
    \            }\n            'w' | 'W' => {\n                encoded_message.push('w');\n\
    \            }\n            'x' | 'X' => {\n                encoded_message.push('x');\n\
    \            }\n            'y' | 'Y' => {\n                encoded_message.push('y');\n\
    \            }\n            'z' | 'Z' => {\n                encoded_message.push('z');\n\
    \            }\n            _ => {\n                continue;\n            }\n\
    \        }\n    }\n    encoded_message.to_string()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0382]: borrow of moved value: `message`\n  --> /tmp/tmpgmv0vb3p.rs:14:19\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |           ------- move\
    \ occurs because `message` has type `String`, which does not implement the `Copy`\
    \ trait\n12 |     \n13 |     let mut encoded_message = message;\n   |        \
    \                       ------- value moved here\n14 |     for letter in message.chars()\
    \ {\n   |                   ^^^^^^^^^^^^^^^ value borrowed here after move\n \
    \  |\n   = note: borrow occurs due to deref coercion to `str`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0382`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: String = message;\n    let mut map = HashMap::new();\n\
    \    map.insert(b'a', b'A');\n    map.insert(b'e', b'E');\n    map.insert(b'i',\
    \ b'I');\n    map.insert(b'o', b'O');\n    map.insert(b'u', b'U');\n    map.insert(b'I',\
    \ b'a');\n    map.insert(b'O', b'o');\n    map.insert(b'U', b'u');\n    map.insert(b'a',\
    \ b'A');\n    map.insert(b'E', b'e');\n    map.insert(b'I', b'i');\n    map.insert(b'O',\
    \ b'o');\n    map.insert(b'U', b'u');\n\n    for &(_, char) in encoded {\n   \
    \     for &(char2, _) in map {\n            if char == char2 {\n             \
    \   encoded.replace(char.clone(), char2.clone());\n            }\n        }\n\
    \    }\n\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp1es4qk28.rs:13:19\n   |\n13 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp1es4qk28.rs:28:23\n   |\n28 |   \
    \  for &(_, char) in encoded {\n   |                       ^^^^^^^ `String` is\
    \ not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0433.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match (message) {\n        Some(message) => encode(message).to_string(),\n\
    \        None => String::new(),\n    }\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `match` scrutinee expression\n\
    \  --> /tmp/tmpw_96efvz.rs:12:11\n   |\n12 |     match (message) {\n   |     \
    \      ^       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp:\
    \ remove these parentheses\n   |\n12 -     match (message) {\n12 +     match message\
    \ {\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw_96efvz.rs:13:9\n\
    \   |\n12 |     match (message) {\n   |           --------- this expression has\
    \ type `String`\n13 |         Some(message) => encode(message).to_string(),\n\
    \   |         ^^^^^^^^^^^^^ expected struct `String`, found enum `Option`\n  \
    \ |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpw_96efvz.rs:14:9\n   |\n12 | \
    \    match (message) {\n   |           --------- this expression has type `String`\n\
    13 |         Some(message) => encode(message).to_string(),\n14 |         None\
    \ => String::new(),\n   |         ^^^^ expected struct `String`, found enum `Option`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Option<_>`\n\
    \nerror: aborting due to 2 previous errors; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoder = String::new();\n    let mut vowels: Vec<String>\
    \ = vec![];\n    let mut ascii_lowercase: Vec<String> = vec![];\n    for i in\
    \ 0..message.len() {\n        vowels.push(\"aeiou\".chars().nth(i + 1).unwrap().to_ascii_lowercase());\n\
    \        ascii_lowercase.push(i.to_string().to_ascii_lowercase());\n    }\n  \
    \  for i in 0..message.len() {\n        encoder.push(message.chars().nth(i + 1).unwrap().to_string());\n\
    \        for j in 0..message.len() {\n            encoder.push(ascii_lowercase[j]);\n\
    \        }\n        for i in 0..message.len() {\n            encoder.push(vowels[i]);\n\
    \        }\n    }\n    encoder\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpr8cg0ono.rs:16:21\n   |\n\
    16 |         vowels.push(\"aeiou\".chars().nth(i + 1).unwrap().to_ascii_lowercase());\n\
    \   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |\n   |                     expected struct `String`, found `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpr8cg0ono.rs:20:22\n   |\n20 |         encoder.push(message.chars().nth(i\
    \ + 1).unwrap().to_string());\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmpr8cg0ono.rs:22:26\n   |\n22 |             encoder.push(ascii_lowercase[j]);\n\
    \   |                          ^^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr8cg0ono.rs:25:26\n\
    \   |\n25 |             encoder.push(vowels[i]);\n   |                       \
    \   ^^^^^^^^^ expected `char`, found struct `String`\n\nerror: aborting due to\
    \ 4 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut newMessage = message;\n    newMessage.replace_all(&regex::Escape::escape_str(\"\
    aeiou\"), \"u\");\n    let vowel = \"a\";\n    let vowel2 = \"e\";\n    let vowel3\
    \ = \"i\";\n    let vowel4 = \"o\";\n    let vowel5 = \"u\";\n    let vowels =\
    \ [&vowel, &vowel2, &vowel3, &vowel4, &vowel5];\n    for &vowel in vowels {\n\
    \        newMessage = newMessage.chars()\n            .filter_map(|c| match c\
    \ {\n                'a' => Some(vowel),\n                'e' => Some(vowel2),\n\
    \                'i' => Some(vowel3),\n                'o' => Some(vowel4),\n\
    \                'u' => Some(vowel5),\n                c => Some(c),\n       \
    \     })\n            .collect::<String>()\n            .join();\n    }\n    newMessage\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `regex`\n\
    \  --> /tmp/tmpbkn6orbb.rs:13:29\n   |\n13 |     newMessage.replace_all(&regex::Escape::escape_str(\"\
    aeiou\"), \"u\");\n   |                             ^^^^^ use of undeclared crate\
    \ or module `regex`\n\nerror[E0599]: no method named `replace_all` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbkn6orbb.rs:13:16\n   |\n13 | \
    \    newMessage.replace_all(&regex::Escape::escape_str(\"aeiou\"), \"u\");\n \
    \  |                ^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `replace`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbkn6orbb.rs:28:27\n\
    \   |\n28 |                 c => Some(c),\n   |                           ^ expected\
    \ `&str`, found `char`\n\nerror[E0599]: no method named `join` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpbkn6orbb.rs:31:14\n   |\n31 | \
    \            .join();\n   |              ^^^^ method not found in `String`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // First we need to find all pairs of vowels. \n    // Then\
    \ we need a function that takes any letter and \n    // returns its letter 2 places\
    \ ahead in the english alphabet. \n    // So the function will look like this:\n\
    \    // fn next_letter(char: char) -> char\n    let vowels = \"aeiouAEIOU\".to_string();\n\
    \    let pairs = vowels.chars().enumerate().filter(|&(_, &c)| {\n        &c >=\
    \ &vowels[0] && &c < &vowels[1]\n    }).map(|&(_, c)| (c, &vowels[1..].chars().next().unwrap()));\n\
    \    let letter_to_number = String::new();\n    for pair in pairs {\n        letter_to_number.push_str(&pair.0[..]);\n\
    \        letter_to_number.push_str(&pair.0[..]);\n    }\n\n    // Now we need\
    \ to make a function from any letter to its letter\n    // 2 places ahead in the\
    \ english alphabet.\n    let letter_to_next_letter = String::new();\n    for letter\
    \ in letter_to_number.chars() {\n        let mut iter = letter.chars().nth(2);\n\
    \        letter_to_next_letter.push_str(&iter.collect::<String>());\n    }\n\n\
    \    // Now we need to map each letter to the letter 2 places \n    // ahead in\
    \ the english alphabet and call our function on it.\n    let mut result = String::new();\n\
    \    message.chars().for_each(|c| {\n        result.push_str(&letter_to_number[&c]);\n\
    \        result.push_str(&letter_to_next_letter[&c]);\n    });\n\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpq2a1gsjx.rs:18:57\n   |\n\
    18 |     let pairs = vowels.chars().enumerate().filter(|&(_, &c)| {\n   |    \
    \                                                     ^^- expected due to this\n\
    \   |                                                         |\n   |        \
    \                                                 expected `char`, found reference\n\
    \   |                                                         help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmpq2a1gsjx.rs:19:16\n   |\n19 |         &c >= &vowels[0]\
    \ && &c < &vowels[1]\n   |                ^^^^^^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpq2a1gsjx.rs:19:35\n   |\n19 |         &c >= &vowels[0] && &c <\
    \ &vowels[1]\n   |                                   ^^^^^^^^^ `String` cannot\
    \ be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is\
    \ not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpq2a1gsjx.rs:2"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoder = Encoder::new(message);\n    let mut result\
    \ = encoder.encode();\n    for a in result.as_slice().to_owned().chars() {\n \
    \       let index = a.to_ascii_lowercase().find(|c| c.is_vowel());\n        let\
    \ index2 = index - 2;\n        if index2 >= 0 {\n            *a = index.unwrap_or(90);\n\
    \        }\n    }\n    String::from(result.to_string())\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Encoder`\n  -->\
    \ /tmp/tmpc_xbsfc3.rs:12:23\n   |\n12 |     let mut encoder = Encoder::new(message);\n\
    \   |                       ^^^^^^^ use of undeclared type `Encoder`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode(&message[..])\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_ezlwed8.rs:12:12\n   |\n\
    12 |     encode(&message[..])\n   |            ^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n12 |     encode((&message[..]).to_string())\n\
    \   |            +            +++++++++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut out = String::new();\n    let vowels = vec![1, 2, 3,\
    \ 4, 5, 6, 7, 8, 9, 0];\n    \n    // Split message into individual letters and\
    \ put them in out with vowels swapped, then join them back together\n    for i\
    \ in message.chars().filter(|c| vowels.contains(c.to_ascii_lowercase())).cloned()\
    \ {\n        let index = vowels.iter().position(|&x| c.to_ascii_lowercase() ==\
    \ x.to_ascii_lowercase()).unwrap();\n        out.push_str(&mut encode(&mut out.push(c),\
    \ index));\n    }\n    out\n}\n\nfn main() {\n    let candidate = encode;\n  \
    \  assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n  \
    \  assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpx3adoz7u.rs:17:49\n\
    \   |\n17 |         let index = vowels.iter().position(|&x| c.to_ascii_lowercase()\
    \ == x.to_ascii_lowercase()).unwrap();\n   |                                 \
    \                ^ help: a local variable with a similar name exists: `i`\n\n\
    error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpx3adoz7u.rs:18:48\n\
    \   |\n18 |         out.push_str(&mut encode(&mut out.push(c), index));\n   |\
    \                                                ^ help: a local variable with\
    \ a similar name exists: `i`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx3adoz7u.rs:16:57\n\
    \   |\n16 |     for i in message.chars().filter(|c| vowels.contains(c.to_ascii_lowercase())).cloned()\
    \ {\n   |                                                         ^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&{integer}`, found `char`\n\nerror[E0271]: type mismatch resolving\
    \ `<Filter<Chars<'_>, [closure@/tmp/tmpx3adoz7u.rs:16:37: 16:80]> as Iterator>::Item\
    \ == &_`\n    --> /tmp/tmpx3adoz7u.rs:16:82\n     |\n16   |     for i in message.chars().filter(|c|\
    \ vowels.contains(c.to_ascii_lowercase())).cloned() {\n     |                \
    \                                                                  ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Filter<Chars<'_>, [closure@/tmp/tmpx3adoz7u.rs:16:37:\
    \ 16:80]> as Iterator>::Item == &_`\n  --> /tmp/tmpx3adoz7u.rs:16:14\n   |\n16\
    \ |     for i in message.chars().filter(|c| vowels.contains(c.to_ascii_lowercase())).cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Filter<Chars<'_>, [closure@/tmp/tmpx3adoz7u.rs:16:37:\
    \ 16:80]>>`\n   = note: required because of the requirements on the impl "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode2(message).to_owned()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode2` in this scope\n  --> /tmp/tmp51f27osr.rs:12:5\n\
    \   |\n12 |     encode2(message).to_owned()\n   |     ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode(&message, message.as_bytes())\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp574631yo.rs:12:5\n   |\n12 |     encode(&message, message.as_bytes())\n\
    \   |     ^^^^^^ --------  ------------------ supplied 2 arguments\n   |     |\n\
    \   |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp574631yo.rs:11:4\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ^^^^^^ ---------------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoder = String::new();\n    for i in 0..message.len()\
    \ {\n        let letter = message.get_mut(i);\n        let mut found = false;\n\
    \        for c in letter.get_chars().chain(&[b'a', b'e', b'i', b'o', b'u', b'y'])\
    \ {\n            if let Some(i) = letter.get_index(&c) {\n                encoder.push_str(&encode(letter,\
    \ i / 2));\n                found = true;\n                break;\n          \
    \  }\n        }\n        if !found {\n            encoder.push_str(&encode(letter,\
    \ 2));\n        }\n    }\n    encoder\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n   --> /tmp/tmpgkrnk9x9.rs:14:38\n\
    \    |\n14  |         let letter = message.get_mut(i);\n    |                \
    \              ------- ^ string indices are ranges of `usize`\n    |         \
    \                     |\n    |                              required by a bound\
    \ introduced by this call\n    |\n    = help: the trait `SliceIndex<str>` is not\
    \ implemented for `usize`\n    = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\nnote: required by a bound in `core::str::<impl str>::get_mut`\n\
    \nerror[E0599]: no method named `get_chars` found for enum `Option` in the current\
    \ scope\n  --> /tmp/tmpgkrnk9x9.rs:16:25\n   |\n16 |         for c in letter.get_chars().chain(&[b'a',\
    \ b'e', b'i', b'o', b'u', b'y']) {\n   |                         ^^^^^^^^^ method\
    \ not found in `Option<&mut _>`\n\nerror[E0599]: no method named `get_index` found\
    \ for enum `Option` in the current scope\n  --> /tmp/tmpgkrnk9x9.rs:17:37\n  \
    \ |\n17 |             if let Some(i) = letter.get_index(&c) {\n   |          \
    \                           ^^^^^^^^^ method not found in `Option<&mut _>`\n\n\
    error[E0061]: this function takes 1 argument but 2 arguments were supplied\n \
    \ --> /tmp/tmpgkrnk9x9.rs:18:35\n   |\n18 |                 encoder.push_str(&encode(letter,\
    \ i / 2));\n   |                                   ^^^^^^ ------  ----- supplied\
    \ 2 arguments\n   |                                   |\n   |                \
    \                   expected 1 argument\n   |\nnote: function defined here\n \
    \ --> /tmp/tmpgkrnk9x9.rs:11:4\n   |\n11 | fn encode(message: String) -> String\
    \ {\n   |    ^^^^^^ ---------------\n\nerror[E0061]: this function takes 1 argument\
    \ but 2 arguments were supplied\n  --> /tmp/tmpgkrnk9x9.rs:24:31\n   |\n24 | \
    \            encoder.push_str(&encode(letter, 2));\n   |                     \
    \          ^^^^^^ ------  - supplied 2 arguments\n   |                       \
    \        |\n   |                               expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpgkrnk9x9.rs:11:4\n   |\n11 | fn encode(message:\
    \ String) -> Str"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut alphabet = alphabet_with_vowels();\n    \n    for letter\
    \ in message.chars() {\n        if let Some(replacement) = alphabet.get_by_index(letter)\
    \ {\n            alphabet.set_by_index(letter, replacement);\n        }\n    }\n\
    \    alphabet.get_by_index('A').unwrap().to_string()\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `alphabet_with_vowels` in this scope\n\
    \  --> /tmp/tmpsnohfg4f.rs:12:24\n   |\n12 |     let mut alphabet = alphabet_with_vowels();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message;\n    let mut new_message_cap\
    \ = message.chars();\n    new_message_cap.sort_by_key(|c| c.to_ascii_lowercase().unwrap());\n\
    \    new_message_cap.for_each(|c| {\n        if c.is_ascii_lowercase() {\n   \
    \         new_message += c;\n        }\n        match c {\n            'a' | ('A'\
    \ as u8) => new_message += c.clone(),\n            'e' | ('E' as u8) => new_message\
    \ += c.clone(),\n            'i' | ('I' as u8) => new_message += c.clone(),\n\
    \            'o' | ('O' as u8) => new_message += c.clone(),\n            'u' |\
    \ ('U' as u8) => new_message += c.clone(),\n            c => new_message += c,\n\
    \        }\n    });\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected identifier, found keyword `as`\n  --> /tmp/tmpyw78dh40.rs:20:24\n\
    \   |\n20 |             'a' | ('A' as u8) => new_message += c.clone(),\n   | \
    \                       ^^ expected identifier, found keyword\n\nerror: expected\
    \ one of `)`, `,`, `...`, `..=`, `..`, or `|`, found keyword `as`\n  --> /tmp/tmpyw78dh40.rs:20:24\n\
    \   |\n20 |             'a' | ('A' as u8) => new_message += c.clone(),\n   | \
    \                      -^^ expected one of `)`, `,`, `...`, `..=`, `..`, or `|`\n\
    \   |                       |\n   |                       help: missing `,`\n\n\
    error: expected one of `)`, `,`, `@`, or `|`, found `u8`\n  --> /tmp/tmpyw78dh40.rs:20:27\n\
    \   |\n20 |             'a' | ('A' as u8) => new_message += c.clone(),\n   | \
    \                         -^^ expected one of `)`, `,`, `@`, or `|`\n   |    \
    \                      |\n   |                          help: missing `,`\n\n\
    error: expected identifier, found keyword `as`\n  --> /tmp/tmpyw78dh40.rs:21:24\n\
    \   |\n21 |             'e' | ('E' as u8) => new_message += c.clone(),\n   | \
    \                       ^^ expected identifier, found keyword\n\nerror: expected\
    \ one of `)`, `,`, `...`, `..=`, `..`, or `|`, found keyword `as`\n  --> /tmp/tmpyw78dh40.rs:21:24\n\
    \   |\n21 |             'e' | ('E' as u8) => new_message += c.clone(),\n   | \
    \                      -^^ expected one of `)`, `,`, `...`, `..=`, `..`, or `|`\n\
    \   |                       |\n   |                       help: missing `,`\n\n\
    error: expected one of `)`, `,`, `@`, or `|`, found `u8`\n  --> /tmp/tmpyw78dh40.rs:21:27\n\
    \   |\n21 |             'e' | ('E' as u8) => new_message += c.clone(),\n   | \
    \                         -^^ expected one of `)`, `,`, `@`, or `|`\n   |    \
    \                      |\n   |                          help: missing `,`\n\n\
    error: expected identifier, found keyword `as`\n  --> /tmp/tmpyw78dh40.rs:22:24\n\
    \   |\n22 |             'i' | ('I' as u8) => new_message += c.clone(),\n   | \
    \                       ^^ expected identifier, found keyword\n\nerror: expected\
    \ one of `)`, `,`, `...`, `..=`, `..`, or `|`, found keyword `as`\n  --> /tmp/tmpyw78dh4"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode(&message, message, true)\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 3 arguments were supplied\n\
    \  --> /tmp/tmp40c4qxqo.rs:12:5\n   |\n12 |     encode(&message, message, true)\n\
    \   |     ^^^^^^ --------  -------  ---- supplied 3 arguments\n   |     |\n  \
    \ |     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp40c4qxqo.rs:11:4\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ^^^^^^ ---------------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().enumerate().filter(|(_, c)| c.is_letter()).map(|(_,\
    \ c)| (c, c)).flat_map(|(c1, c2)| {\n        if c1 == c2 || (c1 == 'A' || c1 ==\
    \ 'a') || (c2 == 'A' || c2 == 'a') {\n            vec![(c1, c2), (2, c1), (3,\
    \ c2), (4, c1), (5, c2), (6, c1), (7, c2)]\n        } else {\n            vec![(&c1,\
    \ &c2), (1, c1), (2, c2), (1, c1), (3, c2), (3, c2)]\n        }\n    })\n    .fold(String::new(),\
    \ |mut s, (_, c1, c2)| {\n        if s.is_empty() {\n            s.push_str(&c1)\n\
    \        } else {\n            s.push_str(&c2)\n        }\n        s\n    })\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp3zb8fido.rs:12:51\n   |\n12 |     message.chars().enumerate().filter(|(_,\
    \ c)| c.is_letter()).map(|(_, c)| (c, c)).flat_map(|(c1, c2)| {\n   |        \
    \                                           ^^^^^^^^^ method not found in `&char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3zb8fido.rs:14:29\n   |\n14 |\
    \             vec![(c1, c2), (2, c1), (3, c2), (4, c1), (5, c2), (6, c1), (7,\
    \ c2)]\n   |                             ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3zb8fido.rs:14:38\n   |\n14 |             vec![(c1,\
    \ c2), (2, c1), (3, c2), (4, c1), (5, c2), (6, c1), (7, c2)]\n   |           \
    \                           ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3zb8fido.rs:14:47\n   |\n14 |             vec![(c1, c2),\
    \ (2, c1), (3, c2), (4, c1), (5, c2), (6, c1), (7, c2)]\n   |                \
    \                               ^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp3zb8fido.rs:14:56\n   |\n14 |             vec![(c1,\
    \ c2), (2, c1), (3, c2), (4, c1), (5, c2), (6, c1), (7, c2)]\n   |           \
    \                                             ^ expected `char`, found `u8`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmp3zb8fido.rs:14:65\n   |\n14 |  \
    \           vec![(c1, c2), (2, c1), (3, c2), (4, c1), (5, c2), (6, c1), (7, c2)]\n\
    \   |                                                                 ^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3zb8fido.rs:14:74\n\
    \   |\n14 |             vec![(c1, c2), (2, c1), (3, c2), (4, c1), (5, c2), (6,\
    \ c1), (7, c2)]\n   |                                                        \
    \                  ^ expected `char`, found `u8`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp3zb8fido.rs:16:31\n   |\n16 |             vec![(&c1, &c2), (1,\
    \ c1), (2, c2), (1, c1), (3, c2), (3, c2)]\n   |                             \
    \  ^ expected `&char`, found integer\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp3zb8fido.r"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars()\n        .map(|c| {\n            match c {\n\
    \                'A'..'Z' => c,\n                'a'..'z' => c + 2,\n        \
    \        '0'..'9' => c + 1,\n                _ => c.to_ascii_lowercase()\n   \
    \         }\n        })\n        .collect()\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmphoj351j9.rs:15:17\n\
    \   |\n15 |                 'A'..'Z' => c,\n   |                 ^^^^^^^^\n  \
    \ |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmphoj351j9.rs:16:17\n   |\n16 |                 'a'..'z' => c + 2,\n\
    \   |                 ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmphoj351j9.rs:17:17\n   |\n17 |                 '0'..'9' => c + 1,\n\
    \   |                 ^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0369]: cannot add `{integer}` to `char`\n  -->\
    \ /tmp/tmphoj351j9.rs:16:31\n   |\n16 |                 'a'..'z' => c + 2,\n \
    \  |                             - ^ - {integer}\n   |                       \
    \      |\n   |                             char\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmphoj351j9.rs:17:31\n   |\n17 |                 '0'..'9'\
    \ => c + 1,\n   |                             - ^ - {integer}\n   |          \
    \                   |\n   |                             char\n\nerror: aborting\
    \ due to 5 previous errors\n\nSome errors have detailed explanations: E0369, E0658.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut vowels = \"aeiou\".to_string();\n    let mut letters\
    \ = Vec::new();\n    for c in message.chars() {\n        if vowels.contains(&c.to_string())\
    \ {\n            letters.push(c.to_string());\n        } else {\n            let\
    \ mut found = 0;\n            for c in vowels.chars() {\n                if c\
    \ == c.to_string() {\n                    found += 2;\n                }\n   \
    \         }\n            letters.push(c + found % 3);\n        }\n    }\n    String::from(letters)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpv6t5w0rj.rs:20:25\n   |\n\
    20 |                 if c == c.to_string() {\n   |                         ^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmpv6t5w0rj.rs:24:28\n   |\n24 |             letters.push(c\
    \ + found % 3);\n   |                          - ^ --------- {integer}\n   | \
    \                         |\n   |                          char\n\nerror[E0277]:\
    \ the trait bound `String: From<Vec<String>>` is not satisfied\n  --> /tmp/tmpv6t5w0rj.rs:27:18\n\
    \   |\n27 |     String::from(letters)\n   |     ------------ ^^^^^^^ the trait\
    \ `From<Vec<String>>` is not implemented for `String`\n   |     |\n   |     required\
    \ by a bound introduced by this call\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"\");\n    for ch in message.chars()\
    \ {\n        if ch.is_lowercase() {\n            encoded.push(char::to_lowercase(ch));\n\
    \        } else {\n            let mut index = ch - 'A' as usize + 2;\n      \
    \      while index >= 0 {\n                if encoded.chars().any(|&c| *c == index)\
    \ {\n                    break;\n                }\n                index -= 1;\n\
    \            }\n            encoded.push((index + 32 as char).to_string());\n\
    \        }\n    }\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5i9095is.rs:15:26\n   |\n\
    15 |             encoded.push(char::to_lowercase(ch));\n   |                 \
    \         ^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmp5i9095is.rs:17:32\n\
    \   |\n17 |             let mut index = ch - 'A' as usize + 2;\n   |         \
    \                    -- ^ ------------ usize\n   |                           \
    \  |\n   |                             char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp5i9095is.rs:19:41\n   |\n19 |                 if encoded.chars().any(|&c|\
    \ *c == index) {\n   |                                         ^--\n   |     \
    \                                    ||\n   |                                \
    \         |expected due to this\n   |                                        \
    \ expected `char`, found reference\n   |                                     \
    \    help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter(|c| c.is_letter()).map(|c| c + '_').collect();\n\
    \    message.chars().filter(|c| c.is_vowel()).map(|c| c.to_ascii_lowercase()).collect();\n\
    \    let mut new_message = \"\";\n    message.chars().enumerate().filter(|&(_,\
    \ c)| c != '_').for_each(|i, c| {\n        let index_of_vowel = i / 2 + 1;\n \
    \       let c = c.to_ascii_lowercase();\n        new_message = new_message.push_str(&c.chars().nth(index_of_vowel).unwrap());\n\
    \        new_message = new_message.push_str(&c.chars().nth(index_of_vowel + 1).unwrap());\n\
    \    });\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp5745e5vj.rs:12:34\n   |\n12 |     message.chars().filter(|c|\
    \ c.is_letter()).map(|c| c + '_').collect();\n   |                           \
    \       ^^^^^^^^^ method not found in `&char`\n\nerror[E0369]: cannot add `char`\
    \ to `char`\n  --> /tmp/tmp5745e5vj.rs:12:57\n   |\n12 |     message.chars().filter(|c|\
    \ c.is_letter()).map(|c| c + '_').collect();\n   |                           \
    \                            - ^ --- char\n   |                              \
    \                         |\n   |                                            \
    \           char\n\nerror[E0599]: no method named `is_vowel` found for reference\
    \ `&char` in the current scope\n  --> /tmp/tmp5745e5vj.rs:13:34\n   |\n13 |  \
    \   message.chars().filter(|c| c.is_vowel()).map(|c| c.to_ascii_lowercase()).collect();\n\
    \   |                                  ^^^^^^^^ method not found in `&char`\n\n\
    error[E0593]: closure is expected to take a single 2-tuple as argument, but it\
    \ takes 2 distinct arguments\n  --> /tmp/tmp5745e5vj.rs:15:60\n   |\n15 |    \
    \ message.chars().enumerate().filter(|&(_, c)| c != '_').for_each(|i, c| {\n \
    \  |                                                            ^^^^^^^^ ------\
    \ takes 2 distinct arguments\n   |                                           \
    \                 |\n   |                                                    \
    \        expected closure that takes a single 2-tuple as argument\n   |\nhelp:\
    \ change the closure to accept a tuple instead of individual arguments\n   |\n\
    15 |     message.chars().enumerate().filter(|&(_, c)| c != '_').for_each(|(i,\
    \ c)| {\n   |                                                                \
    \     ~~~~~~~~\n\nerror[E0599]: no method named `push_str` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmp5745e5vj.rs:18:35\n   |\n18 |   \
    \      new_message = new_message.push_str(&c.chars().nth(index_of_vowel).unwrap());\n\
    \   |                                   ^^^^^^^^ method not found in `&str`\n\n\
    error[E0599]: no method named `push_str` found fo"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::with_capacity(message.len());\n \
    \   let mut vowels = HashSet::new();\n    let mut letter = String::from(\"A\"\
    );\n    for ch in message.chars() {\n        if ch.is_lowercase() {\n        \
    \    if !vowels.contains(ch) {\n                encoded.push((letter + &ch).to_string());\n\
    \                vowels.insert(ch);\n                letter = String::from(\"\
    A\");\n            } else {\n                let index = vowels.find_index(|x|\
    \ x == &ch);\n                encoded.push((letter + &message[index + 2]).to_string());\n\
    \                vowels.remove(ch);\n                letter = String::from(\"\
    A\");\n            }\n        } else {\n            if !vowels.contains(ch) {\n\
    \                encoded.push((letter + &ch).to_string());\n                vowels.insert(ch);\n\
    \                letter = String::from(\"A\");\n            } else {\n       \
    \         let index = vowels.find_index(|x| x == &ch);\n                encoded.push((letter\
    \ + &message[index - 2]).to_string());\n                vowels.remove(ch);\n \
    \               letter = String::from(\"A\");\n            }\n        }\n    }\n\
    \    encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp6_x06hky.rs:13:22\n   |\n13 |     let mut vowels = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp6_x06hky.rs:18:40\n   |\n18 |              \
    \   encoded.push((letter + &ch).to_string());\n   |                          \
    \              ^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6_x06hky.rs:18:30\n   |\n18 |                 encoded.push((letter\
    \ + &ch).to_string());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6_x06hky.rs:23:30\n   |\n23 |                 encoded.push((letter\
    \ + &message[index + 2]).to_string());\n   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror[E0308]: mismatched types\n \
    \ --> /tmp/tmp6_x06hky.rs:29:40\n   |\n29 |                 encoded.push((letter\
    \ + &ch).to_string());\n   |                                        ^^^ expected\
    \ `str`, found `char`\n   |\n   = note: expected reference `&str`\n          \
    \    found reference `&char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_x06hky.rs:29:30\n\
    \   |\n29 |                 encoded.push((letter + &ch).to_string());\n   |  \
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6_x06hky.rs:34:30\n\
    \   |\n34 |                 encoded.push((letter + &message[index - 2]).to_string());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `String`\n\nerror: aborting due to 7 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n    for i in 0..message.len()\
    \ {\n        match message.get_char(i) {\n            c => {\n               \
    \ if !is_vowel(c) {\n                    encoded.push(get_letter_ahead_of(c));\n\
    \                }\n            }\n            _ => (),\n        }\n    }\n  \
    \  encoded\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_vowel` in this scope\n  --> /tmp/tmpi9lkvptj.rs:16:21\n\
    \   |\n16 |                 if !is_vowel(c) {\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `get_letter_ahead_of`\
    \ in this scope\n  --> /tmp/tmpi9lkvptj.rs:17:34\n   |\n17 |                 \
    \    encoded.push(get_letter_ahead_of(c));\n   |                             \
    \     ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named\
    \ `get_char` found for struct `String` in the current scope\n  --> /tmp/tmpi9lkvptj.rs:14:23\n\
    \   |\n14 |         match message.get_char(i) {\n   |                       ^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut index = 0;\n    let mut buffer = String::new();\n \
    \   for (i, c) in message.chars().enumerate() {\n        if c.to_ascii_lowercase().is_ascii_lowercase()\
    \ {\n            buffer.push(c);\n            index = i;\n        }\n    }\n\n\
    \    let mut prev_index = index;\n    let mut prev_c = buffer.chars().next().unwrap();\n\
    \    for (i, c) in buffer.chars().enumerate() {\n        if i > index {\n    \
    \        buffer.push(c);\n            continue;\n        }\n\n        if c ==\
    \ ' ' {\n            buffer.push(c);\n            continue;\n        }\n\n   \
    \     if c.is_ascii_lowercase() {\n            prev_c = buffer.chars().next().unwrap();\n\
    \            if prev_c.is_ascii_lowercase() {\n                continue;\n   \
    \         }\n        }\n        buffer.push(c);\n    }\n    buffer\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused variable: `prev_index`\n  --> /tmp/tmp7ivzxsk9.rs:21:13\n\
    \   |\n21 |     let mut prev_index = index;\n   |             ^^^^^^^^^^ help:\
    \ if this is intentional, prefix it with an underscore: `_prev_index`\n   |\n\
    \   = note: `#[warn(unused_variables)]` on by default\n\nwarning: value assigned\
    \ to `prev_c` is never read\n  --> /tmp/tmp7ivzxsk9.rs:22:13\n   |\n22 |     let\
    \ mut prev_c = buffer.chars().next().unwrap();\n   |             ^^^^^^\n   |\n\
    \   = note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is\
    \ overwritten before being read?\n\nwarning: variable does not need to be mutable\n\
    \  --> /tmp/tmp7ivzxsk9.rs:21:9\n   |\n21 |     let mut prev_index = index;\n\
    \   |         ----^^^^^^^^^^\n   |         |\n   |         help: remove this `mut`\n\
    \   |\n   = note: `#[warn(unused_mut)]` on by default\n\nerror[E0502]: cannot\
    \ borrow `buffer` as mutable because it is also borrowed as immutable\n  --> /tmp/tmp7ivzxsk9.rs:25:13\n\
    \   |\n23 |     for (i, c) in buffer.chars().enumerate() {\n   |             \
    \      --------------------------\n   |                   |\n   |            \
    \       immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n24 |         if i > index {\n25 |             buffer.push(c);\n\
    \   |             ^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror[E0502]: cannot\
    \ borrow `buffer` as mutable because it is also borrowed as immutable\n  --> /tmp/tmp7ivzxsk9.rs:30:13\n\
    \   |\n23 |     for (i, c) in buffer.chars().enumerate() {\n   |             \
    \      --------------------------\n   |                   |\n   |            \
    \       immutable borrow occurs here\n   |                   immutable borrow\
    \ later used here\n...\n30 |             buffer.push(c);\n   |             ^^^^^^^^^^^^^^\
    \ mutable borrow occurs here\n\nerror[E0502]: cannot borrow `buffer` as mutable\
    \ because it is also borrowed as immutable\n  --> /tmp/tmp7ivzxsk9.rs:40:9\n \
    \  |\n23 |     for (i, c) in buffer.chars().enumerate() {\n   |              \
    \     --------------------------\n   |                   |\n   |             \
    \      immutable borrow occurs"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = String::from(\"tHKS \");\n    message.chars()\n\
    \        .enumerate()\n        .flat_map(|(i, ch)| {\n            if ch == 'a'\
    \ || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' {\n                s +=\
    \ &ch.to_lowercase();\n            } else {\n                s += &ch.to_uppercase();\n\
    \            }\n            s += &ch.to_lowercase().chars().nth(i + 1).unwrap();\n\
    \            Vec::new()\n        })\n        .collect::<String>()\n        .reduce(String::from(\"\
    A\"), |a, b| a + b);\n    s\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpykhndryx.rs:17:22\n   |\n\
    17 |                 s += &ch.to_lowercase();\n   |                      ^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found struct `ToLowercase`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpykhndryx.rs:19:22\n   |\n19 |                 s += &ch.to_uppercase();\n\
    \   |                      ^^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToUppercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToUppercase`\n\
    \nerror[E0599]: no method named `chars` found for struct `ToLowercase` in the\
    \ current scope\n  --> /tmp/tmpykhndryx.rs:21:37\n   |\n21 |             s +=\
    \ &ch.to_lowercase().chars().nth(i + 1).unwrap();\n   |                      \
    \               ^^^^^ method not found in `ToLowercase`\n\nerror[E0599]: `String`\
    \ is not an iterator\n   --> /tmp/tmpykhndryx.rs:25:10\n    |\n25  |         \
    \  .reduce(String::from(\"A\"), |a, b| a + b);\n    |            ^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n    |\n    = note:\
    \ the following trait bounds were not satisfied:\n            `String: Iterator`\n\
    \            which is required by `&mut String: Iterator`\n            `str: Iterator`\n\
    \            which is required by `&mut str: Iterator`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buf = [0u8; message.len()];\n    for (index, c) in\
    \ message.chars().enumerate() {\n        if c.is_uppercase() {\n            buf[index\
    \ + (2 * (c.to_ascii_lowercase().unwrap() - 'a' as u8))] = c.to_ascii_lowercase().unwrap();\n\
    \        } else {\n            buf[index + (2 * (c.to_ascii_uppercase().unwrap()\
    \ - 'A' as u8))] = c.to_ascii_uppercase().unwrap();\n        }\n    }\n    let\
    \ mut buf = String::from_utf8_lossy(&mut buf[..]);\n    let mut buf2 = String::new();\n\
    \    for (index, c) in buf.chars().enumerate() {\n        if c.is_lowercase()\
    \ {\n            buf2 += c.to_ascii_lowercase().unwrap();\n        } else {\n\
    \            buf2 += c.to_ascii_uppercase().unwrap();\n        }\n    }\n    buf2\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0435]: attempt to use a non-constant value in a constant\n  -->\
    \ /tmp/tmpo_4r4jzd.rs:12:25\n   |\n11 | fn encode(message: String) -> String {\n\
    \   |           ------- this would need to be a `const`\n12 |     let mut buf\
    \ = [0u8; message.len()];\n   |                         ^^^^^^^\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpo_4r4jzd.rs:15:54\n\
    \   |\n15 |             buf[index + (2 * (c.to_ascii_lowercase().unwrap() - 'a'\
    \ as u8))] = c.to_ascii_lowercase().unwrap();\n   |                          \
    \                            ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpo_4r4jzd.rs:15:103\n\
    \   |\n15 |             buf[index + (2 * (c.to_ascii_lowercase().unwrap() - 'a'\
    \ as u8))] = c.to_ascii_lowercase().unwrap();\n   |                          \
    \                                                                            \
    \ ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpo_4r4jzd.rs:17:54\n\
    \   |\n17 |             buf[index + (2 * (c.to_ascii_uppercase().unwrap() - 'A'\
    \ as u8))] = c.to_ascii_uppercase().unwrap();\n   |                          \
    \                            ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpo_4r4jzd.rs:17:103\n\
    \   |\n17 |             buf[index + (2 * (c.to_ascii_uppercase().unwrap() - 'A'\
    \ as u8))] = c.to_ascii_uppercase().unwrap();\n   |                          \
    \                                                                            \
    \ ^^^^^^ method not found in `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpo_4r4jzd.rs:24:44\n\
    \   |\n24 |             buf2 += c.to_ascii_lowercase().unwrap();\n   |       \
    \                                     ^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().fold(message, \".\")\n        .iter()\n   \
    \     .map(|c| {\n            let v = c[0].to_digit(10) + c[1].to_digit(10);\n\
    \            chr::from_digit(v).unwrap()\n        })\n        .collect()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chr`\n\
    \  --> /tmp/tmp5n8ytpl5.rs:16:13\n   |\n16 |             chr::from_digit(v).unwrap()\n\
    \   |             ^^^ use of undeclared crate or module `chr`\n\nerror[E0277]:\
    \ expected a `Fn<(String, char)>` closure, found `str`\n    --> /tmp/tmp5n8ytpl5.rs:12:35\n\
    \     |\n12   |     message.chars().fold(message, \".\")\n     |             \
    \        ----          ^^^ expected an `Fn<(String, char)>` closure, found `str`\n\
    \     |                     |\n     |                     required by a bound\
    \ introduced by this call\n     |\n     = help: the trait `Fn<(String, char)>`\
    \ is not implemented for `str`\n     = note: required because of the requirements\
    \ on the impl of `FnMut<(String, char)>` for `&str`\nnote: required by a bound\
    \ in `fold`\n\nerror[E0599]: no method named `iter` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp5n8ytpl5.rs:13:10\n   |\n13 |         .iter()\n\
    \   |          ^^^^ method not found in `String`\n   |\nhelp: because of the in-memory\
    \ representation of `&str`, to obtain an `Iterator` over each of its codepoint\
    \ use method `chars`\n   |\n13 |         .chars()\n   |          ~~~~~\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0433, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut alphabet = vec!['A'..'Z'];\n\
    \    let mut vowels = vec!['a'..'z'];\n\n    for i in 0..message.len() {\n   \
    \     // Swaps case for all letters\n        let mut swap = String::new();\n \
    \       for letter in message.as_bytes() {\n            swap.push_str(alphabet.iter().cloned().map(|letter|\
    \ letter.to_ascii_lowercase().unwrap()).collect());\n        }\n        result.push_str(&swap);\n\
    \        // Replaces all vowels with letter 2 places ahead, i.e. vowel + \n  \
    \      // alphabet index\n        for vowel in vowels {\n            let index\
    \ = alphabet.iter().position(|&letter| vowel == letter).unwrap() + 1;\n      \
    \      result.push_str(&alphabet.iter().cloned().map(|letter| letter[index].to_ascii_lowercase().unwrap()).collect());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_ascii_lowercase` found for struct `std::ops::Range`\
    \ in the current scope\n  --> /tmp/tmpjcj9w1ub.rs:20:72\n   |\n20 |          \
    \   swap.push_str(alphabet.iter().cloned().map(|letter| letter.to_ascii_lowercase().unwrap()).collect());\n\
    \   |                                                                        ^^^^^^^^^^^^^^^^^^\
    \ method not found in `std::ops::Range<char>`\n\nerror[E0277]: a value of type\
    \ `&str` cannot be built from an iterator over elements of type `_`\n    --> /tmp/tmpjcj9w1ub.rs:20:103\n\
    \     |\n20   |             swap.push_str(alphabet.iter().cloned().map(|letter|\
    \ letter.to_ascii_lowercase().unwrap()).collect());\n     |                  \
    \                                                                            \
    \         ^^^^^^^ value of type `&str` cannot be built from `std::iter::Iterator<Item=_>`\n\
    \     |\n     = help: the trait `FromIterator<_>` is not implemented for `&str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0608]: cannot index into a value of type `std::ops::Range<char>`\n  -->\
    \ /tmp/tmpjcj9w1ub.rs:27:68\n   |\n27 |             result.push_str(&alphabet.iter().cloned().map(|letter|\
    \ letter[index].to_ascii_lowercase().unwrap()).collect());\n   |             \
    \                                                       ^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ a value of type `str` cannot be built from an iterator over elements of type\
    \ `_`\n    --> /tmp/tmpjcj9w1ub.rs:27:113\n     |\n27   |             result.push_str(&alphabet.iter().cloned().map(|letter|\
    \ letter[index].to_ascii_lowercase().unwrap()).collect());\n     |           \
    \                                                                            \
    \                      "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars()\n        .map(|c| {\n            // Swaps case\
    \ of each letter\n            if !c.is_uppercase() {\n                c.swap();\n\
    \            }\n            // Replace vowels with letters that appear 2 places\
    \ ahead of the vowel\n            c.chars().enumerate()\n                .filter(|(_,\
    \ next_c)| {\n                    // True if 2 places ahead of this letter in\
    \ the alphabet\n                    next_c.is_lowercase() && next_c.chars().any(|c|\
    \ c != c)\n                })\n                .map(|(i, next_c)| i as char).collect::<Vec<char>>()\n\
    \                .into_iter()\n                .map(|i| 'A' as char + i)\n   \
    \             .collect::<String>()\n        })\n        .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsnubh2h5.rs:16:19\n   |\n16 |                 c.swap();\n\
    \   |                   ^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `chars` found for type `char` in the current scope\n  --> /tmp/tmpsnubh2h5.rs:19:15\n\
    \   |\n19 |             c.chars().enumerate()\n   |               ^^^^^ method\
    \ not found in `char`\n\nerror[E0369]: cannot add `_` to `char`\n  --> /tmp/tmpsnubh2h5.rs:26:38\n\
    \   |\n26 |                 .map(|i| 'A' as char + i)\n   |                  \
    \        ----------- ^ - _\n   |                          |\n   |            \
    \              char\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = String::new();\n    let vowels = vowels();\n\
    \    for &letter in message {\n        if let Some(count) = vowels.iter().position(|v|\
    \ letter == v as char) {\n            let a = count + 1;\n            buffer.push_str(&vowels[a]\
    \ as char);\n        } else {\n            buffer.push_str(letter);\n        }\n\
    \    }\n    buffer\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowels` in this scope\n  --> /tmp/tmpfmh6avr_.rs:13:18\n\
    \   |\n13 |     let vowels = vowels();\n   |                  ^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpfmh6avr_.rs:14:20\n\
    \   |\n14 |     for &letter in message {\n   |                    ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0277]:\
    \ can't compare `&str` with `char`\n  --> /tmp/tmpfmh6avr_.rs:15:64\n   |\n15\
    \ |         if let Some(count) = vowels.iter().position(|v| letter == v as char)\
    \ {\n   |                                                                ^^ no\
    \ implementation for `&str == char`\n   |\n   = help: the trait `PartialEq<char>`\
    \ is not implemented for `&str`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             <&'a str as PartialEq<OsString>>\n   \
    \          <&'a str as PartialEq<String>>\n             <&'b str as PartialEq<Cow<'a,\
    \ str>>>\n             <String as PartialEq<&'a str>>\n             <String as\
    \ PartialEq<Cow<'a, str>>>\n             <String as PartialEq<str>>\n        \
    \     <String as PartialEq>\n             <str as PartialEq<Cow<'a, str>>>\n \
    \          and 4 others\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().fold2(\"\"::String)\n        .chain(\n    \
    \        &[\n                \"A\"..\"Z\",\n                \"a\"..\"z\",\n  \
    \              \"0\"..\"9\",\n                \"a\"..\"z\",\n                \"\
    0\"..\"9\",\n                \"A\"..\"Z\",\n                \"a\"..\"z\",\n  \
    \              \"0\"..\"9\",\n            ]\n        )\n        .map(|c| {\n \
    \           if c == c.to_lowercase() {\n                c\n            } else\
    \ {\n                if c.is_vowel() {\n                    c.swap()\n       \
    \         } else {\n                    c\n                }\n            }\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `)`, `,`, `.`, `?`, or an operator, found `::`\n\
    \  --> /tmp/tmp1buhzd2o.rs:12:29\n   |\n12 |     message.chars().fold2(\"\"::String)\n\
    \   |                             -^\n   |                             |\n   |\
    \                             expected one of `)`, `,`, `.`, `?`, or an operator\n\
    \   |                             help: missing `,`\n\nerror[E0425]: cannot find\
    \ value `String` in the crate root\n  --> /tmp/tmp1buhzd2o.rs:12:31\n   |\n12\
    \ |     message.chars().fold2(\"\"::String)\n   |                            \
    \   ^^^^^^ not found in the crate root\n\nerror[E0599]: no method named `fold2`\
    \ found for struct `Chars` in the current scope\n  --> /tmp/tmp1buhzd2o.rs:12:21\n\
    \   |\n12 |     message.chars().fold2(\"\"::String)\n   |                    \
    \ ^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode(message, String::new())\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp1sziwnt_.rs:12:5\n   |\n12 |     encode(message, String::new())\n\
    \   |     ^^^^^^ -------  ------------- supplied 2 arguments\n   |     |\n   |\
    \     expected 1 argument\n   |\nnote: function defined here\n  --> /tmp/tmp1sziwnt_.rs:11:4\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ^^^^^^ ---------------\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message {\n        s => {\n            let mut result\
    \ = String::new();\n            for c in s.chars() {\n                if c.is_lowercase()\
    \ {\n                    let mut new_letter = c;\n                    let mut\
    \ new_vowel = c;\n                    if c.is_vowel() {\n                    \
    \    new_vowel = c.to_lowercase();\n                    }\n                  \
    \  let mut new_position = c.position() + 2;\n                    if new_position\
    \ > 26 {\n                        new_position -= 26;\n                    }\n\
    \                    new_letter =\n                        alphabet[new_position\
    \ as usize - 1].to_uppercase() +\n                        alphabet[new_position\
    \ as usize - 1].to_lowercase();\n                    result += new_letter;\n \
    \               } else if c.is_vowel() {\n                    result += c;\n \
    \               }\n            }\n            result\n        }\n    }\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp_kpmx5de.rs:27:25\n\
    \   |\n27 |                         alphabet[new_position as usize - 1].to_uppercase()\
    \ +\n   |                         ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp_kpmx5de.rs:28:25\n\
    \   |\n28 |                         alphabet[new_position as usize - 1].to_lowercase();\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `is_vowel` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp_kpmx5de.rs:19:26\n   |\n19 |                     if c.is_vowel() {\n\
    \   |                          ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_kpmx5de.rs:20:37\n   |\n18 |              \
    \       let mut new_vowel = c;\n   |                                         -\
    \ expected due to this value\n19 |                     if c.is_vowel() {\n20 |\
    \                         new_vowel = c.to_lowercase();\n   |                \
    \                     ^^^^^^^^^^^^^^^^ expected `char`, found struct `ToLowercase`\n\
    \nerror[E0599]: no method named `position` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_kpmx5de.rs:22:46\n   |\n22 |                     let mut\
    \ new_position = c.position() + 2;\n   |                                     \
    \         ^^^^^^^^ method not found in `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp_kpmx5de.rs:29:31\n   |\n29 |                     result += new_letter;\n\
    \   |                               ^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0599]: no method named `is_vowel` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp_kpmx5de.rs:30:29\n   |\n30 |                 } else if\
    \ c.is_vowel() {\n   |                             ^^^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp_kpmx5de.rs:31:31\n\
    \   |\n31 |                     result += c;\n   |                           \
    \    ^ expected `&str`, found `char`\n\nerror: aborting due to 8 previous errors\n\
    \nSome errors have detailed "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = vec![];\n    for i in message.chars() {\n\
    \        let a = i % 2; // 0 is a, 1 is b\n        let b = i / 2; // 0 is b, 1\
    \ is a\n        buffer.push((a as u8 + b as u8 + 'a' as u8).to_string());\n  \
    \  }\n    String::from_utf8(buffer.to_vec()).unwrap().to_string()\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmpjvdrg764.rs:14:19\n\
    \   |\n14 |         let a = i % 2; // 0 is a, 1 is b\n   |                 - ^\
    \ - {integer}\n   |                 |\n   |                 char\n\nerror[E0369]:\
    \ cannot divide `char` by `{integer}`\n  --> /tmp/tmpjvdrg764.rs:15:19\n   |\n\
    15 |         let b = i / 2; // 0 is b, 1 is a\n   |                 - ^ - {integer}\n\
    \   |                 |\n   |                 char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjvdrg764.rs:18:23\n   |\n18 |     String::from_utf8(buffer.to_vec()).unwrap().to_string()\n\
    \   |                       ^^^^^^^^^^^^^^^ expected `u8`, found struct `String`\n\
    \   |\n   = note: expected struct `Vec<u8>`\n              found struct `Vec<String>`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().collect::<Vec<char>>().into_iter().map(|c|\
    \ {\n        let mut output = String::new();\n        let mut input = String::from(*c);\n\
    \        let mut vowels = HashSet::new();\n        loop {\n            if input.chars().any(|c|\
    \ c.is_ascii()) {\n                break;\n            }\n            input.chars().for_each(|c|\
    \ {\n                let mut i = c;\n                let mut k = c * 2;\n    \
    \            let mut j = &mut i;\n                while j != &mut i {\n      \
    \              if *j != k {\n                        if *j != j {\n          \
    \                  *j = 0;\n                            break;\n             \
    \           }\n                    }\n                    i += 1;\n          \
    \          j += 1;\n                }\n                if !vowels.contains(&i)\
    \ {\n                    output += i;\n                    vowels.insert(i);\n\
    \                }\n            })\n        }\n        output.to_owned()\n   \
    \ }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp34yn6j5d.rs:15:26\n   |\n15 |         let mut vowels = HashSet::new();\n\
    \   |                          ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp34yn6j5d.rs:14:38\n   |\n\
    14 |         let mut input = String::from(*c);\n   |                         \
    \             ^^\n\nerror[E0369]: cannot multiply `char` by `{integer}`\n  -->\
    \ /tmp/tmp34yn6j5d.rs:22:31\n   |\n22 |                 let mut k = c * 2;\n \
    \  |                             - ^ - {integer}\n   |                       \
    \      |\n   |                             char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp34yn6j5d.rs:26:34\n   |\n26 |                         if *j !=\
    \ j {\n   |                                  ^ expected `char`, found `&mut char`\n\
    \   |\nhelp: consider dereferencing the borrow\n   |\n26 |                   \
    \      if *j != *j {\n   |                                  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp34yn6j5d.rs:27:34\n   |\n27 | ...          \
    \         *j = 0;\n   |                       --   ^ expected `char`, found `u8`\n\
    \   |                       |\n   |                       expected due to the\
    \ type of this binding\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmp34yn6j5d.rs:31:21\n   |\n31 |     \
    \                i += 1;\n   |                     -^^^^^\n   |              \
    \       |\n   |                     cannot use `+=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&mut char`\n  -->\
    \ /tmp/tmp34yn6j5d.rs:32:21\n   |\n32 |                     j += 1;\n   |    \
    \                 -^^^^^\n   |                     |\n   |                   \
    \  cannot use `+=` on type `&mut char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp34yn6j5d.rs:35:31\n   |\n35 |                     output += i;\n   |\
    \                               ^ expected `&str`, found `char`\n\nerror: aborting\
    \ due"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoding = Vec::new();\n    let mut vowel = Char::from('U');\n\
    \    let mut consonant = Char::from('C');\n    for letter in &message {\n    \
    \    // Find vowel \n        if letter == vowel.into() {\n            // Find\
    \ next vowel and swap letters \n            vowel = consonant.into();\n      \
    \      encoding += &[consonant.into(), letter.into()].to_vec();\n        } else\
    \ {\n            encoding += &[letter.into(), vowel.into()].to_vec();\n      \
    \  }\n    }\n    encoding.into()\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpi5rut5xa.rs:13:21\n\
    \   |\n13 |     let mut vowel = Char::from('U');\n   |                     ^^^^\
    \ use of undeclared type `Char`\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `Char`\n  --> /tmp/tmpi5rut5xa.rs:14:25\n   |\n14 |     let mut consonant\
    \ = Char::from('C');\n   |                         ^^^^ use of undeclared type\
    \ `Char`\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpi5rut5xa.rs:15:19\n\
    \   |\n15 |     for letter in &message {\n   |                   ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0277]: the trait bound `String: From<Vec<_>>`\
    \ is not satisfied\n  --> /tmp/tmpi5rut5xa.rs:25:14\n   |\n25 |     encoding.into()\n\
    \   |              ^^^^ the trait `From<Vec<_>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \   = note: required because of the requirements on the impl of `Into<String>`\
    \ for `Vec<_>`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.length() == 0 {\n        message\n    } else {\n\
    \        let mut current = String::from(message.chars().next().unwrap());\n  \
    \      let mut next: u8 = 0;\n\n        for c in &message {\n            if c.is_uppercase()\
    \ {\n                next = current.get_char_code(current.get_char_code() + 2)\
    \ as u8;\n            } else {\n                next = current.get_char_code(current.get_char_code()\
    \ + 1) as u8;\n            }\n            current.push(c as char);\n         \
    \   current.push((next as char).into());\n        }\n\n        current\n    }\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp3y6fqbn3.rs:12:16\n   |\n12 |     if message.length()\
    \ == 0 {\n   |                ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmp3y6fqbn3.rs:18:18\n\
    \   |\n18 |         for c in &message {\n   |                  ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror[E0599]: no method named `get_char_code`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp3y6fqbn3.rs:20:32\n\
    \   |\n20 |                 next = current.get_char_code(current.get_char_code()\
    \ + 2) as u8;\n   |                                ^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `get_char_code` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp3y6fqbn3.rs:20:54\n   |\n20 | \
    \                next = current.get_char_code(current.get_char_code() + 2) as\
    \ u8;\n   |                                                      ^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0599]: no method named `get_char_code`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp3y6fqbn3.rs:22:32\n\
    \   |\n22 |                 next = current.get_char_code(current.get_char_code()\
    \ + 1) as u8;\n   |                                ^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror[E0599]: no method named `get_char_code` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp3y6fqbn3.rs:22:54\n   |\n22 | \
    \                next = current.get_char_code(current.get_char_code() + 1) as\
    \ u8;\n   |                                                      ^^^^^^^^^^^^^\
    \ method not found in `String`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in message.chars()\
    \ {\n        let index = ch.to_ascii_lowercase().find(|c| *c >= 'a');\n      \
    \  if index >= 0 {\n            result.push_str(&message.chars().skip_while(|c|\
    \ *c != *ch.to_ascii_lowercase()).take(index).collect());\n            result.push_str(&message.chars().skip_while(|c|\
    \ *c == *ch.to_ascii_lowercase()).take(index + 2).collect());\n        } else\
    \ {\n            result.push_str(&ch.to_ascii_lowercase());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `find` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp3vf1x9xu.rs:14:45\n   |\n14 |         let index = ch.to_ascii_lowercase().find(|c|\
    \ *c >= 'a');\n   |                                             ^^^^ method not\
    \ found in `char`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3vf1x9xu.rs:16:67\n\
    \   |\n16 |             result.push_str(&message.chars().skip_while(|c| *c !=\
    \ *ch.to_ascii_lowercase()).take(index).collect());\n   |                    \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0277]:\
    \ a value of type `str` cannot be built from an iterator over elements of type\
    \ `char`\n    --> /tmp/tmp3vf1x9xu.rs:16:105\n     |\n16   |             result.push_str(&message.chars().skip_while(|c|\
    \ *c != *ch.to_ascii_lowercase()).take(index).collect());\n     |            \
    \                                                                            \
    \                 ^^^^^^^ value of type `str` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `str`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp3vf1x9xu.rs:17:67\n\
    \   |\n17 |             result.push_str(&message.chars().skip_while(|c| *c ==\
    \ *ch.to_ascii_lowercase()).take(index + 2).collect());\n   |                \
    \                                                   ^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0277]: a value of type `str` cannot be built from an iterator over elements\
    \ of type `char`\n    --> /tmp/tmp3vf1x9xu.rs:17:109\n     |\n17   |         \
    \    result.push_str(&message.chars().skip_while(|c| *c == *ch.to_"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    lazy_static! {\n        static ref ENCODE_TABLE: HashMap<u8,\
    \ u8> = HashMap::new();\n        static ref DECODE_TABLE: HashMap<u8, u8> = HashMap::new();\n\
    \    }\n\n    for c in message.chars() {\n        if c.is_uppercase() {\n    \
    \        ENCODE_TABLE.insert(c.to_lowercase(), c as u8);\n        } else {\n \
    \           ENCODE_TABLE.insert(c, c as u8);\n        }\n    }\n\n    let mut\
    \ result = String::new();\n\n    for (i, c) in message.chars().enumerate() {\n\
    \        if i >= 2 {\n            result.push(c == ENCODE_TABLE.get(c)?.clone());\n\
    \        } else {\n            result.push(c);\n        }\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: cannot find macro `lazy_static` in this scope\n  --> /tmp/tmpwj8ll4ye.rs:12:5\n\
    \   |\n12 |     lazy_static! {\n   |     ^^^^^^^^^^^\n\nerror[E0425]: cannot find\
    \ value `ENCODE_TABLE` in this scope\n  --> /tmp/tmpwj8ll4ye.rs:19:13\n   |\n\
    19 |             ENCODE_TABLE.insert(c.to_lowercase(), c as u8);\n   |       \
    \      ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ENCODE_TABLE` in this scope\n  --> /tmp/tmpwj8ll4ye.rs:21:13\n   |\n21 |  \
    \           ENCODE_TABLE.insert(c, c as u8);\n   |             ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `ENCODE_TABLE` in this\
    \ scope\n  --> /tmp/tmpwj8ll4ye.rs:29:30\n   |\n29 |             result.push(c\
    \ == ENCODE_TABLE.get(c)?.clone());\n   |                              ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0277]: the `?` operator can only be used in\
    \ a function that returns `Result` or `Option` (or another type that implements\
    \ `FromResidual`)\n  --> /tmp/tmpwj8ll4ye.rs:29:49\n   |\n11 | / fn encode(message:\
    \ String) -> String {\n12 | |     lazy_static! {\n13 | |         static ref ENCODE_TABLE:\
    \ HashMap<u8, u8> = HashMap::new();\n14 | |         static ref DECODE_TABLE: HashMap<u8,\
    \ u8> = HashMap::new();\n...  |\n29 | |             result.push(c == ENCODE_TABLE.get(c)?.clone());\n\
    \   | |                                                 ^ cannot use the `?` operator\
    \ in a function that returns `String`\n...  |\n35 | |     result\n36 | | }\n \
    \  | |_- this function should return `Result` or `Option` to accept `?`\n   |\n\
    \   = help: the trait `FromResidual<_>` is not implemented for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwj8ll4ye.rs:29:25\n   |\n29 |             result.push(c\
    \ == ENCODE_TABLE.get(c)?.clone());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `bool`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message;\n    message.chars()\n        .map(|c|\
    \ {\n            if c == 'A' {\n                'b'\n            } else if c ==\
    \ 'E' {\n                'e'\n            } else if c == 'I' {\n             \
    \   'g'\n            } else if c == 'O' {\n                'o'\n            }\
    \ else if c == 'U' {\n                'u'\n            } else {\n            \
    \    c.to_string()\n            }\n        })\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .cloned()\n        .for_each(|c| {\n          \
    \  message.swapcase();\n            message.chars()\n                .filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n                .map(|c|\
    \ c.to_string().to_ascii_lowercase().to_string())\n                .collect::<Vec<_>>()\n\
    \                .into_iter()\n                .cloned()\n                .for_each(|c|\
    \ {\n                    message.swapcase();\n                });\n          \
    \  message.swapcase();\n        });\n    message.chars()\n        .filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .map(|c|\
    \ c.to_string().to_ascii_lowercase().to_string())\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .cloned()\n        .for_each(|c| {\n          \
    \  message.swapcase();\n        });\n    message.chars()\n        .filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .map(|c|\
    \ c.to_string().to_ascii_lowercase().to_string())\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .cloned()\n        .for_each(|c| {\n          \
    \  message.swapcase();\n        });\n    message.chars()\n        .filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .map(|c|\
    \ c.to_string().to_ascii_lowercase().to_string())\n        .collect::<Vec<_>>()\n\
    \        .into_iter()\n        .cloned()\n        .for_each(|c| {\n          \
    \  message.swapcase();\n        });\n    message.chars()\n        .filter(|c|\
    \ c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n        .map(|c|\
    \ c.to_string().to_ascii_lowercase().to_string())\n        .collect::<Vec<_>>()\n\
    \        .\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp8_f5wc_1.rs:77:1\n   |\n77\
    \ | }\n   | ^\n\nerror[E0308]: `if` and `else` have incompatible types\n  -->\
    \ /tmp/tmp8_f5wc_1.rs:26:17\n   |\n23 |               } else if c == 'U' {\n \
    \  |  ____________________-\n24 | |                 'u'\n   | |              \
    \   --- expected because of this\n25 | |             } else {\n26 | |        \
    \         c.to_string()\n   | |                 ^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n27 | |             }\n   | |_____________- `if` and `else`\
    \ have incompatible types\n\nerror[E0599]: no method named `swapcase` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp8_f5wc_1.rs:33:21\n   |\n\
    33 |             message.swapcase();\n   |                     ^^^^^^^^ method\
    \ not found in `String`\n\nerror[E0277]: can't compare `&char` with `char`\n \
    \ --> /tmp/tmp8_f5wc_1.rs:35:31\n   |\n35 |                 .filter(|c| c == 'a'\
    \ || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                     \
    \          ^^ no implementation for `&char == char`\n   |\n   = help: the trait\
    \ `PartialEq<char>` is not implemented for `&char`\n   = help: the trait `PartialEq`\
    \ is implemented for `char`\n\nerror[E0277]: can't compare `&char` with `char`\n\
    \  --> /tmp/tmp8_f5wc_1.rs:35:43\n   |\n35 |                 .filter(|c| c ==\
    \ 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n   |                 \
    \                          ^^ no implementation for `&char == char`\n   |\n  \
    \ = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmp8_f5wc_1.rs:35:55\n   |\n35 |           \
    \      .filter(|c| c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n\
    \   |                                                       ^^ no implementation\
    \ for `&char == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&char`\n   = help: the trait `PartialEq` is implemented for `char`\n\n\
    error[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmp8_f5wc_1.rs:35:67\n\
    \   "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    let mut letters = HashSet::new();\n\
    \    for ch in message.chars() {\n        if let Some(hash) = (letters.entry(ch).or_insert(hash::default()));\n\
    \            hash == hash::default() + 2 {\n            output.push_str(&alphabet[hash\
    \ % alphabet.len()].to_string());\n        } else {\n            output.push_str(ch);\n\
    \            letters.insert(ch);\n        }\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected `{`, found `;`\n  --> /tmp/tmp6mxz6jel.rs:15:75\n   |\n\
    15 |         if let Some(hash) = (letters.entry(ch).or_insert(hash::default()));\n\
    \   |         -- this `if` expression has a condition, but no block          \
    \   ^ expected `{`\n\nerror[E0433]: failed to resolve: use of undeclared type\
    \ `HashSet`\n  --> /tmp/tmp6mxz6jel.rs:13:23\n   |\n13 |     let mut letters =\
    \ HashSet::new();\n   |                       ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().fold(String::from(\"$\"), |acc, c| {\n    \
    \    acc + if c.is_uppercase() { \"U\"\n        } else if c.is_lowercase() { \"\
    l\"\n        else if c.is_digit() { \"d\"\n        else if c.is_letter() { \"\
    a\"\n        else if c.is_symbol() { \"s\".to_string()\n        } else {\n   \
    \         // Unknown character\n            format!(\"{}\", c).to_string()\n \
    \       }\n    });\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `else`\n  --> /tmp/tmpo6rl5vhf.rs:15:9\n   |\n14 |         } else if c.is_lowercase()\
    \ { \"l\"\n   |                                         - expected one of `.`,\
    \ `;`, `?`, `}`, or an operator\n15 |         else if c.is_digit() { \"d\"\n \
    \  |         ^^^^ unexpected token\n\nerror: mismatched closing delimiter: `)`\n\
    \  --> /tmp/tmpo6rl5vhf.rs:15:30\n   |\n12 |     message.chars().fold(String::from(\"\
    $\"), |acc, c| {\n   |                         - closing delimiter possibly meant\
    \ for this\n...\n15 |         else if c.is_digit() { \"d\"\n   |             \
    \                 ^ unclosed delimiter\n...\n22 |     });\n   |      ^ mismatched\
    \ closing delimiter\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpo6rl5vhf.rs:11:31\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |    ------           \
    \          ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n...\n22 |     });\n\
    \   |       - help: remove this semicolon\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut newMessage = message;\n    for c in newMessage.chars()\
    \ {\n        match c {\n            'a' => newMessage.replace(&mut c, &\"A\"),\n\
    \            'b' => newMessage.replace(&mut c, &\"B\"),\n            'c' => newMessage.replace(&mut\
    \ c, &\"C\"),\n            'd' => newMessage.replace(&mut c, &\"D\"),\n      \
    \      'e' => newMessage.replace(&mut c, &\"E\"),\n            'f' => newMessage.replace(&mut\
    \ c, &\"F\"),\n            'g' => newMessage.replace(&mut c, &\"G\"),\n      \
    \      'h' => newMessage.replace(&mut c, &\"H\"),\n            'i' => newMessage.replace(&mut\
    \ c, &\"I\"),\n            'j' => newMessage.replace(&mut c, &\"J\"),\n      \
    \      'k' => newMessage.replace(&mut c, &\"K\"),\n            'l' => newMessage.replace(&mut\
    \ c, &\"L\"),\n            'm' => newMessage.replace(&mut c, &\"M\"),\n      \
    \      'n' => newMessage.replace(&mut c, &\"N\"),\n            'o' => newMessage.replace(&mut\
    \ c, &\"O\"),\n            'p' => newMessage.replace(&mut c, &\"P\"),\n      \
    \      'q' => newMessage.replace(&mut c, &\"Q\"),\n            'r' => newMessage.replace(&mut\
    \ c, &\"R\"),\n            's' => newMessage.replace(&mut c, &\"S\"),\n      \
    \      't' => newMessage.replace(&mut c, &\"T\"),\n            'u' => newMessage.replace(&mut\
    \ c, &\"U\"),\n            'v' => newMessage.replace(&mut c, &\"V\"),\n      \
    \      'w' => newMessage.replace(&mut c, &\"W\"),\n            'x' => newMessage.replace(&mut\
    \ c, &\"X\"),\n            'y' => newMessage.replace(&mut c, &\"Y\"),\n      \
    \      'z' => newMessage.replace(&mut c, &\"Z\"),\n            _ => (),\n    \
    \    }\n    }\n    return newMessage\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: expected a `FnMut<(char,)>` closure, found `char`\n   -->\
    \ /tmp/tmpkxnvrkg9.rs:15:39\n    |\n15  |             'a' => newMessage.replace(&mut\
    \ c, &\"A\"),\n    |                               ------- ^^^^^^ expected an\
    \ `FnMut<(char,)>` closure, found `char`\n    |                              \
    \ |\n    |                               required by a bound introduced by this\
    \ call\n    |\n    = help: the trait `FnMut<(char,)>` is not implemented for `char`\n\
    \    = note: required because of the requirements on the impl of `FnOnce<(char,)>`\
    \ for `&mut char`\n    = note: required because of the requirements on the impl\
    \ of `Pattern<'_>` for `&mut char`\nnote: required by a bound in `str::<impl str>::replace`\n\
    help: consider dereferencing here\n    |\n15  |             'a' => newMessage.replace(*&mut\
    \ c, &\"A\"),\n    |                                       +\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `char`\n   --> /tmp/tmpkxnvrkg9.rs:16:39\n\
    \    |\n16  |             'b' => newMessage.replace(&mut c, &\"B\"),\n    |  \
    \                             ------- ^^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `char`\n    |                               |\n    |                 \
    \              required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `FnMut<(char,)>` is not implemented for `char`\n    = note: required\
    \ because of the requirements on the impl of `FnOnce<(char,)>` for `&mut char`\n\
    \    = note: required because of the requirements on the impl of `Pattern<'_>`\
    \ for `&mut char`\nnote: required by a bound in `str::<impl str>::replace`\nhelp:\
    \ consider dereferencing here\n    |\n16  |             'b' => newMessage.replace(*&mut\
    \ c, &\"B\"),\n    |                                       +\n\nerror[E0277]:\
    \ expected a `FnMut<(char,)>` closure, found `char`\n   --> /tmp/tmpkxnvrkg9.rs:17:39\n\
    \    |\n17  |             'c' => newMessage.replace(&mut c, &\"C\"),\n    |  \
    \                             ------- ^^^^^^ expected an `FnMut<(char,)>` closure,\
    \ found `char`\n    |                               |\n    |                 \
    \              requir"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // Find all the letters and put them in an array\n    let mut\
    \ letters: [char; 26] = [0; 26];\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if c == ' ' {\n            letters[i] = ' ';\n        } else {\n\
    \            letters[i] = c;\n        }\n    }\n\n    // Sort the letters and\
    \ put them in alphabetical order\n    letters.sort_unstable();\n\n    // Replace\
    \ the vowels with their 2 places ahead vowels\n    for vowel in &'AEIOU' {\n \
    \       letters[letters.position(vowel)] = vowel.offset(2);\n    }\n\n    // Create\
    \ a string by putting each letter at the correct index\n    String::from_utf8(letters.iter().cloned()).unwrap()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: character literal may only contain one codepoint\n  --> /tmp/tmp_ye9sxq8.rs:26:19\n\
    \   |\n26 |     for vowel in &'AEIOU' {\n   |                   ^^^^^^^\n   |\n\
    help: if you meant to write a `str` literal, use double quotes\n   |\n26 |   \
    \  for vowel in &\"AEIOU\" {\n   |                   ~~~~~~~\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp_ye9sxq8.rs:13:36\n   |\n13 |     let mut letters:\
    \ [char; 26] = [0; 26];\n   |                                    ^ expected `char`,\
    \ found `u8`\n\nerror[E0599]: no method named `position` found for array `[char;\
    \ 26]` in the current scope\n  --> /tmp/tmp_ye9sxq8.rs:27:25\n   |\n27 |     \
    \    letters[letters.position(vowel)] = vowel.offset(2);\n   |               \
    \          ^^^^^^^^ method not found in `[char; 26]`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_ye9sxq8.rs:31:23\n   |\n31 |     String::from_utf8(letters.iter().cloned()).unwrap()\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec`, found\
    \ struct `Cloned`\n   |\n   = note: expected struct `Vec<u8>`\n              found\
    \ struct `Cloned<std::slice::Iter<'_, char>>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut char_map = HashMap::new();\n    for (i, ch) in message.chars().enumerate()\
    \ {\n        char_map.insert(String::from(&ch.to_string()), \n               \
    \         String::from(&i.to_string()));\n    }\n    encode(message, char_map)\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmp9aywhr_u.rs:12:24\n   |\n12 |     let mut char_map = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmp9aywhr_u.rs:17:5\n\
    \   |\n17 |     encode(message, char_map)\n   |     ^^^^^^ -------  -------- supplied\
    \ 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmp9aywhr_u.rs:11:4\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ^^^^^^ ---------------\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0061, E0433.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"t\");\n    message.chars().cloned().for_each(|c|\
    \ {\n        if c.is_uppercase() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else if c.is_lowercase() {\n            result.push_str(&c.to_uppercase());\n\
    \        } else if c.is_numeric() {\n            result.push_str(&c.to_lowercase());\n\
    \        } else {\n            result.push_str(&c.to_lowercase());\n        }\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpus595cdh.rs:13:21\n     |\n13   |     message.chars().cloned().for_each(|c|\
    \ {\n     |                     ^^^^^^ expected reference, found `char`\n    \
    \ |\n     = note: expected reference `&_`\n                     found type `char`\n\
    note: required by a bound in `cloned`\n\nerror[E0599]: the method `for_each` exists\
    \ for struct `Cloned<Chars<'_>>`, but its trait bounds were not satisfied\n  -->\
    \ /tmp/tmpus595cdh.rs:13:30\n   |\n13 |       message.chars().cloned().for_each(|c|\
    \ {\n   |                                ^^^^^^^^ method cannot be called on `Cloned<Chars<'_>>`\
    \ due to unsatisfied trait bounds\n   |\n   = note: the following trait bounds\
    \ were not satisfied:\n           `<Chars<'_> as Iterator>::Item = &_`\n     \
    \      which is required by `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut index = 0;\n \
    \   while index < message.len() {\n        let mut current = message.chars().nth(index).unwrap();\n\
    \        while current >= 'A' && current <= 'Z' {\n            current += 1;\n\
    \        }\n        index += 1;\n        result += &char::from(current);\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `char`\n  --> /tmp/tmpjx4a2pwn.rs:17:13\n   |\n17 |             current += 1;\n\
    \   |             -------^^^^^\n   |             |\n   |             cannot use\
    \ `+=` on type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjx4a2pwn.rs:20:19\n\
    \   |\n20 |         result += &char::from(current);\n   |                   ^^^^^^^^^^^^^^^^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0368.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::from(\"tHKS KS C MGSSCGG\");\n   \
    \ for letter in &message {\n        output.push_str(letter_to_ascii_lowercase(letter));\n\
    \    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `letter_to_ascii_lowercase` in this\
    \ scope\n  --> /tmp/tmpekmwmi4c.rs:14:25\n   |\n14 |         output.push_str(letter_to_ascii_lowercase(letter));\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmpekmwmi4c.rs:13:19\n\
    \   |\n13 |     for letter in &message {\n   |                   ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for letter in message.chars()\
    \ {\n        let position = _position(letter);\n        result += 'A' + position;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `_position` in this scope\n  --> /tmp/tmpwmon1y8f.rs:14:24\n\
    \   |\n14 |         let position = _position(letter);\n   |                  \
    \      ^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot add `_` to `char`\n\
    \  --> /tmp/tmpwmon1y8f.rs:15:23\n   |\n15 |         result += 'A' + position;\n\
    \   |                   --- ^ -------- _\n   |                   |\n   |     \
    \              char\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message {\n        Ok(s) => {\n            let mut new\
    \ = String::new();\n            new.push_str(&s);\n            new.push_str(&encode(&s[1..]));\n\
    \            new.push_str(&encode(&s[2..]));\n            new.push_str(&encode(&s[3..]));\n\
    \            new.push_str(&encode(&s[4..]));\n            new.push_str(&encode(&s[5..]));\n\
    \            new.push_str(&encode(&s[6..]));\n            new.push_str(&encode(&s[7..]));\n\
    \            new.push_str(&encode(&s[8..]));\n            new.push_str(&encode(&s[9..]));\n\
    \            new.push_str(&encode(&s[10..]));\n            new.push_str(&encode(&s[11..]));\n\
    \            new.push_str(&encode(&s[12..]));\n            new.push_str(&encode(&s[13..]));\n\
    \            new.push_str(&encode(&s[14..]));\n            new.push_str(&encode(&s[15..]));\n\
    \            new.push_str(&encode(&s[16..]));\n            new.push_str(&encode(&s[17..]));\n\
    \            new.push_str(&encode(&s[18..]));\n            new.push_str(&encode(&s[19..]));\n\
    \            new.push_str(&encode(&s[20..]));\n            new.push_str(&encode(&s[21]));\n\
    \            new.push_str(&encode(&s[22]));\n            new.push_str(&encode(&s[23]));\n\
    \            new.push_str(&encode(&s[24..]));\n            new.push_str(&encode(&s[25..]));\n\
    \            new.push_str(&encode(&s[26..]));\n            new.push_str(&encode(&s[27..]));\n\
    \            new.push_str(&encode(&s[28..]));\n            new.push_str(&encode(&s[29..]));\n\
    \            new.push_str(&encode(&s[30..]));\n            new.push_str(&encode(&s[31]));\n\
    \            new.push_str(&encode(&s[32..]));\n            new.push_str(&encode(&s[33..]));\n\
    \            new.push_str(&encode(&s[34..]));\n            new.push_str(&encode(&s[35..]));\n\
    \            new.push_str(&encode(&s[36..]));\n            new.push_str(&encode(&s[37..]));\n\
    \            new.push_str(&encode(&s[38..]));\n            new.push_str(&encode(&s[39..]));\n\
    \            new.push_str(&encode(&s[40..]));\n            new.push_str(&encode(&s[4\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp725pu5kp.rs:66:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n12 |     match message {\n   |       \
    \            - unclosed delimiter\n13 |         Ok(s) => {\n   |             \
    \     - this delimiter might not be properly closed...\n...\n57 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n66 | }\n   |   ^\n\n\
    error: expected identifier, found keyword `fn`\n  --> /tmp/tmp725pu5kp.rs:59:1\n\
    \   |\n59 | fn main() {\n   | ^^ expected identifier, found keyword\n\nerror:\
    \ expected one of `=>`, `@`, `if`, or `|`, found `main`\n  --> /tmp/tmp725pu5kp.rs:59:4\n\
    \   |\n59 | fn main() {\n   |    ^^^^ expected one of `=>`, `@`, `if`, or `|`\n\
    \nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmp725pu5kp.rs:56:36\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n56 |     \
    \        new.push_str(&encode(&s[4\n   |                                    ^\
    \ unclosed delimiter\n57 | }\n   | ^ mismatched closing delimiter\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp725pu5kp.rs:13:9\n   |\n12 |     match message\
    \ {\n   |           ------- this expression has type `String`\n13 |         Ok(s)\
    \ => {\n   |         ^^^^^ expected struct `String`, found enum `Result`\n   |\n\
    \   = note: expected struct `String`\n                found enum `Result<_, _>`\n\
    \nerror[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp725pu5kp.rs:13:12\n   |\n13 |         Ok(s) => {\n   | \
    \           ^ doesn't have a size known at compile-time\n   |\n   = help: the\
    \ trait `Sized` is not implemented for `str`\n   = note: all local variables must\
    \ have a statically known size\n   = help: unsized locals are gated as an unstable\
    \ feature\n\nerror[E0277]: the size for values of type `str` cannot be known at\
    \ compilation time\n   --> /tmp/tmp725pu5kp.rs:13:9\n    |\n13  |         Ok(s)\
    \ => {\n    |         ^^^^^ doesn't have a size known at compile-time\n   "
  stdout: ''
  timestamp: 1660009270
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for ch in &message {\n\
    \        if !ch.is_ascii_lowercase() {\n            result.push(ch);\n       \
    \     continue;\n        }\n\n        match ch {\n            'a' | 'e' | 'i'\
    \ | 'o' | 'u' => result.push((ch + 'A') % 26),\n            _ => result.push((ch\
    \ + 'a')  % 26),\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmpee4i_u0p.rs:13:15\n\
    \   |\n13 |     for ch in &message {\n   |               ^^^^^^^^ `&String` is\
    \ not an iterator\n   |\n   = help: the trait `Iterator` is not implemented for\
    \ `&String`\n   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message.chars().collect::<String>();\n  \
    \  for i in 0..message.len() {\n        if message.chars().any(|&c| c != 'A' &&\
    \ c != 'E' && c != 'I' && c != 'O' && c != 'U') {\n            message.swap(i);\n\
    \        }\n    }\n    for i in 0..message.len() {\n        if message.chars().any(|&c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n            message.swap(i);\n\
    \        }\n    }\n    message.chars().collect::<String>().into_owned()\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdhss1nv_.rs:14:33\n   |\n\
    14 |         if message.chars().any(|&c| c != 'A' && c != 'E' && c != 'I' && c\
    \ != 'O' && c != 'U') {\n   |                                 ^--\n   |      \
    \                           ||\n   |                                 |expected\
    \ due to this\n   |                                 expected `char`, found reference\n\
    \   |                                 help: did you mean `c`: `&char`\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `swap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpdhss1nv_.rs:15:21\n   |\n15 |             message.swap(i);\n   |   \
    \                  ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdhss1nv_.rs:19:33\n   |\n19 |         if message.chars().any(|&c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o' && c != 'u') {\n   |          \
    \                       ^--\n   |                                 ||\n   |   \
    \                              |expected due to this\n   |                   \
    \              expected `char`, found reference\n   |                        \
    \         help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror[E0599]: no method named `swap` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpdhss1nv_.rs:20:21\n\
    \   |\n20 |             message.swap(i);\n   |                     ^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `into_owned` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpdhss1nv_.rs:23:41\n   |\n\
    23 |     message.chars().collect::<String>().into_owned()\n   |              \
    \                           ^^^^^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut input = message.to_lowercase();\n\
    \    let mut vowels = \"aeiou\";\n    for &c in input {\n        if let Some(i)\
    \ = vowels.binary_search(&c) {\n            result.push_str(&input[i..i+2]);\n\
    \        } else {\n            result.push_str(&c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpmi8ha06z.rs:15:15\n\
    \   |\n15 |     for &c in input {\n   |               ^^^^^ `String` is not an\
    \ iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no method named\
    \ `binary_search` found for reference `&str` in the current scope\n  --> /tmp/tmpmi8ha06z.rs:16:33\n\
    \   |\n16 |         if let Some(i) = vowels.binary_search(&c) {\n   |        \
    \                         ^^^^^^^^^^^^^ method not found in `&str`\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmpmi8ha06z.rs:15:10\n   |\n15 |     for &c in input {\n   |          ^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n    for (i, char) in encoded_message.chars().enumerate()\
    \ {\n        if let Some(index) = vowel_index(&char) {\n            encoded_message.replace(i,\
    \ index + 1, char.to_string());\n        }\n    }\n    encoded_message\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `vowel_index` in this scope\n  --> /tmp/tmpb6tv71mi.rs:14:30\n\
    \   |\n14 |         if let Some(index) = vowel_index(&char) {\n   |          \
    \                    ^^^^^^^^^^^ not found in this scope\n\nerror[E0061]: this\
    \ function takes 2 arguments but 3 arguments were supplied\n   --> /tmp/tmpb6tv71mi.rs:15:29\n\
    \    |\n15  |             encoded_message.replace(i, index + 1, char.to_string());\n\
    \    |                             ^^^^^^^ -  ---------  ---------------- supplied\
    \ 3 arguments\n    |                             |\n    |                    \
    \         expected 2 arguments\n    |\nnote: associated function defined here\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0425.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter_map(|c| {\n        if c.is_uppercase()\
    \ {\n            c.to_ascii_lowercase().to_string()\n        } else {\n      \
    \      c.to_ascii_uppercase().to_string()\n        }\n    }).collect::<String>().chars().cloned()\n\
    \        .map(|c| match c.to_ascii_lowercase() {\n            'a' => (\"q\".to_string()),\n\
    \            'e' => (\"w\".to_string()),\n            'i' => (\"e\".to_string()),\n\
    \            'o' => (\"r\".to_string()),\n            'u' => (\"t\".to_string()),\n\
    \            'y' => (\"u\".to_string()),\n            _ => c.to_string(),\n  \
    \      }).collect::<String>().to_ascii_lowercase() + message\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpbb3mev_2.rs:14:13\n   |\n\
    14 |             c.to_ascii_lowercase().to_string()\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found struct `String`\n   |\n   = note: expected enum\
    \ `Option<_>`\n            found struct `String`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n14 |             Some(c.to_ascii_lowercase().to_string())\n\
    \   |             +++++                                  +\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpbb3mev_2.rs:16:13\n   |\n16 |             c.to_ascii_uppercase().to_string()\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found\
    \ struct `String`\n   |\n   = note: expected enum `Option<_>`\n            found\
    \ struct `String`\nhelp: try wrapping the expression in `Some`\n   |\n16 |   \
    \          Some(c.to_ascii_uppercase().to_string())\n   |             +++++  \
    \                                +\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpbb3mev_2.rs:18:36\n     |\n18   |\
    \     }).collect::<String>().chars().cloned()\n     |                        \
    \            ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `map` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpbb3mev_2.rs:19:10\n \
    \  |\n19 |           .map(|c| match c.to_ascii_lowercase() {\n   |           \
    \ ^^^ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `<Chars<'_> as Iterator>::Item = &_`\n           which is required by\
    \ `Cloned<Chars<'_>>: Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n  \
    \         which is required by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0308,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    for c in message.chars()\
    \ {\n        match c {\n            'a' => {\n                result.push_str(&c.to_lowercase());\n\
    \            }\n            'e' => {\n                result.push_str(&c.to_lowercase());\n\
    \            }\n            'i' => {\n                result.push_str(&c.to_lowercase());\n\
    \            }\n            'o' => {\n                result.push_str(&c.to_lowercase());\n\
    \            }\n            'u' => {\n                result.push_str(&c.to_lowercase());\n\
    \            }\n            _ => {\n                let c = c.to_lowercase();\n\
    \                let v = c.chars().filter(|&c| c.is_ascii()).count() as u8;\n\
    \                let pos = v.min(2);\n                if pos < 3 {\n         \
    \           result.push_str(&c);\n                } else {\n                 \
    \   result.push_str(&c.to_lowercase());\n                }\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp188manbg.rs:16:33\n   |\n\
    16 |                 result.push_str(&c.to_lowercase());\n   |               \
    \                  ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp188manbg.rs:19:33\n   |\n19 |\
    \                 result.push_str(&c.to_lowercase());\n   |                  \
    \               ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp188manbg.rs:22:33\n   |\n22 |\
    \                 result.push_str(&c.to_lowercase());\n   |                  \
    \               ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp188manbg.rs:25:33\n   |\n25 |\
    \                 result.push_str(&c.to_lowercase());\n   |                  \
    \               ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp188manbg.rs:28:33\n   |\n28 |\
    \                 result.push_str(&c.to_lowercase());\n   |                  \
    \               ^^^^^^^^^^^^^^^^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = note: expected reference `&str`\n              found reference `&ToLowercase`\n\
    \nerror[E0599]: no method named `chars` found for struct `ToLowercase` in the\
    \ current scope\n  --> /tmp/tmp188manbg.rs:32:27\n   |\n32 |                 let\
    \ v = c.chars().filter(|&c| c.is_ascii()).count() as u8;\n   |               \
    \            ^^^^^ method not found in `ToLowercase`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp188manbg.rs:35:37\n   |\n35 |                     result.push_str(&c);\n\
    \   |                                     ^^ expected `str`, found struct `ToLowercase`\n\
    \   |\n   = not"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message1 = message.to_lowercase();\n    let mut vowels\
    \ = \"aeiou\";\n    let mut result: String = \"\";\n    for (i, v) in message1.chars().enumerate()\
    \ {\n        if v.is_lowercase() {\n            if vowels.contains(&message1[i+2].to_string())\
    \ {\n                result += v + message1[i+1].to_string() + \"G\";\n      \
    \      } else {\n                result += v + message1[i+1].to_string() + \"\
    a\";\n            }\n        } else {\n            result += v + message1[i+1].to_string()\
    \ + \"A\";\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpm9g79znl.rs:14:30\n   |\n\
    14 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpm9g79znl.rs:17:33\n   |\n\
    17 |             if vowels.contains(&message1[i+2].to_string()) {\n   |      \
    \                           ^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm9g79znl.rs:18:31\n   |\n18 |                 result += v + message1[i+1].to_string()\
    \ + \"G\";\n   |                               ^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpm9g79znl.rs:20:31\n   |\n20 |                 result += v + message1[i+1].to_string()\
    \ + \"a\";\n   |                               ^^^^^^^^^^^^^ `String` cannot be\
    \ indexe"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: Vec<char> = message.chars().map(|c| match\
    \ c {\n        'A' => b'a',\n        'B' => b'b',\n        'C' => b'c',\n    \
    \    'D' => b'd',\n        'E' => b'e',\n        'F' => b'f',\n        'G' =>\
    \ b'g',\n        'H' => b'h',\n        'I' => b'i',\n        'J' => b'j',\n  \
    \      'K' => b'k',\n        'L' => b'l',\n        'M' => b'm',\n        'N' =>\
    \ b'n',\n        'O' => b'o',\n        'P' => b'p',\n        'Q' => b'q',\n  \
    \      'R' => b'r',\n        'S' => b's',\n        'T' => b't',\n        'U' =>\
    \ b'u',\n        'V' => b'v',\n        'W' => b'w',\n        'X' => b'x',\n  \
    \      'Y' => b'y',\n        'Z' => b'z',\n        _ => match c {\n          \
    \  'a' => b'A',\n            'b' => b'B',\n            'c' => b'C',\n        \
    \    'd' => b'D',\n            'e' => b'E',\n            'f' => b'F',\n      \
    \      'g' => b'G',\n            'h' => b'H',\n            'i' => b'I',\n    \
    \        'j' => b'J',\n            'k' => b'K',\n            'l' => b'L',\n  \
    \          'm' => b'M',\n            'n' => b'N',\n            'o' => b'O',\n\
    \            'p' => b'P',\n            'q' => b'Q',\n            'r' => b'R',\n\
    \            's' => b'S',\n            't' => b'T',\n            'u' => b'U',\n\
    \            'v' => b'V',\n            'w' => b'W',\n            'x' => b'X',\n\
    \            'y' => b'Y',\n            'z' => b'Z',\n            _ => {\n    \
    \            println!(\"unknown char: {}\", c);\n                b'?'\n      \
    \      }\n        }\n    }).collect();\n\n    // swap case of the first letter\n\
    \    encoded[0] = encoded[0].to_ascii_lowercase().into();\n\n    // swap case\
    \ of the vowels\n    for pos in 0..encoded.len() {\n        let vowel_index =\
    \ pos - 1;\n        let vowel = encoded[vowel_index];\n        let vowel_next\
    \ = encoded[vowel_index + 1];\n        // if the vowel is the same as the next\
    \ letter, we don't need to do anything\n        if vowel == vowel_next {\n   \
    \         continue;\n        }\n        // if the next letter is a vowel, swap\
    \ case with that vowel\n        let next_vowel_index = vowel_next \n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpqfyq_vm9.rs:96:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n77 |     for pos in 0..encoded.len()\
    \ {\n   |                                 - this delimiter might not be properly\
    \ closed...\n...\n87 | }\n   | - ...as it matches this but it has different indentation\n\
    ...\n96 | }\n   |   ^\n\nerror: expected `;`, found `}`\n  --> /tmp/tmpqfyq_vm9.rs:86:42\n\
    \   |\n86 |         let next_vowel_index = vowel_next \n   |                 \
    \                         ^ help: add `;` here\n87 | }\n   | - unexpected token\n\
    \nerror[E0277]: a value of type `Vec<char>` cannot be built from an iterator over\
    \ elements of type `u8`\n    --> /tmp/tmpqfyq_vm9.rs:71:8\n     |\n71   |    \
    \ }).collect();\n     |        ^^^^^^^ value of type `Vec<char>` cannot be built\
    \ from `std::iter::Iterator<Item=u8>`\n     |\n     = help: the trait `FromIterator<u8>`\
    \ is not implemented for `Vec<char>`\n     = help: the trait `FromIterator<T>`\
    \ is implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqfyq_vm9.rs:11:31\n   |\n11 | fn encode(message:\
    \ String) -> String {\n   |    ------                     ^^^^^^ expected struct\
    \ `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its body\
    \ has no tail or `return` expression\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter(|c| c.is_letter()).map(|c| {\n     \
    \   let mut swap = HashMap::new();\n        swap.insert(b'A', b'a');\n       \
    \ swap.insert(b'E', b'e');\n        swap.insert(b'I', b'i');\n        swap.insert(b'O',\
    \ b'o');\n        swap.insert(b'U', b'u');\n        swap.insert(b'a', b'A');\n\
    \        swap.insert(b'e', b'E');\n        swap.insert(b'i', b'I');\n        swap.insert(b'o',\
    \ b'O');\n        swap.insert(b'u', b'U');\n        swap.get(c).unwrap()\n   \
    \ }).collect()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpn804h8d4.rs:13:24\n   |\n13 |         let mut swap = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `is_letter` found for reference `&char` in the current scope\n\
    \  --> /tmp/tmpn804h8d4.rs:12:34\n   |\n12 |     message.chars().filter(|c| c.is_letter()).map(|c|\
    \ {\n   |                                  ^^^^^^^^^ method not found in `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut vowels = \"AEIOU\".to_owned();\n    vowels.sort();\n\
    \    let vowel_index = vowels.iter().position(|c| message.chars().any(|c| c ==\
    \ c));\n    let mut result = String::with_capacity(message.len());\n    \n   \
    \ for c in message.chars() {\n        let new_char = if vowel_index > 0 {\n  \
    \          match c {\n                'a' => vowels[vowel_index - 1].to_string(),\n\
    \                'e' => vowels[vowel_index - 2].to_string(),\n               \
    \ 'i' => vowels[vowel_index - 3].to_string(),\n                'o' => vowels[vowel_index\
    \ - 4].to_string(),\n                'u' => vowels[vowel_index - 5].to_string(),\n\
    \                c => c.to_string()\n            }\n        } else {\n       \
    \     c.to_string()\n        };\n        result.push((new_char));\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmprlu1huyh.rs:30:21\n\
    \   |\n30 |         result.push((new_char));\n   |                     ^     \
    \   ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n30 -         result.push((new_char));\n30 +         result.push(new_char);\n\
    \   | \n\nerror[E0599]: no method named `sort` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmprlu1huyh.rs:13:12\n   |\n13 |     vowels.sort();\n\
    \   |            ^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `iter` found for struct `String` in the current scope\n  --> /tmp/tmprlu1huyh.rs:14:30\n\
    \   |\n14 |     let vowel_index = vowels.iter().position(|c| message.chars().any(|c|\
    \ c == c));\n   |                              ^^^^ method not found in `String`\n\
    \   |\nhelp: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n14 |     let vowel_index\
    \ = vowels.chars().position(|c| message.chars().any(|c| c == c));\n   |      \
    \                        ~~~~~\n\nerror: aborting due to 2 previous errors; 1\
    \ warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // TODO: Complete this function\n    // Hint: The code below\
    \ is equivalent to 'fn encode(&str) -> &str'\n    let mut result = message;\n\
    \    for c in &mut result {\n        let mut vowels = \"AEIOU\";\n        let\
    \ mut position = vowels.find(c);\n        while position != char::npos && position\
    \ + 2 < result.len() {\n            let next = position + 3;\n            let\
    \ next = match result[next] { \n                'a' => {\n                   \
    \ let next2 = next + 2;\n                    match result[next2] {\n         \
    \               'e' => next2 + 1,\n                        'i' => next2 + 1,\n\
    \                        'o' => next2 + 1,\n                        'u' => next2\
    \ + 1,\n                        'y' => next2 + 1,\n                        'A'\
    \ => next2,\n                        'E' => next2,\n                        'I'\
    \ => next2,\n                        'O' => next2,\n                        'U'\
    \ => next2,\n                        'Y' => next2,\n                        'a'\
    \ => next2,\n                        'e' => next2,\n                        'i'\
    \ => next2,\n                        'o' => next2,\n                        'u'\
    \ => next2,\n                        'y' => next2,\n                    }\n  \
    \              }\n                'e' => next,\n                'i' => next,\n\
    \                'o' => next,\n                'u' => next,\n                'y'\
    \ => next,\n                'A' => next,\n                'E' => next,\n     \
    \           'I' => next,\n                'O' => next,\n                'U' =>\
    \ next,\n                'Y' => next,\n                'a' => next,\n        \
    \        'e' => next,\n                'i' => next,\n                'o' => next,\n\
    \                'u' => next,\n                'y' => next,\n            };\n\
    \            \n            if result[next] == c\n                && result[next1]\
    \ == c\n                && result[next2] == c\n            {\n               \
    \ position = next2;\n            } else {\n                position = next;\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `next1` in this scope\n  --> /tmp/tmpkl92let1.rs:63:27\n\
    \   |\n63 |                 && result[next1] == c\n   |                      \
    \     ^^^^^ help: a local variable with a similar name exists: `next`\n\nerror[E0425]:\
    \ cannot find value `next2` in this scope\n  --> /tmp/tmpkl92let1.rs:64:27\n \
    \  |\n64 |                 && result[next2] == c\n   |                       \
    \    ^^^^^ help: a local variable with a similar name exists: `next`\n\nerror[E0425]:\
    \ cannot find value `next2` in this scope\n  --> /tmp/tmpkl92let1.rs:66:28\n \
    \  |\n66 |                 position = next2;\n   |                           \
    \ ^^^^^ help: a local variable with a similar name exists: `next`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpkl92let1.rs:15:14\n   |\n15 |   \
    \  for c in &mut result {\n   |              ^^^^^^^^^^^ `String` is not an iterator;\
    \ try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator`\
    \ is not implemented for `String`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `&mut String`\n   = note: required because of\
    \ the requirements on the impl of `IntoIterator` for `&mut String`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpkl92let1.rs:18:33\n   |\n18 |         while position !=\
    \ char::npos && position + 2 < result.len() {\n   |                          \
    \       ^^^^ function or associated item not found in `char`\n\nerror[E0369]:\
    \ cannot add `{integer}` to `Option<usize>`\n  --> /tmp/tmpkl92let1.rs:18:50\n\
    \   |\n18 |         while position != char::npos && position + 2 < result.len()\
    \ {\n   |                                         -------- ^ - {integer}\n   |\
    \                                         |\n   |                            \
    \             Option<usize>\n\nerror[E0369]: cannot add `{integer}` to `Option<usize>`\n\
    \  --> /tmp/tmpkl92let1.rs:19:33\n   |\n19 |             let next = position +\
    \ 3;\n   |                        -------- ^ - {integer}\n   |               \
    \         |\n   |                        Optio"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"\");\n    let vowels = \"aeiouAEIOU\"\
    .to_lowercase();\n    for (i, c) in message.chars().enumerate() {\n        if\
    \ c.is_ascii_uppercase() {\n            result += &message[..i].to_lowercase();\n\
    \            result += &vowels[c.to_ascii_lowercase().next().unwrap()]\n     \
    \               .to_string();\n            result += &message[i..].to_lowercase();\n\
    \        } else {\n            result += &message[..i].to_string();\n        \
    \    result += &vowels[c.to_ascii_lowercase().next().unwrap()]\n             \
    \       .to_string();\n            result += &message[i..].to_string();\n    \
    \    }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `next` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp4jjemg12.rs:17:54\n   |\n17 |             result += &vowels[c.to_ascii_lowercase().next().unwrap()]\n\
    \   |                                                      ^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `next` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp4jjemg12.rs:22:54\n   |\n22 |             result\
    \ += &vowels[c.to_ascii_lowercase().next().unwrap()]\n   |                   \
    \                                   ^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().flat_map(|c|\n        if c.is_uppercase()\n\
    \        {\n            c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c\
    \ as u32)).map(|c| c as char).collect()\n        } else {\n            c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c.to_ascii_lowercase().chars().position(c\
    \ as u32) as u32)).map(|c| c as char).collect()\n        }\n    )\n    .iter()\n\
    \    .map(|c| if c.is_vowel() { c.to_ascii_lowercase() } else { c })\n    .collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpcwddyi36.rs:15:36\n   |\n15 |             c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c\
    \ as u32)).map(|c| c as char).collect()\n   |                                \
    \    ^^^^^ method not found in `char`\n\nerror[E0599]: no method named `chars`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpcwddyi36.rs:15:72\n\
    \   |\n15 |             c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c\
    \ as u32)).map(|c| c as char).collect()\n   |                                \
    \                                        ^^^^^ method not found in `char`\n\n\
    error[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpcwddyi36.rs:17:36\n   |\n17 | ...   c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c.to_ascii_lowercase().chars().position(c\
    \ as u32) as u3...\n   |                              ^^^^^ method not found in\
    \ `char`\n\nerror[E0599]: no method named `chars` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpcwddyi36.rs:17:72\n   |\n17 | ...   c.to_ascii_lowercase().chars().skip(c.to_ascii_lowercase().chars().position(c.to_ascii_lowercase().chars().position(c\
    \ as u32) as u3...\n   |                                                     \
    \             ^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpcwddyi36.rs:17:112\n\
    \   |\n17 | ...owercase().chars().position(c.to_ascii_lowercase().chars().position(c\
    \ as u32) as u32)).map(|c| c as char).collect()\n   |                        \
    \                               ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 5 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message = message;\n    let mut alphabet = [\"a\",\
    \ \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\"\
    , \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\"\
    , \"x\", \"y\", \"z\"];\n    let mut vowels = [\"a\", \"e\", \"i\", \"o\", \"\
    u\"];\n    for i in alphabet {\n        for j in alphabet {\n            if i\
    \ != j {\n                if message[j] == i {\n                    message =\
    \ message.replace(i.to_string(), j.to_string());\n                }\n        \
    \    }\n        }\n    }\n    for i in vowels {\n        for j in alphabet {\n\
    \            if i != j {\n                if message[j] == i {\n             \
    \       message = message.replace(i.to_string(), j.to_string());\n           \
    \     }\n            }\n        }\n    }\n    message\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `&str`\n  --> /tmp/tmpqh8_6r2i.rs:18:20\n\
    \   |\n18 |                 if message[j] == i {\n   |                    ^^^^^^^^^^\
    \ `String` cannot be indexed by `&str`\n   |\n   = help: the trait `Index<&str>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: expected a `FnMut<(char,)>` closure, found `String`\n\
    \   --> /tmp/tmpqh8_6r2i.rs:19:39\n    |\n19  |                     message =\
    \ message.replace(i.to_string(), j.to_string());\n    |                      \
    \                 ^^^^^^^ expected an `FnMut<(char,)>` closure, found `String`\n\
    \    |\n    = help: the trait `FnMut<(char,)>` is not implemented for `String`\n\
    \    = help: the following other types implement trait `Pattern<'a>`:\n      \
    \        &'b String\n              &'b str\n              &'c &'b str\n    = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `String`\n\
    note: required by a bound in `str::<impl str>::replace`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpqh8_6r2i.rs:19:62\n   |\n19 |                     message\
    \ = message.replace(i.to_string(), j.to_string());\n   |                     \
    \                                         ^^^^^^^^^^^^^\n   |                \
    \                                              |\n   |                       \
    \                                       expected `&str`, found struct `String`\n\
    \   |                                                              help: consider\
    \ borrowing here: `&j.to_string()`\n\nerror[E0277]: the type `String` cannot be\
    \ indexed by `&str`\n  --> /tmp/tmpqh8_6r2i.rs:27:20\n   |\n27 |             \
    \    if message[j] == i {\n   |                    ^^^^^^^^^^ `String` ca"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut message_in = message;\n    for ch in message.chars()\
    \ {\n        let idx = ch;\n        let a = ch;\n        let mut idx2 = idx as\
    \ usize;\n        if idx2 == 0 {\n            idx2 = 1;\n        }\n        let\
    \ b = message.chars()[idx2];\n        if b == a {\n            message.chars()[idx2]\
    \ = b;\n        } else {\n            let mut idx3 = idx2 - 1;\n            if\
    \ idx3 >= 0 {\n                let c = message.chars()[idx3];\n              \
    \  message.chars()[idx3] = c;\n                idx3 -= 1;\n            }\n   \
    \         message.chars()[idx2] = a;\n            message.chars()[idx3] = b;\n\
    \        }\n    }\n    message\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:20:17\n\
    \   |\n20 |         let b = message.chars()[idx2];\n   |                 ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:22:13\n\
    \   |\n22 |             message.chars()[idx2] = b;\n   |             ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:26:25\n\
    \   |\n26 |                 let c = message.chars()[idx3];\n   |             \
    \            ^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]: cannot index into a value\
    \ of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:27:17\n   |\n27 |           \
    \      message.chars()[idx3] = c;\n   |                 ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:30:13\n\
    \   |\n30 |             message.chars()[idx2] = a;\n   |             ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmpswc4fgy_.rs:31:13\n\
    \   |\n31 |             message.chars()[idx3] = b;\n   |             ^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror: aborting due to 6 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0608`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut i = 0;\n    let\
    \ mut vowels = vec!['a', 'e', 'i', 'o', 'u'];\n\n    for v in &vowels {\n    \
    \    result.push((&message[i..i+1]).chars().skip(1).next().unwrap().to_ascii_lowercase());\n\
    \        i += 1;\n    }\n\n    for char in &message {\n        let index = vowels.iter().position(|&i|\
    \ i == char).unwrap();\n        result.push((&message[i..i+1]).chars().skip(1).next().unwrap().to_ascii_lowercase());\n\
    \        i += 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&String` is not an iterator\n  --> /tmp/tmplufj17g1.rs:21:17\n\
    \   |\n21 |     for char in &message {\n   |                 ^^^^^^^^ `&String`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `&String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `&String`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: String = String::new();\n    for c in message.chars()\
    \ {\n        if c >= 'A' && c <= 'Z' {\n            encoded += c.to_ascii_uppercase();\n\
    \        } else if c >= 'a' && c <= 'z' {\n            encoded += c.to_ascii_lowercase();\n\
    \        } else {\n            encoded += c;\n        }\n    }\n    let mut pos\
    \ = 0;\n    let mut last = 0;\n    while let Some(_) = _swap(encoded, pos, last)\
    \ {\n        pos += 1;\n        last += 1;\n    }\n    encoded\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `_swap` in this scope\n  --> /tmp/tmpsz82l91s.rs:24:25\n\
    \   |\n24 |     while let Some(_) = _swap(encoded, pos, last) {\n   |        \
    \                 ^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsz82l91s.rs:15:24\n   |\n15 |             encoded += c.to_ascii_uppercase();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsz82l91s.rs:17:24\n   |\n17 |\
    \             encoded += c.to_ascii_lowercase();\n   |                       \
    \ ^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsz82l91s.rs:19:24\n   |\n19 |             encoded += c;\n\
    \   |                        ^ expected `&str`, found `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().filter_map(|c| c.to_ascii_lowercase()).collect::<String>().iter().map(|c|\
    \ \n                let a = c - 'a';\n                let b = (c - 'a') + (2);\n\
    \                let d = (c - 'a') + (3);\n                match a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase())\
    \ {\n                    Ordering::Greater => match b.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n                        Ordering::Less => match c.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n                            Ordering::Equal => c,\n                     \
    \       Ordering::Greater => d,\n                            Ordering::Less =>\
    \ b\n                        },\n                        Ordering::Equal => d,\n\
    \                        Ordering::Greater => b,\n                        Ordering::Less\
    \ => a\n                    },\n                    Ordering::Equal => match b.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n                        Ordering::Less => match c.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n                            Ordering::Equal => c,\n                     \
    \       Ordering::Greater => d,\n                            Ordering::Less =>\
    \ b\n                        },\n                        Ordering::Equal => d,\n\
    \                        Ordering::Greater => b,\n                        Ordering::Less\
    \ => a\n                    },\n                    Ordering::Less => match a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase())\
    \ {\n                        Ordering::Equal => match c.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n                            Ordering::Equal => c,\n                     \
    \       Ordering::Greater => d,\n                            Ordering::Less =>\
    \ b\n                        },\n                        Ordering::Equal => d,\n\
    \                        Ordering::Greater => b,\n                        Ordering::Less\
    \ => a\n                    },\n                }\n            ).collect::<String>().into()\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: closure bodies that contain statements must be surrounded by braces\n\
    \  --> /tmp/tmpmhhatyd_.rs:12:93\n   |\n12 |     message.chars().filter_map(|c|\
    \ c.to_ascii_lowercase()).collect::<String>().iter().map(|c| \n   |          \
    \                                                                            \
    \       ^\n...\n48 |             ).collect::<String>().into()\n   |          \
    \   ^\n   |\nnote: statement found outside of a block\n  --> /tmp/tmpmhhatyd_.rs:13:32\n\
    \   |\n13 |                 let a = c - 'a';\n   |                 ---------------^\
    \ this `;` turns the preceding closure into a statement\n   |                \
    \ |\n   |                 this expression is a statement because of the trailing\
    \ semicolon\nnote: the closure body may be incorrectly delimited\n  --> /tmp/tmpmhhatyd_.rs:12:91\n\
    \   |\n12 |       message.chars().filter_map(|c| c.to_ascii_lowercase()).collect::<String>().iter().map(|c|\
    \ \n   |  ___________________________________________________________________________________________^\n\
    13 | |                 let a = c - 'a';\n   | |_______________________________^\
    \ this is the parsed closure...\n...\n48 |               ).collect::<String>().into()\n\
    \   |               - ...but likely you meant the closure to end here\nhelp: try\
    \ adding braces\n   |\n12 ~     message.chars().filter_map(|c| c.to_ascii_lowercase()).collect::<String>().iter().map(|c|\
    \ { \n13 |                 let a = c - 'a';\n14 |                 let b = (c -\
    \ 'a') + (2);\n15 |                 let d = (c - 'a') + (3);\n16 |           \
    \      match a.to_ascii_lowercase().cmp(&b.to_ascii_lowercase()) {\n17 |     \
    \                Ordering::Greater => match b.to_ascii_lowercase().cmp(&d.to_ascii_lowercase())\
    \ {\n ...\n\nerror[E0658]: `let` expressions in this position are unstable\n \
    \ --> /tmp/tmpmhhatyd_.rs:13:17\n   |\n13 |                 let a = c - 'a';\n\
    \   |                 ^^^^^^^^^^^^^^^\n   |\n   = note: see issue #53667 <https://github.com/rust-lang/rust/issues/53667>\
    \ for more information\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmhhatyd_.rs:12:36\n\
    \   |\n12 |     message.chars().f"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message {\n        Message::Empty => String::from(\"\
    ZZ\"),\n        _ => encode(&message.into_lowercase()),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Message`\n  -->\
    \ /tmp/tmp8we0m059.rs:13:9\n   |\n13 |         Message::Empty => String::from(\"\
    ZZ\"),\n   |         ^^^^^^^ use of undeclared type `Message`\n\nerror[E0599]:\
    \ no method named `into_lowercase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp8we0m059.rs:14:30\n   |\n14 |         _ => encode(&message.into_lowercase()),\n\
    \   |                              ^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `to_lowercase`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = message;\n    \n    // 1. Change all letters to\
    \ lowercase\n    for letter in message.chars() {\n        *letter = letter.to();\n\
    \    }\n    \n    // 2. Replace all vowels with letters 2 places ahead of them\n\
    \    let vowels: Vec<&'static str> = vec![\"a\", \"e\", \"i\", \"o\", \"u\"];\n\
    \    for vowel in vowels {\n        \n        // 2.1 Get a mutable slice\n   \
    \     let mut vowels_slice = vowel.as_bytes().to_mut();\n        \n        //\
    \ 2.2 Go through the current slice and insert letters 2 places ahead\n       \
    \ for index in 0..vowel.len() {\n            vowels_slice[index] = vowels_slice[index\
    \ + 2];\n        }\n        \n        // 2.3 Convert slice back to a string\n\
    \        let vowel_str = String::from_utf8(vowels_slice).unwrap();\n        \n\
    \        // 2.4 Replace vowel with the vowel 2 places ahead of it\n        s =\
    \ s.replace_range(vowel.clone(), vowel.clone() + 1, vowel_str);\n    }\n    \n\
    \    s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpc31lamxl.rs:16:9\n\
    \   |\n16 |         *letter = letter.to();\n   |         ^^^^^^^\n\nerror[E0599]:\
    \ no method named `to` found for type `char` in the current scope\n  --> /tmp/tmpc31lamxl.rs:16:26\n\
    \   |\n16 |         *letter = letter.to();\n   |                          ^^ method\
    \ not found in `char`\n\nerror[E0599]: no method named `to_mut` found for reference\
    \ `&[u8]` in the current scope\n  --> /tmp/tmpc31lamxl.rs:24:49\n   |\n24 |  \
    \       let mut vowels_slice = vowel.as_bytes().to_mut();\n   |              \
    \                                   ^^^^^^ help: there is an associated function\
    \ with a similar name: `align_to_mut`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `&str`\n  --> /tmp/tmpc31lamxl.rs:35:58\n   |\n35 |         s = s.replace_range(vowel.clone(),\
    \ vowel.clone() + 1, vowel_str);\n   |                                       \
    \     ------------- ^ - {integer}\n   |                                      \
    \      |\n   |                                            &str\n\nerror[E0061]:\
    \ this function takes 2 arguments but 3 arguments were supplied\n    --> /tmp/tmpc31lamxl.rs:35:15\n\
    \     |\n35   |         s = s.replace_range(vowel.clone(), vowel.clone() + 1,\
    \ vowel_str);\n     |               ^^^^^^^^^^^^^ -------------  -----------------\
    \  --------- supplied 3 arguments\n     |               |\n     |            \
    \   expected 2 arguments\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpc31lamxl.rs:35:13\n   |\n12 |     let mut s\
    \ = message;\n   |                 ------- expected due to this value\n...\n35\
    \ |         s = s.replace_range(vowel.clone(), vowel.clone() + 1, vowel_str);\n\
    \   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `replace_range` modifies\
    \ its receiver in-place\n  --> /tmp/tmpc31lamxl.rs:35:15\n   |\n35 |         s\
    \ = s.replace_range(vowel.clone(), vowel.clone() + 1, vowel_str);\n   |      \
    \       - ^^^^^^^^^^^^^ this call modifies `s` in-place\n   |             |\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::with_capacity(message.len());\n\
    \    let mut vowels = String::from(\"aeiouAEIOU\");\n    let mut prev_letter_count\
    \ = 2;\n\n    message.chars().for_each(|c| {\n        match vowels.chars().position(|x|\
    \ x == c) {\n            Some(position) => encoded_message.push((&vowels[position]).to_ascii_lowercase()),\n\
    \            None => encoded_message.push((&vowels[prev_letter_count]).to_ascii_lowercase()),\n\
    \        }\n        prev_letter_count = 2;\n        vowels = vowels.clone();\n\
    \        encoded_message.push(c);\n    });\n\n    encoded_message\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpe80k3iip.rs:18:54\n\
    \   |\n18 |             Some(position) => encoded_message.push((&vowels[position]).to_ascii_lowercase()),\n\
    \   |                                                      ^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpe80k3iip.rs:19:44\n   |\n19 |             None => encoded_message.push((&vowels[prev_letter_count]).to_ascii_lowercase()),\n\
    \   |                                            ^^^^^^^^^^^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars().enumerate().map(|(i, c)| {\n        if c.is_lowercase()\
    \ {\n            c.to_lowercase().to_string().to_string().swapcase()\n       \
    \ } else {\n            c.to_string().to_string().swapcase()\n        }\n    }).chain(\n\
    \        message\n            .chars()\n            .enumerate()\n           \
    \ .map(|(i, c)| {\n                if let Some(i) = message.char_indices().nth(i\
    \ + 2) {\n                    if let Some(c) = message.chars().nth(i + 1) {\n\
    \                        match &c {\n                            'a' => {\n  \
    \                              c\n                            }\n            \
    \                'b' => {\n                                c\n               \
    \             }\n                            'c' => {\n                      \
    \          c\n                            }\n                            'd' =>\
    \ {\n                                c\n                            }\n      \
    \                      'e' => {\n                                c\n         \
    \                   }\n                            'f' => {\n                \
    \                c\n                            }\n                          \
    \  'g' => {\n                                c\n                            }\n\
    \                            'h' => {\n                                c\n   \
    \                         }\n                            'i' => {\n          \
    \                      c\n                            }\n                    \
    \        'j' => {\n                                c\n                       \
    \     }\n                            'k' => {\n                              \
    \  c\n                            }\n                            'l' => {\n  \
    \                              c\n                            }\n            \
    \                'm' => {\n                                c\n               \
    \             }\n                            'n' => {\n                      \
    \          c\n                            }\n                            'o' =>\
    \ {\n                                c\n                            }\n      \
    \                      'p' => {\n                                c\n         \
    \                   }\n                            'q' => {\n                \
    \                c\n                            }\n                          \
    \  'r' => {\n                                c\n                            }\n\
    \                            's' => {\n                                c\n   \
    \                         }\n                            't' => {\n          \
    \                      c\n                            }\n                    \
    \        'u' => {\n                                c\n                       \
    \     }\n                            'v' => {\n                              \
    \  c\n                            }\n                            'w' => {\n  \
    \                              c\n                            }\n            \
    \                'x' => {\n                                c\n               \
    \             }\n                            'y' => {\n                      \
    \          c\n                            }\n                            'z' =>\
    \ {\n                                c\n                            }\n      \
    \                      _ => {\n                                c\n           \
    \                 }\n                        }\n                    } else {\n\
    \                        match &c {\n                            'a' => {\n  \
    \                              c\n                            }\n            \
    \                'b' => {\n                                c\n               \
    \             }\n                            'c' => {\n                      \
    \          c\n                            }\n                            'd' =>\
    \ {\n                                c\n                            }\n      \
    \                      'e' => {\n                                c\n         \
    \                   }\n                            'f' => {\n                \
    \                c\n                            }\n                          \
    \  'g' => {\n                                c\n                            }\n\
    \                            'h' => {\n                                c\n   \
    \                         }\n                            'i' => {\n          \
    \                      c\n                            }\n                    \
    \        'j' => {\n                                c\n                       \
    \     }\n                            'k' => {\n                              \
    \  c\n                            }\n                            'l' => {\n  \
    \                              c\n                            }\n            \
    \                'm' => {\n                                c\n               \
    \             }\n                            '\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0762]: unterminated character literal\n   --> /tmp/tmpskot_o0u.rs:149:29\n\
    \    |\n149 | ...                   '\n    |                       ^\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0762`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output: String = String::new();\n    for i in message.chars()\
    \ {\n        let current_char = i as char;\n        if current_char == ' ' {\n\
    \            output.push(i);\n        } else {\n            output.push(current_char.swapcase());\n\
    \            for j in 0..3 {\n                if current_char == vowel_chars[(j\
    \ + 2) % 4] {\n                    output.push(vowel_chars[(j + 2) % 4]);\n  \
    \              } else {\n                    output.push(current_char);\n    \
    \            }\n            }\n        }\n    }\n    output\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowel_chars` in this scope\n  --> /tmp/tmp3ir1fo8m.rs:20:36\n\
    \   |\n20 |                 if current_char == vowel_chars[(j + 2) % 4] {\n  \
    \ |                                    ^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `vowel_chars` in this scope\n  --> /tmp/tmp3ir1fo8m.rs:21:33\n\
    \   |\n21 |                     output.push(vowel_chars[(j + 2) % 4]);\n   | \
    \                                ^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `swapcase` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp3ir1fo8m.rs:18:38\n   |\n18 |             output.push(current_char.swapcase());\n\
    \   |                                      ^^^^^^^^ method not found in `char`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = String::from(\"tHKS KS C MGSSCGG\");\n    for (i,\
    \ c) in message.chars().enumerate() {\n        if i > 0 {\n            let index\
    \ = c as u32;\n            let index1 = index - 2;\n            let index = index1\
    \ as u32;\n            s.push_char(index1 % 26);\n        }\n        s.push_char(c);\n\
    \    }\n    return s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_char` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpoy3plhaa.rs:18:15\n   |\n18 |             s.push_char(index1\
    \ % 26);\n   |               ^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `push_str`\n\nerror[E0599]: no method named `push_char` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpoy3plhaa.rs:20:11\n\
    \   |\n20 |         s.push_char(c);\n   |           ^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `push_str`\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut buffer = String::new();\n    let mut in_vowel = false;\n\
    \    let mut in_new_letter = false;\n    let mut vowels = vec!['A', 'B', 'C',\
    \ 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S',\
    \ 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];\n    \n    for &char in message {\n    \
    \    match char {\n            'A' => {\n                let index = vowels.iter().position(|&i|\
    \ i == char);\n                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"A\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'B'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"B\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'C'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"C\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'D'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"D\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'E'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"E\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'F'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"F\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'G'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"G\");\n     \
    \           }\n                in_vowel = true;\n            },\n            'H'\
    \ => {\n                let index = vowels.iter().position(|&i| i == char);\n\
    \                if index != -1 {\n                    buffer.push_str(&vowels[index]);\n\
    \                } else {\n                    buffer.push_str(\"H\");\n     \
    \           }\n                in_vowel = true;\n            },\n\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpdt0p55uy.rs:101:3\n\
    \    |\n11  | fn encode(message: String) -> String {\n    |                  \
    \                    - unclosed delimiter\n...\n17  |     for &char in message\
    \ {\n    |                          - unclosed delimiter\n18  |         match\
    \ char {\n    |                    - this delimiter might not be properly closed...\n\
    ...\n92  | }\n    | - ...as it matches this but it has different indentation\n\
    ...\n101 | }\n    |   ^\n\nerror[E0277]: `String` is not an iterator\n  --> /tmp/tmpdt0p55uy.rs:17:18\n\
    \   |\n17 |     for &char in message {\n   |                  ^^^^^^^ `String`\
    \ is not an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the\
    \ trait `Iterator` is not implemented for `String`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdt0p55uy.rs:21:29\n   |\n21 |              \
    \   if index != -1 {\n   |                             ^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<usize>`\n            \
    \  found type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n\
    21 |                 if index != Some(-1) {\n   |                            \
    \ +++++  +\n\nerror[E0277]: the type `[char]` cannot be indexed by `Option<usize>`\n\
    \  --> /tmp/tmpdt0p55uy.rs:22:38\n   |\n22 |                     buffer.push_str(&vowels[index]);\n\
    \   |                                      ^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>`\
    \ is not implemented for `Option<usize>`\n   = note: required because of the requirements\
    \ on the impl of `Index<Option<usize>>` for `Vec<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdt0p55uy.rs:30:29\n   |\n30 |                 if index\
    \ != -1 {\n   |                             ^^ expected enum `Option`, found integer\n\
    \   |\n   = note: expected enum `Option<usize>`\n              found type `{integer}`\n\
    help: try wrapping the expression in `Some`\n   |\n30 |                 "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoding = HashMap::new();\n    let vowels = vec!['a',\
    \ 'e', 'i', 'o', 'u'];\n    for (i, ch) in message.chars().enumerate() {\n   \
    \     if let Some(x) = encoding.get(&ch) {\n            encoding.insert(x + 2\
    \ * i, ch);\n        } else {\n            encoding.insert(i, ch);\n        }\n\
    \    }\n    encoding.iter().collect::<String>().to_string()\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpteo06cw9.rs:12:24\n   |\n12 |     let mut encoding = HashMap::new();\n\
    \   |                        ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = String::new();\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if i < (message.len() / 2) {\n            let mut new_c = c;\n  \
    \          if c.is_uppercase() {\n                new_c = c.to_lowercase();\n\
    \            }\n            s.push_str(&new_c.to_string());\n        } else {\n\
    \            s.push_str(&c.to_string());\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp68es8iex.rs:17:25\n   |\n\
    15 |             let mut new_c = c;\n   |                             - expected\
    \ due to this value\n16 |             if c.is_uppercase() {\n17 |            \
    \     new_c = c.to_lowercase();\n   |                         ^^^^^^^^^^^^^^^^\
    \ expected `char`, found struct `ToLowercase`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result: String = message;\n    \n    for i in 0..message.len()\
    \ {\n        let mut found: usize = 0;\n        let mut current_letter: Char =\
    \ message[i];\n        \n        while found < message.len() - 1 {\n         \
    \   let next = message[found + 1];\n            if current_letter == next {\n\
    \                current_letter = next_letter_to_swap(current_letter, next);\n\
    \                found++;\n            } else {\n                found++;\n  \
    \          }\n        }\n        \n        result[i] = current_letter;\n    }\n\
    \    \n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp9metdoq2.rs:22:22\n\
    \   |\n22 |                 found++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n22 |               \
    \  { let tmp = found; found += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n22 -                 found++;\n22 +                 found\
    \ += 1;\n   | \n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmp9metdoq2.rs:24:22\n\
    \   |\n24 |                 found++;\n   |                      ^^ not a valid\
    \ postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n24 |               \
    \  { let tmp = found; found += 1; tmp };\n   |                 +++++++++++   \
    \   ~~~~~~~~~~~~~~~~~~~\n24 -                 found++;\n24 +                 found\
    \ += 1;\n   | \n\nerror[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmp9metdoq2.rs:16:33\n\
    \   |\n16 |         let mut current_letter: Char = message[i];\n   |         \
    \                        ^^^^ help: a builtin type with a similar name exists\
    \ (notice the capitalization): `char`\n\nerror[E0425]: cannot find function `next_letter_to_swap`\
    \ in this scope\n  --> /tmp/tmp9metdoq2.rs:21:34\n   |\n21 |                 current_letter\
    \ = next_letter_to_swap(current_letter, next);\n   |                         \
    \         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmp9metdoq2.rs:16:40\n   |\n\
    16 |         let mut current_letter: Char = message[i];\n   |                \
    \                        ^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_str = message;\n    let mut buffer = Vec::new();\n\
    \    for i in new_str {\n        buffer.push((i.to_lowercase(), i));\n    }\n\
    \    buffer.sort_by_key(|&(first, second)| first.cmp(&second));\n    let mut swap_case\
    \ = false;\n    let mut vowels = String::new();\n    let mut last_char = 0;\n\
    \    let mut last_letter = String::new();\n    let mut first_letter = String::new();\n\
    \    for &(letter, i) in buffer {\n        if swap_case {\n            if let\
    \ Some((vowel, last_letter)) = vowels.split_last_mut() {\n                vowel\
    \ = vowel.to_lowercase();\n                first_letter = last_letter.to_lowercase();\n\
    \            }\n            swap_case = !swap_case;\n        }\n        swap_case\
    \ = i % 2 == 0;\n        if let Some(vowel) = vowels.split_last_mut() {\n    \
    \        vowels.push(vowel);\n        }\n        if i == 0 {\n            last_char\
    \ = letter;\n            last_letter = letter;\n        } else {\n           \
    \ if let Some(vowel) = vowels.split_last_mut() {\n                if letter !=\
    \ vowel {\n                    vowels.push(letter);\n                    last_char\
    \ = letter;\n                    last_letter = vowel;\n                }\n   \
    \         } else if letter != last_letter {\n                vowels.push(last_letter);\n\
    \                vowels.push(letter);\n                last_char = letter;\n \
    \               last_letter = letter;\n            } else {\n                last_char\
    \ = letter;\n            }\n        }\n    }\n    vowels.split_last_mut().collect();\n\
    \    new_str.chars().collect::<String>().join(\"\") + &vowels\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0277]: `String` is not an iterator\n  --> /tmp/tmpxvzfxu9f.rs:14:14\n\
    \   |\n14 |     for i in new_str {\n   |              ^^^^^^^ `String` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `String`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `String`\n\nerror[E0599]: no\
    \ method named `split_last_mut` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpxvzfxu9f.rs:25:56\n   |\n25 |             if let Some((vowel, last_letter))\
    \ = vowels.split_last_mut() {\n   |                                          \
    \              ^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `split_at`\n\nerror[E0599]: no method named `split_last_mut` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpxvzfxu9f.rs:32:37\n   |\n\
    32 |         if let Some(vowel) = vowels.split_last_mut() {\n   |            \
    \                         ^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `split_at`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxvzfxu9f.rs:37:27\n\
    \   |\n21 |     let mut last_letter = String::new();\n   |                   \
    \        ------------- expected due to this value\n...\n37 |             last_letter\
    \ = letter;\n   |                           ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |                           |\n   |             \
    \              expected struct `String`, found integer\n\nerror[E0599]: no method\
    \ named `split_last_mut` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpxvzfxu9f.rs:39:41\n   |\n39 |             if let Some(vowel) = vowels.split_last_mut()\
    \ {\n   |                                         ^^^^^^^^^^^^^^ help: there is\
    \ an associated function with a similar name: `split_at`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpxvzfxu9f.rs:41:33\n   |\n41 |                     vowels.push(letter);\n\
    \   |                                 ^^^^^^ expected `char`, found integer\n\n\
    error[E0277]: can't compare `{integer}` with `String`\n  --> /tmp/tmpxvzfx"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.is_empty() { return String::new(); }\n    let mut\
    \ output: String = \"\".to_string();\n    let mut index = 0;\n    loop {\n   \
    \     let c = message[index];\n        if c.is_ascii_lowercase() {\n         \
    \   let value = c.to_ascii_lowercase();\n            if value == \"a\" {\n   \
    \             output += \"t\".to_string();\n            } else if value == \"\
    e\" {\n                output += \"k\".to_string();\n            } else if value\
    \ == \"i\" {\n                output += \"c\".to_string();\n            } else\
    \ if value == \"o\" {\n                output += \"m\".to_string();\n        \
    \    } else if value == \"u\" {\n                output += \"g\".to_string();\n\
    \            } else if value == \"y\" {\n                output += \"s\".to_string();\n\
    \            } else if value == \"t\" {\n                output += \"t\".to_string();\n\
    \            } else if value == \"s\" {\n                output += \"k\".to_string();\n\
    \            } else if value == \"c\" {\n                output += \"c\".to_string();\n\
    \            } else if value == \"g\" {\n                output += \"g\".to_string();\n\
    \            } else if value == \"k\" {\n                output += \"k\".to_string();\n\
    \            } else if value == \"m\" {\n                output += \"m\".to_string();\n\
    \            }\n        } else {\n            if c.is_ascii_uppercase() {\n  \
    \              let value = c.to_ascii_uppercase();\n                if value ==\
    \ \"A\" {\n                    output += \"t\".to_string();\n                }\
    \ else if value == \"E\" {\n                    output += \"k\".to_string();\n\
    \                } else if value == \"I\" {\n                    output += \"\
    c\".to_string();\n                } else if value == \"O\" {\n               \
    \     output += \"m\".to_string();\n                } else if value == \"U\" {\n\
    \                    output += \"g\".to_string();\n                } else if value\
    \ == \"Y\" {\n                    output += \"s\".to_string();\n             \
    \   } else if value == \"T\" {\n                    output += \"t\".to_string();\n\
    \                } else if value == \"S\" {\n                    output += \"\
    k\".to_string();\n                } else if value == \"C\" {\n               \
    \     output += \"c\".to_string();\n                } else if value == \"G\" {\n\
    \                    output += \"g\".to_string();\n                } else if value\
    \ == \"K\" {\n                    output += \"k\".to_string();\n             \
    \   } else if value == \"M\" {\n                    output += \"m\".to_string();\n\
    \                }\n            } else {\n                if c == \"a\" {\n  \
    \                  output += \"t\".to_string();\n                } else if c ==\
    \ \"e\" {\n                    output += \"k\".to_string();\n                \n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpojskutbb.rs:87:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n15 |     loop {\n   |          -\
    \ unclosed delimiter\n...\n44 |         } else {\n   |                - unclosed\
    \ delimiter\n...\n72 |             } else {\n   |                    - unclosed\
    \ delimiter\n...\n75 |                 } else if c == \"e\" {\n   |          \
    \                          - this delimiter might not be properly closed...\n\
    ...\n78 | }\n   | - ...as it matches this but it has different indentation\n...\n\
    87 | }\n   |   ^\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpojskutbb.rs:16:17\n   |\n16 |         let c = message[index];\n\
    \   |                 ^^^^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpojskutbb.rs:20:27\n\
    \   |\n20 |                 output += \"t\".to_string();\n   |               \
    \            ^^^^^^^^^^^^^^^\n   |                           |\n   |         \
    \                  expected `&str`, found struct `String`\n   |              \
    \             help: consider borrowing here: `&\"t\".to_string()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpojskutbb.rs:22:27\n   |\n22 |              \
    \   output += \"k\".to_string();\n   |                           ^^^^^^^^^^^^^^^\n\
    \   |                           |\n   |                           expected `&str`,\
    \ found struct `String`\n   |                           help: consider borrowing\
    \ here: `&\"k\".to_string()`\n\nerror[E0308]: mismatched types\n  --> /t"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // Write a function that takes a message, and encodes in such\
    \ a \n    // way that it swaps case of all letters, replaces all vowels in \n\
    \    // the message with the letter that appears 2 places ahead of \n    // that\
    \ vowel in the english alphabet. \n    \n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmped4uj9p_.rs:11:31\n   |\n\
    11 | fn encode(message: String) -> String {\n   |    ------                  \
    \   ^^^^^^ expected struct `String`, found `()`\n   |    |\n   |    implicitly\
    \ returns `()` as its body has no tail or `return` expression\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = String::new();\n    encoded_message.push_str(message);\n\
    \    encoded_message.push_str(\"TCGKYSS\");\n    for letter in message.chars()\
    \ {\n        let letter_index = alphabet.index(letter);\n        match letter_index\
    \ {\n            Some(index) => { \n                let mut new_letter = String::from(\"\
    \\0\");\n                new_letter.push_str(&alphabet[(index+2)%26]);\n     \
    \           new_letter.push_str(&alphabet[(index+1)%26]);\n                encoded_message.push_str(&new_letter);\n\
    \            },\n            None => { \n                encoded_message.push_str(&alphabet[letter_index\
    \ as usize]);\n            },\n        }\n    }\n    encoded_message\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpovjavnvo.rs:16:28\n\
    \   |\n16 |         let letter_index = alphabet.index(letter);\n   |         \
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `alphabet` in this scope\n  --> /tmp/tmpovjavnvo.rs:20:38\n   |\n20 |\
    \                 new_letter.push_str(&alphabet[(index+2)%26]);\n   |        \
    \                              ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpovjavnvo.rs:21:38\n\
    \   |\n21 |                 new_letter.push_str(&alphabet[(index+1)%26]);\n  \
    \ |                                      ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpovjavnvo.rs:25:43\n\
    \   |\n25 |                 encoded_message.push_str(&alphabet[letter_index as\
    \ usize]);\n   |                                           ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpovjavnvo.rs:13:30\n\
    \   |\n13 |     encoded_message.push_str(message);\n   |                     \
    \         ^^^^^^^\n   |                              |\n   |                 \
    \             expected `&str`, found struct `String`\n   |                   \
    \           help: consider borrowing here: `&message`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut output = String::new();\n    for c in message.chars()\
    \ {\n        // If it is not a letter, just add it.\n        if !c.is_letter()\
    \ {\n            output += c;\n        } else {\n            // Iterate over all\
    \ letters in the alphabet and find the index\n            // of the letter that\
    \ is 2 places ahead of the letter\n            // in the english alphabet. \n\
    \            let mut i = 0;\n            while i < 26 {\n                if c.to_ascii_lowercase()[i]\
    \ == c.to_ascii_lowercase()[(i + 2) % 26] {\n                    i += 2;\n   \
    \                 break;\n                }\n                i += 1;\n       \
    \     }\n            output += c.to_ascii_lowercase()[i..].to_uppercase();\n \
    \       }\n    }\n    output\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp8gxznkce.rs:15:15\n   |\n15 |         if !c.is_letter()\
    \ {\n   |               ^^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp8gxznkce.rs:16:23\n   |\n16 |             output\
    \ += c;\n   |                       ^ expected `&str`, found `char`\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmp8gxznkce.rs:23:20\n\
    \   |\n23 |                 if c.to_ascii_lowercase()[i] == c.to_ascii_lowercase()[(i\
    \ + 2) % 26] {\n   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `char`\n  --> /tmp/tmp8gxznkce.rs:23:49\n\
    \   |\n23 |                 if c.to_ascii_lowercase()[i] == c.to_ascii_lowercase()[(i\
    \ + 2) % 26] {\n   |                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0608]: cannot index into a value of type `char`\n  --> /tmp/tmp8gxznkce.rs:29:23\n\
    \   |\n29 |             output += c.to_ascii_lowercase()[i..].to_uppercase();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded_message = message;\n    encoded_message.chars().enumerate().filter(|(_,\
    \ c)| c.is_letter()).for_each(|(i, _)| {\n        let mut encoded_char = String::new();\n\
    \        if i > 0 {\n            encoded_char.push(encoded_message[i - 1].chars().next().unwrap());\n\
    \        }\n        encoded_char.push((c as u8).to_string());\n        encoded_message[i]\
    \ = encoded_char;\n    });\n    encoded_message\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpli3tapen.rs:18:28\n\
    \   |\n18 |         encoded_char.push((c as u8).to_string());\n   |          \
    \                  ^ help: a local variable with a similar name exists: `i`\n\n\
    error[E0599]: no method named `is_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpli3tapen.rs:13:59\n   |\n13 |     encoded_message.chars().enumerate().filter(|(_,\
    \ c)| c.is_letter()).for_each(|(i, _)| {\n   |                               \
    \                            ^^^^^^^^^ method not found in `&char`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpli3tapen.rs:16:31\n\
    \   |\n16 |             encoded_char.push(encoded_message[i - 1].chars().next().unwrap());\n\
    \   |                               ^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpli3tapen.rs:19:9\n   |\n19 |         encoded_message[i] = encoded_char;\n\
    \   |         ^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut new_message = message.chars();\n    new_message.map(|x|\
    \ match x {\n        'a' => x => 'w',\n        'e' => x => 'w',\n        'i' =>\
    \ x => 'w',\n        'o' => x => 'w',\n        'u' => x => 'w',\n        'A' =>\
    \ x => 'W',\n        'E' => x => 'W',\n        'I' => x => 'W',\n        'O' =>\
    \ x => 'W',\n        'U' => x => 'W',\n        _ => x,\n    });\n    new_message.fold(String::new(),\
    \ |mut acc, elem| {\n        let mut new_elem = elem.clone();\n        new_elem.chars().cloned().for_each(|x|\
    \ {\n            match x {\n                'a' => x += '.',\n               \
    \ 'e' => x += '.',\n                'i' => x += '.',\n                'o' => x\
    \ += '.',\n                'u' => x += '.',\n                'A' => x = '.',\n\
    \                'E' => x = '.',\n                'I' => x = '.',\n          \
    \      'O' => x = '.',\n                'U' => x = '.',\n                _ =>\
    \ (),\n            }\n        });\n        acc.push_str(&new_elem);\n        acc\n\
    \    });\n    new_message\n}\n\nfn main() {\n    let candidate = encode;\n   \
    \ assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n   \
    \ assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"));\n\
    \    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n  \
    \  assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `,`, `.`, `::`, `?`, `{`, `}`, or an operator,\
    \ found `=>`\n  --> /tmp/tmpdpn0ygmy.rs:14:18\n   |\n14 |         'a' => x =>\
    \ 'w',\n   |             --   ^^ expected one of 8 possible tokens\n   |     \
    \        |\n   |             while parsing the `match` arm starting here\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpdpn0ygmy.rs:28:18\n\
    \   |\n28 |         new_elem.chars().cloned().for_each(|x| {\n   |           \
    \       ^^^^^ method not found in `char`\n\nerror[E0368]: binary assignment operation\
    \ `+=` cannot be applied to type `char`\n  --> /tmp/tmpdpn0ygmy.rs:30:24\n   |\n\
    30 |                 'a' => x += '.',\n   |                        -^^^^^^^\n\
    \   |                        |\n   |                        cannot use `+=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpdpn0ygmy.rs:31:24\n   |\n31 |                \
    \ 'e' => x += '.',\n   |                        -^^^^^^^\n   |               \
    \         |\n   |                        cannot use `+=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpdpn0ygmy.rs:32:24\n\
    \   |\n32 |                 'i' => x += '.',\n   |                        -^^^^^^^\n\
    \   |                        |\n   |                        cannot use `+=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpdpn0ygmy.rs:33:24\n   |\n33 |                \
    \ 'o' => x += '.',\n   |                        -^^^^^^^\n   |               \
    \         |\n   |                        cannot use `+=` on type `char`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpdpn0ygmy.rs:34:24\n\
    \   |\n34 |                 'u' => x += '.',\n   |                        -^^^^^^^\n\
    \   |                        |\n   |                        cannot use `+=` on\
    \ type `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpn0ygmy.rs:43:22\n\
    \   |\n43 |         acc.push_str(&new_elem);\n   |       "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n\n    let mut result = String::from(\"\
    G\");\n    \n    for c in message.chars() {\n        if ('A' <= c && c <= 'Z')\
    \ {\n            let mut index = c - 'A' + 1;\n            loop {\n          \
    \      let c = message.chars().nth(index);\n                if ('A' <= c && c\
    \ <= 'Z') {\n                    result += &c.to_string();\n                }\n\
    \                index += 1;\n                if index >= message.len() {\n  \
    \                  break;\n                }\n            }\n        } else {\n\
    \            result += &c.to_string();\n        }\n    }\n\n    result\n}\n\n\
    fn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::ascii::AsciiExt`\n  --> /tmp/tmpdyzjbjpd.rs:12:9\n\
    \   |\n12 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unnecessary\
    \ parentheses around `if` condition\n  --> /tmp/tmpdyzjbjpd.rs:17:12\n   |\n17\
    \ |         if ('A' <= c && c <= 'Z') {\n   |            ^                   \
    \ ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these\
    \ parentheses\n   |\n17 -         if ('A' <= c && c <= 'Z') {\n17 +         if\
    \ 'A' <= c && c <= 'Z' {\n   | \n\nwarning: unnecessary parentheses around `if`\
    \ condition\n  --> /tmp/tmpdyzjbjpd.rs:21:20\n   |\n21 |                 if ('A'\
    \ <= c && c <= 'Z') {\n   |                    ^                    ^\n   |\n\
    help: remove these parentheses\n   |\n21 -                 if ('A' <= c && c <=\
    \ 'Z') {\n21 +                 if 'A' <= c && c <= 'Z' {\n   | \n\nwarning: use\
    \ of deprecated trait `std::ascii::AsciiExt`: use inherent methods instead\n \
    \ --> /tmp/tmpdyzjbjpd.rs:12:21\n   |\n12 |     use std::ascii::AsciiExt;\n  \
    \ |                     ^^^^^^^^\n   |\n   = note: `#[warn(deprecated)]` on by\
    \ default\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpdyzjbjpd.rs:18:31\n\
    \   |\n18 |             let mut index = c - 'A' + 1;\n   |                   \
    \          - ^ --- char\n   |                             |\n   |            \
    \                 char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdyzjbjpd.rs:21:28\n\
    \   |\n21 |                 if ('A' <= c && c <= 'Z') {\n   |                \
    \            ^ expected `char`, found enum `Option`\n   |\n   = note: expected\
    \ type `char`\n              found enum `Option<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdyzjbjpd.rs:21:38\n   |\n21 |                 if ('A' <=\
    \ c && c <= 'Z') {\n   |                                      ^^^ expected enum\
    \ `Option`, found `char`\n   |\n   = note: expected enum `Option<char>`\n    \
    \          found type `char`\nhelp: try wrapping the expression in `Some`\n  \
    \ |\n21 |                 if ('A' <= c && c <= Some('Z')) {\n   |         "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut vowels = HashMap::new();\n    vowels.insert(\"a\".to_string(),\
    \ 2);\n    vowels.insert(\"e\".to_string(), 2);\n    vowels.insert(\"i\".to_string(),\
    \ 2);\n    vowels.insert(\"o\".to_string(), 2);\n    vowels.insert(\"u\".to_string(),\
    \ 2);\n    vowels.insert(\"y\".to_string(), 2);\n    vowels.insert(\"a\".to_string(),\
    \ 4);\n    vowels.insert(\"e\".to_string(), 4);\n    vowels.insert(\"i\".to_string(),\
    \ 4);\n    vowels.insert(\"o\".to_string(), 4);\n    vowels.insert(\"u\".to_string(),\
    \ 4);\n    vowels.insert(\"y\".to_string(), 4);\n    for x in message.chars()\
    \ {\n        let mut current_val = vowels.get(x);\n        if current_val == 2\
    \ {\n            vowels.insert(&String::from_str(\"a\")[current_val].to_string(),\
    \ current_val + 2);\n        } else if current_val == 4 {\n            vowels.insert(&String::from_str(\"\
    e\")[current_val].to_string(), current_val + 2);\n        } else if current_val\
    \ == 4 {\n            vowels.insert(&String::from_str(\"i\")[current_val].to_string(),\
    \ current_val + 2);\n        } else if current_val == 4 {\n            vowels.insert(&String::from_str(\"\
    o\")[current_val].to_string(), current_val + 2);\n        } else if current_val\
    \ == 4 {\n            vowels.insert(&String::from_str(\"u\")[current_val].to_string(),\
    \ current_val + 2);\n        } else if current_val == 4 {\n            vowels.insert(&String::from_str(\"\
    y\")[current_val].to_string(), current_val + 2);\n        }\n    }\n    vowels.into_iter().map(|(_,\
    \ v)| String::from_str(\"a\".to_string())[v]).collect()\n}\n\nfn main() {\n  \
    \  let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpz_f_246o.rs:12:22\n   |\n12 |     let mut vowels = HashMap::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no function or associated item named `from_str` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpz_f_246o.rs:28:36\n   |\n28 |             vowels.insert(&String::from_str(\"\
    a\")[current_val].to_string(), current_val + 2);\n   |                       \
    \             ^^^^^^^^ function or associated item not found in `String`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or\
    \ associated item named `from_str` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpz_f_246o.rs:30:36\n   |\n30 |             vowels.insert(&String::from_str(\"\
    e\")[current_val].to_string(), current_val + 2);\n   |                       \
    \             ^^^^^^^^ function or associated item not found in `String`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or\
    \ associated item named `from_str` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpz_f_246o.rs:32:36\n   |\n32 |             vowels.insert(&String::from_str(\"\
    i\")[current_val].to_string(), current_val + 2);\n   |                       \
    \             ^^^^^^^^ function or associated item not found in `String`\n   |\n\
    \   = help: items from traits can only be used if the trait is in scope\nhelp:\
    \ the following trait is implemented but not in scope; perhaps add a `use` for\
    \ it:\n   |\n1  | use std::str::FromStr;\n   |\n\nerror[E0599]: no function or\
    \ associated item named `from_str` found for struct `String` in the current scope\n\
    \  --> /tmp/t"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // We use an inner struct to help swap case and replace vowels.\n\
    \    struct Replacement {\n        from: String,\n        to: String,\n    }\n\
    \    let mut replacements = vec![Replacement { from: \"A\", to: \"a\" },\n   \
    \     Replacement { from: \"E\", to: \"e\" },\n        Replacement { from: \"\
    I\", to: \"i\" },\n        Replacement { from: \"O\", to: \"o\" },\n        Replacement\
    \ { from: \"U\", to: \"u\" },\n        Replacement { from: \"Y\", to: \"y\" },\n\
    \        Replacement { from: \"\xC1\", to: \"\xE1\" },\n        Replacement {\
    \ from: \"\xC9\", to: \"\xE9\" },\n        Replacement { from: \"\xCD\", to: \"\
    \xED\" },\n        Replacement { from: \"\xD3\", to: \"\xF3\" },\n        Replacement\
    \ { from: \"\xDA\", to: \"\xFA\" },\n        Replacement { from: \"\xDC\", to:\
    \ \"\xFC\" },\n        Replacement { from: \"\xD1\", to: \"\xF1\" },\n       \
    \ Replacement { from: \"\xF1\", to: \"\xF1\" },\n        Replacement { from: \"\
    \xD6\", to: \"\xF6\" },\n        Replacement { from: \"\xD6\", to: \"\xF6\" },\n\
    \        Replacement { from: \"\xDC\", to: \"\xFC\" },\n        Replacement {\
    \ from: \"\u0170\", to: \"\u0171\" },\n        Replacement { from: \"\xD1\", to:\
    \ \"\xF1\" },\n        Replacement { from: \"\u0170\", to: \"\u0171\" },\n   \
    \     Replacement { from: \"\xC7\", to: \"\xE7\" },\n        Replacement { from:\
    \ \"\xD0\", to: \"\xF0\" },\n        Replacement { from: \"\xD6\", to: \"\xF6\"\
    \ },\n        Replacement { from: \"\xDC\", to: \"\xFC\" },\n        Replacement\
    \ { from: \"\xDC\", to: \"\xFC\" },\n        Replacement { from: \"\u015C\", to:\
    \ \"\u015C\" },\n        Replacement { from: \"\xC1\", to: \"\xE1\" },\n     \
    \   Replacement { from: \"\xC9\", to: \"\xE9\" },\n        Replacement { from:\
    \ \"\xCD\", to: \"\xED\" },\n        Replacement { from: \"\xD3\", to: \"\xF3\"\
    \ },\n        Replacement { from: \"\xDA\", to: \"\xFA\" },\n        Replacement\
    \ { from: \"\xDC\", to: \"\xFC\" },\n        Replacement { from: \"\u0170\", to:\
    \ \"\u0171\" },\n        Replacement { from: \"\xD1\", to\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmp05j2e5k9.rs:60:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n17 |     let mut replacements = vec![Replacement\
    \ { from: \"A\", to: \"a\" },\n   |                                - unclosed\
    \ delimiter\n...\n60 | }\n   |   ^\n\nerror: expected one of `.`, `;`, `?`, `else`,\
    \ or an operator, found `}`\n  --> /tmp/tmp05j2e5k9.rs:60:3\n   |\n60 | }\n  \
    \ |   ^ expected one of `.`, `;`, `?`, `else`, or an operator\n\nerror: aborting\
    \ due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    match message.chars() {\n        Some(message) => encode(message,\
    \ vec![]),\n        None => message,\n    }\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpdczsnvsk.rs:13:9\n   |\n\
    12 |     match message.chars() {\n   |           --------------- this expression\
    \ has type `Chars<'_>`\n13 |         Some(message) => encode(message, vec![]),\n\
    \   |         ^^^^^^^^^^^^^ expected struct `Chars`, found enum `Option`\n   |\n\
    \   = note: expected struct `Chars<'_>`\n                found enum `Option<_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdczsnvsk.rs:14:9\n   |\n12 | \
    \    match message.chars() {\n   |           --------------- this expression has\
    \ type `Chars<'_>`\n13 |         Some(message) => encode(message, vec![]),\n14\
    \ |         None => message,\n   |         ^^^^ expected struct `Chars`, found\
    \ enum `Option`\n   |\n   = note: expected struct `Chars<'_>`\n              \
    \  found enum `Option<_>`\n\nerror[E0061]: this function takes 1 argument but\
    \ 2 arguments were supplied\n  --> /tmp/tmpdczsnvsk.rs:13:26\n   |\n13 |     \
    \    Some(message) => encode(message, vec![]),\n   |                         \
    \ ^^^^^^ -------  ------ supplied 2 arguments\n   |                          |\n\
    \   |                          expected 1 argument\n   |\nnote: function defined\
    \ here\n  --> /tmp/tmpdczsnvsk.rs:11:4\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |    ^^^^^^ ---------------\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message(&message).encode_message(&message)\n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0618]: expected function, found `String`\n  --> /tmp/tmp6kd600k6.rs:12:5\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |           ------- `message`\
    \ has type `String`\n12 |     message(&message).encode_message(&message)\n   |\
    \     ^^^^^^^----------\n   |     |\n   |     call expression requires function\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0618`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::new();\n    let mut current_char_pos:\
    \ usize = 0;\n\n    for letter in message {\n        let letter: Char = letter;\n\
    \        let mut new_letter = letter;\n        if letter == ' ' {\n          \
    \  result.push(letter);\n        } else if letter >= 'a' && letter <= 'z' {\n\
    \            new_letter = Char::to('A' + letter as u32 - 'a');\n        } else\
    \ if letter >= 'A' && letter <= 'Z' {\n            new_letter = Char::to('a' +\
    \ letter as u32 - 'A');\n        } else {\n            write!(f, \"Invalid character\
    \ in message: {}\", letter);\n            return String::new();\n        }\n\n\
    \        let mut last_char_pos = 0;\n        while current_char_pos + 1 < message.len()\
    \ {\n            let pos_one = current_char_pos + 1;\n            let pos_two\
    \ = pos_one + 1;\n            if pos_two > message.len() {\n                pos_two\
    \ = message.len();\n            }\n            if pos_two < message.len() && message.bytes().skip(pos_two).next()\
    \ == letter {\n                new_letter = Char::to('A' + new_letter as u32 -\
    \ 'a');\n                current_char_pos = pos_two;\n            } else {\n \
    \               break;\n            }\n            last_char_pos = pos_one;\n\
    \        }\n        result.push(new_letter);\n        current_char_pos = last_char_pos;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpouf3mcaf.rs:21:26\n\
    \   |\n21 |             new_letter = Char::to('A' + letter as u32 - 'a');\n  \
    \ |                          ^^^^ use of undeclared type `Char`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpouf3mcaf.rs:23:26\n\
    \   |\n23 |             new_letter = Char::to('a' + letter as u32 - 'A');\n  \
    \ |                          ^^^^ use of undeclared type `Char`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Char`\n  --> /tmp/tmpouf3mcaf.rs:37:30\n\
    \   |\n37 |                 new_letter = Char::to('A' + new_letter as u32 - 'a');\n\
    \   |                              ^^^^ use of undeclared type `Char`\n\nerror[E0412]:\
    \ cannot find type `Char` in this scope\n  --> /tmp/tmpouf3mcaf.rs:16:21\n   |\n\
    16 |         let letter: Char = letter;\n   |                     ^^^^ help: a\
    \ builtin type with a similar name exists (notice the capitalization): `char`\n\
    \nerror[E0425]: cannot find value `f` in this scope\n  --> /tmp/tmpouf3mcaf.rs:25:20\n\
    \   |\n25 |             write!(f, \"Invalid character in message: {}\", letter);\n\
    \   |                    ^ not found in this scope\n\nerror[E0277]: `String` is\
    \ not an iterator\n  --> /tmp/tmpouf3mcaf.rs:15:19\n   |\n15 |     for letter\
    \ in message {\n   |                   ^^^^^^^ `String` is not an iterator; try\
    \ calling `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not\
    \ implemented for `String`\n   = note: required because of the requirements on\
    \ the impl of `IntoIterator` for `String`\n\nerror[E0369]: cannot add `u32` to\
    \ `char`\n  --> /tmp/tmpouf3mcaf.rs:37:43\n   |\n37 |                 new_letter\
    \ = Char::to('A' + new_letter as u32 - 'a');\n   |                           \
    \            --- ^ ----------------- u32\n   |                               \
    \        |\n   |                                       char\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0277, E0369,\
    \ E0412, E0425, E0433.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    use std::ascii::AsciiExt;\n    use std::ascii::AsciiExt;\n\
    \    use std::ascii::AsciiExt;\n    use std::ascii::AsciiExt;\n    use std::ascii::AsciiExt;\n\
    \n    message.chars().cloned()\n        .map(|c| {\n            match c {\n  \
    \              c if c.is_ascii_lowercase() => c,\n                c if c.is_ascii_uppercase()\
    \ => c,\n                c if c.is_ascii_punctuation() => c,\n               \
    \ c if c.is_ascii_digit() => c,\n                c if c.is_ascii_letter() => c,\n\
    \                _ => c.to_ascii_lowercase().to_ascii_uppercase()\n          \
    \              .to_ascii_punctuation()\n                        .to_ascii_digit()\n\
    \                        .to_ascii_letter()\n            }\n        })\n     \
    \   .collect::<String>()\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0252]: the name `AsciiExt` is defined multiple times\n  --> /tmp/tmpzim1cf_n.rs:13:9\n\
    \   |\n12 |     use std::ascii::AsciiExt;\n   |         -------------------- previous\
    \ import of the trait `AsciiExt` here\n13 |     use std::ascii::AsciiExt;\n  \
    \ |         ^^^^^^^^^^^^^^^^^^^^ `AsciiExt` reimported here\n   |\n   = note:\
    \ `AsciiExt` must be defined only once in the type namespace of this block\n\n\
    error[E0252]: the name `AsciiExt` is defined multiple times\n  --> /tmp/tmpzim1cf_n.rs:14:9\n\
    \   |\n12 |     use std::ascii::AsciiExt;\n   |         -------------------- previous\
    \ import of the trait `AsciiExt` here\n13 |     use std::ascii::AsciiExt;\n14\
    \ |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^ `AsciiExt`\
    \ reimported here\n   |\n   = note: `AsciiExt` must be defined only once in the\
    \ type namespace of this block\n\nerror[E0252]: the name `AsciiExt` is defined\
    \ multiple times\n  --> /tmp/tmpzim1cf_n.rs:15:9\n   |\n12 |     use std::ascii::AsciiExt;\n\
    \   |         -------------------- previous import of the trait `AsciiExt` here\n\
    ...\n15 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^ `AsciiExt`\
    \ reimported here\n   |\n   = note: `AsciiExt` must be defined only once in the\
    \ type namespace of this block\n\nerror[E0252]: the name `AsciiExt` is defined\
    \ multiple times\n  --> /tmp/tmpzim1cf_n.rs:16:9\n   |\n12 |     use std::ascii::AsciiExt;\n\
    \   |         -------------------- previous import of the trait `AsciiExt` here\n\
    ...\n16 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^ `AsciiExt`\
    \ reimported here\n   |\n   = note: `AsciiExt` must be defined only once in the\
    \ type namespace of this block\n\nwarning: the item `AsciiExt` is imported redundantly\n\
    \  --> /tmp/tmpzim1cf_n.rs:13:9\n   |\n12 |     use std::ascii::AsciiExt;\n  \
    \ |         -------------------- the item `AsciiExt` is already imported here\n\
    13 |     use std::ascii::AsciiExt;\n   |         ^^^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import:\
    \ `std::ascii::AsciiExt`\n  --> /tmp/tmpzim1cf_n.rs:13:9\n   |\n13 |     "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoding = HashMap::new();\n    encoding.insert(\"\
    a\".to_string(), 2);\n    encoding.insert(\"e\".to_string(), 2);\n    encoding.insert(\"\
    i\".to_string(), 2);\n    encoding.insert(\"o\".to_string(), 2);\n    encoding.insert(\"\
    u\".to_string(), 2);\n    encoding.insert(\"A\".to_string(), 3);\n    encoding.insert(\"\
    E\".to_string(), 3);\n    encoding.insert(\"I\".to_string(), 3);\n    encoding.insert(\"\
    O\".to_string(), 3);\n    encoding.insert(\"U\".to_string(), 3);\n    encoding.insert(\"\
    b\".to_string(), 2);\n    encoding.insert(\"B\".to_string(), 3);\n    encoding.insert(\"\
    c\".to_string(), 2);\n    encoding.insert(\"C\".to_string(), 3);\n    encoding.insert(\"\
    d\".to_string(), 2);\n    encoding.insert(\"D\".to_string(), 3);\n    encoding.insert(\"\
    f\".to_string(), 2);\n    encoding.insert(\"F\".to_string(), 3);\n    encoding.insert(\"\
    g\".to_string(), 2);\n    encoding.insert(\"G\".to_string(), 3);\n    encoding.insert(\"\
    h\".to_string(), 2);\n    encoding.insert(\"H\".to_string(), 3);\n    encoding.insert(\"\
    j\".to_string(), 2);\n    encoding.insert(\"J\".to_string(), 3);\n    encoding.insert(\"\
    k\".to_string(), 2);\n    encoding.insert(\"K\".to_string(), 3);\n    encoding.insert(\"\
    l\".to_string(), 2);\n    encoding.insert(\"L\".to_string(), 3);\n    encoding.insert(\"\
    m\".to_string(), 2);\n    encoding.insert(\"M\".to_string(), 3);\n    encoding.insert(\"\
    n\".to_string(), 2);\n    encoding.insert(\"N\".to_string(), 3);\n    encoding.insert(\"\
    p\".to_string(), 2);\n    encoding.insert(\"P\".to_string(), 3);\n    encoding.insert(\"\
    r\".to_string(), 2);\n    encoding.insert(\"R\".to_string(), 3);\n    encoding.insert(\"\
    s\".to_string(), 2);\n    encoding.insert(\"S\".to_string(), 3);\n    encoding.insert(\"\
    t\".to_string(), 2);\n    encoding.insert(\"T\".to_string(), 3);\n    encoding.insert(\"\
    v\".to_string(), 2);\n    encoding.insert(\"V\".to_string(), 3);\n    encoding.insert(\"\
    w\".to_string(), 2);\n    encoding.insert(\"W\".to_string(), 3);\n    encoding.insert(\"\
    x\".to_string(), 2);\n    encoding.insert(\"X\".to_string(), 3);\n    encoding.insert(\"\
    y\".to_string(), 2);\n    encoding.insert(\"Y\".to_string(), 3);\n    encoding.insert(\"\
    z\".to_string(), 2);\n    encoding.insert(\"Z\".to_string(), 3);\n    encoding.insert(\"\
    0\".to_string(), 2);\n    encoding.insert(\"1\".to_string(), 3);\n    encoding.insert(\"\
    2\".to_string(), 2);\n    encoding.insert(\"3\".to_string(), 3);\n    encoding.insert(\"\
    4\".to_string(), 2);\n    encoding.insert(\"5\".to_string(), \n}\n\nfn main()\
    \ {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\"\
    )), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpj0a916jy.rs:68:20\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - closing delimiter possibly meant for this\n...\n68 |     encoding.insert(\"\
    5\".to_string(), \n   |                    ^ unclosed delimiter\n69 | }\n   |\
    \ ^ mismatched closing delimiter\n\nerror[E0433]: failed to resolve: use of undeclared\
    \ type `HashMap`\n  --> /tmp/tmpj0a916jy.rs:12:24\n   |\n12 |     let mut encoding\
    \ = HashMap::new();\n   |                        ^^^^^^^ not found in this scope\n\
    \   |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.length() <= 1 {\n        return message;\n    }\n\
    \    let mut s = String::from(\"\");\n    for (i, c) in message.chars().enumerate()\
    \ {\n        if c.is_lowercase() {\n            if i + 1 < message.length() {\n\
    \                if message[i+1] == 'a' || message[i+1] == 'e' || message[i+1]\
    \ == 'i' || message[i+1] == 'o' || message[i+1] == 'u' {\n                   \
    \ s += 'A';\n                } else if message[i+1] == 'b' || message[i+1] ==\
    \ 'c' || message[i+1] == 'd' || message[i+1] == 'f' || message[i+1] == 'g' {\n\
    \                    s += 'B';\n                } else if message[i+1] == 'h'\
    \ || message[i+1] == 'j' || message[i+1] == 'k' || message[i+1] == 'l' || message[i+1]\
    \ == 'm' || message[i+1] == 'n' || message[i+1] == 'p' || message[i+1] == 'q'\
    \ || message[i+1] == 'r' || message[i+1] == 's' || message[i+1] == 't' || message[i+1]\
    \ == 'v' || message[i+1] == 'w' || message[i+1] == 'x' || message[i+1] == 'y'\
    \ || message[i+1] == 'z' {\n                    s += 'C';\n                }\n\
    \                s += message[i+1];\n            }\n        } else {\n       \
    \     if i + 1 < message.length() && message[i+1] == 'A' || message[i+1] == 'E'\
    \ || message[i+1] == 'I' || message[i+1] == 'O' || message[i+1] == 'U' {\n   \
    \             s += 'a';\n            } else if message[i+1] == 'B' || message[i+1]\
    \ == 'C' || message[i+1] == 'D' || message[i+1] == 'F' || message[i+1] == 'G'\
    \ {\n                s += 'b';\n            } else if message[i+1] == 'H' || message[i+1]\
    \ == 'J' || message[i+1] == 'K' || message[i+1] == 'L' || message[i+1] == 'M'\
    \ || message[i+1] == 'N' || message[i+1] == 'P' || message[i+1] == 'Q' || message[i+1]\
    \ == 'R' || message[i+1] == 'S' || message[i+1] == 'T' || message[i+1] == 'V'\
    \ || message[i+1] == 'W' || message[i+1] == 'X' || message[i+1] == 'Y' || message[i+1]\
    \ == 'Z' {\n                s += 'c';\n            }\n            s += message[i+1];\n\
    \        }\n    }\n    String::from(s)\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6t0i45fd.rs:12:16\n   |\n12 |     if message.length()\
    \ <= 1 {\n   |                ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0599]: no method named `length` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp6t0i45fd.rs:18:32\n   |\n18 | \
    \            if i + 1 < message.length() {\n   |                             \
    \   ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp6t0i45fd.rs:19:20\n\
    \   |\n19 |                 if message[i+1] == 'a' || message[i+1] == 'e' || message[i+1]\
    \ == 'i' || message[i+1] == 'o' || message[i+1] == 'u' {\n   |               \
    \     ^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help: the\
    \ trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp6t0i45fd.rs:19:43\n   |\n19 |                 if message[i+1] ==\
    \ 'a' || message[i+1] == 'e' || message[i+1] == 'i' || message[i+1] == 'o' ||\
    \ message[i+1] == 'u' {\n   |                                           ^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \         "
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded: Vec<String> = vec![];\n    for letter in message.chars()\
    \ {\n        if let Some(pos) = letter_to_pos(&letter) {\n            let mut\
    \ prev_pos = pos;\n            prev_pos += 1;\n            while prev_pos < message.len()\
    \ {\n                let mut curr_pos = pos;\n                curr_pos -= 1;\n\
    \                if curr_pos < 0 {\n                    break;\n             \
    \   }\n                if letter_to_pos(&message.chars()[prev_pos]) != Some(curr_pos)\
    \ {\n                    break;\n                }\n                encoded.push(message.chars()[prev_pos]);\n\
    \                prev_pos += 1;\n            }\n        }\n        encoded.push(letter);\n\
    \    }\n    encode(encoded)\n}\n\nfn main() {\n    let candidate = encode;\n \
    \   assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n \
    \   assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `letter_to_pos` in this scope\n  -->\
    \ /tmp/tmp9x6nmgj1.rs:14:28\n   |\n14 |         if let Some(pos) = letter_to_pos(&letter)\
    \ {\n   |                            ^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `letter_to_pos` in this scope\n  --> /tmp/tmp9x6nmgj1.rs:23:20\n\
    \   |\n23 |                 if letter_to_pos(&message.chars()[prev_pos]) != Some(curr_pos)\
    \ {\n   |                    ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp9x6nmgj1.rs:23:35\n\
    \   |\n23 |                 if letter_to_pos(&message.chars()[prev_pos]) != Some(curr_pos)\
    \ {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0608]:\
    \ cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp9x6nmgj1.rs:26:30\n\
    \   |\n26 |                 encoded.push(message.chars()[prev_pos]);\n   |   \
    \                           ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9x6nmgj1.rs:30:22\n   |\n30 |         encoded.push(letter);\n\
    \   |                      ^^^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                      |\n   |                      expected struct `String`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp9x6nmgj1.rs:32:12\n\
    \   |\n32 |     encode(encoded)\n   |            ^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<String>`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0608.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut alphabet = alphabet_lowercase();\n    let mut vowels\
    \ = vowels();\n    let mut output: String = String::new();\n    let mut first_letter\
    \ = String::new();\n    let mut second_letter = String::new();\n    let mut third_letter\
    \ = String::new();\n    message.chars().for_each(|c| {\n        if c == 'a' {\n\
    \            first_letter = first_letter.chars().next().unwrap();\n        }\n\
    \        if c == 'e' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'i' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'o' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'u' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'A' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'E' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'I' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'O' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'U' {\n            first_letter = first_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'b' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'p' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'd' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 't' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'g' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'f' {\n            second_letter = second_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'h' {\n            third_letter = third_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'r' {\n            third_letter = third_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'l' {\n            third_letter = third_letter.chars().next().unwrap();\n\
    \        }\n        if c == 'c' {\n            third_letter = third_letter.chars().next().unwrap();\n\
    \        }\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmphvk06014.rs:88:3\n\
    \   |\n11 | fn encode(message: String) -> String {\n   |                     \
    \                 - unclosed delimiter\n...\n18 |     message.chars().for_each(|c|\
    \ {\n   |                             - unclosed delimiter\n...\n88 | }\n   |\
    \   ^\n\nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found keyword\
    \ `fn`\n  --> /tmp/tmphvk06014.rs:81:1\n   |\n79 | }\n   |  - expected one of\
    \ `)`, `,`, `.`, `?`, or an operator\n80 | \n81 | fn main() {\n   | ^^ unexpected\
    \ token\n\nerror: aborting due to 2 previous errors\n\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    message.chars()\n        .flat_map(|c| if c.is_ascii_lowercase()\
    \ { Ok(c) } else { Err(c.into()) })\n        .fold(String::new(), |mut acc, c|\
    \ {\n            let mut new_letter = if c.is_ascii_lowercase() { c.to_ascii_lowercase()\
    \ } else { c };\n            if let Some(vowel) = vowels.find(new_letter) {\n\
    \                new_letter = vowels[vowel].clone();\n            }\n        \
    \    acc.push_str(new_letter);\n            acc.push(' ');\n            acc\n\
    \        })\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `vowels` in this scope\n  --> /tmp/tmpii__8e2s.rs:16:34\n\
    \   |\n16 |             if let Some(vowel) = vowels.find(new_letter) {\n   | \
    \                                 ^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `vowels` in this scope\n  --> /tmp/tmpii__8e2s.rs:17:30\n\
    \   |\n17 |                 new_letter = vowels[vowel].clone();\n   |        \
    \                      ^^^^^^ help: a local variable with a similar name exists:\
    \ `vowel`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpii__8e2s.rs:19:26\n\
    \   |\n19 |             acc.push_str(new_letter);\n   |                      \
    \    ^^^^^^^^^^ expected `&str`, found `char`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut s = message.clone();\n    for &c in s.chars() {\n \
    \       match c {\n            'a' ... 'z' => s.swapcase(),\n            'A' ...\
    \ 'Z' => s.swapcase(),\n            c => {\n                let i = &c as usize;\n\
    \                let c = &c as char;\n                let c = i as char + (i as\
    \ i64 - 1);\n                s.replace(i, c, c);\n            }\n        }\n \
    \   }\n    s\n}\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "warning: `...` range patterns are deprecated\n  --> /tmp/tmp3s6ri3l9.rs:15:17\n\
    \   |\n15 |             'a' ... 'z' => s.swapcase(),\n   |                 ^^^\
    \ help: use `..=` for an inclusive range\n   |\n   = note: `#[warn(ellipsis_inclusive_range_patterns)]`\
    \ on by default\n   = warning: this is accepted in the current edition (Rust 2015)\
    \ but is a hard error in Rust 2021!\n   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nwarning: `...` range patterns are deprecated\n  --> /tmp/tmp3s6ri3l9.rs:16:17\n\
    \   |\n16 |             'A' ... 'Z' => s.swapcase(),\n   |                 ^^^\
    \ help: use `..=` for an inclusive range\n   |\n   = warning: this is accepted\
    \ in the current edition (Rust 2015) but is a hard error in Rust 2021!\n   = note:\
    \ for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/warnings-promoted-to-error.html>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp3s6ri3l9.rs:13:9\n   |\n13 | \
    \    for &c in s.chars() {\n   |         ^^    --------- this expression has type\
    \ `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp3s6ri3l9.rs:15:30\n   |\n15 |             'a' ... 'z' => s.swapcase(),\n\
    \   |                              ^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `swapcase` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp3s6ri3l9.rs:16:30\n   |\n16 |             'A' ... 'Z' => s.swapcase(),\n\
    \   |                              ^^^^^^^^ method not found in `String`\n\nerror[E0369]:\
    \ cannot add `i64` to `char`\n  --> /tmp/tmp3s6ri3l9.rs:20:35\n   |\n20 |    \
    \             let c = i as char + (i as i64 - 1);\n   |                      \
    \   --------- ^ -------------- i64\n   |                         |\n   |     \
    \                    char\n\nerror[E"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut ascii_map = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    let mut vowels = String::from(\"aeiou\");\n    let mut result = String::from(\"\
    \");\n    let mut vowel_index = 0;\n    for c in message.chars() {\n        if\
    \ ascii_map.contains_key(&c.to_ascii_lowercase()) {\n            let ascii_lowercase\
    \ = ascii_map.get(&c.to_ascii_lowercase());\n            result.push((ascii_lowercase\
    \ as char).to_ascii_lowercase());\n        } else {\n            result.push(ascii_map.get(&c).unwrap().to_ascii_lowercase());\n\
    \        }\n    }\n    for c in result.chars() {\n        if !vowels.contains(&c)\
    \ {\n            let vowel_before = &vowels[vowel_index];\n            vowels[vowel_index]\
    \ = c;\n            vowel_index += 2;\n            vowels[vowel_index] = vowel_before;\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `contains_key` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp166ivz2w.rs:17:22\n   |\n17 |         if\
    \ ascii_map.contains_key(&c.to_ascii_lowercase()) {\n   |                    \
    \  ^^^^^^^^^^^^ help: there is an associated function with a similar name: `contains`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `&char`\n   --> /tmp/tmp166ivz2w.rs:18:49\n\
    \    |\n18  |             let ascii_lowercase = ascii_map.get(&c.to_ascii_lowercase());\n\
    \    |                                             --- ^^^^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n    |                                \
    \             |\n    |                                             required by\
    \ a bound introduced by this call\n    |\n    = help: the trait `SliceIndex<str>`\
    \ is not implemented for `&char`\nnote: required by a bound in `core::str::<impl\
    \ str>::get`\n\nerror[E0277]: the type `str` cannot be indexed by `&char`\n  \
    \ --> /tmp/tmp166ivz2w.rs:21:39\n    |\n21  |             result.push(ascii_map.get(&c).unwrap().to_ascii_lowercase());\n\
    \    |                                   --- ^^ string indices are ranges of `usize`\n\
    \    |                                   |\n    |                            \
    \       required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `SliceIndex<str>` is not implemented for `&char`\nnote: required by a bound\
    \ in `core::str::<impl str>::get`\n\nerror[E0277]: expected a `Fn<(char,)>` closure,\
    \ found `char`\n    --> /tmp/tmp166ivz2w.rs:25:29\n     |\n25   |         if !vowels.contains(&c)\
    \ {\n     |                    -------- ^^ expected an `Fn<(char,)>` closure,\
    \ found `char`\n     |                    |\n     |                    required\
    \ by a bound introduced by this call\n     |\n     = help: the trait `Fn<(char,)>`\
    \ is not implemented for `char`\n     = note: required because of the requirements\
    \ on the impl of `FnOnce<(char,)>` for `&char`\n     = note: required because\
    \ of the requirements on the impl of `Pattern<'_>` for `&char`\nnote: required\
    \ by a bound in `core::str::<impl str>::contai"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    if message.islower() {\n        encode(message.to_string().to_lowercase())\n\
    \    } else {\n        encode(message.to_string())\n    }\n}\n\nfn main() {\n\
    \    let candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")),\
    \ String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `islower` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1l6b0r17.rs:12:16\n   |\n12 |     if message.islower()\
    \ {\n   |                ^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    // Only letters. \n    let mut counter = 0;\n    let mut result\
    \ = 0;\n    let mut alphabet = ALPHABET.iter().cloned().collect::<Vec<_>>();\n\
    \    let mut vowels = Vowels.iter().cloned().collect::<Vec<_>>();\n\n    for c\
    \ in message.chars() {\n        // Increment the counter each time we encounter\
    \ a vowel. \n        if vowels.contains(&c) { \n            counter += 1;\n  \
    \      } else {\n            counter = 0;\n        }\n        // If the letter\
    \ is found, decrement the counter by 2 if there \n        // are two vowels ahead\
    \ of it. \n        if alphabet.contains(&c) {\n            counter -= 2;\n   \
    \     }\n        // If there are two vowels ahead of the letter, add the letter.\
    \ \n        // Otherwise, add the letter and a vowel. \n        if counter > 0\
    \ {\n            result = result + ((c - alphabet[alphabet.len() - counter as\
    \ usize]) as u8);\n        } else {\n            result = result + ((c + vowels[counter\
    \ as usize]) as u8);\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpud03l3e4.rs:15:24\n\
    \   |\n15 |     let mut alphabet = ALPHABET.iter().cloned().collect::<Vec<_>>();\n\
    \   |                        ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `Vowels` in this scope\n  --> /tmp/tmpud03l3e4.rs:16:22\n\
    \   |\n16 |     let mut vowels = Vowels.iter().cloned().collect::<Vec<_>>();\n\
    \   |                      ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpud03l3e4.rs:38:5\n   |\n11 | fn encode(message: String)\
    \ -> String {\n   |                               ------ expected `String` because\
    \ of return type\n...\n38 |     result\n   |     ^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ integer\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = message;\n    encoded.chars().filter_map(|c|\
    \ \n        match c.to_ascii_lowercase() {\n            \"a\" => \"A\",\n    \
    \        \"b\" => \"B\",\n            \"c\" => \"C\",\n            \"d\" => \"\
    D\",\n            \"e\" => \"E\",\n            \"f\" => \"F\",\n            \"\
    g\" => \"G\",\n            \"h\" => \"H\",\n            \"i\" => \"I\",\n    \
    \        \"j\" => \"J\",\n            \"k\" => \"K\",\n            \"l\" => \"\
    L\",\n            \"m\" => \"M\",\n            \"n\" => \"N\",\n            \"\
    o\" => \"O\",\n            \"p\" => \"P\",\n            \"q\" => \"Q\",\n    \
    \        \"r\" => \"R\",\n            \"s\" => \"S\",\n            \"t\" => \"\
    T\",\n            \"u\" => \"U\",\n            \"v\" => \"V\",\n            \"\
    w\" => \"W\",\n            \"x\" => \"X\",\n            \"y\" => \"Y\",\n    \
    \        \"z\" => \"Z\",\n            _ => \"\"\n        }).\n        filter(|c|\
    \ c != \"a\" && c != \"b\" && c != \"c\" && c != \"d\" && c != \"e\" && c != \"\
    f\" && c != \"g\" && c != \"h\" && c != \"i\" && c != \"j\" && c != \"k\" && c\
    \ != \"l\" && c != \"m\" && c != \"n\" && c != \"o\" && c != \"p\" && c != \"\
    q\" && c != \"r\" && c != \"s\" && c != \"t\" && c != \"u\" && c != \"v\" && c\
    \ != \"w\" && c != \"x\" && c != \"y\" && c != \"z\").\n        map(|c| match\
    \ c {\n            \"a\" => \"a\",\n            \"b\" => \"b\",\n            \"\
    c\" => \"c\",\n            \"d\" => \"d\",\n            \"e\" => \"e\",\n    \
    \        \"f\" => \"f\",\n            \"g\" => \"g\",\n            \"h\" => \"\
    h\",\n            \"i\" => \"i\",\n            \"j\" => \"j\",\n            \"\
    k\" => \"k\",\n            \"l\" => \"l\",\n            \"m\" => \"m\",\n    \
    \        \"n\" => \"n\",\n            \"o\" => \"o\",\n            \"p\" => \"\
    p\",\n            \"q\" => \"q\",\n            \"r\" => \"r\",\n            \"\
    s\" => \"s\",\n            \"t\" => \"t\",\n            \"u\" => \"u\",\n    \
    \        \"v\" => \"v\",\n            \"w\" => \"w\",\n            \"x\" => \"\
    x\",\n            \"y\" => \"y\",\n            \"z\" => \"z\",\n            _\
    \ => \"\"\n        }).collect::<String\n}\n\nfn main() {\n    let candidate =\
    \ encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"\
    ));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `+`, `,`, `::`, `:`, `<`, `=`, or `>`,\
    \ found `}`\n  --> /tmp/tmp478hjunj.rs:73:1\n   |\n72 |         }).collect::<String\n\
    \   |                            - expected one of 9 possible tokens\n73 | }\n\
    \   | ^ unexpected token\n   |\nhelp: you might have meant to end the type parameters\
    \ here\n   |\n72 |         }).collect::<String>\n   |                        \
    \    +\n\nerror: aborting due to previous error\n\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::from(\"A\");\n\n    for x in message.chars()\
    \ {\n        if x.is_alphabetic() {\n            encoded += x.swapcase();\n  \
    \      } else {\n            encoded += x;\n        }\n    }\n\n    encoded\n\
    }\n\nfn main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swapcase` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpucfmo4ac.rs:16:26\n   |\n16 |             encoded += x.swapcase();\n\
    \   |                          ^^^^^^^^ method not found in `char`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpucfmo4ac.rs:18:24\n   |\n18 |             encoded\
    \ += x;\n   |                        ^ expected `&str`, found `char`\n\nerror:\
    \ aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    encode_with_maps(message)\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encode_with_maps` in this scope\n \
    \ --> /tmp/tmp7kajnkv5.rs:12:5\n   |\n12 |     encode_with_maps(message)\n   |\
    \     ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut swap = String::new();\n    let mut result = String::new();\n\
    \    let mut i = 1;\n    let mut j = message.len() - 1;\n\n    while i <= j {\n\
    \        if message[i] == message[j] {\n            swap.push((message[i] + 'a').to_string());\n\
    \            i += 1;\n            j -= 1;\n        } else {\n            swap.push((message[i]\
    \ + 'A').to_string());\n            i += 1;\n        }\n    }\n\n    while i <=\
    \ j {\n        result.push((swap[i] + message[j]).to_string());\n        i +=\
    \ 1;\n        j -= 1;\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encode;\n    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"\
    tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"\
    mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"\
    ygs\"));\n    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpshdjn_4j.rs:18:12\n\
    \   |\n18 |         if message[i] == message[j] {\n   |            ^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpshdjn_4j.rs:18:26\n   |\n18 |         if message[i] == message[j]\
    \ {\n   |                          ^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpshdjn_4j.rs:19:24\n   |\n19 |             swap.push((message[i]\
    \ + 'a').to_string());\n   |                        ^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usi"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut encoded = String::new();\n\n    for i in 0..message.len()\
    \ {\n        let c = message.chars()[i];\n\n        if ('a' <= c && c <= 'z')\
    \ {\n            encoded.push_str(&encode(&message[..i]).unwrap());\n        }\
    \ else {\n            encoded.push_str(&encode(&message[(i + 2) as usize..]).unwrap());\n\
    \        }\n    }\n\n    encoded\n}\n\nfn main() {\n    let candidate = encode;\n\
    \    assert_eq!(candidate(String::from(\"TEST\")), String::from(\"tgst\"));\n\
    \    assert_eq!(candidate(String::from(\"Mudasir\")), String::from(\"mWDCSKR\"\
    ));\n    assert_eq!(candidate(String::from(\"YES\")), String::from(\"ygs\"));\n\
    \    assert_eq!(candidate(String::from(\"This is a message\")), String::from(\"\
    tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"I DoNt KnOw WhAt\
    \ tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around `if` condition\n  --> /tmp/tmp4gut4z5s.rs:17:12\n\
    \   |\n17 |         if ('a' <= c && c <= 'z') {\n   |            ^           \
    \         ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove\
    \ these parentheses\n   |\n17 -         if ('a' <= c && c <= 'z') {\n17 +    \
    \     if 'a' <= c && c <= 'z' {\n   | \n\nerror[E0608]: cannot index into a value\
    \ of type `Chars<'_>`\n  --> /tmp/tmp4gut4z5s.rs:15:17\n   |\n15 |         let\
    \ c = message.chars()[i];\n   |                 ^^^^^^^^^^^^^^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp4gut4z5s.rs:18:38\n   |\n18 |             encoded.push_str(&encode(&message[..i]).unwrap());\n\
    \   |                                      ^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\nhelp: try using a conversion method\n   |\n18 |        \
    \     encoded.push_str(&encode((&message[..i]).to_string()).unwrap());\n   | \
    \                                     +             +++++++++++++\n\nerror[E0599]:\
    \ no method named `unwrap` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp4gut4z5s.rs:18:53\n   |\n18 |             encoded.push_str(&encode(&message[..i]).unwrap());\n\
    \   |                                                     ^^^^^^ method not found\
    \ in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4gut4z5s.rs:20:38\n\
    \   |\n20 |             encoded.push_str(&encode(&message[(i + 2) as usize..]).unwrap());\n\
    \   |                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n20 |             encoded.push_str(&encode((&message[(i + 2) as usize..]).to_string()).unwrap());\n\
    \   |                                      +                            +++++++++++++\n\
    \nerror[E0599]: no method named `unwrap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4gut4z5s.rs:20:68\n   |\n20 |             encoded.push_str(&encode(&message[(i\
    \ + 2) as usize..]).unwrap());\n   |                                         \
    \                           ^^^^^^ method not found in `String`\n"
  stdout: ''
  timestamp: 1660009269
- exit_code: 1
  program: "/// Write a function that takes a message, and encodes in such a \n///\
    \ way that it swaps case of all letters, replaces all vowels in \n/// the message\
    \ with the letter that appears 2 places ahead of that \n/// vowel in the english\
    \ alphabet. \n/// Assume only letters. \n/// Examples:\n/// >>> encode(String::from(\"\
    test\"))\n/// String::from(\"TGST\")\n/// >>> encode(String::from(\"This is a\
    \ message\"))\n/// String::from(\"tHKS KS C MGSSCGG\")\nfn encode(message: String)\
    \ -> String {\n    let mut result = String::from(\"tHKS KS C MGSSCGG\");\n   \
    \ \n    for c in message.chars().cloned() {\n        if let Some(i) = result.find(c)\
    \ {\n            let j = i - 2;\n            result[j].as_mut_ptr().0 = c.to_ascii_lowercase();\n\
    \            result[j+1].as_mut_ptr().0 = c.to_ascii_lowercase();\n        } else\
    \ {\n            result.push(c);\n        }\n    }\n    \n    result\n}\n\nfn\
    \ main() {\n    let candidate = encode;\n    assert_eq!(candidate(String::from(\"\
    TEST\")), String::from(\"tgst\"));\n    assert_eq!(candidate(String::from(\"Mudasir\"\
    )), String::from(\"mWDCSKR\"));\n    assert_eq!(candidate(String::from(\"YES\"\
    )), String::from(\"ygs\"));\n    assert_eq!(candidate(String::from(\"This is a\
    \ message\")), String::from(\"tHKS KS C MGSSCGG\"));\n    assert_eq!(candidate(String::from(\"\
    I DoNt KnOw WhAt tO WrItE\")), String::from(\"k dQnT kNqW wHcT Tq wRkTg\"));\n\
    }\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpwnt6m48w.rs:14:30\n     |\n14   |     for c in message.chars().cloned()\
    \ {\n     |                              ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpwnt6m48w.rs:14:14\n\
    \   |\n14 |     for c in message.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpwnt6m48w.rs:14:14\n   |\n14 |     for c in message.chars().cloned()\
    \ {\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwnt6m48w.rs:17:13\n\
    \   |\n17 |             result[j].as_mut_ptr().0 = c.to_ascii_lowercase();\n \
    \  |             ^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tm"
  stdout: ''
  timestamp: 1660009269
