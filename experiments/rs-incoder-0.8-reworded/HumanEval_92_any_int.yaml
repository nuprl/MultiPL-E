name: HumanEval_92_any_int
language: rs
prompt: "/// Create a function that takes 3 numbers.\n/// Returns true if one of the\
  \ numbers is equal to the sum of the other two, and all numbers are integers.\n\
  /// Returns false in any other cases.\n/// Examples\n/// >>> any_int(5, 2, 7)\n\
  /// true\n/// >>> any_int(3, 2, 2)\n/// false\n/// >>> any_int(3, -2, 1)\n/// true\n\
  /// >>> any_int(3.6, -2.2, 2)\n/// false\nfn any_int(x: f64, y: f64, z: f64) ->\
  \ bool {\n"
tests: "}\n\nfn main() {\n    let candidate = any_int;\n    assert_eq!(candidate(2.0,\
  \ 3.0, 1.0), true);\n    assert_eq!(candidate(2.5, 2.0, 3.0), false);\n    assert_eq!(candidate(1.5,\
  \ 5.0, 3.5), false);\n    assert_eq!(candidate(2.0, 6.0, 2.0), false);\n    assert_eq!(candidate(4.0,\
  \ 2.0, 2.0), true);\n    assert_eq!(candidate(2.2, 2.2, 2.2), false);\n    assert_eq!(candidate(-4.0,\
  \ 6.0, 2.0), true);\n    assert_eq!(candidate(2.0, 1.0, 1.0), true);\n    assert_eq!(candidate(3.0,\
  \ 4.0, 7.0), true);\n    assert_eq!(candidate(3.0, 4.0, 7.0), false);\n}\n"
completions: ["    let x1 = x.into();\n    let x2 = y.into();\n    let x3 = z.into();\n\
    \    (x1 == x2 || x1 == x3 || x2 == x3 || (x1 - x2) * (x1 - x3) == (x3 - y) *\
    \ (x3 - y))", '    x <= x + y && x <= x + z && x <= y + z && x <= z + y', '    x
    <= z && z <= y && x.is_integer() && y.is_integer() && z.is_integer()', "    let\
    \ x_int: i64 = x.into();\n    let y_int: i64 = y.into();\n    let z_int: i64 =\
    \ z.into();\n    let sum = x_int + y_int + z_int;\n    x_int == sum\n        ||\
    \ y_int == sum\n        || z_int == sum\n        || (x_int < y_int)\n        ||\
    \ (x_int < z_int)\n        || (y_int < z_int)", "    if x == z {\n        // \"\
    Any\" is a special case:\n        // We know that x + y == z\n        // and all\
    \ 3 numbers are integers\n        true\n    } else if y == z {\n        true\n\
    \    } else {\n        x < y || y < x\n    }", "    x.is_integer()\n        ||\
    \ y.is_integer()\n        || z.is_integer()\n        || (x >= y && x >= z)\n \
    \       || (y >= x && y >= z)\n        || (z >= x && z >= y)", "    let sum =\
    \ x + y + z;\n    sum != f64::INFINITY\n        && sum != f64::NEG_INFINITY\n\
    \        && sum != f64::NAN\n        && sum.floor() as i64\n        == z", " \
    \   if x == x + y || x == x + z || y == y + z {\n        true\n    } else {\n\
    \        false\n    }", "    x != 0.0\n        && y != 0.0\n        && z != 0.0\n\
    \        && x.is_integer() && y.is_integer() && z.is_integer()\n        && x +\
    \ y + z == f64::from(x + y + z)", '    x >= y && x >= z && y >= z', '    x <=
    y && y <= x && x <= z && z <= x', "    let sum = x + y + z;\n    match sum {\n\
    \        x if x == z => true,\n        _ => false,\n    }", "    let x_int = x.floor()\
    \ as f64 as i32;\n    let y_int = y.floor() as f64 as i32;\n    let z_int = z.floor()\
    \ as f64 as i32;\n    if x_int == y_int && y_int == z_int {\n        return true;\n\
    \    }\n    if x_int != x_int {\n        return false;\n    }\n    if y_int !=\
    \ y_int {\n        return false;\n    }\n    if z_int != z_int {\n        return\
    \ false;\n    }\n    false", "    x != 0.0 && y != 0.0 && z != 0.0 &&\n    x ==\
    \ y + z", "    match x, y, z {\n        (0...).any(|&x| x == y) as _,\n      \
    \  _ as _,\n        _ as _,\n        _ => false,\n    }", '    (x != 0 || y !=
    0 || z != 0) && (x.abs() == y.abs() + z.abs()).is_ok()', "    match x + y {\n\
    \        z => {\n            let x: isize = x.checked_add::<isize>(z).unwrap();\n\
    \            let y: isize = y.checked_add::<isize>(z).unwrap();\n            if\
    \ x > y {\n                true\n            } else {\n                false\n\
    \            }\n        }\n        _ => false,\n    }", "    match x.checked_add(y).unwrap_or(z).checked_div(z)\
    \ {\n        Some(Ok(())) => true,\n        Some(Err(_)) => false,\n        _\
    \ => panic!(\"any_int: x, y, z must be integers!\"),\n    }", '    x.round() ==
    x.round() || y.round() == y.round() || z.round() == z.round()', "    x <= y +\
    \ z &&\n    x >= y - z &&\n    x * x + y * y + z * z > 0", '    x.checked_add(y).is_one()
    || x.checked_add(z).is_one() || y.checked_add(z).is_one()', "    x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n        && x <= y && y <= z && z <= x",
  "    x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer() &&\n \
    \       x.unwrap() + y.unwrap() + z.unwrap() == x.unwrap() + y.unwrap() + z.unwrap()",
  "    let res = x + y + z as f64;\n    match res {\n        0 => false,\n       \
    \ x => true,\n        _ => false,\n    }", '    x <= x + y && x <= x + z && x
    <= z + x && x <= y + z', "    let x_int = x.floor();\n    let y_int = y.floor();\n\
    \    let z_int = z.floor();\n\n    x_int + y_int + z_int == x.checked_add(y).checked_add(z).unwrap()",
  "    let (mut x_int, mut y_int, mut z_int) = (x, y, z);\n    while let Some(Some(_))\
    \ = (x_int, y_int, z_int).as_mut() {\n        x_int = x_int.unwrap().try_into().unwrap();\n\
    \        y_int = y_int.unwrap().try_into().unwrap();\n        z_int = z_int.unwrap().try_into().unwrap();\n\
    \    }\n    x_int == y_int && x_int == z_int", "    let z = z as i32;\n    let\
    \ y = y as i32;\n    let x = x as i32;\n    x >= z && x <= y + z && x >= y &&\
    \ x <= z + y", "    if x != x + y && x != y + z {\n        return false;\n   \
    \ }\n    true", "    let x: f64 = x.floor();\n    let y: f64 = y.floor();\n  \
    \  let z: f64 = z.floor();\n    (x.checked_add(y).and_then(|x| x.checked_add(z).unwrap_or(x.checked_sub(z).unwrap_or(x.checked_mul(1.0f64).unwrap_or(1.0f64)))\
    \ == x) == x", '    (x + y) == z && x == f64::from(z) && y == f64::from(z)', '    any_int(x.round(),
    y, z)', '    (x * y + z) == 0', "    if x.trun() <= y.trun() && y.trun() <= z.trun()\
    \ {\n        true\n    } else {\n        false\n    }", "    match (x, y, z) {\n\
    \        (x + y, x + z, x + y) || (x + z, x + z, x) => true,\n        _ => false,\n\
    \    }", '    x != z && y != z && (x.trunc() == z || y.trunc() == z)', "    let\
    \ x: f64 = x.floor();\n    let y: f64 = y.floor();\n    let z: f64 = z.floor();\n\
    \    if x <= y && y <= z && z <= x {\n        return true;\n    }\n    else {\n\
    \        return false;\n    }", "    if x == z && y == z {\n        true\n   \
    \ } else if x < z && y < z {\n        x < z && y < z\n    } else if x < z {\n\
    \        x < z && x == z\n    } else if y < z {\n        y < z && y == z\n   \
    \ } else {\n        false\n    }", '    x.is_integer() && y.is_integer() && z.is_integer()
    && x + y + z == f64::from(x.to_f64()) + f64::from(y.to_f64()) + f64::from(z.to_f64())',
  "    match x + y {\n        z @ _ as f => f >= x,\n        _ => false,\n    }",
  "    fn check(a: &f64, b: &f64, c: &f64) -> bool {\n        if a == b + c && a +\
    \ b == c {\n            true\n        } else {\n            false\n        }\n\
    \    }\n    check(&x, &y, &z)", "    let x = x as i32;\n    let y = y as i32;\n\
    \    let z = z as i32;\n    (x != 0 || y != 0 || z != 0) && (x != 0 && y != 0\
    \ && z != 0)", "    x.is_integer() && y.is_integer() && z.is_integer()\n     \
    \   && x.checked_add(y).checked_add(z).is_some()", "    let x_int = x as i32;\n\
    \    let y_int = y as i32;\n    let z_int = z as i32;\n\n    match x_int, y_int,\
    \ z_int {\n        (0, 0, 0) | _, _, _ => true,\n        _, _ => false,\n    \
    \    _ => true\n    }", "    if x < y && x < z && y < z {\n        // Check all\
    \ three numbers\n        true\n    } else if x < y && y < z && z < x {\n     \
    \   // Check two of three numbers\n        true\n    } else if y < z && z < x\
    \ && x < y {\n        // Check two of three numbers\n        true\n    } else\
    \ if z < x && x < y && y < z {\n        // Check all three numbers\n        true\n\
    \    } else {\n        // No match\n        false\n    }", "    if x == z && y\
    \ == z || (x == z && y < z) || (x < z && y != z && y != z) {\n        return true;\n\
    \    }\n    false", '    x != 0.0 && y != 0.0 && z != 0.0 && (x + y + z == 0.0)',
  "    // If one of the numbers is smaller than the sum, they are equal.\n    if x\
    \ < z && y < z {\n        return true;\n    }\n\n    // If one of the numbers\
    \ is greater than the sum, they are equal.\n    if x > z && y > z {\n        return\
    \ true;\n    }\n\n    // If no numbers are equal, they are equal.\n    if x ==\
    \ z && y == z {\n        return true;\n    }\n\n    // If one number is less than\
    \ the sum, they are equal.\n    if x < z {\n        return true;\n    }\n\n  \
    \  // If one number is greater than the sum, they are equal.\n    if x > z {\n\
    \        return true;\n    }\n\n    // If none of the above conditions apply,\
    \ they are equal.\n    return false;", '    x.is_integer() && x.is_integer() &&
    y.is_integer() && z.is_integer() && x.checked_add(y).is_ok() && y.checked_add(z).is_ok()
    && z.checked_add(z).is_ok()', '    any_int_impl(x, y, z)', '    x <= y + z &&
    y <= x + z && x <= y + z', "    if x == z {\n        true\n    } else if x ==\
    \ y {\n        false\n    } else {\n        true\n    }", "    debug_assert!(x.is_integer());\n\
    \    debug_assert!(y.is_integer());\n    debug_assert!(z.is_integer());\n\n  \
    \  x > y && x > z && y > z &&\n    (x.checked_add(y).is_some() || z.checked_add(y).is_some())",
  '    (x / y == x + z) || (x % y == -x % z) || (y % z == -y % z)', "    if f64::from(x)\
    \ != f64::from(y) || f64::from(x) != f64::from(z) {\n        return false;\n \
    \   }\n    let x: i32 = f64::from(x).try_into().unwrap();\n    let y: i32 = f64::from(y).try_into().unwrap();\n\
    \    let z: i32 = f64::from(z).try_into().unwrap();\n    if x != y || x != z {\n\
    \        return false;\n    }\n    true", "    match x {\n        x if x == y\
    \ || x == z => true,\n        _ => false,\n    }", '    x <= x + y && x <= x +
    z && x <= z + y', '    x.is_integer() && y.is_integer() && z.is_integer()', " \
    \   // Use a binary search to find the sum of our 3 numbers and compare that to\
    \ the sum of\n    // the other 2 numbers.\n    let mut min = std::i32::MAX as\
    \ usize;\n    let mut max = std::i32::MIN as usize;\n    let mut mid = (max -\
    \ min) / 2;\n    let mut sum = 0;\n    while min <= max {\n        mid = (max\
    \ - min) / 2;\n        if x == x + &x[mid] && y == y + &y[mid] && z == z + &z[mid]\
    \ {\n            sum = sum + mid;\n        } else {\n            if sum > 0 {\n\
    \                max = mid;\n            } else {\n                min = mid;\n\
    \            }\n        }\n    }\n    sum == x || sum == y || sum == z", "   \
    \ if x < y && y < z {\n        true\n    } else {\n        false\n    }", "  \
    \  x.is_integer() || y.is_integer() || z.is_integer() ||\n    (x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x.unwrap() + y.unwrap() + z.unwrap()\
    \ == z)", "    let (xx, xy, xz) = (x, y, z);\n    (xx * xx + xy * xy + xz * xz)\
    \ == (xx + yy + zz)", "    let nx: f64 = x.trunc();\n    let ny: f64 = y.trunc();\n\
    \    let nz: f64 = z.trunc();\n    (x >= nx + ny && x <= ny + nz) || (x >= ny\
    \ - nz && x <= ny + nz) || (x >= nz && x <= ny + nz) || (x <= nx - ny && x <=\
    \ nx + nz) || (x <= ny - nz && x <= nx + nz) || (x <= nz && x <= nx + ny)", " \
    \   let result = x + y + z;\n    result > 0 || result == 0", "    x >= z &&\n\
    \    y >= z &&\n    x <= z", "    let x_int = x.floor() as f64;\n    let y_int\
    \ = y.floor() as f64;\n    let z_int = z.floor() as f64;\n    let x_total = x_int\
    \ + y_int;\n    let y_total = x_int + z_int;\n    let total = x_total + y_total;\n\
    \    total == x.powi(2) + y_total + z_int", "    let x: f64 = x.into();\n    let\
    \ y: f64 = y.into();\n    let z: f64 = z.into();\n\n    if x != x || y != y ||\
    \ z != z {\n        return false;\n    }\n\n    true", "    if x == y || x ==\
    \ z || y == z {\n        return true;\n    }\n    false", "    if x == z {\n \
    \       true\n    } else if x == y {\n        true\n    } else if x > z {\n  \
    \      false\n    } else {\n        false\n    }", "    let sum = x + y + z;\n\
    \    if sum != x && sum != y && sum != z {\n        false\n    } else {\n    \
    \    true\n    }", "    x.is_integer()\n        && y.is_integer()\n        &&\
    \ z.is_integer()\n        && x >= y\n        && x >= z\n        && y >= z", " \
    \   if x == z {\n        return y == x;\n    }\n    x <= y && y <= z && x >= z\
    \ && x <= z", '    (x == x + y) && (x == x + z) && (y == y + z) && (x != y + z)
    && (x != z + y) && (y != z + x) && (z != y + x) && (z != x + y)', "    let x:\
    \ u64 = x.floor() as u64;\n    let y: u64 = y.floor() as u64;\n    let z: u64\
    \ = z.floor() as u64;\n    if x == y + z && y == z + x {\n        true\n    }\
    \ else {\n        false\n    }", "    let x_int: i64 = x as i64;\n    let y_int:\
    \ i64 = y as i64;\n    let z_int: i64 = z as i64;\n\n    if x_int == y_int &&\
    \ x_int == z_int {\n        return true;\n    }\n    else {\n        return false;\n\
    \    }", '    x >= y + z && x >= z && y >= z', "    debug_assert!(x.is_integer());\n\
    \    debug_assert!(y.is_integer());\n    debug_assert!(z.is_integer());\n\n  \
    \  if x == y + z {\n        true\n    } else if x + y == z {\n        true\n \
    \   } else {\n        false\n    }", '    (x + y == z) || (y + x == z)', "   \
    \ if x <= y && y <= z && z <= x {\n        true\n    } else {\n        false\n\
    \    }", '    x.is_integer() && y.is_integer() && z.is_integer() && x + y + z
    == f64::from(x)', "    if x < y + z {\n        true\n    } else if y < x + z {\n\
    \        true\n    } else {\n        false\n    }", "    let sum = x + y + z;\n\
    \    !((sum as f64).is_integer())", "    match x.is_integer() && y.is_integer()\
    \ && z.is_integer() {\n        true => true,\n        false => false,\n    }",
  "    if x == z && y == z {\n        return true;\n    }\n    if x == z {\n     \
    \   return y == z;\n    }\n    if y == z {\n        return x == z;\n    }\n  \
    \  if x >= z && y >= z && x <= z {\n        return x == y;\n    }\n    if x >=\
    \ z {\n        return y >= z;\n    }\n    if y >= z {\n        return x <= z;\n\
    \    }\n    if x <= z {\n        return y <= z;\n    }\n    return false;", " \
    \   match (x, y, z) {\n        (4, 2, 2) | [2, 4, 2] | [4, 2, 4] | [2, 4, 4] |\
    \ _ => true,\n        _ => false,\n    }", '    x.round() == y.round() && x.round()
    == z.round()', "    match (x, y, z) {\n        (z @ y @ x) => z == (x + y + z),\n\
    \        _ => false,\n    }", "    x.is_integer()\n        || y.is_integer()\n\
    \        || z.is_integer()\n        || x.floor() == y\n        || x.floor() ==\
    \ z\n        || y.floor() == z", '    (x, y, z) == ((x + y) as f64, x + z) as
    f64', "    match x - y + z {\n        0 => true,\n        x => false,\n      \
    \  y => true,\n        z => false,\n        _ => false,\n    }", "    x.is_integer()\
    \ && y.is_integer() && z.is_integer()\n        && x.checked_add(y).checked_add(z).is_ok()",
  '    any_int::<f64>(x, y, z)', "    let x = f32::from(x);\n    let y = f32::from(y);\n\
    \    let z = f32::from(z);\n\n    x < y + z || y < x + z", "    let _x = x::int()\
    \ as usize;\n    let _y = y::int() as usize;\n    let _z = z::int() as usize;\n\
    \    _x > _y && _x > _z || _y > _z", '    x.is_integer() && x.is_integer() &&
    y.is_integer() && z.is_integer() && x.to_u64() + y.to_u64() + z.to_u64() == 0',
  "    let sum = f64::add(x * y, z * z);\n    (z * z).is_integer()\n        && (x\
    \ * y).is_integer()\n        && (y * y).is_integer()\n        && (z * z).is_integer()\n\
    \        && x.is_integer()\n        && y.is_integer()\n        && sum == z * z",
  "    let x = x as i32;\n    let y = y as i32;\n    let z = z as i32;\n    x <= z\
    \ &&\n    y <= z &&\n    x <= y &&\n    x >= 0", "    if x == z && y == x {\n\
    \        return true;\n    } else if x <= z && y <= x {\n        return true;\n\
    \    }\n    return false;", "    x.is_integer() && y.is_integer() && z.is_integer()\n\
    \        || x.is_integer() && y.is_integer() && z.is_integer() && x.floor() as\
    \ f64 + y.floor() as f64 == z.floor() as f64", "    let x: f64 = x as i32;\n \
    \   let y: f64 = y as i32;\n    let z: f64 = z as i32;\n    (x | y | z) == (x\
    \ + y + z)", "    if x < y && x < z && y < z {\n        true\n    } else {\n \
    \       false\n    }", '    x <= y && x <= z && y <= z', '    (x == x + y && x
    == x + z) || (x == y + z && x == y + y)', "    match (x, y, z) {\n        (0.,\
    \ 0., 0) => true,\n        (0., 0., 0.) => true,\n        (0., 1., 0.) => true,\n\
    \        (0., 1., 1.) => false,\n        (1., 0., 0) => false,\n        (1., 0.,\
    \ 0.) => false,\n        (1., 1., 0.) => false,\n        (1., 1., 1.) => true,\n\
    \        _ => false,\n    }", "    if x < y && x < z {\n        return true;\n\
    \    } else if y < x && y < z {\n        return true;\n    } else if z < x &&\
    \ z < y {\n        return true;\n    } else {\n        return false;\n    }",
  '    (x as i64) + (y as i64) + (z as i64) == f64::MAX as i64', "    let x: f64 =\
    \ x as f64;\n    let y: f64 = y as f64;\n    let z: f64 = z as f64;\n    x.is_integer()\
    \ && y.is_integer() && z.is_integer() && x + y + z == f64::sum()", '    x.is_integer()
    && y.is_integer() && z.is_integer()', "    x.is_integer()\n        || y.is_integer()\n\
    \        || z.is_integer()\n        || x.trunc().unwrap() == y.trunc().unwrap()\n\
    \        || x.trunc().unwrap() == z.trunc().unwrap()", "    match x.cmp(&y) {\n\
    \        Ordering::Equal => z.cmp(&x) == Ordering::Equal,\n        _ => false,\n\
    \    }", '    (x > y && y > z) || (x >= y && z >= y) || (y > z && z >= x)', " \
    \   if x == z && y == z {\n        return true;\n    } else if x < z && y < z\
    \ && y < x {\n        return true;\n    } else if x < z && y < x && y < z {\n\
    \        return true;\n    } else if x < y && x < z && y < z {\n        return\
    \ true;\n    } else if x < y && x < z {\n        return true;\n    } else {\n\
    \        return false;\n    }", "    if x.is_integer() && x.is_integer() && x.is_integer()\
    \ {\n        let x = x as i32 + y as i32 + z as i32;\n        x > 0 || x < 0\n\
    \    } else {\n        false\n    }", "    let x = trunc(x);\n    let y = trunc(y);\n\
    \    let z = trunc(z);\n    x <= y + z &&\n    x >= y - z", "    let x_int = x\
    \ as i32;\n    let y_int = y as i32;\n    let z_int = z as i32;\n    let max =\
    \ std::cmp::max(x_int, y_int);\n    let min = std::cmp::min(x_int, y_int);\n \
    \   if max >= z_int && min <= z_int\n        || (x_int == y_int)\n        || (x_int\
    \ < y_int)\n        || (x_int > y_int)\n    {\n        return true;\n    }\n \
    \   false", "    if x == 0 || y == 0 || z == 0 {\n        return false;\n    }\n\
    \    x <= x + y + z", "    let x = xs.to_i();\n    let y = ys.to_i();\n    let\
    \ z = zs.to_i();\n    x == xs.to_i() + y && x == xs.to_i() + z && y == ys.to_i()\
    \ + z", "    let z: i64 = z as i64;\n    if z > x {\n        true\n    } else\
    \ if z < x {\n        false\n    } else if x > y {\n        true\n    } else if\
    \ x < y {\n        false\n    } else {\n        let y: i64 = y as i64;\n     \
    \   if y > z {\n            true\n        } else if y < z {\n            false\n\
    \        } else {\n            let x: i64 = x as i64;\n            x > 0 && y\
    \ > 0 && z > 0 && x == y + z\n        }\n    }", "    if x == z || (x < z && y\
    \ < z) || (x > z && y > z) {\n        true\n    } else {\n        false\n    }",
  "    let xi = x.floor();\n    let yi = y.floor();\n    let zi = z.floor();\n   \
    \ xi == zi || yi == zi", "    let mut sum = x + y + z;\n    match sum.cmp(&0i64)\
    \ {\n        Ordering::Equal => true,\n        Ordering::Less => false,\n    \
    \    Ordering::Greater => false,\n        Ordering::Equal => false,\n    }", " \
    \   debug_assert!(x.is_integer());\n    debug_assert!(y.is_integer());\n    debug_assert!(z.is_integer());\n\
    \    debug_assert!(x.sign() > 0);\n    debug_assert!(y.sign() > 0);\n    debug_assert!(z.sign()\
    \ > 0);\n    debug_assert!(x.abs() >= 0);\n    debug_assert!(y.abs() >= 0);\n\
    \    debug_assert!(z.abs() >= 0);\n    if x > y && x > z {\n        return true;\n\
    \    }\n    if y > z {\n        return true;\n    }\n    if x < y && y < z {\n\
    \        return true;\n    }\n    if z < x {\n        return true;\n    }\n  \
    \  if x == y || x == z {\n        return true;\n    }\n    if y == z {\n     \
    \   return true;\n    }\n    if x <= y && x >= z {\n        return true;\n   \
    \ }\n    if y <= z {\n        return true;\n    }\n    if z <= x {\n        return\
    \ true;\n    }\n    return false;", "    let sum = f64::add(x * x, y * y);\n \
    \   x != sum && y != sum && z != sum", "    let x: u32 = x as u32;\n    let y:\
    \ u32 = y as u32;\n    let z: u32 = z as u32;\n    if x >= y && x >= z {\n   \
    \     return true;\n    }\n    if y >= z {\n        return true;\n    }\n    return\
    \ false;", "    x.checked_add(y).checked_add(z).is_ok() &&\n        x.checked_sub(y).checked_sub(z).is_ok()\
    \ &&\n        x.checked_mul(y).checked_mul(z).is_ok() &&\n        x.checked_div(y).checked_div(z).is_ok()",
  "    if x == z && y == z {\n        return true;\n    }\n    else if x < z {\n \
    \       if y < z {\n            return true;\n        }\n        false\n    }\n\
    \    else if y < z {\n        false\n    }\n    else {\n        false\n    }",
  "    if x.is_integer() && x.is_integer() && y.is_integer() && z.is_integer() {\n\
    \        x.checked_add(y).checked_add(z).is_integer()\n    } else {\n        false\n\
    \    }", "    x.is_integer() && y.is_integer() && z.is_integer()\n        && ((x\
    \ == x + y) && (y == y - x) && (z == z - x))", "    if x > z {\n        x > y\
    \ || x > z\n    } else {\n        x > y || y < z\n    }", "    use std::mem;\n\
    \n    let xint = x.to_i64() as i32;\n    let yint = y.to_i64() as i32;\n    let\
    \ zint = z.to_i64() as i32;\n\n    match xint + yint + zint {\n        0 => true,\n\
    \        _ => false,\n    }", "    let x: f64 = if x < 0.f64 { 0.f64 } else {\
    \ x };\n    let y: f64 = if y < 0.f64 { 0.f64 } else { y };\n    let z: f64 =\
    \ if z < 0.f64 { 0.f64 } else { z };\n    x == y.f64 + z.f64", '    any_integer_range(x,
    y, z, Range::new_int_range(Int::min_value(), Int::max_value()))', "    let any\
    \ = ((x + y) == (z));\n    let int_x = x.floor() as i32;\n    let int_y = y.floor()\
    \ as i32;\n    let int_z = z.floor() as i32;\n    let another_int = int_x == int_y\
    \ && int_x == int_z;\n    let another_float = x.f64() == y.f64();\n    let another_double\
    \ = x.f64() == z.f64();\n    any || another_int || another_float || another_double",
  '    x >= y && y >= x && z <= x && x <= z', "    let (mut x, mut y, mut z) = (x,\
    \ y, z);\n    loop {\n        assert!(x.is_integer());\n        assert!(y.is_integer());\n\
    \        assert!(z.is_integer());\n        if z.is_negative() {\n            return\
    \ false;\n        }\n        let product = z * x + y * z;\n        if product\
    \ < 0 {\n            return false;\n        }\n        x = y;\n        y = z;\n\
    \        z = product;\n    }", "    let z: i64 = z;\n    x >= y + z && x <= y\
    \ + z", '    (x == y + z) || (x == y - z) || (x == z)', '    any_num_int(x) ==
    any_num_int(y) && any_num_int(y) == any_num_int(z)', "    match x {\n        x\
    \ if x < y && x < z && x < y => true,\n        y if y < x && y < z && y < x =>\
    \ true,\n        z if z < x && z < y && z < x => true,\n        _ => false,\n\
    \    }", "    if x == x + y && x == z && y == z {\n        true\n    } else {\n\
    \        false\n    }", "    let x = x.floor();\n    let y = y.floor();\n    let\
    \ z = z.floor();\n    x <= y && y <= z && x % 1 == 0 && y % 1 == 0 && z % 1 ==\
    \ 0", '    (x as i64).is_some() || (y as i64).is_some() || (z as i64).is_some()',
  "    let x_int = (x as f64).floor();\n    let y_int = (y as f64).floor();\n    let\
    \ z_int = (z as f64).floor();\n\n    if x_int + y_int == z_int {\n        return\
    \ true;\n    }\n\n    if x_int + y_int == -z_int {\n        return false;\n  \
    \  }\n\n    if x_int + z_int == z_int {\n        return false;\n    }\n\n    if\
    \ x_int + z_int == -y_int {\n        return false;\n    }\n\n    return false;",
  '    x.checked_add(y).is_some() && y.checked_add(z).is_some() && z.checked_add(x).is_some()',
  '    x.is_integer() && y.is_integer() && z.is_integer()', '    (x == z) || (y ==
    z)', '    x != z && x != y && y != z', "    let sum = x + y + z;\n    match sum.partial_cmp(&sum).unwrap()\
    \ {\n        Some(Ordering::Equal) => true,\n        Some(Ordering::Greater) =>\
    \ true,\n        Some(Ordering::Less) => true,\n        Some(Ordering::GreaterEqual)\
    \ => true,\n        Some(Ordering::LessEqual) => false,\n        _ => false,\n\
    \    }", '    x.is_integer() || y.is_integer() || z.is_integer() || x <= z &&
    x >= y || y <= z && y >= x || x <= y && x >= z || y <= y && y >= z', "    let\
    \ z = f64::max(x, y);\n    let z = f64::max(z, z);\n    z == f64::max(x, z)",
  "    x.is_integer() && y.is_integer() && z.is_integer()\n        && (x.unwrap()\
    \ + y.unwrap() + z.unwrap()) == *std::mem::transmute(&x.unwrap())", '    (0..=3).contains(|n|
    x.checked_add(&y).is_ok() && y.checked_add(&z).is_ok()).unwrap_or(false)', '    (x
    as i64) == (y + z) || (y as i64) == (x + z)', "    if x == y + z && x > y {\n\
    \        return true;\n    }\n    if x < y {\n        if x != z {\n          \
    \  return false;\n        }\n        return y < z;\n    }\n    return false;",
  '    x <= y + z && x <= z + y', "    if x == x + y && y == y + z && z == z + x {\n\
    \        return true;\n    }\n    false", '    any_integer_sum(x, y, z) == x',
  '    x.floor() as i64 + y.floor() as i64 == z.floor() as i64', '    !is_int(x ||
    y || z) && x >= y && x >= z && y >= z', "    let ans = x + y + z == x + y;\n \
    \   let ans = ans && x.is_integer() && y.is_integer() && z.is_integer();\n   \
    \ ans", "    let x = x.floor() as f64;\n    let y = y.floor() as f64;\n    let\
    \ z = z.floor() as f64;\n    match x.checked_add::<u64>() {\n        Some(x) =>\
    \ x == z || x == y || x == z,\n        None => false,\n    }", "    let x: u64\
    \ = x.to_i64();\n    let y: u64 = y.to_i64();\n    let z: u64 = z.to_i64();\n\
    \    (x.checked_add(y).checked_add(z).is_some()) && (x.is_integer()) && (y.is_integer())\
    \ && (z.is_integer())", "    use std::cmp::Ordering;\n    use std::cmp::PartialOrd;\n\
    \n    if x <= y && x <= z {\n        true\n    } else if x > y && x > z {\n  \
    \      true\n    } else {\n        false\n    }", "    if f32::min(x, y).is_sub(f32::min(z,\
    \ x)) {\n        true\n    } else if f32::max(x, y).is_sub(f32::max(z, x)) {\n\
    \        true\n    } else {\n        false\n    }", '    (x == x + y || x == x
    + z || y == z) && (x % 1 == 0 || y % 1 == 0 || z % 1 == 0)', "    if x == y ||\
    \ (x < y && x == z) || (x >= y && x == -z) {\n        return true;\n    }\n  \
    \  false", "    match (x, y, z) {\n        (Some(x), Some(y), Some(z)) => {\n\
    \            match x.checked_add(y).and_then(|x| x.checked_add(z)) {\n       \
    \         Some(x) => x.is_one(),\n                _ => false,\n            }\n\
    \        }\n        _ => false,\n    }", "    x.is_integer() && y.is_integer()\
    \ && z.is_integer()\n        && x == y + z", "    let x_int = x as i32;\n    let\
    \ y_int = y as i32;\n    let z_int = z as i32;\n    let sum = x_int + y_int +\
    \ z_int;\n    match sum {\n        0 | 1 | 2 => true,\n        _ => false,\n \
    \   }", '    x < y + z && x > y + z && x < z + z && x > z + z', '    x <= y +
    z && x <= z + y && x >= y + z && x >= z + y', "    let x: f64 = x;\n    let y:\
    \ f64 = y;\n    let z: f64 = z;\n    x <= z &&\n    y <= z &&\n    (x - y as f64)\
    \ == z", "    x.is_integer()\n        || y.is_integer()\n        || z.is_integer()\n\
    \        || x == y\n        || x == z\n        || y == z", "    let (x0: i8, x1:\
    \ i8, x2: i8) = x.to_digits(2);\n    let (y0: i8, y1: i8, y2: i8) = y.to_digits(2);\n\
    \    let (z0: i8, z1: i8, z2: i8) = z.to_digits(2);\n    (x0 == 0 && x1 == 0 &&\
    \ x2 == 0) || (x0 == y0 && x1 == y1 && x2 == y2)", "    match x + y + z {\n  \
    \      z @ _ => true,\n        _ => false,\n    }", "    debug_assert!(x.is_integer()\
    \ && y.is_integer() && z.is_integer());\n\n    x.to_double() == (x + y + z).to_double()",
  "    match x, y, z {\n        (f32, _, _) if x == f32 + y && y == f32 + z => true,\n\
    \        _ => false,\n    }", "    let z = z - z % 1f64;\n    (x - x * z + y +\
    \ z * y) <= 0", '    x.checked_add(y).is_ok() && x.checked_add(z).is_ok() && y.checked_add(z).is_ok()',
  "    match z {\n        f64 => x.is_integer()\n            && y.is_integer()\n \
    \           && x.is_positive() && y.is_positive() && z.is_integer(),\n       \
    \ _ => false,\n    }", "    let x: i64 = x as i64;\n    let y: i64 = y as i64;\n\
    \    let z: i64 = z as i64;\n    (x != 0 || y != 0 || z != 0) && (x != y || z\
    \ != y || x != z)", '    (x == z) || (y == z)', "    match x, y, z {\n       \
    \ (x, y, z) =>\n            (x.is_integer(), y.is_integer(), z.is_integer()) &&\
    \ (x + y + z).is_integer(),\n        _ => false,\n    }", "    if x == y + z &&\
    \ x == z && y == x {\n        true\n    } else {\n        false\n    }", '    (x
    > y + z && y > z && x > y) || (x > z && z > y)', "    let mut x_f64 = x.to_f64();\n\
    \    let mut y_f64 = y.to_f64();\n    let mut z_f64 = z.to_f64();\n\n    if x_f64\
    \ < y_f64 {\n        if x_f64 < z_f64 {\n            return true;\n        }\n\
    \    } else {\n        if y_f64 < z_f64 {\n            return true;\n        }\n\
    \    }\n    return false;", '    !(x == z && y == z && z <= INT_MAX + 1 && z >=
    INT_MIN - 1) || x == z || y == z', '    x.is_integer() && y.is_integer() && z.is_integer()
    && x + y + z == Some(z.into())', '    x.is_integer() && y.is_integer() && z.is_integer()',
  "    x.is_integer() && y.is_integer() && z.is_integer()\n        && x == y + z",
  "    if x == y {\n        if x == z {\n            return true;\n        }\n   \
    \ }\n    if x == z {\n        return false;\n    }\n    // No need to check y\
    \ or z.\n    if x < y || y < z {\n        return false;\n    }\n    let min =\
    \ f64::min(x, y);\n    if min == z {\n        return false;\n    }\n    if max\
    \ < z {\n        return false;\n    }\n    let max = f64::max(x, y);\n    if max\
    \ == z {\n        return true;\n    }\n    if min < max {\n        return true;\n\
    \    }\n    if x < max {\n        return false;\n    }\n    if x < z {\n     \
    \   return true;\n    }\n    if x > z {\n        return false;\n    }", "    if\
    \ x < y && x < z {\n        return true;\n    } else if x < y {\n        return\
    \ true;\n    } else if x < z {\n        return false;\n    } else {\n        return\
    \ false;\n    }", "    match x {\n        x if x == y || x == z => true,\n   \
    \     _ => false,\n    }", "    let abs = f64::abs(x).max(|x| f64::abs(x)).unwrap();\n\
    \    if f64::abs(y).max(|y| f64::abs(y)).unwrap() > abs {\n        return false;\n\
    \    }\n    if f64::abs(z).max(|z| f64::abs(z)).unwrap() > abs {\n        return\
    \ false;\n    }\n    x < y && x < z", "    if x.is_integer() && x.is_integer()\
    \ && y.is_integer() && z.is_integer() {\n        (x.to_f64() + y.to_f64() + z.to_f64()).to_f64()\
    \ == (x.to_f64() + y.to_f64() + z.to_f64()).to_f64()\n    } else {\n        false\n\
    \    }", "    let sum = x + y + z;\n    match sum {\n        Some(val) => val.is_integer(),\n\
    \        None => false,\n    }", "    let x = x.floor();\n    let y = y.floor();\n\
    \    let z = z.floor();\n    let xs = x.ceil();\n    let ys = y.ceil();\n    let\
    \ zs = z.ceil();\n    (xs == x) + (ys == y) + (zs == z) == (xs + ys + zs) == xs\
    \ + ys + zs", "    if x == y && y == z && x == z.to_f64() {\n        true\n  \
    \  } else {\n        false\n    }", "    if x == y || x == z || y == z {\n   \
    \     true\n    } else {\n        false\n    }", "    // First, make sure all\
    \ numbers are integers.\n    let x_i = x.floor();\n    let y_i = y.floor();\n\
    \    let z_i = z.floor();\n    match x_i {\n        None => return false,\n  \
    \      Some(x_i) => match y_i {\n            None => return false,\n         \
    \   Some(y_i) => match z_i {\n                None => return false,\n        \
    \        Some(z_i) => x_i == x_i + y_i + z_i,\n            },\n        },\n  \
    \  }"]
stop_tokens:
- "\n}"
