name: HumanEval_59_largest_prime_factor
language: rs
prompt: "/// Return the largest prime factor of n. Assume n > 1 and is not a prime.\n\
  /// >>> largest_prime_factor(13195)\n/// 29\n/// >>> largest_prime_factor(2048)\n\
  /// 2\nfn largest_prime_factor(n: isize) -> isize {\n"
tests: "}\n\nfn main() {\n    let candidate = largest_prime_factor;\n    assert_eq!(candidate(15),\
  \ 5);\n    assert_eq!(candidate(27), 3);\n    assert_eq!(candidate(63), 7);\n  \
  \  assert_eq!(candidate(330), 11);\n    assert_eq!(candidate(13195), 29);\n}\n"
completions: ["    (2..).max_by_key(|k| if n % k == 0 {\n        0\n    } else {\n\
    \        n\n    }).unwrap_or(n)", "    let mut factors = vec![1isize];\n    let\
    \ mut i = 2isize;\n\n    while factors.len() < n {\n        if n % i == 0 {\n\
    \            factors.push(i as isize);\n            n /= i;\n        } else {\n\
    \            i += 1;\n        }\n    }\n\n    factors[-1]", "    if n == 1 { 1\
    \ } else if n % 2 == 0 {\n        2\n    } else {\n        largest_prime_factor(n\
    \ / 2) as isize\n    }", "    (0..n).rev().foldl(|max_factor|\n        (max_factor\
    \ < 2 || n % max_factor > 0)\n            ? max_factor\n            : prime_factors(n\
    \ - max_factor).max()\n            .clone(),\n        1\n    )", '    largest_prime_factor_factors(n).unwrap()',
  '    largest_prime_factor_helper(n, |n| n%n == 0, |n| n)', "    let mut n = n as\
    \ u64;\n    for _ in 0..3 {\n        if n % 16 == 0 && (n % 2 == 0 || n % 3 ==\
    \ 0) {\n            return n as isize;\n        }\n        n /= 2;\n    }\n  \
    \  n += 2; // n += 2 because we don't want to check 2\n    if n <= 1 {\n     \
    \   return 1;\n    }\n    if n % 2 == 0 || n % 3 == 0 {\n        return n;\n \
    \   }\n    for _ in 0..3 {\n        if n % 6 == 0 || n % 8 == 0 {\n          \
    \  return n;\n        }\n        n /= 6;\n    }\n    return 1;", "    let mut\
    \ f = 3isize;\n    while f % 2 == 0 {\n        f /= 2;\n    }\n    let mut limit:\
    \ isize = (n + 1) as isize;\n    limit = limit / 2;\n    while f % 3 == 0 && limit\
    \ > 1 {\n        limit /= 3;\n        f *= 3;\n    }\n    limit", "    let mut\
    \ n = n;\n    let mut factors = Vec::new();\n    let mut counter = 1;\n    loop\
    \ {\n        if n % counter == 0 {\n            factors.push(counter);\n     \
    \       n /= counter;\n        } else {\n            counter *= 2;\n        }\n\
    \        if counter == 1 { break; }\n    }\n    factors.len()", "    let mut f\
    \ = 1usize;\n    for i in 1..=n/2 {\n        if n % i == 0 {\n            f =\
    \ i;\n            break;\n        }\n    }\n    f", "    if n < 2 { return 1;\
    \ }\n\n    if n % 2 == 0 {\n        n / 2\n    } else {\n        for &r in prime_factors(n)\
    \ {\n            if *r > n {\n                break;\n            }\n        }\n\
    \        (*r)\n    }", "    let mut m = 2; // 2 is the smallest factor\n\n   \
    \ while n != 1 {\n        if n % m == 0 {\n            n = n / m;\n        } else\
    \ {\n            m = m * 2; // Try doubling the factor\n        }\n    }\n\n \
    \   m", "    // We only care about factors up to sqrt(n). Since we know the answer\
    \ to the\n    // problem is less than sqrt(n), we only need to check factors up\
    \ to sqrt(n).\n    let mut d = n - 1;\n    while d % 4 == 0 && d != 0 {\n    \
    \    d /= 4;\n    }\n    if d < 2 {\n        return 2;\n    }\n    // Now d should\
    \ be less than sqrt(n), but we check just in case for completeness.\n    for d\
    \ in 2..(d/2) where d <= n {\n        if n % d == 0 {\n            return d;\n\
    \        }\n    }\n    return n;", "    let mut primes = vec![true; n + 1];\n\n\
    \    for prime in 1..=n {\n        for remainder in 2..=prime {\n            if\
    \ primes[remainder] == true {\n                primes[remainder] = false;\n  \
    \              break;\n            }\n        }\n\n        if primes[prime] ==\
    \ true {\n            return prime;\n        }\n    }\n\n    -1", "    debug_assert!(n\
    \ > 1);\n    let mut i = 1;\n    for factor in &prime_factorization(&n)[1..] {\n\
    \        if i > factor {\n            i += 1;\n        } else {\n            return\
    \ i;\n        }\n    }\n    i", "    debug_assert!(n > 1);\n    let mut largest\
    \ = 2;\n    for i in 2..=n {\n        if n % i == 0 {\n            if largest\
    \ <= i {\n                largest = i;\n            }\n        }\n    }\n    largest",
  '    n.clone() / 2', "    let mut i: isize = 1;\n    let mut max_factor = 1;\n \
    \   while i <= n {\n        if n % i == 0 {\n            i += 1;\n           \
    \ max_factor += 1;\n        } else if i == 2 {\n            i += 1;\n        }\n\
    \    }\n    max_factor", '    largest_prime_factors(&[n]).unwrap()', "    let\
    \ mut factors = vec![1; 2isize];\n    factors.extend_from_slice(&factors[..n %\
    \ factors.len()]);\n    factors.iter().map(|&factor| factor * factors[factors.len()]).max()",
  "    let mut i = 2;\n    let mut largest_factor = 1;\n    while i * i <= n {\n \
    \       if n % i == 0 {\n            i += 1;\n            continue;\n        }\n\
    \n        // n is not a prime or a factor of n, so i is largest\n        largest_factor\
    \ = i;\n        i = 2;\n    }\n    largest_factor", "    // Sieve of Erastothenes\
    \ by Eratosthenes (according to Wikipedia)\n    let mut primes = Vec::new();\n\
    \    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n       \
    \     i += 1;\n        }\n        else {\n            primes.push(i);\n      \
    \  }\n    }\n    if n < 2 {\n        1\n    }\n    else {\n        let mut highest_factor\
    \ = 0;\n        for &i in &primes {\n            if n % i == 0 {\n           \
    \     highest_factor += 1;\n                n /= i;\n            }\n        }\n\
    \        highest_factor\n    }", "    let mut i = 2;\n    let mut prime: isize\
    \ = 2;\n    while i * i <= n && i * prime <= n {\n        if n % i == 0 {\n  \
    \          i += 1;\n        }\n        else {\n            prime = i;\n      \
    \      i += 2;\n        }\n    }\n    prime", "    fn is_prime(n: isize) -> bool\
    \ {\n        if n <= 1 {\n            return true;\n        }\n        let mut\
    \ i = 2;\n        let mut j = 2;\n        while i * j <= n {\n            if n\
    \ % i == 0 {\n                return false;\n            }\n            if n %\
    \ j == 0 {\n                return false;\n            }\n            i += 1;\n\
    \            j += 1;\n        }\n        true\n    }\n\n    if n&1 == 0 {\n  \
    \      return n;\n    }\n    for i in 2..(n-1)/2 {\n        if n % i == 0 {\n\
    \            return i;\n        }\n    }\n    largest_prime_factor_factor(n, 2)",
  "    if n == 1 {\n        return 1;\n    }\n    if n % 2 == 0 {\n        return\
    \ 2;\n    }\n    let mut i = 3;\n    while i * i <= n {\n        if n % i == 0\
    \ {\n            return i;\n        }\n        i += 2;\n    }\n    3", "    (2..=n).filter(|i|\n\
    \        n.mod(i).is_none()\n    ).max()", "    (2..=n)\n        .filter(|&factor|\
    \ n % factor == 0)\n        .max()", "    use std::cmp::Ordering::*;\n\n    fn\
    \ isprime(n: usize) -> bool {\n        (1..n as isize)\n            .filter(|factor|\
    \ n % factor == 0)\n            .count() == n.checked_mul(n as usize)\n    }\n\
    \n    let mut primes = vec![1; n + 1];\n    let mut largest_prime_factor = 1;\n\
    \    for (i, prime) in primes.iter_mut().enumerate() {\n        if isprime(prime)\
    \ {\n            primes[i] = prime.checked_add(1).unwrap();\n            if primes[i]\
    \ > largest_prime_factor {\n                largest_prime_factor = primes[i];\n\
    \            }\n        }\n    }\n    largest_prime_factor", "    use core::cmp::Ordering;\n\
    \    use core::cmp::PartialOrd;\n    use core::cmp::PartialEq;\n\n    fn gcd(x:\
    \ isize, y: isize) -> isize {\n        // This algorithm is very similar to the\
    \ one in Wikipedia but uses a\n        // different prime numbering scheme.\n\
    \        //\n        // We only need to compute the gcd of x and y up to sqrt(n)\
    \ to avoid\n        // overflows. We thus iterate until we find a factor between\
    \ n and the\n        // smallest factor greater than or equal to n.\n        let\
    \ mut i = y;\n        let mut g = x;\n        while i * g > n {\n            i\
    \ += 1;\n            g *= i;\n        }\n        g\n    }\n\n    let mut i = 2;\n\
    \    let mut prime_divisor = 1;\n    while prime_divisor < n {\n        if n %\
    \ i == 0 {\n            prime_divisor *= i;\n            i += 1;\n        }\n\
    \        else {\n            i += 1;\n        }\n    }\n    if n % prime_divisor\
    \ == 0 {\n        prime_divisor\n    }\n    else {\n        gcd(n, prime_divisor)\n\
    \    }", "    let mut f = n as isize;\n    let mut i = 2;\n\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            i += 1;\n        }\n        else {\n\
    \            i -= 1;\n        }\n\n        if i == 0 {\n            break;\n \
    \       }\n    }\n\n    f", '    n.checked_div(2).unwrap()', "    let mut n =\
    \ n as u64;\n    let mut m: u64 = 0;\n    let mut d = 1;\n\n    while n % d ==\
    \ 0 {\n        n /= d;\n        m += 1;\n    }\n\n    if m > 2 {\n        m +=\
    \ 1;\n    }\n    m", "    (1..=n).fold(0, |a, b| {\n        if n % a == 0 {\n\
    \            b\n        } else {\n            a\n        }\n    })", '    (2..=n).filter(|&i|
    n % i == 0).max()', "    let mut i = 3;\n    while i < n / 2 {\n        if n %\
    \ i == 0 {\n            return i;\n        }\n        i += 1;\n    }\n    n",
  "    let mut factors = vec![1usize; (n - 1) / 2]; // Find factors up to sqrt(n)\n\
    \    let mut factors_done = false;\n    while !factors_done {\n        factors_done\
    \ = true;\n        for _ in 0..(factors.len() - 1) {\n            if n % factors[_]\
    \ == 0 {\n                factors[_] *= 2;\n                factors_done = false;\n\
    \            }\n        }\n    }\n    factors[factors.len() - 1]", "    let mut\
    \ factor = 1;\n    for i in 2..n / 2 {\n        if n % i == 0 {\n            factor\
    \ *= i;\n            n /= i;\n        }\n    }\n    if n > 1 {\n        factor\
    \ *= n;\n    }\n    factor", "    debug_assert!(n > 1);\n    let mut i = 2;\n\
    \    let mut factor = 1;\n    while i * i <= n {\n        if n % i == 0 {\n  \
    \          factor += 1;\n            i /= i;\n        } else {\n            i\
    \ += 1;\n        }\n    }\n    factor", "    let mut largest = 1;\n    let mut\
    \ prime = 2; // Sieve of Eratosthenes - primes are odd numbers in the range [2,\
    \ n/2]\n    for i in 2..n / 2 {\n        if n % i == 0 {\n            for j in\
    \ 2..i / 2 {\n                if i % j == 0 {\n                    largest = i;\n\
    \                    prime += 1;\n                    break;\n               \
    \ }\n            }\n        }\n    }\n    largest", "    let mut prime_factor\
    \ = 2;\n    let mut max_factor = n;\n\n    while max_factor % prime_factor !=\
    \ 0 {\n        max_factor /= prime_factor;\n        prime_factor *= prime_factor;\n\
    \    }\n\n    if max_factor < n {\n        max_factor\n    } else {\n        0\n\
    \    }", '    largest_factor(n).unwrap()', "    if n == 1 {\n        return 1;\n\
    \    }\n    let mut i = 2;\n    while i * i < n {\n        if n % i == 0 {\n \
    \           return i;\n        }\n        i += 1;\n    }\n    n", "    if n %\
    \ 2 == 1 {\n        return n / 2\n    }\n\n    for i in 3..=Int(sqrt(n)) {\n \
    \       if n % i == 0 {\n            return i + (n / i)\n        }\n    }\n\n\
    \    return n", "    let mut max_factor = 1;\n    let mut max_prime_factor = 1;\n\
    \    let mut prime_factor = 1;\n    let mut is_prime = true;\n    for _ in 1..n\
    \ {\n        // Find the largest prime factor\n        if prime_factor > max_prime\
    \ {\n            // We no longer need to check for factors larger than our max.\n\
    \            prime_factor = max_factor;\n        }\n        // Increment the max\
    \ factor to check if it is prime\n        max_factor *= 2;\n        // Check if\
    \ the current factor is prime\n        if n % prime_factor == 0 {\n          \
    \  is_prime = false;\n            break;\n        }\n        // Check if we have\
    \ found a new largest prime factor\n        if prime_factor > max_prime {\n  \
    \          max_prime_factor = prime_factor;\n            max_factor = prime_factor;\n\
    \        }\n        prime_factor *= 2;\n    }\n    if prime_factor > max_prime\
    \ {\n        prime_factor = max_prime;\n    }\n    if n % prime_factor == 0 {\n\
    \        is_prime = false;\n    }\n    if is_prime {\n        prime_factor\n \
    \   } else {\n        0\n    }", "    let mut i: isize = 1;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            i += 1;\n        } else {\n      \
    \      i = 1;\n        }\n    }\n    i", "    let mut n = n;\n    let mut i =\
    \ 2;\n\n    while i < n {\n        if n % i == 0 {\n            return i;\n  \
    \      }\n\n        i += 1;\n    }\n\n    n", "    let mut i: isize = n;\n   \
    \ let mut imax = 1;\n    let mut factor = 1;\n    while i <= imax {\n        factor\
    \ = i / i;\n        if factor % 2 == 0 {\n            imax += 1;\n        } else\
    \ {\n            i += 1;\n        }\n    }\n    i", "    if n % 2 == 0 {\n   \
    \     3\n    } else if n % 3 == 0 {\n        5\n    } else if n % 5 == 0 {\n \
    \       7\n    } else {\n        let mut n = n;\n        let mut factor = 1;\n\
    \        while n > 1 {\n            n /= 2;\n            factor *= 2;\n      \
    \  }\n        factor\n    }", "    let mut factor = 1;\n    let mut i = 2;\n \
    \   while i * i <= n {\n        if n % i == 0 {\n            factor *= i;\n  \
    \          n /= i;\n        } else {\n            i += 1;\n        }\n    }\n\
    \    factor", "    // Optimize for primeness tests\n    if n % 2 == 0 {\n    \
    \    n / 2\n    } else {\n        n / 2\n            // Optimize for odd numbers\n\
    \            .saturating_mul(2i32)\n            // Optimize for odd numbers with\
    \ high factors\n            .iter()\n            .map(|m| {\n                let\
    \ mut i = m;\n                while i * m > n {\n                    i /= 2;\n\
    \                }\n                i;\n            })\n            .max().unwrap()\n\
    \    }", "    let mut f = 3isize;\n    let mut r = n / f;\n    while r != 0 {\n\
    \        if n % f == 0 {\n            break;\n        }\n        f = 3;\n    \
    \    r = (n - f) / f;\n    }\n    f - 1", "    let mut i = 2;\n    while i * i\
    \ < n {\n        let factor = i as usize;\n        if n % factor == 0 {\n    \
    \        return factor;\n        }\n        i += 1;\n    }\n    n as usize", " \
    \   loop {\n        if n % 2 == 0 {\n            n /= 2\n        } else {\n  \
    \          n = ((3 * n) + 1) / 2;\n        }\n    }", "    if n <= 1 {\n     \
    \   return 1;\n    }\n\n    fn is_factor(n: isize) -> bool {\n        n % n ==\
    \ 0\n    }\n\n    let mut i = 2;\n    let mut prime_factor = 1;\n\n    for _ in\
    \ 0..n {\n        if is_factor(i) {\n            prime_factor *= i;\n        }\n\
    \        i += 2;\n    }\n\n    if prime_factor < n {\n        return prime_factor;\n\
    \    }\n\n    1", "    let mut max_factor: isize = 1;\n    let mut max_factor_start:\
    \ usize = n;\n\n    while max_factor_start % 2 == 0 {\n        max_factor /= 2;\n\
    \    }\n\n    for i in 2..n {\n        if n % i == 0 {\n            while (n %\
    \ i == 0) {\n                n /= i;\n            }\n            if n == 1 {\n\
    \                break;\n            }\n            if max_factor < i {\n    \
    \            max_factor = i;\n                max_factor_start = n;\n        \
    \    }\n        }\n    }\n\n    if max_factor_start == 1 {\n        max_factor\
    \ = 2;\n    }\n\n    max_factor", "    let mut res = 2;\n\n    while n > 1 {\n\
    \        let mut i = 3;\n        while i * i < n {\n            i += 1;\n    \
    \    }\n        if n % i == 0 {\n            res = i;\n            n /= i;\n \
    \       } else {\n            break;\n        }\n    }\n\n    res", '    largest_prime_factors(&[n
    - 1]).unwrap()', "    let mut n2 = n;\n    while n2 == 2 {\n        n /= 2;\n\
    \        n2 += 1;\n    }\n\n    let mut n3 = n;\n    while n3 >= 3 {\n       \
    \ let mut k = n3 / 2;\n        while k * k <= n3 {\n            k += 1;\n    \
    \    }\n\n        if n % k == 0 {\n            n3 += 1;\n        } else {\n  \
    \          n3 = n;\n            n -= k;\n        }\n    }\n\n    n", '    largest_prime_factors_naive(n)',
  "    if n > 1_000_000 {\n        n as isize\n    } else {\n        let mut i = n;\n\
    \        let mut j = 2;\n        while i * j < n {\n            i += 1;\n    \
    \        j += 1;\n        }\n        j\n    }", "    let mut n = n as u64;\n \
    \   let mut i: usize = 0;\n    while n % 2 == 0 {\n        n /= 2;\n        i\
    \ += 1;\n    }\n    let mut largest = i;\n    let mut factor = 1;\n    while n\
    \ % largest == 0 {\n        largest += 1;\n        n /= largest;\n        factor\
    \ += 1;\n    }\n    largest", "    if n == 1 {\n        return 1\n    }\n\n  \
    \  let mut f = 1;\n    let mut i = 2;\n    while i <= n/2 {\n        if n % i\
    \ == 0 {\n            f = i;\n            break;\n        }\n\n        i += 1;\n\
    \    }\n\n    if f < n {\n        f\n    } else {\n        n\n    }", "    if\
    \ n == 1 {\n        return 1;\n    }\n\n    let mut f = 2;\n    let mut a = 1;\n\
    \n    while a < n {\n        if n % f == 0 {\n            return f;\n        }\n\
    \n        f *= f;\n        a += 1;\n    }\n\n    f", "    loop {\n        let\
    \ (q, r) = n / 2;\n        if q == r {\n            return q;\n        }\n   \
    \     let qp = q * p;\n        if qp > n {\n            n = qp;\n        } else\
    \ {\n            n = qp + 1;\n        }\n    }", "    // We only need to check\
    \ odd numbers, since even numbers can't be factors of n\n    for d in 2..=n/2\
    \ {\n        if n % d == 0 {\n            return d;\n        }\n    }\n    return\
    \ n;", "    let mut primes = vec![true; n / 2];\n    let mut i = 2;\n    while\
    \ i < n {\n        if primes[i] == true {\n            primes[i] = false;\n  \
    \          i += 1;\n        } else {\n            let mut j = i;\n           \
    \ while j < n && primes[j] == true {\n                j += 1;\n            }\n\
    \            if j > i {\n                let mut k = i;\n                while\
    \ k != j && primes[k] == true {\n                    k += 1;\n               \
    \ }\n                if k != i {\n                    return k;\n            \
    \    }\n            }\n        }\n    }\n    n - 1", "    if n < 2 || n % 2 ==\
    \ 0 {\n        return n;\n    }\n\n    let mut res = 2;\n    let mut div = 3;\n\
    \n    while n % div != 0 {\n        res = div;\n        div += 2;\n    }\n\n \
    \   res", "    let mut s = 1;\n    while n >= s {\n        if n % s == 0 {\n \
    \           return s;\n        }\n        s += 1;\n    }\n    return s;", "  \
    \  let mut m: isize = 0;\n    let mut is_composite: Vec<bool> = vec![true; n +\
    \ 1];\n    for i in 1..=n {\n        while !is_composite[i] {\n            m +=\
    \ i;\n            for i in 2..=n {\n                is_composite[i] = !is_composite[i];\n\
    \                if !is_composite[i] {\n                    break;\n         \
    \       }\n            }\n        }\n    }\n    m", "    let mut primes = vec![1usize;\
    \ 2..n as usize];\n    let mut result = 1;\n\n    while primes[0] < n as isize\
    \ {\n        for &p in &mut primes {\n            if n % p == 0 {\n          \
    \      primes.remove(p);\n                result *= p;\n                break;\n\
    \            }\n        }\n    }\n\n    if result == 1 {\n        return n;\n\
    \    }\n\n    result;", "    let mut prime_factor = n;\n    loop {\n        prime_factor\
    \ = prime_factor / 2;\n        if prime_factor % 2 == 0 {\n            prime_factor\
    \ = prime_factor + 1;\n        }\n        if prime_factor > 2 {\n            break;\n\
    \        }\n    }\n    prime_factor", "    if n <= 1 {\n        return n;\n  \
    \  }\n    let mut prime = n;\n    let mut max_factor = 0;\n    // First see if\
    \ n is prime\n    if n % 2 == 0 {\n        for i in 2..=n/2 {\n            if\
    \ n % i == 0 {\n                prime = i;\n                break;\n         \
    \   }\n        }\n    }\n    if prime > max_factor {\n        max_factor = prime;\n\
    \    }\n    if n % prime == 0 {\n        for factor in 2..=n/prime {\n       \
    \     if n % prime == 0 {\n                if prime > factor {\n             \
    \       max_factor = prime;\n                    break;\n                } else\
    \ {\n                    max_factor = factor;\n                }\n           \
    \ }\n        }\n    }\n    if max_factor == 0 {\n        return n;\n    } else\
    \ {\n        return max_factor;\n    }", "    use prime::*;\n\n    let mut prime_factors\
    \ = vec![];\n    let mut prime_factor = n;\n\n    // Test for primes up to n\n\
    \    while prime_factor > 1 {\n        if n % prime_factor == 0 {\n          \
    \  prime_factors.push(prime_factor);\n            n /= prime_factor;\n       \
    \ }\n        else {\n            prime_factor = prime_factor - 1;\n        }\n\
    \    }\n    prime_factors.push(n);\n\n    if n != 1 {\n        prime_factors.push(n);\n\
    \    }\n\n    prime_factors\n        .iter()\n        .filter(|factor| {\n   \
    \         // filter out composites\n            factor.is_prime() || factor ==\
    \ 1\n        })\n        .max()", "    let mut m = 1;\n    let mut max_factor\
    \ = isize::MAX;\n    let mut max_factor_inc = isize::MAX;\n    let mut cur_factor\
    \ = m;\n    while n > m {\n        if n % cur_factor == 0 {\n            n /=\
    \ cur_factor;\n        } else {\n            m *= cur_factor;\n        }\n   \
    \     if m > max_factor {\n            max_factor = m;\n        }\n        if\
    \ m < max_factor_inc {\n            max_factor_inc = m;\n        }\n        cur_factor\
    \ *= m;\n    }\n    max_factor", "    debug_assert_eq!(n > 1, \"n must be > 1\"\
    );\n    let mut i = 1;\n    let mut j = n;\n    let mut m = 0;\n    while m !=\
    \ i {\n        let mut k = j;\n        while k * k <= i {\n            k += 1;\n\
    \        }\n        if k == i {\n            i += 1;\n        } else {\n     \
    \       m = k;\n        }\n        j -= k;\n    }\n    i", "    let mut f = 2;\n\
    \    while f * f <= n {\n        if n % f == 0 {\n            return f;\n    \
    \    }\n        f += 1;\n    }\n    n", "    (1..n).max_by(|a, b| {\n        a.cmp(&b).unwrap()\
    \ <= 0 && a.cmp(&b).unwrap() > -1\n    })", "    if n <= 1 {\n        1\n    }\
    \ else if n % 2 == 0 {\n        largest_prime_factor(n / 2)\n    } else {\n  \
    \      let max_prime = prime_divisors(n).last().unwrap();\n        let max_prime_divisor\
    \ = max_prime + 1;\n        let mut i = 2;\n        while i * i <= n {\n     \
    \       if n % i == 0 {\n                i += 1;\n            } else {\n     \
    \           i = max_prime_divisor;\n            }\n        }\n        i as usize\n\
    \    }", "    let mut f: isize = 0;\n    let mut c: isize = 1;\n    loop {\n \
    \       if n % c == 0 {\n            f = c + 1;\n        }\n        c = c * f\
    \ + 1;\n        if c >= n {\n            break;\n        }\n    }\n    f", " \
    \   debug_assert!(n > 1);\n    debug_assert!(n & 1 == 0);\n\n    let mut factor\
    \ = 1;\n    let mut prime = 1;\n    let mut i = 2;\n\n    while i < n {\n    \
    \    if n % i == 0 {\n            factor *= i;\n            prime += 1;\n    \
    \    }\n        i += 2;\n    }\n\n    if factor < n / prime {\n        factor\n\
    \    } else {\n        prime * largest_prime_factor(n / prime)\n    }", "    use\
    \ std::cmp::min;\n    use std::cmp::Ordering;\n\n    let mut fp = 1;\n    let\
    \ mut fd = 1;\n\n    let mut n = n / fd;\n\n    while n > 1 {\n        if n %\
    \ fd != 0 {\n            n = n / fd;\n        } else {\n            n = n * fd;\n\
    \            fp = fp * fd;\n            fd = 1;\n        }\n    }\n\n    fn largest_prime_factor(n:\
    \ isize) -> isize {\n        let mut fp = 1;\n        let mut fd = 1;\n\n    \
    \    while n > 1 {\n            let mut n = n / fd;\n            while n % fd\
    \ == 0 && n > 1 {\n                n = n / fd;\n            }\n            if\
    \ n % fd != 0 {\n                n = n / fd;\n            } else {\n         \
    \       n = n * fd;\n                fp = fp * fd;\n                fd = 1;\n\
    \            }\n        }\n\n        n / fd\n    }\n\n    if n > 2 {\n       \
    \ if n < 2 {\n            return 1;\n        }\n        if n % 2 == 0 {\n    \
    \        return n;\n        }\n        let mut p = 2;\n        while p < n {\n\
    \            if n % p == 0 {\n                n = n / p;\n                break;\n\
    \            }\n            p = p * 2;\n        }\n    }\n    largest_prime_factor(n)",
  "    let mut result = n;\n    for i in 2..result {\n        result = if n % i ==\
    \ 0 {\n            i\n        } else {\n            result\n        };\n    }\n\
    \    result", "    let mut f = 2;\n    while f * f <= n {\n        if n % f ==\
    \ 0 {\n            f += 2;\n        } else if f == 2 {\n            f = 2;\n \
    \       } else {\n            break;\n        }\n    }\n    f", "    if n > 1\
    \ {\n        largest_prime_factor_inner(n - 1)\n    } else {\n        n\n    }",
  "    let mut i = 1;\n    while i * i <= n {\n        if n % i == 0 {\n         \
    \   i += 1;\n        } else {\n            i -= 1;\n        }\n    }\n    n -\
    \ i", "    let mut r = 1;\n    let mut m = n;\n\n    for _ in 0..=3 {\n      \
    \  m *= 2;\n\n        if m % 2 == 0 {\n            break;\n        }\n\n     \
    \   r *= m;\n    }\n\n    if m == 1 {\n        return 2;\n    }\n\n    m -= 1;\n\
    \n    while m % 2 == 0 {\n        r -= 1;\n        m /= 2;\n    }\n\n    if m\
    \ == 1 {\n        return r;\n    }\n\n    return r;", "    fn largest_prime_factor(n:\
    \ isize) -> isize {\n        if n < 1 {\n            return n;\n        }\n\n\
    \        let mut i = 1;\n        let mut prime_found = true;\n\n        while\
    \ prime_found && i <= n {\n            if n % i == 0 {\n                prime_found\
    \ = false;\n            } else {\n                i += 1;\n            }\n   \
    \     }\n\n        if prime_found {\n            i\n        } else {\n       \
    \     n\n        }\n    }\n\n    let largest_prime = largest_prime_factor(n);\n\
    \n    if n % largest_prime == 0 {\n        largest_prime\n    } else {\n     \
    \   n\n    }", "    let mut max_prime = n;\n    let mut prime_factor = 1;\n  \
    \  for _ in 0..((max_prime - 1) / 2) {\n        if n % prime_factor == 0 {\n \
    \           max_prime /= prime_factor;\n        } else {\n            prime_factor\
    \ *= 2;\n        }\n    }\n    max_prime", "    if n < 2 {\n        return 1;\n\
    \    }\n\n    let mut i = 2; // i is guaranteed to be odd above by the while loop.\n\
    \    let mut prime_factor = 1;\n\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            prime_factor = i;\n            break;\n        }\n\n      \
    \  i += 2;\n    }\n\n    if prime_factor > 2 {\n        prime_factor\n    } else\
    \ {\n        n\n    }", "    let mut fs = vec![n];\n    for i in 1..=n {\n   \
    \     if fs[i - 1] != 1 {\n            let s = 2;\n            let mut m = i;\n\
    \            loop {\n                if fs[m - 1] != 1 {\n                   \
    \ fs[m - 1] += 1;\n                } else {\n                    break;\n    \
    \            }\n                if m * m < i {\n                    break;\n \
    \               }\n                if fs[m] == 1 {\n                    break;\n\
    \                }\n                s += 2;\n                m *= m;\n       \
    \     }\n            fs[i] = s;\n        }\n    }\n    fs.iter().max().unwrap_or(1)",
  "    let mut max_factor = 1;\n\n    while n % 2 == 0 {\n        max_factor *= 2;\n\
    \        n /= 2;\n    }\n\n    for divisor in &[2..] {\n        while n % divisor\
    \ == 0 {\n            n /= divisor;\n            max_factor = cmp::max(max_factor,\
    \ divisor);\n        }\n    }\n\n    if n == 1 {\n        max_factor\n    } else\
    \ {\n        max_factor\n    }", "    fn prime_factors_iter(n: isize) -> Result<Vec<isize>,\
    \ Vec<isize>> {\n        if n < 2 {\n            return Err(vec![0isize]);\n \
    \       }\n        if n == 2 {\n            return Ok(vec![2]);\n        }\n \
    \       let mut prime_factors: Vec<isize> = Vec::new();\n        let mut next_prime_factor\
    \ = 2;\n        let mut factors = Vec::new();\n        while factors.len() < n\
    \ {\n            if n % next_prime_factor == 0 {\n                prime_factors.push(next_prime_factor);\n\
    \                factors.push(next_prime_factor);\n            } else {\n    \
    \            next_prime_factor *= prime_factors.last().unwrap() + 1;\n       \
    \     }\n        }\n        Ok(prime_factors)\n    }\n    let prime_factors =\
    \ prime_factors_iter(n)?;\n    prime_factors.iter().rev().next().unwrap_or(n)",
  "    let mut result = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            result = (result * (i));\n            i /= i;\n  \
    \      } else {\n            i += 1;\n        }\n    }\n    result", "    debug_assert!(n\
    \ > 1);\n\n    let mut i = 2;\n    let mut prime = true;\n    let mut highest\
    \ = n;\n\n    while i * i <= n && prime {\n        i += 1;\n\n        if n % i\
    \ == 0 {\n            prime = false;\n            i += 1;\n            highest\
    \ = n;\n        }\n    }\n\n    i", "    if n > 1 && is_prime(n) {\n        return\
    \ n;\n    }\n\n    for i in 2..=n/2 {\n        if n % i == 0 {\n            return\
    \ i;\n        }\n    }\n\n    n", "    if n == 0 {\n        return 0;\n    }\n\
    \n    fn next_factor(mut x: isize, i: usize) -> bool {\n        if x%i == 0 {\n\
    \            x = x/i;\n            return false;\n        }\n        i += 1;\n\
    \        x*=i;\n        return true;\n    }\n    \n    let mut x = 2u64;\n   \
    \ let mut i: usize = 2;\n    loop {\n        if next_factor(x, i) && (x>n) then\
    \ break x;\n        i += 1;\n        x*=i;\n    }\n    i", "    let mut f = 1;\
    \ // The largest prime factor seen so far\n    let mut m = n;\n    while m > 1\
    \ && prime_factorize(m) == 1 {\n        m /= 2;\n        f *= 2;\n    }\n    f",
  "    let mut max_factor = 1;\n    let mut max_factor_count = n;\n    while max_factor_count\
    \ > 1 {\n        if n % max_factor_count == 0 {\n            max_factor_count\
    \ = n / max_factor_count;\n        } else {\n            max_factor_count = 1;\n\
    \        }\n        max_factor *= max_factor_count;\n    }\n    max_factor", " \
    \   let mut i = 2;\n    while i <= n {\n        if n % i == 0 {\n            n\
    \ = n / i;\n        } else {\n            i += 1;\n        }\n    }\n    i", " \
    \   let mut s = 2;\n    while n % s != 0 {\n        s += 1;\n    }\n    s", '    factorization(n).iter().max().expect("no
    prime factors found")', '    largest_factor(n) + 1', "    let mut f = n;\n   \
    \ let mut f_sq = f;\n    loop {\n        f_sq = f_sq * f;\n        if f_sq ==\
    \ 1 {\n            break;\n        }\n        let q = div_mod_positive(n, f_sq);\n\
    \        let r = n % f_sq;\n        n = q;\n        f = r;\n    }\n    f", " \
    \   let mut a = n + 1;\n    let mut i = 3;\n    while i <= n {\n        if n %\
    \ i == 0 {\n            a = i;\n            break;\n        }\n        i += 2;\n\
    \    }\n    a", "    if n <= 1 {\n        return 1;\n    }\n    fn factor(i: isize)\
    \ -> bool {\n        n % i == 0\n    }\n    let mut i = 2; // The next prime to\
    \ test\n    let mut max_factor = 1;\n    while i <= n {\n        if factor(i)\
    \ {\n            while i <= n && factor(i) {\n                i += 1;\n      \
    \      }\n            if i == n {\n                break;\n            }\n   \
    \         max_factor = i;\n        }\n        i += 1;\n    }\n    max_factor",
  "    let mut largest_prime_factor = std::cmp::max(self.prime_factor(n));\n    while\
    \ n % largest_prime_factor != 0 {\n        largest_prime_factor = std::cmp::max(\n\
    \            largest_prime_factor,\n            self.prime_factor(n % largest_prime_factor),\n\
    \        );\n        n /= largest_prime_factor;\n    }\n    n", "    let mut factors\
    \ = vec![1, 2];\n    while n > 1 {\n        if n % factors.last().unwrap() ==\
    \ 0 {\n            break;\n        }\n        factors.push(n % factors.last().unwrap());\n\
    \        n /= factors.last().unwrap();\n    }\n    factors.pop()", "    if n <\
    \ 3 {\n        return 1;\n    }\n    fn gcd(a: isize, b: isize) -> isize {\n \
    \       if b == 0 {\n            a\n        } else {\n            gcd(b, a % b)\n\
    \        }\n    }\n\n    let mut f = 1;\n    for &i in &[3..] {\n        let mut\
    \ g = f;\n        if n % i == 0 {\n            let mut j = 0;\n            for\
    \ &j in &[i..] {\n                let t = i / j;\n                if t != 1 {\n\
    \                    g = gcd(g, t);\n                }\n            }\n      \
    \      f = g;\n        }\n    }\n    f", "    let mut res = 2; // Start with 2\n\
    \    let mut limit = (n as isize) as isize; // n must be odd\n\n    // Loop while\
    \ limit is greater than or equal to 2\n    while limit > 1 {\n        if n % res\
    \ == 0 {\n            limit = limit / res;\n        } else {\n            res\
    \ = res + 2;\n        }\n    }\n\n    if limit > 1 {\n        limit\n    } else\
    \ {\n        n\n    }", "    let mut i = 2;\n    let mut m = n;\n    loop {\n\
    \        let mut m = m / i;\n        if m == 1 {\n            break;\n       \
    \ }\n        i += 1;\n    }\n    i", "    // The prime factors found will be cached\
    \ as we find them.\n    let mut largest = 1;\n\n    // The first prime candidate\
    \ is 2, which is prime\n    for p in 2..n {\n        if n % p == 0 {\n       \
    \     largest = p;\n            break;\n        }\n    }\n\n    for p in 3..n\
    \ {\n        if n % p == 0 {\n            largest = p;\n            break;\n \
    \       }\n    }\n\n    largest", "    // Use Fermat's little theorem to find\
    \ the largest prime factor of n.\n    let mut i = 2;\n    let mut max_factor:\
    \ isize = 0;\n    let mut prime_found = false;\n\n    while i * i <= n && !prime_found\
    \ {\n        if n % i == 0 {\n            max_factor = i;\n            prime_found\
    \ = true;\n        }\n        i += 1;\n    }\n    max_factor", "    let mut i\
    \ = 1;\n    while n % i == 0 {\n        i += 1;\n    }\n    i", "    if n > 1\
    \ {\n        let mut max_divisor = 1;\n        let mut factor = 1;\n\n       \
    \ for divisor in 2..n {\n            if n % divisor == 0 {\n                factor\
    \ = divisor;\n            } else {\n                if factor > max_divisor {\n\
    \                    max_divisor = factor;\n                }\n              \
    \  factor = 1;\n            }\n        }\n\n        max_divisor\n    } else {\n\
    \        n\n    }", "    (2..=n).step_by(|i| {\n        if n % i == 0 {\n    \
    \        i += 1;\n        }\n        i % 2\n    }).rev().first().unwrap()", " \
    \   let mut res = 1;\n\n    for (i, factor) in (&n)*(&n).rev().iter().enumerate()\
    \ {\n        if factor*factor > res {\n            res = factor;\n        }\n\
    \    }\n\n    res", "    if n < 2 {\n        return 1;\n    }\n\n    let mut max\
    \ = 2;\n    let mut prime: isize = 2;\n    while prime <= n {\n        if n %\
    \ prime == 0 {\n            max = prime;\n        }\n        prime += 1;\n   \
    \ }\n\n    max", "    let mut n = n as isize;\n    loop {\n        let mut n2\
    \ = n * n as isize;\n        loop {\n            n += 1;\n            if n % n2\
    \ == 0 {\n                break n2;\n            }\n            n2 += 2;\n   \
    \     }\n    }\n    n", "    use num_bigint::{BigInt, Sign};\n\n    if n == 1\
    \ {\n        return 1;\n    }\n\n    let mut p = 2;\n    let mut d = 2;\n    let\
    \ mut i = 1;\n\n    while i < n {\n        if n % p == 0 {\n            d = p;\n\
    \        }\n\n        if n % d == 0 {\n            p = d;\n        }\n\n     \
    \   i += 1;\n    }\n\n    if p*p > n {\n        p\n    } else {\n        n\n \
    \   }", "    if n % 2 == 0 {\n        return 2\n    }\n    let mut m = 3;\n  \
    \  while m <= n / 2 {\n        if n % m == 0 {\n            return m;\n      \
    \  }\n        m += 1;\n    }\n    n", "    let mut prime_limit = n as usize;\n\
    \    while prime_limit > 2 {\n        if n % prime_limit == 0 {\n            prime_limit\
    \ = n;\n        } else {\n            prime_limit /= 2;\n        }\n    }\n  \
    \  prime_limit", "    let mut i = 2;\n    let mut p = 0;\n    while i <= n {\n\
    \        if n % i == 0 {\n            p = i;\n            break;\n        }\n\
    \        i += 1;\n    }\n    p", "    loop {\n        if n % 2 == 0 {\n      \
    \      return 2;\n        }\n\n        for factor in &[2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43, 47] {\n            if n % factor == 0 {\n      \
    \          return factor;\n            }\n        }\n\n        n /= 2;\n    }",
  "    let mut i = 26;\n    let mut j = 0;\n    let mut p = 1;\n    let mut largest_prime_factor\
    \ = 1;\n\n    while i * i <= n {\n        while n % i == 0 {\n            i +=\
    \ 1;\n        }\n        if i == 1 {\n            break;\n        }\n        if\
    \ i % j == 0 {\n            break;\n        }\n        j += 1;\n        p += 1;\n\
    \        if p > largest_prime_factor {\n            largest_prime_factor = p;\n\
    \        }\n    }\n    largest_prime_factor", '    n.checked_add((2..=n.sqrt()
    as isize).find(|&x| n % x == 0).unwrap()).unwrap_or(n)', "    let mut i = 2;\n\
    \    let mut j = n;\n\n    while i < j {\n        let mut k = 1;\n\n        while\
    \ j * k < i {\n            k += 1;\n        }\n\n        if i == k {\n       \
    \     return i;\n        }\n\n        i = k;\n        j -= k;\n    }\n\n    i",
  "    let mut i: isize = 2;\n    loop {\n        while n % i == 0 {\n           \
    \ i += 1;\n            if i > n {\n                break;\n            }\n   \
    \     }\n        if i == 2 {\n            break;\n        }\n        i += 2;\n\
    \    }\n    i", "    factorization(n)\n        .iter()\n        .filter_map(|i|\
    \ if *i > 1 { Some(*i) } else { None })\n        .max()\n        .unwrap_or(1)",
  "    fn max_factor(n: isize) -> isize {\n        fn factor(n: isize) -> isize {\n\
    \            if n == 1 {\n                return 1;\n            }\n         \
    \   let mut max_factor = 2;\n            let mut div = n / 2;\n            while\
    \ div != 0 {\n                if n % div == 0 {\n                    max_factor\
    \ *= div;\n                    n /= div;\n                } else {\n         \
    \           div *= max_factor;\n                }\n            }\n           \
    \ return max_factor;\n        }\n        let max_factor = factor(n);\n       \
    \ if max_factor == 1 {\n            return 1;\n        }\n        factor(n)\n\
    \    }\n    let max_factor = max_factor(n);\n    max_factor", "    if n < 3 {\n\
    \        1\n    } else {\n        let mut i = 2;\n        let mut j = 0;\n   \
    \     while i * j < n {\n            if n % i == 0 {\n                i += 1;\n\
    \                break;\n            } else {\n                j += 1;\n     \
    \       }\n        }\n        j\n    }", "    let mut prime_factors = Vec::new();\n\
    \    let mut is_prime = true;\n    let mut max_prime = n / 2;\n\n    while is_prime\
    \ {\n        let mut i = 1;\n        while i <= max_prime {\n            let mut\
    \ test = (i * max_prime) % n;\n            if test != 0 {\n                break;\n\
    \            }\n            i += 1;\n        }\n\n        if i == max_prime {\n\
    \            is_prime = false;\n            prime_factors.push(i);\n        }\
    \ else {\n            max_prime += 1;\n        }\n    }\n\n    prime_factors.iter().max().unwrap()",
  "    let mut factor = 1;\n    let mut i = 2;\n    while i * i <= n {\n        if\
    \ n % i == 0 {\n            factor = i;\n            i += 1;\n        }\n    \
    \    i += 1;\n    }\n    factor", "    if n < 2 {\n        return n;\n    }\n\n\
    \    let mut largest = u64::from(2);\n\n    for prime in 1..=n {\n        if n\
    \ % prime == 0 {\n            if largest < prime as u64 {\n                largest\
    \ = prime;\n            }\n        }\n    }\n\n    largest", "    let mut i =\
    \ 2;\n    let mut max_factor = 1;\n    while i * i <= n {\n        if n % i ==\
    \ 0 {\n            i += 1;\n            continue;\n        }\n        while n\
    \ % i == 0 {\n            i += 1;\n            n /= i;\n        }\n        max_factor\
    \ = i;\n    }\n    if n == 1 {\n        max_factor\n    } else {\n        max_factor\
    \ + 1\n    }", "    let mut largest_divisor = 0;\n    let mut largest_divisor_n\
    \ = 0;\n    let mut largest_divisor_n_size = 0;\n    let mut largest_divisor_n_size_index\
    \ = 0;\n    for i in 1..n {\n        let mut found = false;\n        for j in\
    \ 2..i {\n            if i % j == 0 {\n                found = true;\n       \
    \         break;\n            }\n        }\n        if found {\n            if\
    \ largest_divisor_n_size < j {\n                largest_divisor_n_size = j;\n\
    \                largest_divisor_n_size_index = i;\n            }\n        }\n\
    \    }\n    if largest_divisor_n_size != 0 {\n        if largest_divisor < largest_divisor_n_size\
    \ {\n            largest_divisor = largest_divisor_n_size;\n        }\n    }\n\
    \    largest_divisor_n_size", "    fn is_prime(n: isize) -> bool {\n        n\
    \ > 1 && !(n % 2)\n    }\n\n    let mut highest_factor = 1;\n    for f in 2..n\
    \ {\n        if !is_prime(f) {\n            highest_factor = f\n            break;\n\
    \        }\n    }\n\n    highest_factor", "    let mut result = n;\n\n    // Factor\
    \ the number by squaring it.\n    // Do this until it gets small enough that we\
    \ can factor it.\n    loop {\n        result *= result % isize::max_value();\n\
    \        if result < n {\n            break;\n        }\n    }\n\n    // The number\
    \ was squared, so if it had a factor, then it was bigger than\n    // n. Otherwise,\
    \ check if it made a prime (by trying all odd numbers up to\n    // sqrt(n)).\n\
    \    if n % result == 0 {\n        result\n    } else {\n        prime_factors_up_to_root(&mut\
    \ result).unwrap()\n    }", "    let mut factor = 1;\n    let mut i = 2;\n   \
    \ while i * i < n && n % i != 0 {\n        factor *= i;\n        i += 1;\n   \
    \ }\n    i", "    let mut i = 2;\n\n    while i * i <= n {\n        i += 1;\n\
    \    }\n\n    i;", "    let mut result = 2;\n\n    while result < n {\n      \
    \  result = n % result;\n    }\n\n    result", "    // Avoid division by zero\n\
    \    if n % 2 == 0 {\n        return n / 2;\n    }\n    let mut m = n;\n    let\
    \ mut p = 2;\n    while p * p <= m {\n        if m % p == 0 {\n            m /=\
    \ p;\n        } else {\n            p *= 2;\n        }\n    }\n    p", "    let\
    \ mut max_factor = 1;\n    let mut max_prime = 2;\n\n    for f in 2..=n {\n  \
    \      if n % f == 0 {\n            let p = f*max_factor;\n            if p >\
    \ max_prime {\n                max_prime = p;\n                max_factor = 1;\n\
    \            } else {\n                max_factor = p;\n            }\n      \
    \  }\n    }\n    max_prime", "    let mut largest_prime_factor = isize::max_value();\n\
    \    for i in 2..=n/2 {\n        if n % i == 0 {\n            if largest_prime_factor\
    \ > i {\n                largest_prime_factor = i;\n            }\n        }\n\
    \    }\n    largest_prime_factor", "    assert!(n > 1);\n    let mut i = 2;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            i += 1;\n      \
    \  } else {\n            i += 2;\n        }\n    }\n    i", "    let mut n = n\
    \ as u64;\n    let mut max_factor = n as isize;\n\n    while n > 1 {\n       \
    \ if n % 2 == 0 {\n            n /= 2;\n        } else {\n            n /= 2;\n\
    \            max_factor = std::cmp::max(max_factor, n as isize);\n        }\n\
    \    }\n\n    max_factor", "    let mut n = n / 2;\n    let mut i = 1;\n    while\
    \ i * i <= n {\n        i = i + 1;\n        n = n / i;\n    }\n    i", "    let\
    \ mut factors = Vec::new();\n    factors.push(2);\n    while n >= 2 {\n      \
    \  let factor: isize = n % factors.last().unwrap();\n        factors.push(factor);\n\
    \        n = n / factor;\n    }\n    factors.reverse();\n    factors.last().unwrap()",
  "    largest_prime_factor_iter(n)\n        .next()\n        .expect(\"cannot find\
    \ largest_prime_factor\")", "    debug!(\"largest_prime_factor\");\n    let mut\
    \ factor = 1;\n    while n % factor == 0 {\n        factor += 1;\n    }\n    factor",
  "    match n {\n        1 => 1,\n        2 => 2,\n        _ => {\n            let\
    \ m = &*n % isize::max_value();\n            if *m > m {\n                m\n\
    \            } else {\n                largest_prime_factor(&(n - m))\n      \
    \      }\n        }\n    }", "    match n % 2 {\n        0 => 3,\n        1 =>\
    \ 5,\n        _ => n,\n    }", '    largest_prime_factors(n)[0]', "    let mut\
    \ p = 2;\n    while n >= p {\n        let next = n%p;\n        if next != 0 {\n\
    \            break;\n        }\n        p += 1;\n    }\n    p", "    let mut f:\
    \ usize = 2; // starting at 2 since the largest prime factor is 2\n    while f\
    \ * f <= n {\n        if n % f == 0 {\n            return f;\n        }\n    \
    \    f += 1;\n    }\n    return f;", '    (1..n).filter(|&n| is_prime(n)).max()',
  "    let mut p = 1i32;\n    let mut i = 3i32;\n    while i <= n {\n        if n\
    \ % i == 0 {\n            p += 1;\n        }\n        i += 2i32;\n    }\n    p",
  "    if n < 2 {\n        return 0;\n    }\n\n    let mut i = 1;\n\n    while i *\
    \ i <= n {\n        if n % i == 0 {\n            return i;\n        }\n\n    \
    \    i += 1;\n    }\n\n    return n;", "    let mut f = 1usize;\n    loop {\n\
    \        if n % f == 0 {\n            return f;\n        }\n        f += 2usize;\n\
    \        if f > 1usize {\n            return 1usize;\n        }\n    }", "   \
    \ let mut i = 2;\n    while i * i < n {\n        if n % i == 0 {\n           \
    \ return i;\n        }\n        i += 1;\n    }\n    n", "    let mut m = n as\
    \ usize;\n    let mut p = 2 as usize;\n    while p < n {\n        if n % p ==\
    \ 0 {\n            m = n / p;\n            p += 1;\n        }\n        p += 1;\n\
    \    }\n    m", "    let mut f = 1isize;\n    let mut max_f = 2isize;\n    while\
    \ f * f <= n {\n        if n % f == 0 {\n            f = f * 2;\n        } else\
    \ {\n            f += 1;\n        }\n        if f > max_f {\n            max_f\
    \ = f;\n        }\n    }\n    max_f", "    let mut primes = vec![2;]; // Primes\
    \ <= n are already known to be non-prime factors\n    let mut factors = Vec::new();\n\
    \    // Check prime factors up to the square root of the number.\n    for i in\
    \ 2..=n.sqrt() {\n        if n / i != i {\n            continue;\n        }\n\
    \        for p in primes.iter().rev() {\n            // Test for factor of i\n\
    \            if n % p == 0 {\n                factors.push(i);\n             \
    \   break;\n            }\n        }\n    }\n    factors.sort_unstable();\n  \
    \  factors.first().unwrap_or(n)", "    let mut factors = vec![];\n    let mut\
    \ i = 2;\n    while i <= n {\n        if n % i == 0 {\n            factors.push(i);\n\
    \        }\n        i += 1;\n    }\n    factors.iter().max().unwrap()", "    let\
    \ mut i = 2;\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ i;\n        }\n        i += 1;\n    }\n    return n;", "    let mut ns: Vec<_>\
    \ = vec![n as usize];\n    loop {\n        ns.push(n);\n        n = smallest_prime_factor(n);\n\
    \        if ns.remove(&n).is_some() {\n            break;\n        }\n    }\n\
    \    ns.reverse();\n    ns.pop()", "    debug_assert_eq!(n > 0, \"n must be greater\
    \ than 0\");\n    let mut primes = vec![2..n];\n    primes.remove(&1);\n\n   \
    \ for prime in primes.iter() {\n        let mut max_multiple: isize = 0;\n   \
    \     let mut prime_factor = 1;\n        while prime > 1 {\n            if prime\
    \ % 2 == 0 {\n                prime_factor *= 2;\n            }\n            prime_factor\
    \ = prime / 2;\n            prime = prime % primes.len();\n        }\n       \
    \ max_multiple = max_multiple < prime_factor ? max_multiple : prime_factor;\n\
    \    }\n    max_multiple", "    let mut n = n as isize;\n    let mut max_factor\
    \ = 1;\n    let mut i = 2;\n    while i < n {\n        let mut j = i;\n      \
    \  while j < n && n % j == 0 {\n            j = j + 1;\n        }\n        if\
    \ j > max_factor {\n            max_factor = j;\n        }\n        i = j;\n \
    \   }\n    max_factor", "    if n < 2 {\n        return 1;\n    }\n\n    // n\
    \ & 1 => n must be prime\n    if n == 1 {\n        return n;\n    }\n\n    let\
    \ mut i = 2;\n\n    while i * i <= n {\n        if n % i == 0 {\n            return\
    \ i;\n        }\n        i += 1;\n    }\n\n    return n;", "    let mut m = n;\n\
    \    let mut m2 = 1;\n    while m2 <= m {\n        let mut m3 = m;\n        while\
    \ m3 % m2 == 0 {\n            m3 /= m2;\n        }\n        if m3 != 1 {\n   \
    \         m2 += m3;\n        } else {\n            break;\n        }\n    }\n\
    \    m", "    let mut a = primes::get();\n    a.checked_add(n).unwrap();\n   \
    \ while a.is_prime(1) {\n        a.checked_add(1).unwrap();\n    }\n    a.checked_add(2).unwrap();\n\
    \    while a.is_prime(2) {\n        a.checked_add(1).unwrap();\n    }\n    a.checked_add(3).unwrap();\n\
    \    while a.is_prime(3) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(4) {\n        a.checked_add(1).unwrap();\n    }\n    a.checked_add(5).unwrap();\n\
    \    while a.is_prime(5) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(6) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(7)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(8) {\n  \
    \      a.checked_add(1).unwrap();\n    }\n    while a.is_prime(9) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(10) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(11) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(12) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(13)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(14) {\n \
    \       a.checked_add(1).unwrap();\n    }\n    while a.is_prime(15) {\n      \
    \  a.checked_add(1).unwrap();\n    }\n    while a.is_prime(16) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(17) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(18) {\n        a.checked_add(1).unwrap();\n    }\n    while\
    \ a.is_prime(19) {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(20)\
    \ {\n        a.checked_add(1).unwrap();\n    }\n    while a.is_prime(21) {\n \
    \       a.checked_add(1).unwrap();\n    }\n    while a.is_prime(22) {\n      \
    \  a.checked_add(1).unwrap();\n    }\n    while a.is_prime(23) {\n        a.checked_add(1).unwrap();\n\
    \    }\n    while a.is_prime(24) {\n        a.checked_add(1).unwrap();\n    }\n\
    \    while a.is_prime(25) {\n        a.checked_add(1).", "    let mut i: isize\
    \ = 1;\n    let mut m: isize = 1;\n    for _ in 0..n {\n        if n % i == 0\
    \ {\n            i = i * m / i;\n            m = 1;\n        } else {\n      \
    \      m = m * m / i;\n        }\n    }\n    i", "    use std::cmp::Ordering::{GT,\
    \ Less};\n\n    // n is odd\n    if n % 2 == 1 {\n        return 1;\n    }\n\n\
    \    // n is prime\n    if n == 1 {\n        return n;\n    }\n\n    // 2 is the\
    \ smallest even integer\n    if n == 2 || n % 2 == 0 {\n        return 2;\n  \
    \  }\n\n    let mut m = n::max_value();\n\n    while m % 2 == 0 {\n        m /=\
    \ 2;\n    }\n\n    while m % 3 == 0 {\n        m /= 3;\n    }\n\n    while m %\
    \ 5 == 0 {\n        m /= 5;\n    }\n\n    while m % 7 == 0 {\n        m /= 7;\n\
    \    }\n\n    while m % 11 == 0 {\n        m /= 11;\n    }\n\n    while m % 13\
    \ == 0 {\n        m /= 13;\n    }\n\n    while m % 17 == 0 {\n        m /= 17;\n\
    \    }\n\n    while m % 19 == 0 {\n        m /= 19;\n    }\n\n    while m % 23\
    \ == 0 {\n        m /= 23;\n    }\n\n    while m % 29 == 0 {\n        m /= 29;\n\
    \    }\n\n    while m % 31 == 0 {\n        m /= 31;\n    }\n\n    while m % 37\
    \ == 0 {\n        m /= 37;\n    }\n\n    while m % 41 == 0 {\n        m /= 41;\n\
    \    }\n\n    while m % 43 == 0 {\n        m /= 43;\n    }\n\n    while m % 47\
    \ == 0 {\n        m /= 47;\n    }\n\n    while m % 53 == 0 {\n        m /= 53;\n\
    \    }\n\n    while m % 59 == 0 {\n        m /= 59;\n    }\n\n    while m % 61\
    \ == 0 {\n        m /= 61;\n    }\n\n    while m % 67 == 0 {\n        m /= 67;\n\
    \    }\n\n    while m % 71 == 0 {\n        m /= 71;\n    }\n\n    while m % 73\
    \ == 0 {\n        m /= 73;\n    }\n\n    while m % 79 == 0 {\n        m /= 79;\n\
    \    }\n\n    while m % 83 == 0 {\n        m /= 83;\n    }\n\n    while m % 89\
    \ == 0 {\n        m /= 89;\n    }\n\n    while m % 97 == 0 {\n        m /= 97;\n\
    \    }\n\n    while m % 101 == 0 {\n        m /= 101;\n    }\n\n    while m %\
    \ 103 == 0 {\n        m /= 103;\n    }\n\n    while m % 107 == 0 {\n        m\
    \ /= 107;\n    }\n\n    while m % 109 == 0 {\n        m /= 109;\n    }\n\n   \
    \ while m % 113 == 0 {\n        m /= 113;\n", "    let mut prime_factor: Vec<_>\
    \ = (0..n).filter(|&x| *x == 0).collect();\n    let mut prime_factors = vec![0;\
    \ n];\n\n    for &d in &mut prime_factors {\n        if *d >= 2 {\n          \
    \  for &r in &mut prime_factor {\n                if r > d {\n               \
    \     *d = r;\n                    break;\n                }\n            }\n\
    \        }\n    }\n\n    let mut largest_factor = 1;\n    for &d in &prime_factors\
    \ {\n        largest_factor *= d;\n    }\n\n    if largest_factor > n {\n    \
    \    largest_factor\n    } else {\n        n\n    }", '    largest_prime_factors_iter(n).next()',
  "    let mut factor = 1;\n    while n % factor == 0 {\n        factor += 1;\n  \
    \  }\n    factor", "    let mut i = 3;\n    let mut lf = 1;\n    while i * i <=\
    \ n {\n        if n % i == 0 {\n            if i != n {\n                i +=\
    \ 1;\n                lf = 0;\n            } else {\n                i += 1;\n\
    \            }\n        } else {\n            i += 1;\n        }\n    }\n    i",
  "    let mut prime_factor = 2;\n    let mut prime_factors_found = 0;\n\n    while\
    \ prime_factors_found < n / prime_factor {\n        if n % prime_factor == 0 {\n\
    \            n /= prime_factor;\n            prime_factors_found += 1;\n     \
    \   } else {\n            prime_factor += 1;\n        }\n    }\n\n    prime_factor",
  "    let mut is_prime: Vec<_> = Vec::new();\n    for i in 2..n {\n        if is_prime.iter().any(|&x|\
    \ x == true) {\n            return i;\n        }\n        for divisor in 0..i\
    \ {\n            if n % divisor == 0 {\n                is_prime.push(divisor);\n\
    \                break;\n            }\n        }\n    }\n    0", "    let mut\
    \ primes = vec![0; 3];\n    let mut p = 1usize;\n    let mut i = 2;\n    while\
    \ i <= n {\n        while n % p == 0 {\n            primes[0] += 1;\n        \
    \    n /= p;\n        }\n        primes[i] += 1;\n        p *= i;\n        i +=\
    \ 1;\n    }\n    primes[2] // the last one", "    let mut primes = prime_factors(n);\n\
    \    primes.reverse();\n    primes.filter(|x| x < n).max()", "    let mut largest\
    \ = n;\n    let mut counter = 1;\n    loop {\n        largest /= counter;\n  \
    \      if largest % 2 == 1 {\n            return largest;\n        }\n       \
    \ counter += 1;\n    }", "    let mut i = 2isize;\n    let mut max: isize = 1;\n\
    \    while i <= n {\n        if n % i == 0 {\n            max = i;\n        }\n\
    \        i += 2isize;\n    }\n    max", "    let mut i = 1;\n    loop {\n    \
    \    if n % i == 0 {\n            i += 1;\n            n /= i;\n        } else\
    \ {\n            break;\n        }\n    }\n    i", "    // Prime factors of n\
    \ are (n - 1) // 2 - 1 or (n - 1) // 2 + 1\n    let mut prime_factors = vec![n];\n\
    \    prime_factors.push(n - 1);\n    prime_factors.push(n - 1);\n    while prime_factors.len()\
    \ < n.clone() / 2 {\n        for &p in &prime_factors {\n            if n % p\
    \ == 0 {\n                break;\n            }\n        }\n        prime_factors.push(2\
    \ * p);\n    }\n    prime_factors[0]", "    let mut largest_prime_factor = 1;\n\
    \n    if n % 2 == 0 {\n        largest_prime_factor = n.checked_mul(2).unwrap();\n\
    \        largest_prime_factor = largest_prime_factor.checked_add(1).unwrap();\n\
    \    }\n\n    let mut counter = 1;\n    while counter <= n {\n        largest_prime_factor\
    \ = n.checked_mul(largest_prime_factor).unwrap();\n        counter = counter.checked_add(1).unwrap();\n\
    \    }\n\n    largest_prime_factor", "    let mut max_factor = 0;\n    let mut\
    \ next_factor = 1;\n    for prime in &primes {\n        if n > prime {\n     \
    \       n /= prime;\n            max_factor = next_factor;\n            next_factor\
    \ = 1;\n        } else {\n            n /= prime;\n            next_factor *=\
    \ prime;\n        }\n    }\n    max_factor", "    let mut i = 2;\n    while i\
    \ <= n {\n        if n % i == 0 {\n            return i;\n        }\n        i\
    \ += 1;\n    }\n    n", "    let mut n = n as isize;\n    if n % 2 == 1 {\n  \
    \      return 2;\n    }\n    n /= 2;\n    loop {\n        if n == 1 {\n      \
    \      return n;\n        }\n        if n % 2 == 1 {\n            return 2;\n\
    \        }\n        n /= 2;\n    }", "    let mut i = 1;\n    while i <= n {\n\
    \        if n % i == 0 {\n            i += 1;\n        } else {\n            return\
    \ i;\n        }\n    }\n    return i;", "    // Optimize for small numbers that\
    \ won't need a prime.\n    if n < 3 {\n        return n;\n    }\n\n    let mut\
    \ n = n;\n    let mut i = 1;\n\n    // Scan for prime factors.\n    while i *\
    \ i <= n {\n        if n % i == 0 {\n            n /= i;\n        } else {\n \
    \           i += 1;\n        }\n    }\n\n    // Return only the largest prime\
    \ factor.\n    n", "    let mut largest_factor = 1;\n    let mut primes = prime_factors(n);\n\
    \n    while primes.len() > 0 {\n        let mut found = false;\n        let mut\
    \ factor = 1;\n        for prime in primes {\n            if n == prime {\n  \
    \              found = true;\n                factor = 1;\n                continue;\n\
    \            }\n            factor *= prime;\n        }\n        if !found {\n\
    \            largest_factor *= factor;\n        }\n        primes.clear();\n \
    \   }\n    largest_factor", "    let mut i = 2; // start at 2 since 2 will never\
    \ be a prime number\n    let mut max_factor_found = 0;\n\n    // continue increasing\
    \ i by one until we hit our maximum factor\n    while i <= n {\n        // check\
    \ if i is a prime by checking if it divides evenly\n        let mut is_prime =\
    \ true;\n\n        // check if i is divisible by any prime less than i\n     \
    \   while i % 2 == 0 {\n            i += 1;\n            i += 2;\n           \
    \ is_prime = false;\n        }\n\n        // check if i is divisible by any prime\
    \ greater than i\n        while i % 3 == 0 {\n            i += 1;\n          \
    \  i += 2;\n            is_prime = false;\n        }\n\n        // check if i\
    \ is divisible by any prime greater than i\n        while i % 5 == 0 {\n     \
    \       i += 1;\n            i += 2;\n            is_prime = false;\n        }\n\
    \n        // check if i is divisible by any prime greater than i\n        while\
    \ i % 7 == 0 {\n            i += 1;\n            i += 2;\n            is_prime\
    \ = false;\n        }\n\n        // check if i is divisible by any prime greater\
    \ than i\n        while i % 11 == 0 {\n            i += 1;\n            i += 2;\n\
    \            is_prime = false;\n        }\n\n        // check if i is divisible\
    \ by any prime greater than i\n        while i % 13 == 0 {\n            i += 1;\n\
    \            i += 2;\n            is_prime = false;\n        }\n\n        // check\
    \ if i is divisible by any prime greater than i\n        while i % 17 == 0 {\n\
    \            i += 1;\n            i += 2;\n            is_prime = false;\n   \
    \     }\n\n        // check if i is divisible by any prime greater than i\n  \
    \      while i % 19 == 0 {\n            i += 1;\n            i += 2;\n       \
    \     is_prime = false;\n        }\n\n        // check if i is divisible by any\
    \ prime greater than i\n        while i % 23 == 0 {\n            i += 1;\n   \
    \         i += 2;\n            is_prime = false;\n        }\n\n        // check\
    \ if i is divisible by any prime greater than i\n        while i % 29 == 0 {\n\
    \            i += 1;\n            i += 2;\n            is_prime = false;\n   \
    \     }\n\n        // check if i is divisible by any prime greater than i\n  \
    \      while i % 31 == 0 {\n            i += 1;\n            i += 2;\n       \
    \     is_prime = false;\n        }\n\n        // check if i is divisible by any\
    \ prime greater than i\n        while i % 37 == 0 {\n            i += 1;\n   \
    \         i += 2;\n            is_prime = false;\n        }\n\n        // check\
    \ if i is divisible by any prime greater than i\n        while i % 41 == 0 {\n\
    \            i += 1;\n            i += 2;\n            is_prime = false;\n   \
    \     }\n\n        // check if i is divisible by any prime greater than i\n  \
    \      while i % 43 == 0 {\n            i += 1;\n            i += 2;\n       \
    \     is_prime = false;\n        }\n\n        // check if ", "    let mut n =\
    \ n as u64;\n    let mut factors: Vec<isize> = vec![];\n    let mut max = 1;\n\
    \    let mut i = 1;\n    while i <= n {\n        if n % i == 0 {\n           \
    \ factors.push(i);\n            max = i;\n        }\n        i += 1;\n    }\n\
    \    for i in 1..factors.len() {\n        if factors[i] > max {\n            max\
    \ = factors[i];\n        }\n    }\n    max", "    debug_assert_ne!(n as usize,\
    \ \"cannot take the absolute value of a usize\");\n    let mut factors = vec![n\
    \ as isize];\n    factors.insert(factors.len(), 1);\n    loop {\n        let mut\
    \ i = factors.len() - 1;\n        let mut found = false;\n        while i >= 0\
    \ {\n            if factors[i] % n == 0 {\n                factors.pop();\n  \
    \              found = true;\n                break;\n            }\n        \
    \    i -= 1;\n        }\n        if found {\n            break;\n        }\n \
    \       factors.insert(0, n);\n    }\n    factors.len()", "    loop {\n      \
    \  let mut primes = Vec::new();\n        for d in divisors(n) {\n            if\
    \ d > 1 {\n                primes.push(d % n);\n            }\n        }\n   \
    \     if primes.len() == 1 {\n            return primes[0];\n        }\n     \
    \   n = primes[0];\n    }", "    match factorization(n) {\n        Some(factors)\
    \ => factors.len() as isize,\n        None => 1,\n    }", "    let mut i = 2;\n\
    \    while i * i <= n {\n        if n % i == 0 {\n            i += 1;\n      \
    \  } else {\n            i -= 1;\n        }\n    }\n    i", "    if n > 1 {\n\
    \        let mut n = n;\n        let mut d = 0;\n        while n % d == 0 {\n\
    \            d += 1;\n            n /= d;\n        }\n        d\n    } else {\n\
    \        1\n    }", "    let mut prime_factor = 1;\n    let mut current_factor\
    \ = 2;\n\n    while current_factor < n {\n        prime_factor = current_factor;\n\
    \        if n % current_factor == 0 {\n            while n % current_factor !=\
    \ 0 {\n                n /= current_factor;\n                current_factor *=\
    \ 2;\n            }\n            break;\n        }\n        current_factor *=\
    \ 2;\n    }\n    prime_factor", "    let mut i = 3 * n;\n    while i * i <= n\
    \ {\n        i += 1;\n    }\n    i"]
stop_tokens:
- "\n}"
