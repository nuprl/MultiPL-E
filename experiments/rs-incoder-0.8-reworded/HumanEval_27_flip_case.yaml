name: HumanEval_27_flip_case
language: rs
prompt: "/// For a given string, flip lowercase characters to uppercase and uppercase\
  \ to lowercase.\n/// >>> flip_case(String::from(\"Hello\"))\n/// String::from(\"\
  hELLO\")\nfn flip_case(string: String) -> String {\n"
tests: "}\n\nfn main() {\n    let candidate = flip_case;\n    assert_eq!(candidate(String::from(\"\
  \")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"Hello!\")),\
  \ String::from(\"hELLO!\"));\n    assert_eq!(candidate(String::from(\"These violent\
  \ delights have violent ends\")), String::from(\"tHESE VIOLENT DELIGHTS HAVE VIOLENT\
  \ ENDS\"));\n}\n"
completions: ["    match string.len() {\n        0 => return string,\n        _ =>\
    \ {\n            let mut string = string.clone();\n            string.chars().filter(|c|\
    \ c.is_uppercase()).for_each(|c| c.to_ascii_lowercase());\n            string.chars().filter(|c|\
    \ c.is_lowercase()).for_each(|c| c.to_ascii_uppercase());\n            string\n\
    \        }\n    }", "    string.chars().map(|c| match c {\n        'A' .. 'Z'\
    \ => c.to_ascii_lowercase(),\n        'a' .. 'z' => c.to_ascii_uppercase(),\n\
    \        _ => c,\n    })\n    .collect()", '    string.chars().enumerate().map(|(i,
    c)| (c, if i % 2 == 0 { c.to_lowercase() } else { c.to_uppercase() } )).collect()',
  "    if string.is_empty() {\n        string\n    } else {\n        let mut iter\
    \ = string.chars().enumerate();\n        let mut next = match iter.next() {\n\
    \            None => return string,\n            Some((index, c)) if index ==\
    \ 0 => String::from(\"_\"),\n            Some((index, c)) if c.is_lowercase()\
    \ => String::from(\"_\"),\n            Some((index, c)) => c,\n        };\n  \
    \      while let Some(index) = iter.next() {\n            if index == 0 {\n  \
    \              next = match iter.next() {\n                    None => return\
    \ string,\n                    Some((index, c)) if index == 0 => String::from(\"\
    _\"),\n                    Some((index, c)) if c.is_lowercase() => String::from(\"\
    _\"),\n                    Some((index, c)) => c,\n                };\n      \
    \      } else {\n                next = match iter.next() {\n                \
    \    None => return string,\n                    Some((index, c)) if index ==\
    \ 0 => String::from(\"_\"),\n                    Some((index, c)) if c.is_lowercase()\
    \ => String::from(\"_\"),\n                    Some((index, c)) => c,\n      \
    \          };\n            }\n        }\n        String::from(next)\n    }", " \
    \   string.chars().enumerate().filter(|(i, c)| c.is_ascii_lowercase()).map(|(i,\
    \ c)| {\n        c ^ ('A' as u8) - ('A' as u8)\n    }).collect().collect::<String>().to_string()",
  "    let mut string = string.to_string();\n\n    // Convert to lowercase\n    string.chars().for_each(|c|\
    \ {\n        if c >= 'A' && c <= 'Z' {\n            *c = c ^ 'a' - 'A';\n    \
    \    }\n    });\n\n    // Convert to uppercase\n    string.chars().for_each(|c|\
    \ {\n        if c >= 'a' && c <= 'z' {\n            *c = c ^ 'A' - 'a';\n    \
    \    }\n    });\n\n    string", "    string.chars()\n        .filter(|c| !c.is_ascii_lowercase())\n\
    \        .map(|c| if c.is_ascii_uppercase() { c } else { c.to_ascii_lowercase()\
    \ })\n        .collect::<String>()", "    match string.chars() {\n        chars\
    \ => String::from_utf8(\n            chars\n                .iter()\n        \
    \        .map(|c| match c.to_lowercase() { Some(c) => c, None => c })\n      \
    \          .collect::<Vec<_>>(),\n        ),\n    }", '    string.to_lowercase().to_uppercase()',
  "    let mut reversed = string;\n    reversed.chars().for_each(|c| {\n        if\
    \ c.is_lowercase() {\n            *c = c.to_uppercase();\n        } else if c.is_uppercase()\
    \ {\n            *c = c.to_lowercase();\n        }\n    });\n    reversed", " \
    \   string.chars().map(|c| match c {\n        'a' .. 'z' => char::from_digit(c\
    \ - 'a' + 10).unwrap(),\n        'A' .. 'Z' => char::from_digit(c - 'A' + 10).unwrap(),\n\
    \        _ => c,\n    }).collect::<String>().to_string()", "    string.chars().map(|c|\
    \ c.to_ascii_lowercase().to_ascii_uppercase())\n        .collect::<String>()",
  "    string.chars()\n        .map(|c| c.to_ascii_lowercase().into())\n        .chain(string.chars().map(|c|\
    \ c.to_ascii_uppercase().into()))\n        .collect()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            'a' => (c as u8) as char,\n         \
    \   _ => (c as u8) as char,\n        })\n        .collect::<String>()", "    string.chars().rev().chain(string.chars())\n\
    \        .cloned()\n        .map(|c| match c {\n            'A' -> 'a';\n    \
    \        'a' -> 'A';\n            _ -> c,\n        })\n        .collect()", " \
    \   string.chars()\n        .map(|c| if c == 'a' { 'A' } else if c == 'A' { 'a'\
    \ }\n        else if c == 'b' { 'B' } else if c == 'B' { 'b' }\n        else if\
    \ c == 'c' { 'C' } else if c == 'C' { 'c' }\n        else if c == 'd' { 'D' }\
    \ else if c == 'D' { 'd' }\n        else if c == 'e' { 'E' } else if c == 'E'\
    \ { 'e' }\n        else if c == 'f' { 'F' } else if c == 'F' { 'f' }\n       \
    \ else if c == 'g' { 'G' } else if c == 'G' { 'g' }\n        else if c == 'h'\
    \ { 'H' } else if c == 'H' { 'h' }\n        else if c == 'i' { 'I' } else if c\
    \ == 'I' { 'i' }\n        else if c == 'j' { 'J' } else if c == 'J' { 'j' }\n\
    \        else if c == 'k' { 'K' } else if c == 'K' { 'k' }\n        else if c\
    \ == 'l' { 'L' } else if c == 'L' { 'l' }\n        else if c == 'm' { 'M' } else\
    \ if c == 'M' { 'm' }\n        else if c == 'n' { 'N' } else if c == 'N' { 'n'\
    \ }\n        else if c == 'o' { 'O' } else if c == 'O' { 'o' }\n        else if\
    \ c == 'p' { 'P' } else if c == 'P' { 'p' }\n        else if c == 'q' { 'Q' }\
    \ else if c == 'Q' { 'q' }\n        else if c == 'r' { 'R' } else if c == 'R'\
    \ { 'r' }\n        else if c == 's' { 'S' } else if c == 'S' { 's' }\n       \
    \ else if c == 't' { 'T' } else if c == 'T' { 't' }\n        else if c == 'u'\
    \ { 'U' } else if c == 'U' { 'u' }\n        else if c == 'v' { 'V' } else if c\
    \ == 'V' { 'v' }\n        else if c == 'w' { 'W' } else if c == 'W' { 'w' }\n\
    \        else if c == 'x' { 'X' } else if c == 'X' { 'x' }\n        else if c\
    \ == 'y' { 'Y' } else if c == 'Y' { 'y' }\n        else if c == 'z' { 'Z' } else\
    \ if c == 'Z' { 'z' }\n        else { c })\n        .collect::<String", "    string.chars().fold(string,\
    \ |result, c| match c {\n        'A' | 'a' => result.to_ascii_uppercase(),\n \
    \       'B' | 'b' => result.to_ascii_lowercase(),\n        'C' | 'c' => result.to_ascii_uppercase().to_ascii_lowercase(),\n\
    \        'D' | 'd' => result.to_ascii_lowercase(),\n        'E' | 'e' => result.to_ascii_uppercase(),\n\
    \        'F' | 'f' => result.to_ascii_lowercase(),\n        'G' | 'g' => result.to_ascii_uppercase(),\n\
    \        'H' | 'h' => result.to_ascii_lowercase(),\n        _ => result,\n   \
    \ })", "    string.chars().map(|c| match c {\n        'A' .. 'Z' => (c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase()),\n        _ => (c.to_ascii_uppercase(), c.to_ascii_lowercase()),\n\
    \    })\n    .collect()", '    string.to_ascii_lowercase().into_uppercase().to_ascii_lowercase()',
  "    string\n        .chars()\n        .filter_map(|c| match c {\n            c\
    \ @ b'a' => (b'A' as u8) as u8 | c,\n            c @ b'A' => (b'a' as u8) as u8\
    \ | c,\n            _ => c,\n        })\n        .collect::<String>()", "    let\
    \ mut string = string.to_lowercase();\n    for c in string.chars().cloned() {\n\
    \        *c = match c.to_lowercase() {\n            'A' | 'a' => c.to_uppercase(),\n\
    \            _ => c,\n        };\n    }\n    string", "    string.chars()\n  \
    \      .map(|c| if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase()\
    \ })\n        .collect()", "    let mut result: String = string;\n    let mut\
    \ i = 0;\n    while i < result.len() {\n        if result.chars().any(|c| c.to_lowercase()\
    \ == c) {\n            result[i] = result.chars().find(|c| c.to_uppercase() ==\
    \ c).unwrap();\n        } else {\n            result[i] = result.chars().find(|c|\
    \ c.to_uppercase() == c).unwrap();\n        }\n        i += 1;\n    }\n    result",
  "    string.chars().map(|c| match c {\n        c @ b'A' => c @ b'a' as u8,\n   \
    \     _ => c,\n    })\n    .collect()", "    string.chars().map(|c| match c {\n\
    \        'a' .. 'z' => match c {\n            'A' .. 'Z' => c,\n            _\
    \ => c.to_uppercase().to_string()\n        },\n        'A' .. 'Z' => match c {\n\
    \            'a' .. 'z' => c,\n            _ => c.to_lowercase().to_string()\n\
    \        },\n        _ => c\n    }).collect()", "    string.chars().map(|c| match\
    \ c {\n        c if c.is_lowercase() => c.to_uppercase(),\n        c if c.is_uppercase()\
    \ => c.to_lowercase(),\n        _ => c,\n    }).collect::<String>()", "    string.chars()\n\
    \        .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            c if c.is_uppercase() => c.to_lowercase(),\n            _ => c,\n\
    \        })\n        .collect::<String>()", "    string.chars()\n        .map(|c|\
    \ if c >= 'a' && c <= 'z' { c + 32 - 'a' }\n                else             {\
    \ c })\n        .collect::<String>()", "    string.chars()\n        .map(|c| match\
    \ c {\n            b'A' .. b'Z' => c.to_ascii_lowercase(),\n            _ => c.to_ascii_uppercase(),\n\
    \        })\n        .collect()", '    string.into_uppercase().to_lowercase()',
  '    string.to_lowercase().to_uppercase()', "    string.chars()\n        .map(|c|\
    \ c.to_ascii_lowercase().to_ascii_uppercase())\n        .collect()", '    string.to_lowercase().to_uppercase()',
  "    string.chars().filter_map(|c| match c {\n        c @ b'a'..b'z' => (c as u32)..(b'z'\
    \ as u32).saturating_add((b'a' as u32) as u32)..(b'A' as u32) as u8,\n       \
    \ c @ b'A'..b'Z' => (c as u32)..(b'Z' as u32).saturating_add((b'A' as u32) as\
    \ u32)..(b'a' as u32) as u8,\n        _ => c,\n    }).collect()", "    string\n\
    \        .chars()\n        .map(|c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            _ => c.to_lowercase(),\n        })\n     \
    \   .collect()", "    string.chars().map(|c| match c {\n        c @ ('A' as u8..='Z'\
    \ as u8) => {\n            'a' <= c && c <= 'z' as char\n        }\n        c\
    \ @ ('a'..='z' as u8) => {\n            'A' <= c && c <= 'Z' as char\n       \
    \ }\n        _ => c,\n    }).collect()", '    string.to_string().chars().iter().map(|c|
    if c.is_lowercase() { c.to_uppercase() } else { c.to_lowercase() }).collect()',
  "    string\n        .chars()\n        .map(|c| match c {\n            c @ b'A'\
    \ => b'a',\n            c @ b'a' => b'A',\n            c => c,\n        })\n \
    \       .collect::<String>()", "    let mut reversed = String::new();\n    for\
    \ &c in string.chars() {\n        if c.is_lowercase() {\n            reversed.push_uppercase();\n\
    \        } else {\n            reversed.push_lowercase();\n        }\n    }\n\
    \    reversed", "    string.chars()\n        .map(|c| if c.is_lowercase() {\n\
    \            c.to_uppercase()\n        } else {\n            c.to_lowercase()\n\
    \        })\n        .collect()", "    string\n        .chars()\n        .chain(string.chars().map(|c|\
    \ if c == 'a' { c } else if c == 'A' { c } else { c })),\n        .collect()",
  "    string.chars().map(|c| match c {\n        'A' .. 'Z' => c + &'a' - &'A',\n\
    \        'a' .. 'z' => c + &'A' - &'a',\n        _ => c,\n    }).collect()", " \
    \   string\n        .to_uppercase()\n        .chars()\n        .map(|c| match\
    \ c {\n            c => c,\n            _ => c,\n        })\n        .collect()",
  "    let mut s = string.clone();\n    let mut buffer = Vec::new();\n    let mut\
    \ i = 0;\n\n    for c in s.chars() {\n        buffer.push(c);\n        if c.is_lowercase()\
    \ {\n            buffer[i] = c.to_uppercase();\n            i += 1;\n        }\n\
    \        if c.is_uppercase() {\n            buffer[i] = c.to_lowercase();\n  \
    \          i += 1;\n        }\n    }\n\n    String::from_utf8(buffer).unwrap()",
  "    string.chars().map(|c| match c {\n        'A' ..= 'Z' => c - 32,\n        _\
    \ => c,\n    }).collect()", "    string\n        .chars()\n        .filter_map(|c|\
    \ {\n            match c {\n                c if c >= 'a' && c <= 'z' => (c as\
    \ u8) - ('a' as u8) as char,\n                c if c >= 'A' && c <= 'Z' => (c\
    \ as u8) - ('A' as u8) as char,\n                _ => c,\n            }\n    \
    \    })\n        .collect::<String>()", "    string.chars().rev().map(|c| match\
    \ c {\n        c if c.is_uppercase() => c.to_lowercase(),\n        c if c.is_lowercase()\
    \ => c.to_uppercase(),\n        _ => c,\n    }).collect()", "    string\n    \
    \    .chars()\n        .map(|c| {\n            let (ascii_value, ascii_ascii_lower)\
    \ = (c as u32, (c as u32 as u8 as char) as char);\n            ascii_lower + ascii_value\
    \ as char\n        })\n        .collect()", '    string.to_ascii_lowercase().to_ascii_uppercase()',
  "    string.chars()\n        .map(|c| match c.to_ascii_lowercase() {\n         \
    \   Some('a') => Some('A'),\n            Some('b') => Some('B'),\n           \
    \ Some('c') => Some('C'),\n            Some('d') => Some('D'),\n            Some('e')\
    \ => Some('E'),\n            Some('f') => Some('F'),\n            Some('g') =>\
    \ Some('G'),\n            Some('h') => Some('H'),\n            Some('i') => Some('I'),\n\
    \            Some('j') => Some('J'),\n            Some('k') => Some('K'),\n  \
    \          Some('l') => Some('L'),\n            Some('m') => Some('M'),\n    \
    \        Some('n') => Some('N'),\n            Some('o') => Some('O'),\n      \
    \      Some('p') => Some('P'),\n            Some('q') => Some('Q'),\n        \
    \    Some('r') => Some('R'),\n            Some('s') => Some('S'),\n          \
    \  Some('t') => Some('T'),\n            Some('u') => Some('U'),\n            Some('v')\
    \ => Some('V'),\n            Some('w') => Some('W'),\n            Some('x') =>\
    \ Some('X'),\n            Some('y') => Some('Y'),\n            Some('z') => Some('Z'),\n\
    \            _ => None,\n        })\n        .filter(|c| c.is_some())\n      \
    \  .collect::<String>()\n        .join(\"\")", "    string.chars().map(|c| match\
    \ c {\n        'A' ..='Z' => c.to_uppercase(),\n        'a' ..='z' => c.to_lowercase(),\n\
    \        _ => c,\n    })\n    .collect()", "    match string.chars() {\n     \
    \   &char::IsLower() => {\n            let mut builder = String::new();\n    \
    \        for &ch in string.chars() {\n                builder.push((*ch).to_uppercase());\n\
    \            }\n            builder\n        }\n        &char::IsUpper(_) => {\n\
    \            let mut builder = String::new();\n            for &ch in string.chars()\
    \ {\n                builder.push((*ch).to_lowercase());\n            }\n    \
    \        builder\n        }\n        _ => string,\n    }", "    string.chars()\n\
    \        .map(|c| match c {\n            c => c as u32,\n            _ => c.to_ascii_lowercase().into(),\n\
    \        })\n        .filter(|c| c.is_ascii())\n        .map(|c| match c {\n \
    \           c => c as u32,\n            _ => c.to_ascii_uppercase().into(),\n\
    \        })\n        .collect()", "    string.chars().map(|c| match c {\n    \
    \    c if c.is_lowercase() => c,\n        c if c.is_uppercase() => c.to_uppercase(),\n\
    \        c => c.to_lowercase(),\n    }).collect()", "    string\n        .chars()\n\
    \        .map(|c| if c.is_upper() { c.to_ascii_lowercase() } else { c.to_ascii_uppercase()\
    \ })\n        .collect()", '    string.into_iter().map(|c| c.to_ascii_lowercase().to_ascii_uppercase()).collect()',
  "    match string {\n        Ok(s) => s.to_ascii_lowercase().to_string(),\n    \
    \    Err(_) => string.to_string(),\n    }", "    let mut input = string.to_string();\n\
    \    let mut buf = [0u8; input.len()];\n    for i in 0..input.len() {\n      \
    \  if input[i] >= 'a' && input[i] <= 'z' {\n            buf[i] = (input[i] - 'a')\
    \ + ('A' as u8) + 1;\n        }\n        if input[i] >= 'A' && input[i] <= 'Z'\
    \ {\n            buf[i] = (input[i] - 'A') + ('a' as u8) + 1;\n        }\n   \
    \ }\n    String::from_utf8(buf)", '    string.to_ascii_lowercase().to_ascii_uppercase()',
  "    match string.len() {\n        0 => string,\n        _ => {\n            let\
    \ mut buffer = String::from(\"\");\n            for c in string.chars() {\n  \
    \              match c.to_lowercase() {\n                    Some(_) => buffer.push(c),\n\
    \                    _ => buffer.push(c),\n                }\n               \
    \ buffer.push(' ');\n            }\n            buffer\n        }\n    }", " \
    \   string.chars().chain(string.chars().map(|c| match c {\n        c if c.is_lowercase()\
    \ => c.to_uppercase(),\n        c if c.is_uppercase() => c.to_lowercase(),\n \
    \       _ => c,\n    }).collect()).collect()", '    string.to_lowercase().to_uppercase()',
  "    string.chars()\n        .map(|c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    string.chars().map(|c|\
    \ if c.is_uppercase() then c.to_lowercase() else c.to_uppercase())\n        .collect()",
  "    string.chars().filter_map(|c| match c {\n        c @ 'A' => (c as u8 + ('a'\
    \ as u8).to_ascii_lowercase() as u8) as char,\n        c @ 'a' => (c as u8 - ('a'\
    \ as u8).to_ascii_lowercase() as u8) as char,\n        _ => c,\n    })\n    .collect()",
  "    string.chars().map(|c| match c {\n        'A' .. 'Z' => c as u16 ^ 0x20,\n\
    \        'a' .. 'z' => c as u16 ^ 0x20,\n        _ => c,\n    }).collect()", '    string.to_string().to_lowercase().to_uppercase()',
  "    string.to_lowercase()\n        .chars()\n        .map(|c| if c.is_uppercase()\
    \ then c.to_lowercase() else c.to_uppercase())\n        .collect::<String>() +\
    \ string.to_uppercase()", "    string\n        .to_ascii_lowercase()\n       \
    \ .iter()\n        .map(|c| if c >= 'a' && c <= 'z' { c + 32 - ('a' as usize)\
    \ else c })\n        .collect::<String>() + string.to_ascii_uppercase().iter().cloned().collect::<String>()\
    \ + string.to_ascii_lowercase().iter().cloned().collect::<String>()", "    string\n\
    \        .chars()\n        .map(|c| if c.is_lowercase() { c.to_uppercase() } else\
    \ { c.to_lowercase() })\n        .collect()", "    string.chars().map(|c| match\
    \ c {\n        'a' .. 'z' => c as char + 'A' as char,\n        _ => c,\n    }).collect()",
  "    string.chars()\n        .chain(string.chars().map(|c| c.to_lowercase()))\n\
    \        .chain(string.chars().map(|c| c.to_uppercase()))\n        .collect()",
  "    string.chars().chain(\n        string.chars().map(|c| if c >= 'A' && c <= 'Z'\
    \ { c - 'A' + 'a' } else { c }),\n    )\n    .collect::<String>()\n    .to_owned()",
  "    let mut buffer = String::new();\n    let mut iter = string.chars().peekable();\n\
    \    let mut prev: Option<Char> = None;\n    let mut next_lower: Option<Char>\
    \ = None;\n    let mut next_upper: Option<Char> = None;\n    while let Some(next)\
    \ = iter.next() {\n        match prev {\n            None => {}\n            Some(&mut\
    \ c) => {\n                buffer.push(c);\n                prev = Some(next);\n\
    \            }\n            Some(_) => {}\n        }\n        match next_lower\
    \ {\n            None => {}\n            Some(&mut c) => {\n                buffer.push(Char::to_upper(c));\n\
    \                next_lower = Some(next);\n            }\n            Some(_)\
    \ => {}\n        }\n        match next_upper {\n            None => {}\n     \
    \       Some(&mut c) => {\n                buffer.push(Char::to_lower(c));\n \
    \               next_upper = Some(next);\n            }\n            Some(_) =>\
    \ {}\n        }\n    }\n    buffer", "    string.chars().rev().chain(\n      \
    \  string.chars().map(|c| *c < *c.to_ascii_lowercase().unwrap()).rev(),\n    )",
  '    string.to_string().to_lowercase().to_uppercase()', "    string.chars()\n  \
    \      .map(|c| match c {\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            c => c.to_uppercase(),\n        })\n        .collect()", "    if\
    \ string.len() <= 1 {\n        string\n    } else {\n        let mut s = string;\n\
    \        for c in s.chars() {\n            if c.to_lowercase() == c {\n      \
    \          s.swap(0, 1);\n            }\n        }\n        s\n    }", '    string.to_lowercase().to_uppercase()',
  '    string.chars().filter(|c| c.is_ascii_lowercase()).map(|c| c.to_ascii_uppercase()).collect::<String>().into()',
  "    string.chars().chain(string.chars().map(|c| *c ^ (c as u32).to_ascii_lowercase()))\n\
    \             .chain(string.chars().map(|c| *c ^ (c as u32).to_ascii_uppercase()))\n\
    \             .collect()", "    string.chars()\n        .map(|c| if c.is_lowercase()\
    \ { 'a'.to_string() } else if c.is_uppercase() { 'A'.to_string() })\n        .collect::<Vec<_>>()\n\
    \        .join(\"\".to_string())", "    match string {\n        Ok(text) => {\n\
    \            let mut buffer = String::with_capacity(text.len());\n           \
    \ for c in text.chars() {\n                buffer.push_str(match c.to_ascii_lowercase()\
    \ {\n                    Ok(s) => s,\n                    Err(_) => c,\n     \
    \           });\n            }\n            buffer\n        }\n        Err(_)\
    \ => \"\",\n    }", "    string.chars()\n        .map(|c| match c {\n        \
    \    c => c.to_ascii_lowercase(),\n            c => c.to_ascii_uppercase(),\n\
    \        })\n        .collect()", "    string.chars()\n        .map(|c| match\
    \ c {\n            c @ ' ' => c.to_string().to_uppercase(),\n            _ =>\
    \ c,\n        })\n        .collect::<String>()", "    match string.rev() {\n \
    \       None => string,\n        Some(rev) => rev.rev(),\n    }", "    string\n\
    \        .chars()\n        .map(|c| match c {\n            c @ ascii_lowercase()\
    \ => ascii_uppercase(),\n            c @ ascii_uppercase() => ascii_lowercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    string.chars()\n \
    \       .filter_map(|c| match c {\n            c @ b'A' => b'a' << 8 | b'A' <<\
    \ 0 | b'_',\n            _ => c,\n        })\n        .collect::<String>()", " \
    \   match string.to() {\n        None => return string,\n        Some(s) => match\
    \ s.chars().filter_map(|c| match c {\n            c if c.is_uppercase() => Some(c.to_ascii_lowercase()),\n\
    \            c if c.is_lowercase() => Some(c.to_ascii_uppercase()),\n        \
    \    _ => None,\n        }).collect::<Vec<_>>() {\n            [] => return string,\n\
    \            v => v.to_owned(),\n        },\n    }", "    string.chars()\n   \
    \     .map(|c| {\n            if c >= 'a' && c <= 'z' {\n                c - 'a'\
    \ + 'A'\n            } else {\n                c - 'A' + 'a'\n            }\n\
    \        })\n        .collect::<String>() + string.chars().map(|c| {\n       \
    \     if c >= 'A' && c <= 'Z' {\n                c - 'A' + 'a'\n            }\
    \ else {\n                c - 'a' + 'A'\n            }\n        }).collect::<String>()",
  "    string.chars()\n        .map(|c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    string.chars().map(|c|\
    \ match c {\n        c if c.is_lowercase() => c.to_uppercase(),\n        _ =>\
    \ c.to_lowercase(),\n    }).collect()", "    string.to_lowercase().chars().rev().chain(string.chars().rev())\n\
    \        .map(|c| (*c).to_upper().unwrap())\n        .collect()", "    string\n\
    \        .to_ascii_lowercase()\n        .into_uppercase()\n        .to_ascii_lowercase()",
  "    match string.chars() {\n        Ok(mut chars) => {\n            let mut new_chars\
    \ = vec![];\n            for (pos, char) in chars.iter().enumerate() {\n     \
    \           if char >= 'A' && char <= 'Z' {\n                    new_chars.push(char\
    \ - 'A'.to_string().chars().next().unwrap());\n                } else {\n    \
    \                new_chars.push(char.to_string());\n                }\n      \
    \      }\n            new_chars\n                .into_iter()\n              \
    \  .map(|char| char.chars().next().unwrap())\n                .collect()\n   \
    \     }\n        Err(_) => string.to_string(),\n    }", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            c @ ' ' => c,\n            c @ _ if c.is_uppercase()\
    \ => c.to_lowercase(),\n            c @ _ if c.is_lowercase() => c.to_uppercase(),\n\
    \        })\n        .collect()", "    string\n        .chars()\n        .filter(|c|\
    \ c.is_ascii_lowercase())\n        .map(|c| match c.to_ascii_lowercase() {\n \
    \           Ok(c) => c,\n            _ => c.to_ascii_uppercase(),\n        })\n\
    \        .collect()", "    string.chars().enumerate().flat_map(|(i, c)| {\n  \
    \      match c {\n            c @ _ if c >= 'a' && c <= 'z' => (c, c.to_uppercase()),\n\
    \            _ => (c, c.to_lowercase())\n        }\n    })", "    match string.chars().map(|c|\
    \ if c >= 'a' && c <= 'z' { 'A' - c } else if c >= 'A' && c <= 'Z' { 'a' - c }\
    \ else { c }).collect::<Vec<char>>() {\n        Err(_) => unreachable!(\"invalid\
    \ characters in string: {}\", string),\n        Ok(output) => String::from(output.into_iter().map(|c|\
    \ if c >= 'A' && c <= 'Z' { 'A' - c } else if c >= 'a' && c <= 'z' { 'a' - c }\
    \ else { c }).collect()),\n    }", "    string\n        .chars()\n        .filter_map(|c|\
    \ {\n            match c {\n                c @ b'a' => c @ b'A',\n          \
    \      c @ b'B' => c @ b'b',\n                c @ b'C' => c @ b'C',\n        \
    \        c @ b'D' => c @ b'D',\n                c @ b'E' => c @ b'e',\n      \
    \          c @ b'F' => c @ b'F',\n                c @ b'G' => c @ b'G',\n    \
    \            c @ b'H' => c @ b'H',\n                c @ b'I' => c @ b'I',\n  \
    \              c @ b'J' => c @ b'J',\n                c @ b'K' => c @ b'k',\n\
    \                c @ b'L' => c @ b'L',\n                c @ b'M' => c @ b'm',\n\
    \                c @ b'N' => c @ b'N',\n                c @ b'O' => c @ b'o',\n\
    \                c @ b'P' => c @ b'P',\n                c @ b'Q' => c @ b'Q',\n\
    \                c @ b'R' => c @ b'r',\n                c @ b'S' => c @ b'S',\n\
    \                c @ b'T' => c @ b't',\n                c @ b'U' => c @ b'U',\n\
    \                c @ b'V' => c @ b'V',\n                c @ b'W' => c @ b'W',\n\
    \                c @ b'X' => c @ b'X',\n                c @ b'Y' => c @ b'Y',\n\
    \                c @ b'Z' => c @ b'z',\n                _ => c,\n            }\n\
    \        })\n        .collect::<String>()", "    string.chars().map(|c| match\
    \ c {\n        c if c <= 'Z' => (c as u32).to_ascii_uppercase().into(),\n    \
    \    c if c >= 'a' => (c as u32).to_ascii_lowercase().into(),\n        c => c,\n\
    \    })\n    .collect()", "    string.chars().map(|c| match c {\n        'a' ..\
    \ 'z' => Char::new('z' - 1 + c.digit(2), false),\n        'A' .. 'Z' => Char::new('A'\
    \ - 1 + c.digit(2), false),\n        _ => c,\n    }).collect()", "    string.chars().map(|c|\
    \ match c {\n        c @ b'a' => b'A'.to_ascii_uppercase().to_ascii_lowercase()\n\
    \        c @ b'A' => b'a'.to_ascii_lowercase().to_ascii_uppercase()\n        _\
    \ => c,\n    }).collect()", '    string.chars().rev().map(|c| *c.to_ascii_lowercase()).collect()',
  "    string.chars().map(|c| match c {\n        c => c.to_ascii_lowercase().to_ascii_uppercase(),\n\
    \        _ => c,\n    }).collect()", "    string.chars()\n        .map(|c| {\n\
    \            if c == 'a' {\n                'A'\n            } else if c == 'A'\
    \ {\n                'a'\n            } else {\n                c\n          \
    \  }\n        })\n        .collect()", "    string.chars().map(|c| match c {\n\
    \        c if c.is_ascii_lowercase() => c.to_ascii_uppercase(),\n        c if\
    \ c.is_ascii_uppercase() => c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()",
  "    string.chars().map(|c| match c {\n        'a' => *c as u8 | ('a' as u8) as\
    \ u8,\n        'A' => *c as u8 | ('A' as u8) as u8,\n        _ => c,\n    }).collect()",
  "    string\n        .chars()\n        .filter(|c| c.is_ascii_lowercase())\n   \
    \     .map(|c| if c.is_ascii_uppercase() { c } else { c.to_ascii_uppercase() })\n\
    \        .collect::<String>()", '    string.to_ascii_lowercase().to_ascii_uppercase().to_string()',
  "    string.chars()\n        .map(|c| match c {\n            'A' =>\n          \
    \      match c {\n                    'a' =>\n                        'A',\n \
    \                   'b' =>\n                        'B',\n                   \
    \ 'c' =>\n                        'C',\n                    'd' =>\n         \
    \               'D',\n                    'e' =>\n                        'E',\n\
    \                    'f' =>\n                        'F',\n                  \
    \  'g' =>\n                        'G',\n                    'h' =>\n        \
    \                'H',\n                    'i' =>\n                        'I',\n\
    \                    'j' =>\n                        'J',\n                  \
    \  'k' =>\n                        'K',\n                    'l' =>\n        \
    \                'L',\n                    'm' =>\n                        'M',\n\
    \                    'n' =>\n                        'N',\n                  \
    \  'o' =>\n                        'O',\n                    'p' =>\n        \
    \                'P',\n                    'q' =>\n                        'Q',\n\
    \                    'r' =>\n                        'R',\n                  \
    \  's' =>\n                        'S',\n                    't' =>\n        \
    \                'T',\n                    'u' =>\n                        'U',\n\
    \                    'v' =>\n                        'V',\n                  \
    \  'w' =>\n                        'W',\n                    'x' =>\n        \
    \                'X',\n                    'y' =>\n                        'Y',\n\
    \                    'z' =>\n                        'Z',\n                  \
    \  'A' =>\n                        'a',\n                    'B' =>\n        \
    \                'b',\n                    'C' =>\n                        'c',\n\
    \                    'D' =>\n                        'd',\n                  \
    \  'E' =>\n                        'e',\n                    'F' =>\n        \
    \                'f',\n                    'G' =>\n                        'g',\n\
    \                    'H' =>\n                        'h',\n                  \
    \  'I' =>\n                        'i',\n                    'J' =>\n        \
    \                'j',\n                    'K' =>\n                        'k',\n\
    \                    'L' =>\n                        'l',\n                  \
    \  'M' =>\n                        'm',\n                    'N' =>\n        \
    \                'n',\n                    'O' =>\n                        'o',\n\
    \                    'P' =>\n                        'p',\n                  \
    \  'Q' =>\n                        'q',\n                    'R' =>\n        \
    \                'r',\n                    'S' =>\n                        's',\n\
    \                    'T' =>\n                        't',\n                  \
    \  'U' =>\n                        'u',\n                    'V' =>\n        \
    \                'v',\n                    'W' =>\n                        'w',\n\
    \                    'X' =>\n                        'x',\n                  \
    \  'Y' =>\n                        'y',\n                    'Z' =>\n        \
    \                'z',\n                    '0' =>\n                        '0',\n\
    \                    '1' =>\n                        '1',\n                  \
    \  '2' =>\n                        '2',\n                    '3' =>\n        \
    \                '3',\n                    '4' =>\n                        '4',\n\
    \                    '5' =>", '    string.chars().rev().map(|c| c.to_ascii_lowercase()).collect::<String>()',
  "    string\n        .chars()\n        .map(|c| match c {\n            'a' => {\
    \ 'A' }\n            'A' => { 'a' }\n            'b' => { 'B' }\n            'B'\
    \ => { 'b' }\n            'c' => { 'C' }\n            'C' => { 'c' }\n       \
    \     'd' => { 'D' }\n            'D' => { 'd' }\n            'e' => { 'E' }\n\
    \            'E' => { 'e' }\n            'f' => { 'F' }\n            'F' => {\
    \ 'f' }\n            'g' => { 'G' }\n            'G' => { 'g' }\n            'h'\
    \ => { 'H' }\n            'H' => { 'h' }\n            'i' => { 'I' }\n       \
    \     'I' => { 'i' }\n            'j' => { 'J' }\n            'J' => { 'j' }\n\
    \            'k' => { 'K' }\n            'K' => { 'k' }\n            'l' => {\
    \ 'L' }\n            'L' => { 'l' }\n            'm' => { 'M' }\n            'M'\
    \ => { 'm' }\n            'n' => { 'N' }\n            'N' => { 'n' }\n       \
    \     'o' => { 'O' }\n            'O' => { 'o' }\n            'p' => { 'P' }\n\
    \            'P' => { 'p' }\n            'q' => { 'Q' }\n            'Q' => {\
    \ 'q' }\n            'r' => { 'R' }\n            'R' => { 'r' }\n            's'\
    \ => { 'S' }\n            'S' => { 's' }\n            't' => { 'T' }\n       \
    \     'T' => { 't' }\n            'u' => { 'U' }\n            'U' => { 'u' }\n\
    \            'v' => { 'V' }\n            'V' => { 'v' }\n            'w' => {\
    \ 'W' }\n            'W' => { 'w' }\n            'x' => { 'X' }\n            'X'\
    \ => { 'x' }\n            'y' => { 'Y' }\n            'Y' => { 'y' }\n       \
    \     'z' => { 'Z' }\n            'Z' => { 'z' }\n            _ => c,\n      \
    \  })\n        .collect::<String>()", "    string.chars().map(|c|\n        c.to_string().chars().collect::<Vec<_>>()\n\
    \            .iter()\n            .map(|c|\n                if c >= 'A' && c <=\
    \ 'Z' { c as u8 + 'a' as u8 + 26 }\n                else if c >= 'a' && c <= 'z'\
    \ { c as u8 + 'A' as u8 + 26 })\n            .collect::<Vec<_>>()\n          \
    \  .join()\n    ).collect::<String>()", "    string.chars()\n        .map(|c|\
    \ if c >= 'A' && c <= 'Z' { c + ('a' - 'A') } else { c })\n        .collect::<String>()",
  "    string.to_lowercase().chars().map(|c| match c {\n        c if c.is_upper()\
    \ => c.to_uppercase().to_string(),\n        c => c.to_string(),\n    }).collect::<String>()",
  "    string\n        .chars()\n        .filter_map(|c| match c.to_ascii_lowercase()\
    \ {\n            Ok(c) => Some(c.to_ascii_uppercase()),\n            Err(_) =>\
    \ None,\n        })\n        .collect::<String>()\n        .join(\"\")", "   \
    \ match string.chars().rev() {\n        Some(iter) => String::from_iter(iter.flip().cloned().rev()),\n\
    \        None => string,\n    }", "    string.chars()\n        .filter_map(|c|\n\
    \            if c.is_lowercase() {\n                c.to_uppercase()\n       \
    \     } else {\n                c.to_lowercase()\n            })\n        .collect::<String>()",
  "    string\n        .chars()\n        .map(|c| match c {\n            c if c.is_uppercase()\
    \ => c.to_lowercase(),\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            _ => c,\n        })\n        .collect()", "    string\n        .chars()\n\
    \        .filter(|c| c.is_uppercase())\n        .map(|c| c.to_ascii_lowercase())\n\
    \        .collect::<String>()\n        .join(\"\".into())\n        .into()\n \
    \       .to_ascii_lowercase()\n        .into()", "    let mut buffer = string.into_bytes();\n\
    \    buffer.iter().for_each(|b| {\n        if *b >= 'a' && *b <= 'z' {\n     \
    \       *b = *b - ('a'..'z').contains(*b) ? *b + 'A' - ('a'..'z').contains(*b)\
    \ : 'z';\n        }\n    });\n    String::from_utf8(buffer).unwrap()", "    string.chars().map(|c|\
    \ if c >= 'A' && c <= 'Z' { c - 'A' + 'a' }\n                         else { c\
    \ }).collect()", "    string.to_string()\n        .chars()\n        .map(|c| match\
    \ c {\n            c if c.is_uppercase() => c.to_lowercase(),\n            c if\
    \ c.is_lowercase() => c.to_uppercase(),\n            _ => c,\n        })\n   \
    \     .collect()", "    string\n        .chars()\n        .map(|c| if c.is_lowercase()\
    \ { c.to_uppercase() } else { c.to_lowercase() })\n        .collect()", "    let\
    \ mut output = String::with_capacity(string.length());\n    let mut iter = string.char_indices();\n\
    \    for (i, c) in iter.enumerate() {\n        match c {\n            b'a' =>\
    \ output.push(b'A'),\n            b'A' => output.push(b'a'),\n            _ =>\
    \ output.push(c.clone()),\n        }\n    }\n    output", "    string.chars().map(|c|\
    \ match c.to_ascii_lowercase() {\n        Some('a') => Some('A'),\n        Some('b')\
    \ => Some('B'),\n        Some('c') => Some('C'),\n        Some('d') => Some('D'),\n\
    \        Some('e') => Some('E'),\n        Some('f') => Some('F'),\n        Some('g')\
    \ => Some('G'),\n        Some('h') => Some('H'),\n        Some('i') => Some('I'),\n\
    \        Some('j') => Some('J'),\n        Some('k') => Some('K'),\n        Some('l')\
    \ => Some('L'),\n        Some('m') => Some('M'),\n        Some('n') => Some('N'),\n\
    \        Some('o') => Some('O'),\n        Some('p') => Some('P'),\n        Some('q')\
    \ => Some('Q'),\n        Some('r') => Some('R'),\n        Some('s') => Some('S'),\n\
    \        Some('t') => Some('T'),\n        Some('u') => Some('U'),\n        Some('v')\
    \ => Some('V'),\n        Some('w') => Some('W'),\n        Some('x') => Some('X'),\n\
    \        Some('y') => Some('Y'),\n        Some('z') => Some('Z'),\n        Some('0')\
    \ => Some('0'),\n        Some('1') => Some('1'),\n        Some('2') => Some('2'),\n\
    \        Some('3') => Some('3'),\n        Some('4') => Some('4'),\n        Some('5')\
    \ => Some('5'),\n        Some('6') => Some('6'),\n        Some('7') => Some('7'),\n\
    \        Some('8') => Some('8'),\n        Some('9') => Some('9'),\n        Some(c)\
    \ => Some(c),\n    })\n    .collect::<String>()\n    .to_ascii_lowercase()", " \
    \   string.chars()\n        .map(|c| if c.to_ascii_lowercase().is_ascii() {\n\
    \            c.to_ascii_uppercase()\n        } else {\n            c.to_ascii_lowercase()\n\
    \        })\n        .collect()", "    string.to_string().chars().map(|c| match\
    \ c {\n        c if c.is_uppercase() => c.to_lowercase(),\n        _ => c.to_uppercase(),\n\
    \    }).collect()", "    string.chars().map(|c| match c {\n        c if c.is_lowercase()\
    \ => c.to_uppercase(),\n        c if c.is_uppercase() => c.to_lowercase(),\n \
    \       _ => c,\n    })\n    .collect()", "    match string.len() {\n        0\
    \ => string,\n        1 => &string[0] as &'static str,\n        _ => {\n     \
    \       let mut buffer = Vec::new();\n            for &c in string.chars() {\n\
    \                if c.is_lowercase() {\n                    buffer.push((c.to_uppercase()\
    \ as &'static str).into());\n                } else {\n                    buffer.push((c.to_lowercase()\
    \ as &'static str).into());\n                }\n            }\n            String::from(buffer.into_iter().collect::<String>())\n\
    \        }\n    }", "    string.chars()\n        .map(|c| if c.is_lowercase()\
    \ { c.to_uppercase() } else { c.to_lowercase() })\n        .collect()", "    string.chars()\n\
    \        .filter_map(|c| match c {\n            'a' => b'A',\n            'b'\
    \ => b'B',\n            'c' => b'C',\n            'd' => b'D',\n            'e'\
    \ => b'E',\n            'f' => b'F',\n            'g' => b'G',\n            'h'\
    \ => b'H',\n            'i' => b'I',\n            'j' => b'J',\n            'k'\
    \ => b'K',\n            'l' => b'L',\n            'm' => b'M',\n            'n'\
    \ => b'N',\n            'o' => b'O',\n            'p' => b'P',\n            'q'\
    \ => b'Q',\n            'r' => b'R',\n            's' => b'S',\n            't'\
    \ => b'T',\n            'u' => b'U',\n            'v' => b'V',\n            'w'\
    \ => b'W',\n            'x' => b'X',\n            'y' => b'Y',\n            'z'\
    \ => b'Z',\n            _ => c,\n        })\n        .collect::<String>()", " \
    \   string.chars().map(|c| match c.to_ascii_lowercase() {\n        Some('z') =>\
    \ Some('Z'),\n        _ => c,\n    }).collect()", "    string.chars().rev().chain(string.chars())\n\
    \        .map(|c| match c {\n            'A'..='Z' => c as u8 ^ ('A' as u8) as\
    \ u8,\n            'a'..='z' => c as u8 ^ ('a' as u8) as u8,\n            _ =>\
    \ c,\n        })\n        .collect::<String>()", "    match string.chars() {\n\
    \        chars => String::from_utf8(chars)\n            .chain(|c| if c.is_lowercase()\
    \ { c.to_uppercase() } else { c.to_lowercase() })\n            .collect()\n  \
    \  }", "    string\n        .chars()\n        .filter_map(|c| match c {\n    \
    \        c if c.is_uppercase() => c.to_lowercase(),\n            c => c.to_uppercase(),\n\
    \        })\n        .collect::<String>(\"\")", "    string.chars().map(|c| match\
    \ c {\n        'a' ..= 'A' => { 'A' .. 'a' }\n        'a' ..= 'B' => { 'a' ..\
    \ 'B' }\n        'b' ..= 'A' => { 'B' .. 'a' }\n        'b' ..= 'B' => { 'b' ..\
    \ 'B' }\n        _ => c,\n    }).collect()", "    string.chars().map(|c| match\
    \ c {\n        'A'..='Z' => c as u8 | 0x20,\n        'a'..='z' => c as u8 | 0x21,\n\
    \        _ => c,\n    }).collect()", "    string.chars()\n        .map(|c| {\n\
    \            if c.is_lowercase() {\n                c.to_uppercase()\n       \
    \     } else {\n                c.to_lowercase()\n            }\n        })\n\
    \        .collect()", '    string.to_lowercase().to_uppercase()', "    string.chars().flat_map(|c|\
    \ {\n        if c.is_lowercase() {\n            c.to_uppercase()\n        } else\
    \ {\n            c.to_lowercase()\n        }\n    }).collect()", "    string.chars().map(|c|\
    \ match c {\n        'A'..'Z' => c as char + 'a' - 'A' as char,\n        'a'..'z'\
    \ => c as char + 'A' - 'a' as char,\n        _ => c,\n    })\n    .collect()",
  "    string.chars()\n        .map(|c| if c.is_upper() { c.to_lowercase() } else\
    \ { c.to_uppercase() })\n        .collect()", '    string.to_ascii_lowercase().to_ascii_uppercase().to_string()',
  "    let mut buffer = StringBuffer::new();\n    for c in string.chars() {\n    \
    \    match c {\n            c if c.is_uppercase() => buffer.push(c),\n       \
    \     c if c.is_lowercase() => buffer.push(c),\n            _ => (),\n       \
    \ }\n    }\n    buffer.into()", "    string.chars().fold(String::from(\"__\"),\
    \ |mut acc, c| {\n        acc.push_str(c.to_lowercase());\n        acc.push_str(c.to_uppercase());\n\
    \        acc\n    })", '    string.into_iter().map(|c| c.to_ascii_lowercase().to_string()).collect::<String>().into_owned()',
  "    let mut buffer = Buffer::new(string);\n    for &b in buffer.bytes() {\n   \
    \     let c = b.to_ascii_lowercase();\n        buffer.replace(b as usize, c.len(),\
    \ c);\n    }\n    buffer.into()", '    string.chars().map(|c| if c.is_upper()
    { c.to_lowercase() } else { c.to_uppercase() }).collect()', '    string.to_lowercase().chars().chain(&string.to_uppercase()).collect()',
  "    let mut string = string;\n    string.chars().enumerate().for_each(|(i, char)|\
    \ {\n        match char {\n            c if c.is_lowercase() => (*char).to_uppercase(),\n\
    \            c => (*char).to_lowercase(),\n        }\n    });\n    string", " \
    \   string.chars().chain(string.chars().map(|c| if c == c.to_ascii_lowercase()\
    \ || c == c.to_ascii_uppercase() { c } else { c.to_ascii_lowercase() }))\n   \
    \ .collect::<String>()", "    string.chars().map(|c| match c {\n        c if c.is_ascii_lowercase()\
    \ => c.to_ascii_uppercase(),\n        c => c.to_ascii_lowercase(),\n    }).collect()",
  "    match string.chars() {\n        x @ _ => string.replace(&x, x.to_uppercase().to_lowercase()).to_string()\n\
    \    }", "    string.chars().map(|c| match c {\n        'A'..='Z' => c + &'a'\
    \ - &'A',\n        'a'..='z' => c + &'A' - &'a',\n        _ => c,\n    }).collect::<String>().to_string()",
  "    let mut iter = string.chars();\n    let mut s = String::new();\n    for (i,\
    \ &c) in iter.into_iter().enumerate() {\n        if c.is_lowercase() {\n     \
    \       s.push_str(&c.to_uppercase());\n        } else {\n            s.push_str(&c.to_lowercase());\n\
    \        }\n    }\n    s", "    string.chars()\n        .map(|c| match c {\n \
    \           'a' => { 'A' }\n            'A' => { 'a' }\n            'b' => { 'B'\
    \ }\n            'B' => { 'b' }\n            'c' => { 'C' }\n            'C' =>\
    \ { 'c' }\n            'd' => { 'D' }\n            'D' => { 'd' }\n          \
    \  'e' => { 'E' }\n            'E' => { 'e' }\n            'f' => { 'F' }\n  \
    \          'F' => { 'f' }\n            'g' => { 'G' }\n            'G' => { 'g'\
    \ }\n            'h' => { 'H' }\n            'H' => { 'h' }\n            'i' =>\
    \ { 'I' }\n            'I' => { 'i' }\n            'j' => { 'J' }\n          \
    \  'J' => { 'j' }\n            'k' => { 'K' }\n            'K' => { 'k' }\n  \
    \          'l' => { 'L' }\n            'L' => { 'l' }\n            'm' => { 'M'\
    \ }\n            'M' => { 'm' }\n            'n' => { 'N' }\n            'N' =>\
    \ { 'n' }\n            'o' => { 'O' }\n            'O' => { 'o' }\n          \
    \  'p' => { 'P' }\n            'P' => { 'p' }\n            'q' => { 'Q' }\n  \
    \          'Q' => { 'q' }\n            'r' => { 'R' }\n            'R' => { 'r'\
    \ }\n            's' => { 'S' }\n            'S' => { 's' }\n            't' =>\
    \ { 'T' }\n            'T' => { 't' }\n            'u' => { 'U' }\n          \
    \  'U' => { 'u' }\n            'v' => { 'V' }\n            'V' => { 'v' }\n  \
    \          'w' => { 'W' }\n            'W' => { 'w' }\n            'x' => { 'X'\
    \ }\n            'X' => { 'x' }\n            'y' => { 'Y' }\n            'Y' =>\
    \ { 'y' }\n            'z' => { 'Z' }\n            'Z' => { 'z' }\n          \
    \  _ => {\n                panic!(\"String contains invalid character\")\n   \
    \         }\n        })\n        .collect::<String>()", "    string.chars().fold1(|mut\
    \ acc: Char, f| {\n        match f {\n            c if c >= 'a' && c <= 'z' =>\
    \ {\n                acc += Char::to_upper(c);\n            }\n            c if\
    \ c >= 'A' && c <= 'Z' => {\n                acc += Char::to_lower(c);\n     \
    \       }\n            _ => panic!(\"invalid character: {}\", f),\n        }\n\
    \        acc\n    })", "    string\n        .chars()\n        .map(|c| match c\
    \ {\n            c @ b'a' | b'A' => (c as u8 - b'a' + b'A') as u8,\n         \
    \   c => (c as u8 + b'a' as u8) as u8,\n        })\n        .collect()", "   \
    \ string.chars().map(|c| match c {\n        'A' .. 'Z' => c as 'a' .. 'z' as u8,\n\
    \        _ => c,\n    }).collect()", "    string\n        .chars()\n        .map(|c|\
    \ match c {\n            c @ &'a' as char => char.to_uppercase().to_string(),\n\
    \            c @ &'A' as char => char.to_lowercase().to_string(),\n          \
    \  c => c,\n        })\n        .collect::<String>()", "    string.chars().enumerate().filter(|&(i,\
    \ c)| {\n        match c {\n            'a' .. 'z' => c >= 'A' && c <= 'Z',\n\
    \            'A' .. 'Z' => c >= 'a' && c <= 'z',\n            _ => false,\n  \
    \      }\n    }).map(|(_, c)| {\n        match c {\n            'a' .. 'z' =>\
    \ c as u8 + 'A' as u8,\n            'A' .. 'Z' => c as u8 + 'a' as u8,\n     \
    \       _ => c,\n        }\n    }).collect()", "    if string.len() == 0 {\n \
    \       string\n    } else {\n        let mut s = string;\n        for c in s.chars()\
    \ {\n            if c.is_upper() {\n                s.insert(c.to_lowercase(),\
    \ c.to_uppercase());\n            } else {\n                s.insert(c.to_uppercase(),\
    \ c.to_lowercase());\n            }\n        }\n        s\n    }", "    string.chars()\n\
    \        .map(|c| if c.is_lowercase() { c } else { c.to_uppercase() })\n     \
    \   .collect::<String>()", "    match string.chars() {\n        chars => chars.map(|c|\
    \ match c {\n            c @ b'A' => b'Z' |\n            c @ b'a' => b'z' |\n\
    \            c          => c,\n        }).collect(),\n    }", "    string\n  \
    \      .chars()\n        .map(|c| c.to_lowercase().to_uppercase())\n        .collect::<String>()",
  "    let mut result = String::new();\n    for c in string.chars() {\n        if\
    \ c.is_lowercase() {\n            result.push('_');\n            result.push(c);\n\
    \        } else {\n            result.push(c);\n        }\n    }\n    result",
  '    string.into_lowercase().into_uppercase()', '    string.to_string().to_lowercase().to_uppercase()',
  "    string.chars().map(|c| match c {\n        'a' ... 'z' => c + '_',\n       \
    \ 'A' ... 'Z' => c + '_',\n        _ => c,\n    }).collect()", "    match string.length()\
    \ {\n        0 => \"\",\n        _ => {\n            let mut string = string;\n\
    \            for c in &mut string {\n                if c.is_lowercase() {\n \
    \                   c.to_uppercase();\n                } else {\n            \
    \        c.to_lowercase();\n                }\n            }\n            string\n\
    \        }\n    }", "    string.chars()\n        .chain(string.chars().map(|c|\
    \ match c {\n            c @ b'a' as 'A' | 'a' => b'A' | b'a' as 'a' | 'z' =>\
    \ b'a' | 'A' | b'A' as 'z' | 'a' =>\n                b'a' | 'a' as 'A' | 'A' as\
    \ 'z',\n            _ => c,\n        }))\n        .collect::<String>()", "   \
    \ string\n        .chars()\n        .map(|c| if c == 'A' { c } else if c == 'a'\
    \ { c.to_ascii_lowercase() } else { c.to_ascii_uppercase() })\n        .collect()",
  "    match string\n        .chars()\n        .map(|c| match c {\n            c if\
    \ c.is_lowercase() => c.to_uppercase(),\n            _ => c,\n        })\n   \
    \     .collect::<String>() {\n        \"\" => \"\",\n        s => s,\n    }",
  "    string.chars().filter_map(|c| match c {\n        'A' .. 'Z' => Some('A' + c.to_ascii_lowercase().chars().next().unwrap()),\n\
    \        'a' .. 'z' => Some('a' + c.to_ascii_lowercase().chars().next().unwrap()),\n\
    \        _ => None,\n    }).collect()", "    string.to_ascii_lowercase()\n   \
    \     .to_ascii_uppercase()\n        .to_string()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            c if c.is_lowercase() => c.to_uppercase(),\n\
    \            c => c.to_lowercase(),\n        })\n        .collect()", "    string.chars().map(|c|\
    \ match c {\n        'a' => (c as u8) - 0x20,\n        'A' => (c as u8) + 0x20,\n\
    \        c => (c as u8) as char,\n    }).collect()", "    string\n        .chars()\n\
    \        .map(|c| match c {\n            c @ b'A' => b'a'..b'z',\n           \
    \ c @ b'a' => b'A'..b'Z',\n            c @ b'_' => b'_',\n            _ => c,\n\
    \        })\n        .collect::<String>()", "    string.chars().map(|c| match\
    \ c {\n        'a' => (char::A as u8),\n        'b' => (char::B as u8),\n    \
    \    'c' => (char::C as u8),\n        'd' => (char::D as u8),\n        'e' =>\
    \ (char::E as u8),\n        'f' => (char::F as u8),\n        'g' => (char::G as\
    \ u8),\n        'h' => (char::H as u8),\n        'i' => (char::I as u8),\n   \
    \     'j' => (char::J as u8),\n        'k' => (char::K as u8),\n        'l' =>\
    \ (char::L as u8),\n        'm' => (char::M as u8),\n        'n' => (char::N as\
    \ u8),\n        'o' => (char::O as u8),\n        'p' => (char::P as u8),\n   \
    \     'q' => (char::Q as u8),\n        'r' => (char::R as u8),\n        's' =>\
    \ (char::S as u8),\n        't' => (char::T as u8),\n        'u' => (char::U as\
    \ u8),\n        'v' => (char::V as u8),\n        'w' => (char::W as u8),\n   \
    \     'x' => (char::X as u8),\n        'y' => (char::Y as u8),\n        'z' =>\
    \ (char::Z as u8),\n        _ => c,\n    }).collect::<String>()", "    let mut\
    \ buf = [0u8; string.len()];\n    for &c in string.as_bytes_mut() {\n        let\
    \ x = c as u8;\n        match x {\n            c if c >= 'a' && c <= 'z' => (c\
    \ as u8 + 'A' as u8) as u8,\n            c if c >= 'A' && c <= 'Z' => (c as u8\
    \ + 'a' as u8) as u8,\n            _ => x,\n        }\n    }\n    String::from_utf8(buf).unwrap()",
  "    string.chars()\n        .map(|c| match c {\n            'a' => {\n        \
    \        char::From('A').from_ascii()\n            }\n            'b' => {\n \
    \               char::From('B').from_ascii()\n            }\n            'c' =>\
    \ {\n                char::From('C').from_ascii()\n            }\n           \
    \ 'd' => {\n                char::From('D').from_ascii()\n            }\n    \
    \        'e' => {\n                char::From('E').from_ascii()\n            }\n\
    \            'f' => {\n                char::From('F').from_ascii()\n        \
    \    }\n            'g' => {\n                char::From('G').from_ascii()\n \
    \           }\n            'h' => {\n                char::From('H').from_ascii()\n\
    \            }\n            'i' => {\n                char::From('I').from_ascii()\n\
    \            }\n            'j' => {\n                char::From('J').from_ascii()\n\
    \            }\n            'k' => {\n                char::From('K').from_ascii()\n\
    \            }\n            'l' => {\n                char::From('L').from_ascii()\n\
    \            }\n            'm' => {\n                char::From('M').from_ascii()\n\
    \            }\n            'n' => {\n                char::From('N').from_ascii()\n\
    \            }\n            'o' => {\n                char::From('O').from_ascii()\n\
    \            }\n            'p' => {\n                char::From('P').from_ascii()\n\
    \            }\n            'q' => {\n                char::From('Q').from_ascii()\n\
    \            }\n            'r' => {\n                char::From('R').from_ascii()\n\
    \            }\n            's' => {\n                char::From('S').from_ascii()\n\
    \            }\n            't' => {\n                char::From('T').from_ascii()\n\
    \            }\n            'u' => {\n                char::From('U').from_ascii()\n\
    \            }\n            'v' => {\n                char::From('V').from_ascii()\n\
    \            }\n            'w' => {\n                char::From('W').from_ascii()\n\
    \            }\n            'x' => {\n                char::From('X').from_ascii()\n\
    \            }\n            'y' => {\n                char::From('Y').from_ascii()\n\
    \            }\n            'z' => {\n                char::From('Z').from_ascii()\n\
    \            }\n            _ => {\n                char::From(c).from_ascii()\n\
    \            }\n        })\n        .collect()", "    string.chars().enumerate().map(|(i,\
    \ c)| {\n        if c.is_lowercase() {\n            c.to_uppercase()\n       \
    \ } else {\n            c.to_lowercase()\n        }\n    }).collect()", "    if\
    \ string.len() <= 1 {\n        string\n    } else {\n        let mut flipped =\
    \ String::from(string);\n        flipped.chars().for_each(|c|\n            if\
    \ c.is_uppercase() {\n                flipped.replace(c.to_ascii_lowercase(),\
    \ c.to_ascii_uppercase())\n            } else if c.is_lowercase() {\n        \
    \        flipped.replace(c.to_ascii_uppercase(), c.to_ascii_lowercase())\n   \
    \         }\n        );\n        flipped\n    }", "    if string.is_empty() {\n\
    \        \"\".to_string()\n    } else {\n        let mut buffer = String::from(\"\
    \\\"\");\n        for ch in string.chars() {\n            match ch {\n       \
    \         'a' => (ch as i32 + ('A' as i32)).to_string(),\n                'A'\
    \ => (ch as i64 - ('A' as i64))\n                    .to_string(),\n         \
    \       _ => buffer.push_char(ch),\n            }\n        }\n        buffer.push_str(\"\
    \\\"\").to_string()\n    }", "    string.chars()\n        .map(|c| if c.is_lowercase()\
    \ then c.into().into().to_string().to_uppercase() else c.into())\n        .collect::<String>()",
  "    let mut buffer = String::with_capacity(string.len());\n    let mut prev_case\
    \ = false;\n    for ch in string.chars() {\n        match ch {\n            c\
    \ if prev_case && c.is_upper() => buffer.push_char(c.to_ascii_lowercase()),\n\
    \            c if !prev_case && c.is_lower() => buffer.push_char(c.to_ascii_uppercase()),\n\
    \            _ => buffer.push_char(ch),\n        }\n        prev_case = c.is_upper();\n\
    \    }\n    buffer", "    string.chars()\n        .map(|c| match c {\n       \
    \     c if c.is_uppercase() => c.to_lowercase(),\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            _ => c,\n        })\n        .collect()",
  "    string\n        .chars()\n        .map(|c| match c {\n            c @ b'A'\
    \ as b'a' => b'A' as b'a',\n            c @ b'a' as b'A' => b'a' as b'A',\n  \
    \          _ => c,\n        })\n        .collect()", "    string\n        .into_iter()\n\
    \        .map(|c| match c.to_lowercase() {\n            Some(c) => c,\n      \
    \      _ => c.to_uppercase(),\n        })\n        .collect()", "    let mut new\
    \ = string.to_string();\n    for c in new.chars() {\n        if c.is_lowercase()\
    \ {\n            new.set_char(c, c.to_uppercase());\n        } else {\n      \
    \      new.set_char(c, c.to_lowercase());\n        }\n    }\n    new", "    string\n\
    \        .chars()\n        .map(|c| match c {\n            c if c.is_lowercase()\
    \ => c.to_uppercase(),\n            c if c.is_uppercase() => c.to_lowercase(),\n\
    \            c => c,\n        })\n        .collect()", "    string\n        .chars()\n\
    \        .map(|c| if c.is_lowercase() then c.to_uppercase() else c.to_lowercase())\n\
    \        .collect()", "    string\n        .chars()\n        .map(|c| match c\
    \ {\n            c @ b'a' | b'A' => c @ b'A' | b'a',\n            _ => c,\n  \
    \      })\n        .collect::<String>()", "    string.into_bytes().to_vec()\n\
    \        .iter()\n        .map(|b| b as char).enumerate()\n        .map(|(i, c)|\
    \ (c as u8 >> i as usize) as char)\n        .collect()\n        .to_string()",
  "    string.to_lowercase()\n        .chars()\n        .map(|c| match c {\n     \
    \       c @ b'a' => c @ b'A' as char,\n            _ => c,\n        })\n     \
    \   .collect::<String>()", "    string.chars()\n        .map(|c| match c {\n \
    \           'a' => ('A' as u8),\n            'b' => ('B' as u8),\n           \
    \ 'c' => ('C' as u8),\n            'd' => ('D' as u8),\n            'e' => ('E'\
    \ as u8),\n            'f' => ('F' as u8),\n            'g' => ('G' as u8),\n\
    \            'h' => ('H' as u8),\n            'i' => ('I' as u8),\n          \
    \  'j' => ('J' as u8),\n            'k' => ('K' as u8),\n            'l' => ('L'\
    \ as u8),\n            'm' => ('M' as u8),\n            'n' => ('N' as u8),\n\
    \            'o' => ('O' as u8),\n            'p' => ('P' as u8),\n          \
    \  'q' => ('Q' as u8),\n            'r' => ('R' as u8),\n            's' => ('S'\
    \ as u8),\n            't' => ('T' as u8),\n            'u' => ('U' as u8),\n\
    \            'v' => ('V' as u8),\n            'w' => ('W' as u8),\n          \
    \  'x' => ('X' as u8),\n            'y' => ('Y' as u8),\n            'z' => ('Z'\
    \ as u8),\n            'A' => ('A' as u8),\n            'B' => ('B' as u8),\n\
    \            'C' => ('C' as u8),\n            'D' => ('D' as u8),\n          \
    \  'E' => ('E' as u8),\n            'F' => ('F' as u8),\n            'G' => ('G'\
    \ as u8),\n            'H' => ('H' as u8),\n            'I' => ('I' as u8),\n\
    \            'J' => ('J' as u8),\n            'K' => ('K' as u8),\n          \
    \  'L' => ('L' as u8),\n            'M' => ('M' as u8),\n            'N' => ('N'\
    \ as u8),\n            'O' => ('O' as u8),\n            'P' => ('P' as u8),\n\
    \            'Q' => ('Q' as u8),\n            'R' => ('R' as u8),\n          \
    \  'S' => ('S' as u8),\n            'T' => ('T' as u8),\n            'U' => ('U'\
    \ as u8),\n            'V' => ('V' as u8),\n            'W' => ('W' as u8),\n\
    \            'X' => ('X' as u8),\n            'Y' => ('Y' as u8),\n          \
    \  'Z' => ('Z' as u8),\n            _ => c.to_ascii_uppercase(),\n        })\n\
    \        .collect()", "    string\n        .chars()\n        .map(|c| match c\
    \ {\n            c => match c.to_ascii_lowercase().to_string().as_str() {\n  \
    \              \"a\" => \"A\",\n                _ => c.to_ascii_uppercase().to_string().as_str().to_ascii_lowercase().to_string(),\n\
    \            },\n            _ => c,\n        })\n        .collect()", "    let\
    \ mut s = string.to_lowercase();\n    s.replace(s.chars().filter(|c| *c != 'A'\
    \ && *c != 'a').cloned().collect::<String>(), \"A\").to_uppercase()"]
stop_tokens:
- "\n}"
