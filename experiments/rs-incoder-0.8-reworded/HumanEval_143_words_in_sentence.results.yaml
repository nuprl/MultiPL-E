language: rs
name: HumanEval_143_words_in_sentence
results:
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    let mut ret: String =\
    \ String::from(\"[\");\n    let mut prime_words: Vec<String> = Vec::new();\n \
    \   let mut s = sentence.to_string();\n    let mut cur_word: String;\n    for\
    \ c in s.chars() {\n        if c.to_digit() == 0 {\n            cur_word = \"\"\
    ;\n        } else {\n            cur_word += c.to_string();\n        }\n\n   \
    \     if cur_word.is_empty() {\n            continue;\n        }\n\n        if\
    \ prime_words.iter().any(|x| x.to_ascii_lowercase() == cur_word.to_ascii_lowercase())\
    \ {\n            prime_words.push(cur_word);\n        } else {\n            ret\
    \ = ret.push_str(&cur_word);\n        }\n    }\n\n    ret = ret.push_str(\"]\"\
    );\n    return ret;\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmpx_zp3qnj.rs:22:14\n    |\n22  |         if c.to_digit() == 0 {\n\
    \    |              ^^^^^^^^- supplied 0 arguments\n    |              |\n   \
    \ |              expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx_zp3qnj.rs:22:28\n  \
    \ |\n22 |         if c.to_digit() == 0 {\n   |                            ^ expected\
    \ enum `Option`, found integer\n   |\n   = note: expected enum `Option<u32>`\n\
    \              found type `{integer}`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n22 |         if c.to_digit() == Some(0) {\n   |                       \
    \     +++++ +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx_zp3qnj.rs:23:24\n\
    \   |\n20 |     let mut cur_word: String;\n   |                       ------ expected\
    \ due to this type\n...\n23 |             cur_word = \"\";\n   |             \
    \           ^^- help: try using a conversion method: `.to_string()`\n   |    \
    \                    |\n   |                        expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpx_zp3qnj.rs:25:25\n\
    \   |\n25 |             cur_word += c.to_string();\n   |                     \
    \    ^^^^^^^^^^^^^\n   |                         |\n   |                     \
    \    expected `&str`, found struct `String`\n   |                         help:\
    \ consider borrowing here: `&c.to_string()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpx_zp3qnj.rs:35:19\n   |\n17 |     let mut ret: String = String::from(\"\
    [\");\n   |                  ------ expected due to this type\n...\n35 |     \
    \        ret = ret.push_str(&cur_word);\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpx_zp3qnj.rs:35:23\n   |\n35 |         \
    \    ret = ret.push_str(&cur_word);\n   |                   --- ^^^^^^^^ this\
    \ call modifies `ret` in-place\n   |                   |\n   |               \
    \    you probably want to use this value after calling the method...\n   "
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::with_capacity(sentence.len());\n\
    \    for &s in sentence.split_whitespace() {\n        let n = prime_number_of(&s);\n\
    \        for i in 2..n {\n            if s.chars().all(|c| c % i == 0) {\n   \
    \             result.push_str(&s);\n                break;\n            }\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_number_of` in this scope\n  -->\
    \ /tmp/tmp0fdd5z2y.rs:18:17\n   |\n18 |         let n = prime_number_of(&s);\n\
    \   |                 ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the size for values of type `str` cannot be known at compilation time\n  -->\
    \ /tmp/tmp0fdd5z2y.rs:17:10\n   |\n17 |     for &s in sentence.split_whitespace()\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0369]: cannot mod `char` by `{integer}`\n  --> /tmp/tmp0fdd5z2y.rs:20:36\n\
    \   |\n20 |             if s.chars().all(|c| c % i == 0) {\n   |             \
    \                     - ^ - {integer}\n   |                                  |\n\
    \   |                                  char\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0369, E0425.\nFor\
    \ more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::with_capacity(sentence.len());\n\
    \    for ch in sentence.chars() {\n        if prime(&ch.as_bytes()) {\n      \
    \      result.push_str(&ch);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime` in this scope\n  --> /tmp/tmp3cq4md9n.rs:18:12\n\
    \   |\n18 |         if prime(&ch.as_bytes()) {\n   |            ^^^^^ not found\
    \ in this scope\n\nerror[E0599]: no method named `as_bytes` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp3cq4md9n.rs:18:22\n   |\n18 |         if\
    \ prime(&ch.as_bytes()) {\n   |                      ^^^^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp3cq4md9n.rs:19:29\n\
    \   |\n19 |             result.push_str(&ch);\n   |                          \
    \   ^^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    trace!(\"words_in_sentence: sentence: {:?}\", sentence);\n\
    \    sentence\n        .split_whitespace()\n        .flat_map(|word| word.chars().map(|c|\
    \ c as usize))\n        .filter(|c| c%2 == 0)\n        .filter(|c| c > 2)\n  \
    \      .filter(|c| c < 100)\n        .collect()\n        .to_owned()\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `trace` in this scope\n  --> /tmp/tmpu9kyhjqz.rs:16:5\n\
    \   |\n16 |     trace!(\"words_in_sentence: sentence: {:?}\", sentence);\n   |\
    \     ^^^^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu9kyhjqz.rs:21:25\n\
    \   |\n21 |         .filter(|c| c > 2)\n   |                         ^\n   | \
    \                        |\n   |                         expected `&usize`, found\
    \ integer\n   |                         help: consider borrowing here: `&2`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpu9kyhjqz.rs:22:25\n   |\n22 |  \
    \       .filter(|c| c < 100)\n   |                         ^^^\n   |         \
    \                |\n   |                         expected `&usize`, found integer\n\
    \   |                         help: consider borrowing here: `&100`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = Vec::new();\n    let mut counter =\
    \ 1;\n    let mut words_to_print = String::new();\n    primes.push(2);\n    let\
    \ mut current_prime = 2;\n\n    for &c in sentence.chars() {\n        if primes.iter().all(|&x|\
    \ x != current_prime) {\n            current_prime += 2;\n        } else {\n \
    \           primes.push(counter);\n            counter += 1;\n        }\n\n  \
    \      words_to_print.push_str(&c.to_string());\n    }\n\n    words_to_print\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpx3v2njtd.rs:22:9\n   |\n\
    22 |     for &c in sentence.chars() {\n   |         ^^    ---------------- this\
    \ expression has type `Option<char>`\n   |         |\n   |         expected `char`,\
    \ found reference\n   |         help: you can probably remove the explicit borrow:\
    \ `c`\n   |\n   = note:   expected type `char`\n           found reference `&_`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_words: Vec<u64> = vec![];\n    let mut\
    \ len: u64 = sentence.length();\n\n    loop {\n        let mut prime = true;\n\
    \n        for _ in 0..len {\n            if prime_words.iter().any(|w| w == len\
    \ % w as u64) {\n                prime = false;\n                break;\n    \
    \        }\n        }\n        if prime {\n            prime_words.push(len);\n\
    \        }\n        len += 1;\n    }\n\n    for &w in &prime_words {\n       \
    \ sentence = sentence.replace(&w, \" \").to_string();\n    }\n\n    sentence\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp1iigp31w.rs:17:33\n   |\n17 |     let mut len:\
    \ u64 = sentence.length();\n   |                                 ^^^^^^ help:\
    \ there is an associated function with a similar name: `len`\n\nerror[E0277]:\
    \ can't compare `&u64` with `u64`\n  --> /tmp/tmp1iigp31w.rs:23:45\n   |\n23 |\
    \             if prime_words.iter().any(|w| w == len % w as u64) {\n   |     \
    \                                        ^^ no implementation for `&u64 == u64`\n\
    \   |\n   = help: the trait `PartialEq<u64>` is not implemented for `&u64`\n \
    \  = help: the following other types implement trait `PartialEq<Rhs>`:\n     \
    \        f32\n             f64\n             i128\n             i16\n        \
    \     i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nwarning: unreachable statement\n  --> /tmp/tmp1iigp31w.rs:34:5\n\
    \   |\n19 | /     loop {\n20 | |         let mut prime = true;\n21 | |\n22 | |\
    \         for _ in 0..len {\n...  |\n31 | |         len += 1;\n32 | |     }\n\
    \   | |_____- any code following this expression is unreachable\n33 | \n34 | /\
    \     for &w in &prime_words {\n35 | |         sentence = sentence.replace(&w,\
    \ \" \").to_string();\n36 | |     }\n   | |_____^ unreachable statement\n   |\n\
    \   = note: `#[warn(unreachable_code)]` on by default\n\nerror[E0277]: expected\
    \ a `Fn<(char,)>` closure, found `u64`\n   --> /tmp/tmp1iigp31w.rs:35:37\n   \
    \ |\n35  |         sentence = sentence.replace(&w, \" \").to_string();\n    |\
    \                             ------- ^^ expected an `Fn<(char,)>` closure, found\
    \ `u64`\n    |                             |\n    |                          \
    \   required by a bound introduced by this call\n    |\n    = help: the trait\
    \ `Fn<(char,)>` is not implemented for `u64`\n    = help: the following other\
    \ types implement trait `Pattern<'a>`:\n              &'b String\n           \
    \   &'b [char; N]\n              &'b [char]\n              &'b str\n         \
    \     &'c &'b str\n              [char; N]\n              char\n             \
    \ pattern::MultiCharEqPattern<C>\n    = note: r"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::from(\"words not found\");\n\
    \    for word in sentence.split_whitespace() {\n        if !is_prime_number(word.length())\
    \ {\n            res.push_str(word);\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_number` in this scope\n  -->\
    \ /tmp/tmpr94f_gt8.rs:18:13\n   |\n18 |         if !is_prime_number(word.length())\
    \ {\n   |             ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `length` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpr94f_gt8.rs:18:34\n   |\n18 |         if !is_prime_number(word.length())\
    \ {\n   |                                  ^^^^^^ help: there is an associated\
    \ function with a similar name: `len`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result: Vec<String> = vec![];\n    sentence\n\
    \        .split_whitespace()\n        .filter(|&word| is_prime(word.len()))\n\
    \        .for_each(|word| result.push(word.clone()));\n    result.join(\", \"\
    )\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp124kmnqp.rs:19:25\n\
    \   |\n19 |         .filter(|&word| is_prime(word.len()))\n   |              \
    \           ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp124kmnqp.rs:20:38\n   |\n20 |         .for_each(|word| result.push(word.clone()));\n\
    \   |                                      ^^^^^^^^^^^^\n   |                \
    \                      |\n   |                                      expected struct\
    \ `String`, found `&str`\n   |                                      help: try\
    \ using a conversion method: `word.to_string()`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.is_empty() {\n        String::new()\n \
    \   } else {\n        let mut words = Vec::new();\n        let mut index = 0;\n\
    \        let mut prime_found = false;\n\n        while index < sentence.len()\
    \ {\n            let word = sentence.split_whitespace()[index];\n            if\
    \ prime_found {\n                break;\n            }\n\n            if word.length()\
    \ == 1 {\n                prime_found = true;\n            }\n            let\
    \ mut i = 1;\n            while i <= word.length() {\n                let mut\
    \ j = 2;\n                while j * i <= word.length() && j * i <= i {\n     \
    \               if word.length() % i == 0 {\n                        break;\n\
    \                    }\n                    j += 1;\n                }\n     \
    \           i += 1;\n                if j == i {\n                    words.push(word);\n\
    \                }\n            }\n            index += 1;\n        }\n\n    \
    \    String::from(words.join(\" \"))\n    }\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpxyyj_fbv.rs:24:24\n   |\n24 |             let word = sentence.split_whitespace()[index];\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0608`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Write your code here\n    let mut prime_numbers\
    \ = vec![];\n    let mut splits = sentence.split_whitespace();\n    for split_char\
    \ in splits.into_iter() {\n        if split_char != \" \" {\n            prime_numbers.push(split_char.len());\n\
    \        }\n    }\n    let mut string = \"\";\n    for prime in prime_numbers.into_iter().rev()\
    \ {\n        for split in splits.split_at(prime) {\n            string += split\
    \ + \" \"\n        }\n    }\n    string.trim()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `split_at` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp2_3m79pv.rs:26:29\n   |\n26 |         for\
    \ split in splits.split_at(prime) {\n   |                             ^^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmp2_3m79pv.rs:27:13\n\
    \   |\n27 |             string += split + \" \"\n   |             ------^^^^^^^^^^^^^^^\n\
    \   |             |\n   |             cannot use `+=` on type `&str`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp2_3m79pv.rs:30:5\n   |\n15 | fn words_in_sentence(sentence:\
    \ String) -> String {\n   |                                           ------ expected\
    \ `String` because of return type\n...\n30 |     string.trim()\n   |     ^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0368, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut s = String::from(sentence);\n    let mut result\
    \ = String::from(\"\");\n    let mut primes = Vec::new();\n    primes.push((1..=100).collect::<Vec<usize>>());\n\
    \    for (i, p) in primes.iter().enumerate() {\n        if s.chars().filter(|c|\
    \ c >= p).count() == 0 {\n            s.push_str(&format!(\"{}\", i));\n     \
    \       break;\n        }\n    }\n    let mut words = s.split_whitespace();\n\
    \    for (i, word) in words.iter().enumerate() {\n        if let Some(prime) =\
    \ primes.iter().find(|&p| p >= i) {\n            if word.len() == prime {\n  \
    \              result.push_str(word);\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu525pem3.rs:21:38\n   |\n\
    21 |         if s.chars().filter(|c| c >= p).count() == 0 {\n   |            \
    \                          ^ expected `char`, found struct `Vec`\n   |\n   = note:\
    \ expected reference `&char`\n              found reference `&Vec<usize>`\n\n\
    error[E0599]: no method named `iter` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpu525pem3.rs:27:28\n   |\n27 |     for (i, word)\
    \ in words.iter().enumerate() {\n   |                            ^^^^ method not\
    \ found in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug!(\"words_in_sentence\");\n    let mut primes\
    \ = vec![2, 3];\n    let mut primes_found = false;\n    let mut temp_str = String::new();\n\
    \n    for c in sentence.chars() {\n        if c.is_whitespace() {\n          \
    \  continue;\n        }\n\n        temp_str = temp_str.to_string() + c.to_string();\n\
    \        for &p in &primes {\n            if temp_str.chars().all(|c| c.to_digit()\
    \ > p) {\n                primes_found = true;\n            }\n        }\n   \
    \     if !primes_found {\n            primes.push(temp_str.chars().count(|c| c.to_digit()\
    \ > p));\n        }\n        primes_found = false;\n        temp_str = String::new();\n\
    \    }\n    if temp_str.chars().count() > 1 && !primes.iter().all(|&p| p > 1)\
    \ {\n        temp_str += \" \";\n    }\n    temp_str.trim()\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmprpqe427w.rs:16:5\n\
    \   |\n16 |     debug!(\"words_in_sentence\");\n   |     ^^^^^\n\nerror[E0425]:\
    \ cannot find value `p` in this scope\n  --> /tmp/tmprpqe427w.rs:33:67\n   |\n\
    33 |             primes.push(temp_str.chars().count(|c| c.to_digit() > p));\n\
    \   |                                                                   ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmprpqe427w.rs:26:43\n   |\n26 |         temp_str = temp_str.to_string()\
    \ + c.to_string();\n   |                                           ^^^^^^^^^^^^^\n\
    \   |                                           |\n   |                      \
    \                     expected `&str`, found struct `String`\n   |           \
    \                                help: consider borrowing here: `&c.to_string()`\n\
    \nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmprpqe427w.rs:28:43\n    |\n28  |             if temp_str.chars().all(|c|\
    \ c.to_digit() > p) {\n    |                                           ^^^^^^^^-\
    \ supplied 0 arguments\n    |                                           |\n  \
    \  |                                           expected 1 argument\n    |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprpqe427w.rs:28:56\n\
    \   |\n28 |             if temp_str.chars().all(|c| c.to_digit() > p) {\n   |\
    \                                                        ^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<u32>`\n              found\
    \ type `{integer}`\nhelp: try wrapping the expression in `Some`\n   |\n28 |  \
    \           if temp_str.chars().all(|c| c.to_digit() > Some(p)) {\n   |      \
    \                                                  +++++ +\n\nerror[E0061]: this\
    \ function takes 0 arguments but 1 argument was supplied\n   --> /tmp/tmprpqe427w.rs:33:42\n\
    \    |\n33  |             primes.push(temp_str.chars().count(|c| c.to_digit()\
    \ > p));\n    |                                          ^^^^^ --------------------\
    \ supplie"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence_iter(&sentence).collect()\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence_iter` in this scope\n\
    \  --> /tmp/tmp4hau3bry.rs:16:5\n   |\n16 |     words_in_sentence_iter(&sentence).collect()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![];\n    for i in 1..=sentence.chars().count()\
    \ + 1 {\n        if isprime(i) {\n            primes.push(i);\n        }\n   \
    \ }\n    let mut res = String::from(\"[\");\n    for prime in &primes {\n    \
    \    res = res.insert(res.len() - 1, \",\").unwrap();\n        res = res.insert(res.len()\
    \ - 1, \"*\").unwrap();\n        res = res.insert(res.len() - 1, \" \").unwrap();\n\
    \        res = res.insert(res.len() - 1, &sentence[prime - 1]);\n        res =\
    \ res.insert(res.len() - 1, \" \").unwrap();\n    }\n    res = res.insert(res.len()\
    \ - 1, \"]\");\n    return res;\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `isprime` in this scope\n  --> /tmp/tmpuxm7ql24.rs:18:12\n\
    \   |\n18 |         if isprime(i) {\n   |            ^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuxm7ql24.rs:24:41\n \
    \  |\n24 |         res = res.insert(res.len() - 1, \",\").unwrap();\n   |    \
    \                                     ^^^ expected `char`, found `&str`\n   |\n\
    help: if you meant to write a `char` literal, use single quotes\n   |\n24 |  \
    \       res = res.insert(res.len() - 1, ',').unwrap();\n   |                 \
    \                        ~~~\n\nerror[E0599]: no method named `unwrap` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmpuxm7ql24.rs:24:46\n   |\n\
    24 |         res = res.insert(res.len() - 1, \",\").unwrap();\n   |          \
    \                                    ^^^^^^ method not found in `()`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuxm7ql24.rs:25:41\n   |\n25 |         res =\
    \ res.insert(res.len() - 1, \"*\").unwrap();\n   |                           \
    \              ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to\
    \ write a `char` literal, use single quotes\n   |\n25 |         res = res.insert(res.len()\
    \ - 1, '*').unwrap();\n   |                                         ~~~\n\nerror[E0599]:\
    \ no method named `unwrap` found for unit type `()` in the current scope\n  -->\
    \ /tmp/tmpuxm7ql24.rs:25:46\n   |\n25 |         res = res.insert(res.len() - 1,\
    \ \"*\").unwrap();\n   |                                              ^^^^^^ method\
    \ not found in `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuxm7ql24.rs:26:41\n\
    \   |\n26 |         res = res.insert(res.len() - 1, \" \").unwrap();\n   |   \
    \                                      ^^^ expected `char`, found `&str`\n   |\n\
    help: if you meant to write a `char` literal, use single quotes\n   |\n26 |  \
    \       res = res.insert(res.len() - 1, ' ').unwrap();\n   |                 \
    \                        ~~~\n\nerror[E0599]: no method named `unwrap` found for\
    \ unit type `()` in the current scope\n  --> /tmp/tmpuxm7ql24.rs:26:46\n   |\n\
    26 |         res = res.insert(res.len() - 1, \" \")"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime = String::new();\n    let mut prime_count\
    \ = 0;\n    let mut mut_prime = String::new();\n    let mut mut_prime_count =\
    \ 0;\n    for c in sentence.chars() {\n        if prime_count == 0 {\n       \
    \     prime = prime + &c.to_string();\n            prime_count = 1;\n        }\
    \ else if prime == &mut mut_prime {\n            prime_count = prime_count + 1;\n\
    \        } else {\n            prime_count = 1;\n            prime = &mut mut_prime;\n\
    \            mut_prime = &mut c.to_string();\n        }\n    }\n\n    let mut\
    \ prime_prime_count = 0;\n    for c in prime.chars() {\n        if prime_prime_count\
    \ == 0 {\n            prime_prime_count = 1;\n        } else if prime_prime_count\
    \ == 1 && prime == &mut c.to_string() {\n            prime_prime_count = prime_prime_count\
    \ + 1;\n        } else {\n            prime_prime_count = 1;\n        }\n    }\n\
    \    let mut mut_prime_prime_count = 0;\n    for c in mut_prime.chars() {\n  \
    \      if mut_prime_prime_count == 0 {\n            mut_prime_prime_count = 1;\n\
    \        } else if mut_prime_prime_count == 1 && mut_prime == &mut c.to_string()\
    \ {\n            mut_prime_prime_count = mut_prime_prime_count + 1;\n        }\
    \ else {\n            mut_prime_prime_count = 1;\n        }\n    }\n\n    if prime_count\
    \ == 0 || prime_prime_count == 0 || mut_prime_count == 0 || mut_prime_prime_count\
    \ == 0 {\n        return String::from(\"None\");\n    }\n\n    return prime\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: can't compare `String` with `&mut String`\n  --> /tmp/tmp6in735rt.rs:24:25\n\
    \   |\n24 |         } else if prime == &mut mut_prime {\n   |                \
    \         ^^ no implementation for `String == &mut String`\n   |\n   = help: the\
    \ trait `PartialEq<&mut String>` is not implemented for `String`\n   = help: the\
    \ following other types implement trait `PartialEq<Rhs>`:\n             <&'a str\
    \ as PartialEq<OsString>>\n             <&'a str as PartialEq<String>>\n     \
    \        <&'b str as PartialEq<Cow<'a, str>>>\n             <String as PartialEq<&'a\
    \ str>>\n             <String as PartialEq<Cow<'a, str>>>\n             <String\
    \ as PartialEq<str>>\n             <String as PartialEq>\n             <str as\
    \ PartialEq<Cow<'a, str>>>\n           and 4 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6in735rt.rs:28:21\n   |\n16 |     let mut prime = String::new();\n\
    \   |                     ------------- expected due to this value\n...\n28 |\
    \             prime = &mut mut_prime;\n   |                     ^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&mut String`\n   |\nhelp: consider removing\
    \ the borrow\n   |\n28 -             prime = &mut mut_prime;\n28 +           \
    \  prime = mut_prime;\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6in735rt.rs:29:25\n\
    \   |\n18 |     let mut mut_prime = String::new();\n   |                     \
    \    ------------- expected due to this value\n...\n29 |             mut_prime\
    \ = &mut c.to_string();\n   |                         ^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found `&mut String`\n   |\nhelp: consider removing the borrow\n\
    \   |\n29 -             mut_prime = &mut c.to_string();\n29 +             mut_prime\
    \ = c.to_string();\n   | \n\nerror[E0277]: can't compare `String` with `&mut String`\n\
    \  --> /tmp/tmp6in735rt.rs:37:51\n   |\n37 |         } else if prime_prime_count\
    \ == 1 && prime == &mut c.to_string() {\n   |                                \
    \                   ^^ no implementation for `String == &mut String`\n   |\n \
    \  = help: the trait `PartialEq<&mut String>` is not implemented for `String`\n\
    \   = help: the following oth"
  stdout: ''
  timestamp: 1659978464
- exit_code: 101
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter(|x| x.len() > 1).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Thisistest\"`,\n right: `\"is\"`', /tmp/tmpgwuwnbxj.rs:21:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // \u601D\u60F3\uFF1A\u5229\u7528\u6570\u7EC4\u53EF\
    \u4EE5\u5F88\u597D\u7684\u8BA9\u5B57\u7B26\u4E32\u590D\u5236\n    // \u5148\u53BB\
    \u6389\u6240\u6709\u7A7A\u683C\n    let mut words = sentence.split(' ');\n   \
    \ words.remove_if(|&x| x == \"\".to_string());\n    // \u53BB\u6389\u6240\u6709\
    \u7A7A\u683C\u7684\u540E\u9762\u7684\u6240\u6709\u7684\u7A7A\u683C\n    // \u53BB\
    \u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\n    // \u53BB\u6389\u7A7A\u683C\
    \u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6709\u7684\u7A7A\u683C\n    // \u53BB\u6389\
    \u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6CA1\u6709\u7684\u7A7A\u683C\
    \n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6709\u7684\
    \u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\
    \u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6709\u7684\u7A7A\u683C\u7684\u540E\u9762\
    \u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\
    \u4E2D\u6709\u7684\u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\u548C\u540E\
    \u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\
    \u4E32\u4E2D\u6CA1\u6709\u7684\u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\
    \n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6CA1\u6709\
    \u7684\u7A7A\u683C\u7684\u540E\u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\
    \u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6709\u7684\u7A7A\u683C\u7684\u524D\
    \u9762\u7684\u7A7A\u683C\u548C\u540E\u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\
    \u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\u6CA1\u6709\u7684\u7A7A\u683C\
    \u7684\u524D\u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\
    \u5B57\u7B26\u4E32\u4E2D\u6CA1\u6709\u7684\u7A7A\u683C\u7684\u540E\u9762\u7684\
    \u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\u4E2D\
    \u6709\u7684\u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\u548C\u540E\u9762\
    \u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\u4E32\
    \u4E2D\u6709\u7684\u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\u548C\u540E\
    \u9762\u7684\u7A7A\u683C\n    // \u53BB\u6389\u7A7A\u683C\u540E\u7684\u5B57\u7B26\
    \u4E32\u4E2D\u6CA1\u6709\u7684\u7A7A\u683C\u7684\u524D\u9762\u7684\u7A7A\u683C\
    \u548C\u540E\u9762\u7684\u7A7A\u683C\n\n    words.filter_map(|x| x.chars().filter(|&y|\
    \ y != ' ').count()).collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `remove_if` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp8upwc2i2.rs:19:11\n   |\n19 |     words.remove_if(|&x|\
    \ x == \"\".to_string());\n   |           ^^^^^^^^^ method not found in `std::str::Split<'_,\
    \ char>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8upwc2i2.rs:36:26\n\
    \   |\n36 |     words.filter_map(|x| x.chars().filter(|&y| y != ' ').count()).collect()\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found `usize`\n   |\n   = note: expected enum `Option<_>`\n \
    \             found type `usize`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n36 |     words.filter_map(|x| Some(x.chars().filter(|&y| y != ' ').count())).collect()\n\
    \   |                          +++++                                       +\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::from(\"\");\n    for (i, char)\
    \ in sentence.chars().enumerate() {\n        if i % 2 == 0 {\n            res.push_str(&char);\n\
    \        } else {\n            if char.chars().filter(|c| !c.is_whitespace()).count()\
    \ > 0 {\n                let prime_digits = primes(i);\n                if prime_digits.is_empty()\
    \ {\n                    panic!(\"Not prime number\");\n                }\n  \
    \              let mut prime_string = String::from(\"\");\n                for\
    \ p in prime_digits {\n                    prime_string.push_str(&char.chars().filter(|c|\
    \ c == p).collect::<String>().to_owned());\n                }\n              \
    \  res.push_str(&prime_string);\n            }\n        }\n    }\n    return res;\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmpwqvrij9y.rs:22:36\n\
    \   |\n22 |                 let prime_digits = primes(i);\n   |              \
    \                      ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpwqvrij9y.rs:19:26\n   |\n19 |             res.push_str(&char);\n\
    \   |                          ^^^^^ expected `str`, found `char`\n   |\n   =\
    \ note: expected reference `&str`\n              found reference `&char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpwqvrij9y.rs:21:21\n\
    \   |\n21 |             if char.chars().filter(|c| !c.is_whitespace()).count()\
    \ > 0 {\n   |                     ^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpwqvrij9y.rs:28:49\n\
    \   |\n28 |                     prime_string.push_str(&char.chars().filter(|c|\
    \ c == p).collect::<String>().to_owned());\n   |                             \
    \                    ^^^^^ method not found in `char`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![];\n    for &s in sentence.split_whitespace()\
    \ {\n        if primes.is_empty() {\n            primes.push(1);\n        } else\
    \ {\n            for i in 2..(s.len() - 1) as usize {\n                if s[i]\
    \ == s[i - 1] {\n                    primes.push(i);\n                }\n    \
    \        }\n        }\n    }\n    sentence.split_whitespace()\n        .iter()\n\
    \        .filter(|&x| primes.iter().any(|&i| x <= i))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmp35dp2qxr.rs:17:10\n   |\n17 |     for &s in sentence.split_whitespace()\
    \ {\n   |          ^ doesn't have a size known at compile-time\n   |\n   = help:\
    \ the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror[E0277]: the type `str` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp35dp2qxr.rs:22:20\n   |\n22 |                 if s[i] == s[i -\
    \ 1] {\n   |                    ^^^^ string indices are ranges of `usize`\n  \
    \ |\n   = help: the trait `SliceIndex<str>` is not implemented for `usize`\n \
    \  = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<usize>` for `str`\n\
    \nerror[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp35dp2qxr.rs:22:28\n\
    \   |\n22 |                 if s[i] == s[i - 1] {\n   |                      \
    \      ^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help: the trait\
    \ `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<usize>` for `str`\n\nerror[E0599]: no method named `iter`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmp35dp2qxr.rs:29:10\n\
    \   |\n29 |         .iter()\n   |          ^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    constraints!(sentence);\n    let mut prime_string =\
    \ String::new();\n    let mut prime_number = 2;\n\n    while prime_number < sentence.len()\
    \ {\n        if sentence.chars().filter(|c| prime_number % c == 0).count() < sentence.len()\
    \ / prime_number {\n            prime_string += &sentence.chars().filter(|c| prime_number\
    \ % c == 0).collect::<String>().to_string();\n            prime_number += 2;\n\
    \        }\n        prime_number += 2;\n    }\n\n    prime_string\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `constraints` in this scope\n  --> /tmp/tmphlq0wzd7.rs:16:5\n\
    \   |\n16 |     constraints!(sentence);\n   |     ^^^^^^^^^^^\n\nerror[E0277]:\
    \ cannot mod `usize` by `&char`\n  --> /tmp/tmphlq0wzd7.rs:21:53\n   |\n21 | \
    \        if sentence.chars().filter(|c| prime_number % c == 0).count() < sentence.len()\
    \ / prime_number {\n   |                                                     ^\
    \ no implementation for `usize % &char`\n   |\n   = help: the trait `Rem<&char>`\
    \ is not implemented for `usize`\n   = help: the following other types implement\
    \ trait `Rem<Rhs>`:\n             <&'a f32 as Rem<f32>>\n             <&'a f64\
    \ as Rem<f64>>\n             <&'a i128 as Rem<i128>>\n             <&'a i16 as\
    \ Rem<i16>>\n             <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n\
    \             <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n  \
    \         and 54 others\n\nerror[E0277]: cannot mod `usize` by `&char`\n  -->\
    \ /tmp/tmphlq0wzd7.rs:22:71\n   |\n22 |             prime_string += &sentence.chars().filter(|c|\
    \ prime_number % c == 0).collect::<String>().to_string();\n   |              \
    \                                                         ^ no implementation\
    \ for `usize % &char`\n   |\n   = help: the trait `Rem<&char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Rem<Rhs>`:\n\
    \             <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n    \
    \         <&'a i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n      \
    \       <&'a i32 as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n          \
    \   <&'a i8 as Rem<i8>>\n             <&'a isize as Rem<isize>>\n           and\
    \ 54 others\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    shortest_string_length(sentence, prime_number_filter(sentence.chars().count()),\
    \ sentence.len())\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shortest_string_length` in this scope\n\
    \  --> /tmp/tmpakbpja7d.rs:16:5\n   |\n16 |     shortest_string_length(sentence,\
    \ prime_number_filter(sentence.chars().count()), sentence.len())\n   |     ^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `prime_number_filter`\
    \ in this scope\n  --> /tmp/tmpakbpja7d.rs:16:38\n   |\n16 |     shortest_string_length(sentence,\
    \ prime_number_filter(sentence.chars().count()), sentence.len())\n   |       \
    \                               ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut chars = sentence.chars();\n    let mut primes\
    \ = String::new();\n\n    while let Some(next_char) = chars.next() {\n       \
    \ if !primes.is_empty() {\n            if next_char == ' ' {\n               \
    \ primes = primes.chars().collect::<Vec<_>>();\n            } else {\n       \
    \         break;\n            }\n        }\n\n        let new_primes = primes.clone()\
    \ + next_char;\n        primes = new_primes;\n    }\n\n    primes\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkye_v39e.rs:22:26\n   |\n\
    17 |     let mut primes = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n22 |                 primes = primes.chars().collect::<Vec<_>>();\n\
    \   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Vec<char>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpkye_v39e.rs:28:43\n   |\n28 |         let new_primes = primes.clone()\
    \ + next_char;\n   |                                           ^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    require(sentence.length() > 0);\n\n    // The first\
    \ character of the sentence will be the first word.\n    let mut first_character\
    \ = String::from(sentence.chars().nth(0).unwrap().to_string());\n    let mut last_character\
    \ = String::from(sentence.chars().nth(sentence.len() - 1).unwrap().to_string());\n\
    \    let mut prime = true;\n\n    // Find the word where the next character is\
    \ the same as the first character of last word.\n    for c in sentence.chars().rev()\
    \ {\n        let current_word = String::from(sentence.chars().nth(sentence.len()\
    \ - 1).unwrap().to_string());\n        let prev_character = String::from(c.to_string());\n\
    \        if current_word == prev_character {\n            prime = false;\n   \
    \         last_character = c;\n            break;\n        }\n    }\n\n    //\
    \ If the current word is a prime number, then we add the first character of last\
    \ word.\n    if prime {\n        first_character = String::from(last_character.chars().nth(0).unwrap().to_string());\n\
    \    }\n\n    first_character + &first_character[1..]\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `require` in this scope\n  --> /tmp/tmp1brybv_0.rs:16:5\n\
    \   |\n16 |     require(sentence.length() > 0);\n   |     ^^^^^^^ not found in\
    \ this scope\n\nerror[E0599]: no method named `length` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp1brybv_0.rs:16:22\n   |\n16 |     require(sentence.length()\
    \ > 0);\n   |                      ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1brybv_0.rs:29:30\n\
    \   |\n20 |     let mut last_character = String::from(sentence.chars().nth(sentence.len()\
    \ - 1).unwrap().to_string());\n   |                              ---------------------------------------------------------------------------\
    \ expected due to this value\n...\n29 |             last_character = c;\n   |\
    \                              ^- help: try using a conversion method: `.to_string()`\n\
    \   |                              |\n   |                              expected\
    \ struct `String`, found `char`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut ret = \"\";\n    let mut primes = Vec::new();\n\
    \    let mut last_prime = 0;\n    sentence.split_whitespace().into_iter().filter(|&s|\
    \ s.chars().all(|c| 'A' <= c && c <= 'Z')).for_each(|c| primes.push(c as i32));\n\
    \    while last_prime < primes.len() {\n        if last_prime == primes.len()\
    \ - 1 {\n            if primes[last_prime] * (primes[last_prime] + 1) as i32 ==\
    \ sentence.len() {\n                break;\n            }\n        }\n       \
    \ else {\n            if primes[last_prime] * (primes[last_prime] + 2) as i32\
    \ == sentence.len() {\n                break;\n            }\n        }\n    \
    \    last_prime += 1;\n    }\n    ret = sentence;\n    for i in 0..last_prime\
    \ {\n        ret += &sentence[i as usize];\n    }\n    ret\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp96p8a9sl.rs:22:72\n   |\n\
    22 |             if primes[last_prime] * (primes[last_prime] + 1) as i32 == sentence.len()\
    \ {\n   |                                                                    \
    \    ^^^^^^^^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can convert\
    \ a `usize` to an `i32` and panic if the converted value doesn't fit\n   |\n22\
    \ |             if primes[last_prime] * (primes[last_prime] + 1) as i32 == sentence.len().try_into().unwrap()\
    \ {\n   |                                                                    \
    \                  ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp96p8a9sl.rs:27:72\n   |\n27 |             if primes[last_prime] * (primes[last_prime]\
    \ + 2) as i32 == sentence.len() {\n   |                                      \
    \                                  ^^^^^^^^^^^^^^ expected `i32`, found `usize`\n\
    \   |\nhelp: you can convert a `usize` to an `i32` and panic if the converted\
    \ value doesn't fit\n   |\n27 |             if primes[last_prime] * (primes[last_prime]\
    \ + 2) as i32 == sentence.len().try_into().unwrap() {\n   |                  \
    \                                                                    ++++++++++++++++++++\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp96p8a9sl.rs:33:11\n   |\n16 |\
    \     let mut ret = \"\";\n   |                   -- expected due to this value\n\
    ...\n33 |     ret = sentence;\n   |           ^^^^^^^^\n   |           |\n   |\
    \           expected `&str`, found struct `String`\n   |           help: consider\
    \ borrowing here: `&sentence`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmp96p8a9sl.rs:35:17\n   |\n35 |         ret += &sentence[i\
    \ as usize];\n   |                 ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug_assert!(sentence.len() <= 100);\n    let mut\
    \ result = String::new();\n    let words = sentence.split_whitespace().collect::<Vec<String>>();\n\
    \    for word in words {\n        assert!(prime_number_helper(word));\n      \
    \  result.push_str(&word);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_number_helper` in this scope\n\
    \  --> /tmp/tmpjeb7daug.rs:20:17\n   |\n20 |         assert!(prime_number_helper(word));\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ a value of type `Vec<String>` cannot be built from an iterator over elements\
    \ of type `&str`\n    --> /tmp/tmpjeb7daug.rs:18:45\n     |\n18   |     let words\
    \ = sentence.split_whitespace().collect::<Vec<String>>();\n     |            \
    \                                 ^^^^^^^ value of type `Vec<String>` cannot be\
    \ built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::from(\"\");\n    sentence.split_whitespace().for_each(|word|\
    \ {\n        if !is_prime(word.size()) {\n            return;\n        }\n   \
    \     res += \" \" + word;\n    });\n    res\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpcigo060f.rs:18:13\n\
    \   |\n18 |         if !is_prime(word.size()) {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no method named `size` found for reference\
    \ `&str` in the current scope\n  --> /tmp/tmpcigo060f.rs:18:27\n   |\n18 |   \
    \      if !is_prime(word.size()) {\n   |                           ^^^^ method\
    \ not found in `&str`\n\nerror[E0369]: cannot add `&str` to `&str`\n  --> /tmp/tmpcigo060f.rs:21:20\n\
    \   |\n21 |         res += \" \" + word;\n   |                --- ^ ---- &str\n\
    \   |                |   |\n   |                |   `+` cannot be used to concatenate\
    \ two `&str` strings\n   |                &str\n   |\n   = note: string concatenation\
    \ requires an owned `String` on the left\nhelp: create an owned `String` from\
    \ a string reference\n   |\n21 |         res += \" \".to_owned() + word;\n   |\
    \                   +++++++++++\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0369, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut s = sentence.clone();\n    for word in s.split_whitespace()\
    \ {\n        let mut num = 1;\n        for ch in word {\n            if ch !=\
    \ 'a' && ch != 'e' && ch != 'i' && ch != 'o' && ch != 'u'\n                &&\
    \ ch != 'A' && ch != 'E' && ch != 'I' && ch != 'O' && ch != 'U' {\n          \
    \      num *= 2; // this word is a single unit\n                break;\n     \
    \       }\n            num /= 2; // this word is a double unit\n        }\n  \
    \      if num == 2 {\n            s += word;\n        }\n    }\n    s\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&str` is not an iterator\n  --> /tmp/tmp4bozowu2.rs:19:19\n\
    \   |\n19 |         for ch in word {\n   |                   ^^^^ `&str` is not\
    \ an iterator; try calling `.chars()` or `.bytes()`\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `&str`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    let mut prime_words = [\"\"\
    .to_string(); 26];\n    prime_words[0] = sentence.clone();\n\n    for i in 1..(sentence.len()\
    \ as u32) {\n        for j in 2..26 {\n            if ((i - j)%2) == 0 {\n   \
    \             if let str = prime_words[j].clone() {\n                    if let\
    \ str_prime = str.clone() {\n                        prime_words[j] = str_prime;\n\
    \                        prime_words[j] += \" \";\n                    }\n   \
    \             }\n            }\n        }\n    }\n    let mut prime_words_string\
    \ = String::new();\n    for word in prime_words {\n        prime_words_string.push_str(word);\n\
    \    }\n    return prime_words_string;\n}\n\nfn main() {\n    let candidate =\
    \ words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: Copy` is not satisfied\n  --> /tmp/tmppp5eyrlv.rs:17:28\n\
    \   |\n17 |     let mut prime_words = [\"\".to_string(); 26];\n   |          \
    \                  ^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `String`\n\
    \   |\n   = note: the `Copy` trait is required because this value will be copied\
    \ for each element of the array\n\nerror[E0277]: the type `[String]` cannot be\
    \ indexed by `u32`\n  --> /tmp/tmppp5eyrlv.rs:23:30\n   |\n23 |              \
    \   if let str = prime_words[j].clone() {\n   |                              ^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[String]>` is not implemented for `u32`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<u32>` for `[String]`\n\nerror[E0277]:\
    \ the type `[String]` cannot be indexed by `u32`\n  --> /tmp/tmppp5eyrlv.rs:25:25\n\
    \   |\n25 |                         prime_words[j] = str_prime;\n   |        \
    \                 ^^^^^^^^^^^^^^ slice indices are of type `usize` or ranges of\
    \ `usize`\n   |\n   = help: the trait `SliceIndex<[String]>` is not implemented\
    \ for `u32`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<u32>` for\
    \ `[String]`\n\nerror[E0277]: the type `[String]` cannot be indexed by `u32`\n\
    \  --> /tmp/tmppp5eyrlv.rs:26:25\n   |\n26 |                         prime_words[j]\
    \ += \" \";\n   |                         ^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[String]>`\
    \ is not implemented for `u32`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u32>` for `[String]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppp5eyrlv.rs:34:37\n\
    \   |\n34 |         prime_words_string.push_str(word);\n   |                 \
    \                    ^^^^\n   |                                     |\n   |  \
    \       "
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.as_str())\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp34go0tab.rs:16:23\n   |\n\
    16 |     words_in_sentence(sentence.as_str())\n   |                       ^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \     |\n   |                       expected struct `String`, found `&str`\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in sentence.chars()\
    \ {\n        if !is_prime(c) && c != ' ' {\n            res.push_str(&c.to_ascii_lowercase());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpljhkbpdd.rs:18:13\n\
    \   |\n18 |         if !is_prime(c) && c != ' ' {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpljhkbpdd.rs:19:26\n\
    \   |\n19 |             res.push_str(&c.to_ascii_lowercase());\n   |         \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut a = String::with_capacity(sentence.length());\n\
    \    a.push_str(&sentence);\n    let mut i = 1;\n    while i <= a.len() {\n  \
    \      let len = a.len() / i;\n        for (j, t) in a.chars().enumerate() {\n\
    \            if t != ' ' && (j+1) * i != len {\n                a.remove(j, 1);\n\
    \                i += 1;\n                break;\n            }\n        }\n \
    \   }\n    a\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpsj8mil44.rs:16:48\n   |\n16 |     let mut a = String::with_capacity(sentence.length());\n\
    \   |                                                ^^^^^^ help: there is an\
    \ associated function with a similar name: `len`\n\nerror[E0061]: this function\
    \ takes 1 argument but 2 arguments were supplied\n    --> /tmp/tmpsj8mil44.rs:23:19\n\
    \     |\n23   |                 a.remove(j, 1);\n     |                   ^^^^^^\
    \ -  - supplied 2 arguments\n     |                   |\n     |              \
    \     expected 1 argument\n     |\nnote: associated function defined here\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjhq8etac.rs:15:43\n   |\n\
    15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut list = vec![];\n    list.push(sentence[0]);\n\
    \    for i in 1..sentence.len() {\n        if isPrime(&sentence[i]) {\n      \
    \      list.push(sentence[i]);\n        }\n    }\n    list.join(\" \")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `isPrime` in this scope\n  --> /tmp/tmpct7qy4o7.rs:19:12\n\
    \   |\n19 |         if isPrime(&sentence[i]) {\n   |            ^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpct7qy4o7.rs:17:15\n   |\n17 |     list.push(sentence[0]);\n   |\
    \               ^^^^^^^^^^^ `String` cannot be indexed by `{integer}`\n   |\n\
    \   = help: the trait `Index<{integer}>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpct7qy4o7.rs:19:21\n   |\n19 |         if isPrime(&sentence[i])\
    \ {\n   |                     ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpct7qy4o7.rs:20:23\n   |\n20 |             list.push(sentence[i]);\n\
    \   |                       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclus"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.len() < 1 {\n        return String::new();\n\
    \    }\n    loop {\n        let mut prime = true;\n        for &c in sentence.chars()\
    \ {\n            if !c.is_uppercase() {\n                return String::new();\n\
    \            }\n            if !prime.is_lowercase() {\n                prime\
    \ = false;\n                break;\n            }\n        }\n        if prime\
    \ {\n            return sentence;\n        }\n        sentence += \" \";\n   \
    \ }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpqfysntu8.rs:21:13\n   |\n\
    21 |         for &c in sentence.chars() {\n   |             ^^    ----------------\
    \ this expression has type `Option<char>`\n   |             |\n   |          \
    \   expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0599]: no method named `is_lowercase`\
    \ found for type `bool` in the current scope\n  --> /tmp/tmpqfysntu8.rs:25:23\n\
    \   |\n25 |             if !prime.is_lowercase() {\n   |                     \
    \  ^^^^^^^^^^^^ method not found in `bool`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    validate_length(sentence);\n    let mut words = sentence.chars().collect::<Vec<_>>();\n\
    \    let mut prime_words = Vec::new();\n    let mut prime_lengths = Vec::new();\n\
    \    let mut prime_max_length = sentence\n        .chars()\n        .map(|c| {\n\
    \            prime_words.push(true);\n            prime_lengths.push(c == ' '\
    \ || c == ',' ? 2 : 1);\n            prime_words.push(true);\n            prime_lengths.push(c\
    \ == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n        \
    \    prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            prime_lengths.push(c == ' ' || c == ',' ? 2 : 1);\n            prime_words.push(true);\n\
    \            \n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpexxzezly.rs:76:3\n\
    \   |\n15 | fn words_in_sentence(sentence: String) -> String {\n   |         \
    \                                         - unclosed delimiter\n...\n22 |    \
    \     .map(|c| {\n   |             - unclosed delimiter\n...\n76 | }\n   |   ^\n\
    \nerror: expected one of `)`, `,`, `.`, `?`, or an operator, found `2`\n  -->\
    \ /tmp/tmpexxzezly.rs:24:55\n   |\n24 |             prime_lengths.push(c == '\
    \ ' || c == ',' ? 2 : 1);\n   |                                              \
    \         ^ expected one of `)`, `,`, `.`, `?`, or an operator\n\nerror: expected\
    \ one of `!`, `&&`, `&`, `(`, `)`, `*`, `...`, `.`, `;`, `<`, `?`, `[`, `_`, `async`,\
    \ `const`, `dyn`, `extern`, `fn`, `for`, `impl`, `unsafe`, `}`, `~`, an operator,\
    \ lifetime, or path, found `1`\n  --> /tmp/tmpexxzezly.rs:15:50\n   |\n15 | fn\
    \ words_in_sentence(sentence: String) -> String {\n   |                      \
    \                            ^ unclosed delimiter\n...\n24 |             prime_lengths.push(c\
    \ == ' ' || c == ',' ? 2 : 1);\n   |                                         \
    \                 -^ expected one of 26 possible tokens\n   |                \
    \                                          |\n   |                           \
    \                               help: `}` may belong here\n\nerror: expected one\
    \ of `)`, `,`, `.`, `?`, or an operator, found keyword `fn`\n  --> /tmp/tmpexxzezly.rs:67:1\n\
    \   |\n65 | }\n   |  - expected one of `)`, `,`, `.`, `?`, or an operator\n66\
    \ | \n67 | fn main() {\n   | ^^ unexpected token\n\nerror: aborting due to 4 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_lengths: Vec<u32> = Vec::new();\n   \
    \ let mut prime_words: Vec<&str> = Vec::new();\n    for length in 0..(sentence.len())\
    \ {\n        prime_lengths.push(1);\n        for &c in sentence.chars() {\n  \
    \          if length > c {\n                break;\n            }\n          \
    \  if c % length != 0 {\n                continue;\n            }\n          \
    \  prime_lengths.push(*prime_lengths.last().unwrap() + 1);\n        }\n    }\n\
    \    for (i, prime_length) in prime_lengths.iter().enumerate() {\n        for\
    \ &w in sentence.chars().skip(i) {\n            if prime_lengths.iter().all(|p|\
    \ p == w) {\n                prime_words.push(w.to_string());\n            }\n\
    \        }\n    }\n    prime_words[0..prime_words.len() - 1].join()\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpsvvu85ok.rs:20:13\n   |\n\
    20 |         for &c in sentence.chars() {\n   |             ^^    ----------------\
    \ this expression has type `Option<char>`\n   |             |\n   |          \
    \   expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpsvvu85ok.rs:31:13\n\
    \   |\n31 |         for &w in sentence.chars().skip(i) {\n   |             ^^\
    \    ------------------------ this expression has type `Option<char>`\n   |  \
    \           |\n   |             expected `char`, found reference\n   |       \
    \      help: you can probably remove the explicit borrow: `w`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0061]: this\
    \ function takes 1 argument but 0 arguments were supplied\n   --> /tmp/tmpsvvu85ok.rs:37:43\n\
    \    |\n37  |     prime_words[0..prime_words.len() - 1].join()\n    |        \
    \                                   ^^^^- supplied 0 arguments\n    |        \
    \                                   |\n    |                                 \
    \          expected 1 argument\n    |\nnote: associated function defined here\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0308.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut output = String::new();\n\n    let mut counter\
    \ = 1;\n    let mut primes = vec![];\n    let mut words = sentence.split(' ').collect::<Vec<_>>();\n\
    \    let mut last_word = sentence;\n\n    while counter < words.len() {\n    \
    \    let mut word = &words[counter];\n\n        if primes.contains(&counter) {\n\
    \            primes.push(counter);\n            continue;\n        }\n\n     \
    \   while primes.contains(&counter) && counter <= last_word.len() {\n        \
    \    let mut temp = counter;\n            while primes.contains(&temp) {\n   \
    \             temp = temp + 2;\n            }\n\n            if counter % temp\
    \ == 0 {\n                primes.push(counter);\n                break;\n    \
    \        }\n\n            counter = counter + 1;\n        }\n        last_word\
    \ = word;\n\n        output.push_str(&word);\n        output.push(' ');\n    \
    \    counter = counter + 1;\n    }\n\n    output\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpl_evn9e_.rs:44:21\n   |\n\
    21 |     let mut last_word = sentence;\n   |                         --------\
    \ expected due to this value\n...\n44 |         last_word = word;\n   |      \
    \               ^^^^- help: try using a conversion method: `.to_string()`\n  \
    \ |                     |\n   |                     expected struct `String`,\
    \ found `&&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    \n    // Your code here\n    let mut result = String::new();\n\
    \    let mut primes = String::new();\n    let mut words = sentence.split(' ').collect::<Vec<String>>();\n\
    \    primes.clear();\n    \n    for word in words {\n        let mut prime = false;\n\
    \        let mut prime_start = -1;\n        let mut prime_end = -1;\n        for\
    \ index in 0..(word.len() - 1) {\n            let first_letter = word[index];\n\
    \            if prime_start == -1 && first_letter > 'a' && first_letter < 'z'\
    \ {\n                prime_start = index;\n            }\n            if prime_end\
    \ == -1 && first_letter > 'a' && first_letter < 'z' {\n                prime_end\
    \ = index;\n            }\n            if !prime {\n                if prime_start\
    \ != -1 && prime_end != -1 && prime_start < prime_end {\n                    if\
    \ prime_start == index {\n                        prime = true;\n            \
    \        }\n                }\n            }\n        }\n        if prime {\n\
    \            primes.push(word);\n        }\n    }\n    primes.sort();\n    for\
    \ prime in primes {\n        let mut s = String::new();\n        for word in words\
    \ {\n            if prime == word {\n                s.push_str(\" \");\n    \
    \        }\n            s.push_str(word);\n        }\n        result.push_str(s);\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpxls5z_xc.rs:20:41\n     |\n20\
    \   |     let mut words = sentence.split(' ').collect::<Vec<String>>();\n    \
    \ |                                         ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpxls5z_xc.rs:28:32\n   |\n28 |             let first_letter\
    \ = word[index];\n   |                                ^^^^^^^^^^^ `String` cannot\
    \ be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the trait bound `usize: Neg` is not satisfied\n \
    \ --> /tmp/tmpxls5z_xc.rs:25:31\n   |\n25 |         let mut prime_start = -1;\n\
    \   |                               ^^ the trait `Neg` is not implemented for\
    \ `usize`\n   |\n   = help: the following other types implement trait `Neg`:\n\
    \             &f32\n             &f64\n             &i128\n             &i16\n\
    \             &i32\n             &i64\n             &i8\n             &isize\n\
    \           and 8 others\n\nerror[E0277]: the trait bound `usize: Neg` is not\
    \ satisfied\n  --> /tmp/tmpxls5z_xc.rs:29:31\n   |\n29 |             if prime_start\
    \ == -1 && first_letter > 'a' && first_letter < 'z' {\n   |                  \
    \             ^^ the trait `Neg` is not implemented for `usize`\n   |\n   = help:\
    \ the following other types implement trait `Neg`"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter(|word| is_prime(word.len()))\n\
    \        .collect()\n        .join(' ')\n}\n\nfn main() {\n    let candidate =\
    \ words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpp3po54v0.rs:16:47\n\
    \   |\n16 |     sentence.split_whitespace().filter(|word| is_prime(word.len()))\n\
    \   |                                               ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = String::new();\n    words.reserve(sentence.length());\n\
    \n    let mut prime_numbers = vec![2, 3];\n\n    let mut s = sentence.chars();\n\
    \    for c in s.rev() {\n        let index = c.len_utf8();\n\n        if prime_numbers.contains(index)\
    \ {\n            if index > 0 {\n                words.push(c.chars().collect::<String>().to_string());\n\
    \            }\n            prime_numbers.remove(index);\n        }\n    }\n\n\
    \    words\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpf5hlissp.rs:17:28\n   |\n17 |     words.reserve(sentence.length());\n\
    \   |                            ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpf5hlissp.rs:25:35\n\
    \   |\n25 |         if prime_numbers.contains(index) {\n   |                 \
    \                  ^^^^^\n   |                                   |\n   |     \
    \                              expected `&{integer}`, found `usize`\n   |    \
    \                               help: consider borrowing here: `&index`\n\nerror[E0599]:\
    \ no method named `chars` found for type `char` in the current scope\n  --> /tmp/tmpf5hlissp.rs:27:30\n\
    \   |\n27 |                 words.push(c.chars().collect::<String>().to_string());\n\
    \   |                              ^^^^^ method not found in `char`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace();\n    let\
    \ mut result: String = \"\";\n    let mut prime = true;\n\n    while !words.is_empty()\
    \ {\n        let word = words.split_whitespace()[0];\n\n        if !prime(word)\
    \ {\n            break;\n        }\n\n        result.append(&word);\n        words\
    \ = words.split_whitespace();\n    }\n\n    result\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp27n18s1.rs:17:30\n   |\n\
    17 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0599]: no method\
    \ named `is_empty` found for struct `SplitWhitespace` in the current scope\n \
    \ --> /tmp/tmpp27n18s1.rs:20:18\n   |\n20 |     while !words.is_empty() {\n  \
    \ |                  ^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror[E0599]:\
    \ no method named `split_whitespace` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpp27n18s1.rs:21:26\n   |\n21 |         let word\
    \ = words.split_whitespace()[0];\n   |                          ^^^^^^^^^^^^^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror[E0618]: expected function,\
    \ found `bool`\n  --> /tmp/tmpp27n18s1.rs:23:13\n   |\n18 |     let mut prime\
    \ = true;\n   |         --------- `prime` has type `bool`\n...\n23 |         if\
    \ !prime(word) {\n   |             ^^^^^------\n   |             |\n   |     \
    \        call expression requires function\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpp27n18s1.rs:27:16\n\
    \   |\n27 |         result.append(&word);\n   |                ^^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `split_whitespace` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpp27n18s1.rs:28:23\n\
    \   |\n28 |         words = words.split_whitespace();\n   |                  \
    \     ^^^^^^^^^^^^^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0618.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debugln!(\"words_in_sentence is called\");\n    let\
    \ mut words = sentence.split_whitespace();\n    let mut res = String::with_capacity(sentence.len());\n\
    \    while !words.is_empty() {\n        let len = words.len();\n        if len\
    \ == 2 {\n            res.push_str(\"{}\");\n            words.remove();\n   \
    \         continue;\n        }\n        let num_primes = prime_numbers::primes(len).count();\n\
    \        if num_primes < 2 {\n            res.push_str(\"{}\");\n            words.remove();\n\
    \            continue;\n        }\n        let prime_candidates = prime_numbers::primes(num_primes\
    \ + 1).collect();\n        debugln!(\"prime_candidates: {:?}\", prime_candidates);\n\
    \        let mut found = false;\n        for p in prime_candidates {\n       \
    \     let mut num = p.pow(len).unwrap();\n            debugln!(\"num: {:?}\",\
    \ num);\n            while num > 1 {\n                if words.len() <= num {\n\
    \                    debugln!(\"num is: {:?}\", num);\n                    break;\n\
    \                }\n                if words.contains(' ') {\n               \
    \     debugln!(\"num is: {:?}\", num);\n                    break;\n         \
    \       }\n                if !res.contains(&words[num - 2]) {\n             \
    \       debugln!(\"num is: {:?}\", num);\n                    break;\n       \
    \         }\n                found = true;\n                words.remove(&words[num\
    \ - 2]);\n                num -= 1;\n            }\n        }\n        if !found\
    \ {\n            res.push_str(\"{}\");\n        }\n        words.remove();\n \
    \   }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n   \
    \ assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debugln` in this scope\n  --> /tmp/tmplimtwp2c.rs:16:5\n\
    \   |\n16 |     debugln!(\"words_in_sentence is called\");\n   |     ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmplimtwp2c.rs:33:9\n\
    \   |\n33 |         debugln!(\"prime_candidates: {:?}\", prime_candidates);\n\
    \   |         ^^^^^^^\n\nerror: cannot find macro `debugln` in this scope\n  -->\
    \ /tmp/tmplimtwp2c.rs:37:13\n   |\n37 |             debugln!(\"num: {:?}\", num);\n\
    \   |             ^^^^^^^\n\nerror: cannot find macro `debugln` in this scope\n\
    \  --> /tmp/tmplimtwp2c.rs:40:21\n   |\n40 |                     debugln!(\"num\
    \ is: {:?}\", num);\n   |                     ^^^^^^^\n\nerror: cannot find macro\
    \ `debugln` in this scope\n  --> /tmp/tmplimtwp2c.rs:44:21\n   |\n44 |       \
    \              debugln!(\"num is: {:?}\", num);\n   |                     ^^^^^^^\n\
    \nerror: cannot find macro `debugln` in this scope\n  --> /tmp/tmplimtwp2c.rs:48:21\n\
    \   |\n48 |                     debugln!(\"num is: {:?}\", num);\n   |       \
    \              ^^^^^^^\n\nerror[E0433]: failed to resolve: use of undeclared crate\
    \ or module `prime_numbers`\n  --> /tmp/tmplimtwp2c.rs:26:26\n   |\n26 |     \
    \    let num_primes = prime_numbers::primes(len).count();\n   |              \
    \            ^^^^^^^^^^^^^ use of undeclared crate or module `prime_numbers`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `prime_numbers`\n\
    \  --> /tmp/tmplimtwp2c.rs:32:32\n   |\n32 |         let prime_candidates = prime_numbers::primes(num_primes\
    \ + 1).collect();\n   |                                ^^^^^^^^^^^^^ use of undeclared\
    \ crate or module `prime_numbers`\n\nerror[E0599]: no method named `is_empty`\
    \ found for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmplimtwp2c.rs:19:18\n\
    \   |\n19 |     while !words.is_empty() {\n   |                  ^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `len` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmplimtwp2c.rs:20:25\n\
    \   |\n20 |         let len = words.len();\n   |                         ^^^ method\
    \ n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split(' ').to_vec();\n   \
    \ words.sort_unstable();\n    String::from(words.join(\" \"))\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp3izmuws8.rs:16:41\n   |\n16 |     let mut\
    \ words = sentence.split(' ').to_vec();\n   |                                \
    \         ^^^^^^ method not found in `std::str::Split<'_, char>`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    match sentence\n        .split_whitespace()\n     \
    \   .filter_map(|s| s.chars().collect(|c| {\n            if c.is_letter() {\n\
    \                Some(c)\n            } else {\n                None\n       \
    \     }\n        }))\n    {\n        None => \"\",\n        Some(_) => \"\",\n\
    \    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpssgizt11.rs:18:44\n\
    \   |\n18 |         .filter_map(|s| s.chars().collect(|c| {\n   |            \
    \                                ^ consider giving this closure parameter a type\n\
    \   |\n   = note: type must be known at this point\n\nerror[E0061]: this function\
    \ takes 0 arguments but 1 argument was supplied\n    --> /tmp/tmpssgizt11.rs:18:35\n\
    \     |\n18   |           .filter_map(|s| s.chars().collect(|c| {\n     |  ___________________________________^^^^^^^_-\n\
    \     | |                                   |\n     | |                      \
    \             expected 0 arguments\n19   | |             if c.is_letter() {\n\
    20   | |                 Some(c)\n21   | |             } else {\n22   | |    \
    \             None\n23   | |             }\n24   | |         }))\n     | |_________-\
    \ supplied 1 argument\n     |\nnote: associated function defined here\n\nerror[E0277]:\
    \ a value of type `Option<_>` cannot be built from an iterator over elements of\
    \ type `char`\n    --> /tmp/tmpssgizt11.rs:18:35\n     |\n18   |         .filter_map(|s|\
    \ s.chars().collect(|c| {\n     |                                   ^^^^^^^ value\
    \ of type `Option<_>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Option<_>`\n\
    \     = help: the trait `FromIterator<Option<A>>` is implemented for `Option<V>`\n\
    note: required by a bound in `collect`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpssgizt11.rs:26:9\n   |\n16 |        match sentence\n   |   ___________-\n\
    17 |  |         .split_whitespace()\n18 |  |         .filter_map(|s| s.chars().collect(|c|\
    \ {\n   |  |_____________________-\n19 | ||             if c.is_letter() {\n20\
    \ | ||                 Some(c)\n21 | ||             } else {\n22 | ||        \
    \         None\n23 | ||             }\n24 | ||         }))\n   | ||__________--\
    \ this expression has type `FilterMap<SplitWhitespace<'_>, [closure@/tmp/tmpssgizt11.rs:18:21:\
    \ 24:11]>`\n   | |___________|\n   |             the expected closure\n25 |  \
    \      {\n26 |            None => \"\",\n   |          "
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentences(sentence.split(), \"\")\n      \
    \  .iter()\n        .cloned()\n        .map(String::from)\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentences` in this scope\n\
    \  --> /tmp/tmp124_aq6w.rs:16:5\n   |\n16 |     words_in_sentences(sentence.split(),\
    \ \"\")\n   |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0061]:\
    \ this function takes 1 argument but 0 arguments were supplied\n    --> /tmp/tmp124_aq6w.rs:16:33\n\
    \     |\n16   |     words_in_sentences(sentence.split(), \"\")\n     |       \
    \                          ^^^^^- supplied 0 arguments\n     |               \
    \                  |\n     |                                 expected 1 argument\n\
    \     |\nnote: associated function defined here\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::from(\"\");\n    let\
    \ mut primes = String::from(\"\");\n    let mut n = sentence.length();\n    //\
    \ O(n)\n    while n != 0 {\n        if n % 2 == 0 {\n            new_sentence\
    \ += &sentence[n/2];\n        }\n        n /= 2;\n    }\n    new_sentence = String::from(new_sentence.split_whitespace().collect::<Vec<_>>());\n\
    \    new_sentence = String::from(new_sentence.iter().map(|s| primes.contains(&s).unwrap()).collect::<Vec<_>>());\n\
    \    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpdk2boi3z.rs:18:26\n   |\n18 |     let mut n = sentence.length();\n\
    \   |                          ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: the trait bound `String: From<Vec<&str>>`\
    \ is not satisfied\n  --> /tmp/tmpdk2boi3z.rs:26:20\n   |\n26 |     new_sentence\
    \ = String::from(new_sentence.split_whitespace().collect::<Vec<_>>());\n   | \
    \                   ^^^^^^^^^^^^ the trait `From<Vec<&str>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdk2boi3z.rs:27:46\n   |\n27 |     new_sentence = String::from(new_sentence.iter().map(|s|\
    \ primes.contains(&s).unwrap()).collect::<Vec<_>>());\n   |                  \
    \                            ^^^^ method not found in `String`\n   |\nhelp: because\
    \ of the in-memory representation of `&str`, to obtain an `Iterator` over each\
    \ of its codepoint use method `chars`\n   |\n27 |     new_sentence = String::from(new_sentence.chars().map(|s|\
    \ primes.contains(&s).unwrap()).collect::<Vec<_>>());\n   |                  \
    \                            ~~~~~\n\nerror[E0599]: no method named `unwrap` found\
    \ for type `bool` in the current scope\n  --> /tmp/tmpdk2boi3z.rs:27:81\n   |\n\
    27 |     new_sentence = String::from(new_sentence.iter().map(|s| primes.contains(&s).unwrap()).collect::<Vec<_>>());\n\
    \   |                                                                        \
    \         ^^^^^^ method not found in `bool`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.split_whitespace();\n    let mut\
    \ result = String::from(\"\");\n    let mut prime_numbers = Vec::new();\n    let\
    \ mut counter = 1;\n    \n    for word in words {\n        if counter == 2 {\n\
    \            let mut prime_numbers_copy = prime_numbers.clone();\n           \
    \ for prime in prime_numbers_copy {\n                if prime == word {\n    \
    \                prime_numbers.remove(&prime);\n                    result.push_str(&word);\n\
    \                    break;\n                }\n            }\n            counter\
    \ = 0;\n        } else {\n            if counter < 2 {\n                if is_prime(word)\
    \ {\n                    prime_numbers.push(word);\n                    counter++;\n\
    \                } else {\n                    result.push_str(&word);\n     \
    \           }\n            } else {\n                result.push_str(&word);\n\
    \            }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp03e0h_al.rs:36:28\n\
    \   |\n36 |                     counter++;\n   |                            ^^\
    \ not a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n36 |   \
    \                  { let tmp = counter; counter += 1; tmp };\n   |           \
    \          +++++++++++        ~~~~~~~~~~~~~~~~~~~~~\n36 -                    \
    \ counter++;\n36 +                     counter += 1;\n   | \n\nerror[E0425]: cannot\
    \ find function `is_prime` in this scope\n  --> /tmp/tmp03e0h_al.rs:34:20\n  \
    \ |\n34 |                 if is_prime(word) {\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp03e0h_al.rs:26:42\n\
    \   |\n26 |                     prime_numbers.remove(&prime);\n   |          \
    \                                ^^^^^^ expected `usize`, found reference\n  \
    \ |\n   = note:   expected type `usize`\n           found reference `&_`\nhelp:\
    \ consider removing the borrow\n   |\n26 -                     prime_numbers.remove(&prime);\n\
    26 +                     prime_numbers.remove(prime);\n   | \n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = String::new();\n    let mut word_count\
    \ = 1;\n    for word in sentence.split_whitespace() {\n        words += &word;\n\
    \        if word.length() == word_count {\n            continue;\n        }\n\
    \        while word.length() > word_count {\n            words.remove_prefix(1);\n\
    \            word_count += 1;\n        }\n    }\n    words\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpvy6hb1kx.rs:20:17\n   |\n20 |         if word.length()\
    \ == word_count {\n   |                 ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `length` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpvy6hb1kx.rs:23:20\n   |\n\
    23 |         while word.length() > word_count {\n   |                    ^^^^^^\
    \ help: there is an associated function with a similar name: `len`\n\nerror[E0599]:\
    \ no method named `remove_prefix` found for struct `String` in the current scope\n\
    \  --> /tmp/tmpvy6hb1kx.rs:24:19\n   |\n24 |             words.remove_prefix(1);\n\
    \   |                   ^^^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prime_numbers:\
    \ Vec<i32> = vec![2, 3];\n    let mut prime_numbers_counter = 0;\n    for char\
    \ in sentence.chars() {\n        let mut current_prime_number: i32;\n        for\
    \ current_prime_number in prime_numbers {\n            if char.len_utf8() > 0\
    \ {\n                if char.chars().any(|c| c == ' ' && prime_numbers_counter\
    \ < current_prime_number) {\n                    prime_numbers_counter += 1;\n\
    \                    break;\n                }\n                if char.chars().any(|c|\
    \ c == ' ' && prime_numbers_counter == current_prime_number) {\n             \
    \       prime_numbers_counter += 1;\n                    break;\n            \
    \    }\n                if char.chars().any(|c| !c.is_ascii_alphanumeric() &&\
    \ prime_numbers_counter == current_prime_number) {\n                    prime_numbers_counter\
    \ += 1;\n                    break;\n                }\n                if char.chars().any(|c|\
    \ c.is_ascii_alphanumeric() && prime_numbers_counter == current_prime_number)\
    \ {\n                    prime_numbers_counter += 1;\n                    break;\n\
    \                }\n                if char.chars().any(|c| c.is_ascii_alphanumeric()\
    \ || c == ' ' && prime_numbers_counter == current_prime_number) {\n          \
    \          prime_numbers_counter += 1;\n                    break;\n         \
    \       }\n            }\n        }\n        if char.len_utf8() > 0 {\n      \
    \      result.push_str(&char);\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpbp2mou5o.rs:23:25\n   |\n23 |                 if char.chars().any(|c|\
    \ c == ' ' && prime_numbers_counter < current_prime_number) {\n   |          \
    \               ^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `chars` found for type `char` in the current scope\n  --> /tmp/tmpbp2mou5o.rs:27:25\n\
    \   |\n27 |                 if char.chars().any(|c| c == ' ' && prime_numbers_counter\
    \ == current_prime_number) {\n   |                         ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpbp2mou5o.rs:31:25\n   |\n31 |             \
    \    if char.chars().any(|c| !c.is_ascii_alphanumeric() && prime_numbers_counter\
    \ == current_prime_number) {\n   |                         ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpbp2mou5o.rs:35:25\n   |\n35 |             \
    \    if char.chars().any(|c| c.is_ascii_alphanumeric() && prime_numbers_counter\
    \ == current_prime_number) {\n   |                         ^^^^^ method not found\
    \ in `char`\n\nerror[E0599]: no method named `chars` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpbp2mou5o.rs:39:25\n   |\n39 |             \
    \    if char.chars().any(|c| c.is_ascii_alphanumeric() || c == ' ' && prime_numbers_counter\
    \ == current_prime_number) {\n   |                         ^^^^^ method not found\
    \ in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbp2mou5o.rs:46:29\n\
    \   |\n46 |             result.push_str(&char);\n   |                        \
    \     ^^^^^ expected `str`, found `char`\n   |\n   = note: expected reference\
    \ `&str`\n              found reference `&char`\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter(|w| !is_prime(w)).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjc_czzwr.rs:16:45\n\
    \   |\n16 |     sentence.split_whitespace().filter(|w| !is_prime(w)).collect()\n\
    \   |                                             ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence |> String::split |> Vec::map { |w| w.to_str().unwrap().to_string()\
    \ } |> Vec::sort\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n \
    \   assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `>`\n  --> /tmp/tmpj1fdcknj.rs:16:15\n\
    \   |\n16 |     sentence |> String::split |> Vec::map { |w| w.to_str().unwrap().to_string()\
    \ } |> Vec::sort\n   |               ^ expected expression\n\nerror: aborting\
    \ due to previous error\n\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prime_numbers\
    \ = Vec::new();\n    let mut temp_prime_numbers = Vec::new();\n    for &letter\
    \ in sentence.chars() {\n        if !prime_numbers.contains(&letter) {\n     \
    \       prime_numbers.push(letter);\n        }\n    }\n    let mut temp_prime_number_iter\
    \ = prime_numbers.iter().cloned();\n    while temp_prime_number_iter.next() {\n\
    \        let temp_prime_number = temp_prime_number_iter.peek().unwrap();\n   \
    \     if temp_prime_numbers.iter().all(|&x| x == temp_prime_number) {\n      \
    \      for &letter in sentence.chars() {\n                if letter == temp_prime_number\
    \ {\n                    result.push(*letter);\n                }\n          \
    \  }\n            break;\n        }\n    }\n    result\n}\n\nfn main() {\n   \
    \ let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd0g7u438.rs:19:9\n   |\n\
    19 |     for &letter in sentence.chars() {\n   |         ^^^^^^^    ----------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `letter`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpd0g7u438.rs:25:11\n\
    \   |\n25 |     while temp_prime_number_iter.next() {\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `bool`, found enum `Option`\n   |\n   = note: expected type `bool`\n\
    \              found enum `Option<_>`\n\nerror[E0599]: no method named `peek`\
    \ found for struct `Cloned` in the current scope\n  --> /tmp/tmpd0g7u438.rs:26:56\n\
    \   |\n26 |         let temp_prime_number = temp_prime_number_iter.peek().unwrap();\n\
    \   |                                                        ^^^^ method not found\
    \ in `Cloned<std::slice::Iter<'_, _>>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpd0g7u438.rs:28:17\n   |\n28 |             for &letter in sentence.chars()\
    \ {\n   |                 ^^^^^^^    ---------------- this expression has type\
    \ `Option<char>`\n   |                 |\n   |                 expected `char`,\
    \ found reference\n   |                 help: you can probably remove the explicit\
    \ borrow: `letter`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code goes here\n    let mut primes = Vec::new();\n\
    \    for &word in sentence.chars().filter_map(|c| match c {\n        c => match\
    \ c.to_ascii_lowercase().as_ref() {\n            \"a\" => \"ab\",\n          \
    \  \"b\" => \"ac\",\n            \"c\" => \"bd\",\n            \"d\" => \"ab\"\
    ,\n            \"e\" => \"ce\",\n            \"f\" => \"ef\",\n            \"\
    g\" => \"fg\",\n            \"h\" => \"gh\",\n            \"i\" => \"ij\",\n \
    \           \"j\" => \"ij\",\n            \"k\" => \"jk\",\n            \"l\"\
    \ => \"kl\",\n            \"m\" => \"mm\",\n            \"n\" => \"nn\",\n   \
    \         \"o\" => \"oo\",\n            \"p\" => \"pp\",\n            \"q\" =>\
    \ \"qq\",\n            \"r\" => \"rr\",\n            \"s\" => \"ss\",\n      \
    \      \"t\" => \"tt\",\n            \"u\" => \"uu\",\n            \"v\" => \"\
    vv\",\n            \"w\" => \"ww\",\n            \"x\" => \"xx\",\n          \
    \  \"y\" => \"yy\",\n            \"z\" => \"zz\",\n            _ => return c,\n\
    \        },\n        _ => c,\n    }).take(10000).collect::<Vec<_>>() {\n     \
    \   primes.push(&*word);\n    }\n    primes.iter().map(|w| w.to_string()).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_ref` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp6989kzxm.rs:19:43\n   |\n19 |         c => match c.to_ascii_lowercase().as_ref()\
    \ {\n   |                                           ^^^^^^ method not found in\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6989kzxm.rs:20:20\n\
    \   |\n20 |             \"a\" => \"ab\",\n   |                    ^^^^ expected\
    \ enum `Option`, found `&str`\n   |\n   = note:   expected enum `Option<_>`\n\
    \           found reference `&'static str`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n20 |             \"a\" => Some(\"ab\"),\n   |             \
    \       +++++    +\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6989kzxm.rs:46:25\n\
    \   |\n46 |             _ => return c,\n   |                         ^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n46 |             _ => return Some(c),\n   |                         +++++\
    \ +\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.chars().filter(Character::is_alphanumeric).count()\
    \ == 0 {\n        return String::from(\"\");\n    }\n    let mut count = 1;\n\
    \    let mut prime_words = String::from(\"\");\n    let mut pos = 0;\n    while\
    \ pos < sentence.len() {\n        if !is_prime(pos, sentence) {\n            count\
    \ = 1;\n            prime_words = String::from(\"\");\n        }\n        if count\
    \ == 1 && prime_words != String::from(\"\") {\n            prime_words = prime_words.to_string()\
    \ + &sentence.chars().nth(pos).unwrap().to_string();\n        }\n        pos +=\
    \ count;\n        count += 1;\n    }\n    prime_words\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Character`\n \
    \ --> /tmp/tmpjti_f35j.rs:16:32\n   |\n16 |     if sentence.chars().filter(Character::is_alphanumeric).count()\
    \ == 0 {\n   |                                ^^^^^^^^^ use of undeclared type\
    \ `Character`\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpjti_f35j.rs:23:13\n   |\n23 |         if !is_prime(pos, sentence)\
    \ {\n   |             ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.isEmpty() {\n        String::from(\"\"\
    )\n    } else {\n        let mut prime_numbers = Vec::new();\n        let mut\
    \ words = String::from(\"\");\n        let mut index = -1;\n        for ch in\
    \ sentence.split(' ').iter().rev() {\n            if prime_numbers.contains(&ch)\
    \ {\n                index = words.length();\n            }\n            words.append(&ch);\n\
    \            if let Some(&mut index) = prime_numbers.iter().find(|&x| x == &ch)\
    \ {\n                prime_numbers.push(index);\n            }\n        }\n  \
    \      for &index in prime_numbers.iter() {\n            words.append(&sentence[..index]);\n\
    \        }\n        words\n    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `isEmpty` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplkx04k_0.rs:16:17\n   |\n16 |     if sentence.isEmpty()\
    \ {\n   |                 ^^^^^^^ help: there is an associated function with a\
    \ similar name: `is_empty`\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::str::Split` in the current scope\n  --> /tmp/tmplkx04k_0.rs:22:39\n  \
    \ |\n22 |         for ch in sentence.split(' ').iter().rev() {\n   |         \
    \                              ^^^^ method not found in `std::str::Split<'_, char>`\n\
    \nerror[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmplkx04k_0.rs:24:31\n   |\n24 |                 index = words.length();\n\
    \   |                               ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmplkx04k_0.rs:26:19\n   |\n\
    26 |             words.append(&ch);\n   |                   ^^^^^^ method not\
    \ found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplkx04k_0.rs:27:25\n\
    \   |\n27 |             if let Some(&mut index) = prime_numbers.iter().find(|&x|\
    \ x == &ch) {\n   |                         ^^^^^^^^^^    ----------------------------------------\
    \ this expression has type `Option<&_>`\n   |                         |\n   |\
    \                         types differ in mutability\n   |                   \
    \      help: you can probably remove the explicit borrow: `index`\n   |\n   =\
    \ note:      expected reference `&_`\n           found mutable reference `&mut\
    \ _`\n\nerror[E0599]: no method named `append` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmplkx04k_0.rs:32:19\n   |\n32 |             words.append(&sentence[..index]);\n\
    \   |                   ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::from(\"\");\n    for\
    \ (i, c) in sentence.chars().enumerate() {\n        if i % 2 == 0 {\n        \
    \    new_sentence += c;\n        }\n    }\n    new_sentence\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp_9tfgdhm.rs:19:29\n   |\n\
    19 |             new_sentence += c;\n   |                             ^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![2, 3];\n    for prime in &primes\
    \ {\n        if sentence.chars().filter(|&x| x <= prime).count() > 1 {\n     \
    \       return String::from(\"\");\n        }\n    }\n    let mut new_sentence\
    \ = sentence;\n    let mut first_word = true;\n    while new_sentence.is_ok()\
    \ && !new_sentence.is_empty() {\n        let mut last_word = new_sentence[..].chars().filter(|&x|\
    \ x > prime).count();\n        while last_word == 1 && new_sentence.is_ok() &&\
    \ !new_sentence.is_empty() {\n            last_word = 1;\n            new_sentence\
    \ = String::from(\"\");\n        }\n        new_sentence = new_sentence.drain(first_word,\
    \ last_word);\n        first_word = false;\n    }\n    new_sentence\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prime` in this scope\n  --> /tmp/tmpd83iu7kp.rs:25:70\n\
    \   |\n25 |         let mut last_word = new_sentence[..].chars().filter(|&x| x\
    \ > prime).count();\n   |                                                    \
    \                  ^^^^^ help: a local variable with a similar name exists: `primes`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpd83iu7kp.rs:18:46\n   |\n18 |\
    \         if sentence.chars().filter(|&x| x <= prime).count() > 1 {\n   |    \
    \                                          ^^^^^ expected `char`, found `&{integer}`\n\
    \nerror[E0599]: no method named `is_ok` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpd83iu7kp.rs:24:24\n   |\n24 |     while new_sentence.is_ok()\
    \ && !new_sentence.is_empty() {\n   |                        ^^^^^ method not\
    \ found in `String`\n\nerror[E0599]: no method named `is_ok` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpd83iu7kp.rs:26:46\n   |\n26 | \
    \        while last_word == 1 && new_sentence.is_ok() && !new_sentence.is_empty()\
    \ {\n   |                                              ^^^^^ method not found\
    \ in `String`\n\nerror[E0061]: this function takes 1 argument but 2 arguments\
    \ were supplied\n    --> /tmp/tmpd83iu7kp.rs:30:37\n     |\n30   |         new_sentence\
    \ = new_sentence.drain(first_word, last_word);\n     |                       \
    \              ^^^^^ ----------  --------- supplied 2 arguments\n     |      \
    \                               |\n     |                                    \
    \ expected 1 argument\n     |\nnote: associated function defined here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpd83iu7kp.rs:30:24\n   |\n22 |     let mut new_sentence\
    \ = sentence;\n   |                            -------- expected due to this value\n\
    ...\n30 |         new_sentence = new_sentence.drain(first_word, last_word);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ struct `String`, found struct `std::string::Drain`\n\nerror: aborting due to\
    \ 6 previous errors\n\nSome errors have detailed explanations: E0061, E0308, E0425,\
    \ E0599.\nFor more informa"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // M1. \u5C07\u8A5E\u6578\u9663\u5217\u5217\u5347\u6210\
    \u9806\u5E8F\u6392\u5E8F\n    let mut words = sentence.split_whitespace().collect::<Vec<_>>();\n\
    \    words.sort(); // \u9019\u662F\u81EA\u5DF1\u5EFA\u7ACB\u7684\u6392\u5E8F\uFF0C\
    \u76F4\u63A5\u7528words\u5C31\u597D\n    words.sort_unstable(); // \u5982\u679C\
    \u4E0D\u60F3\u7528\u81EA\u5DF1\u7684\u6392\u5E8F\uFF0C\u53EF\u4EE5\u6539\u6210\
    words.sort();\n    // M2. \u628A\u6BCF\u500B\u8A5E\u7684\u5B57\u4E32\u7D50\u6210\
    \u5B57\u4E32\u7684\u9577\u5EA6\u70BA\u6578\u5B57\uFF0C\u4E14\u80FD\u7372\u5F97\
    \u6578\u5B57\u8207\u5B57\u4E32\u7684\u9577\u5EA6\u4E0D\u540C\u7684\u7B54\u6848\
    \n    // M3. \u7528map\u7372\u5F97\u8A5E\u51FA\u7684\u6578\u5B57\uFF0C\u518D\u7528\
    sort\n    words.iter().map(|w| w.chars().filter(|c| !c.is_whitespace()).count()).collect()\n\
    \        .iter()\n        .map(|w| {\n            words[w as usize].to_string()\n\
    \        })\n        .collect::<Vec<_>>()\n        .sort()\n        .iter()\n\
    \        .map(|w| w.to_string())\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmprwdz1q2f.rs:22:76\n\
    \   |\n22 |     words.iter().map(|w| w.chars().filter(|c| !c.is_whitespace()).count()).collect()\n\
    \   |                                                                        \
    \    ^^^^^^^ cannot infer type for type parameter `B` declared on the associated\
    \ function `collect`\n   |\n   = note: type must be known at this point\nhelp:\
    \ consider specifying the type argument in the method call\n   |\n22 |     words.iter().map(|w|\
    \ w.chars().filter(|c| !c.is_whitespace()).count()).collect::<B>()\n   |     \
    \                                                                            \
    \  +++++\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.split_whitespace())\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6fal14n.rs:16:23\n   |\n\
    16 |     words_in_sentence(sentence.split_whitespace())\n   |                \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct `SplitWhitespace`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    verify_max_size(sentence.len());\n\n    let mut primes\
    \ = Vec::<i64>::new();\n    for i in 1..sentence.len() {\n        primes.push(check_prime(i));\n\
    \    }\n\n    let mut str = String::with_capacity(sentence.len());\n    for i\
    \ in 0..sentence.len() {\n        str.push_str(sentence.chars().nth(i + 1).unwrap());\n\
    \        if primes.contains(&str[i..]) {\n            return str;\n        }\n\
    \    }\n\n    str\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `verify_max_size` in this scope\n  -->\
    \ /tmp/tmppomvr4vk.rs:16:5\n   |\n16 |     verify_max_size(sentence.len());\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `check_prime` in this scope\n  --> /tmp/tmppomvr4vk.rs:20:21\n   |\n\
    20 |         primes.push(check_prime(i));\n   |                     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppomvr4vk.rs:25:22\n\
    \   |\n25 |         str.push_str(sentence.chars().nth(i + 1).unwrap());\n   |\
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmppomvr4vk.rs:26:28\n\
    \   |\n26 |         if primes.contains(&str[i..]) {\n   |                    \
    \        ^^^^^^^^^ expected `i64`, found `str`\n   |\n   = note: expected reference\
    \ `&i64`\n              found reference `&str`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut words_in_sentence\
    \ = vec![];\n    for letter in sentence.chars().cloned().collect::<Vec<char>>()\
    \ {\n        if letter.is_alphanumeric() {\n            words_in_sentence.push(letter);\n\
    \        }\n    }\n    for i in 2..words_in_sentence.len() {\n        if words_in_sentence.is_prime()\
    \ {\n            result.append(&words_in_sentence[i]);\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp8nlwbjps.rs:18:36\n     |\n18   |     for letter in sentence.chars().cloned().collect::<Vec<char>>()\
    \ {\n     |                                    ^^^^^^ expected reference, found\
    \ `char`\n     |\n     = note: expected reference `&_`\n                     found\
    \ type `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: the method\
    \ `collect` exists for struct `Cloned<Chars<'_>>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp8nlwbjps.rs:18:45\n   |\n18 |       for letter in sentence.chars().cloned().collect::<Vec<char>>()\
    \ {\n   |                                               ^^^^^^^ method cannot\
    \ be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   =\
    \ note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror[E0599]: no method named `is_prime`\
    \ found for struct `Vec<_>` in the current scope\n  --> /tmp/tmp8nlwbjps.rs:24:30\n\
    \   |\n24 |         if words_in_sentence.is_prime() {\n   |                  \
    \            ^^^^^^^^ method not found in `Vec<_>`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmp8nlwbjps.rs:25:20\n\
    \   |\n25 |             result.append(&words_in_sentence[i]);\n   |          \
    \          ^^^^^^ method not found in `String`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0271, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![];\n    let mut prime_counter\
    \ = vec![];\n    let mut num_words = sentence.split_whitespace().count();\n  \
    \  let mut prime = String::new();\n\n    while num_words > 0 {\n        if num_words\
    \ == 1 {\n            let mut cur_prime = primes[prime_counter[0] % primes.len()];\n\
    \            prime_counter[0] += 1;\n            num_words -= 1;\n\n         \
    \   prime = cur_prime.to_string();\n        } else {\n            let mut cur_prime\
    \ = primes[prime_counter[0] % primes.len()];\n            prime_counter[0] +=\
    \ 1;\n            prime = cur_prime.to_string();\n            primes.push(prime);\n\
    \n            while num_words > 1 {\n                if num_words == 2 {\n   \
    \                 let cur_prime = primes[prime_counter[1] % primes.len()];\n \
    \                   prime_counter[1] += 1;\n                    num_words -= 2;\n\
    \n                    prime = cur_prime.to_string();\n                } else {\n\
    \                    let mut cur_prime = primes[prime_counter[1] % primes.len()];\n\
    \                    prime_counter[1] += 1;\n                    prime = cur_prime.to_string();\n\
    \                    primes.push(prime);\n                    num_words += 1;\n\
    \                }\n            }\n        }\n    }\n    prime\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpsxm_e54b.rs:27:21\n\
    \   |\n23 |             let mut cur_prime = primes[prime_counter[0] % primes.len()];\n\
    \   |                 ------------- consider giving `cur_prime` a type\n...\n\
    27 |             prime = cur_prime.to_string();\n   |                     ^^^^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut primes\
    \ = String::new();\n    for i in 0..sentence.len() {\n        if primes.is_empty()\
    \ {\n            primes = &sentence[i..i];\n            result += &primes;\n \
    \       }\n        if primes.contains(&sentence[i..i]) {\n            continue;\n\
    \        }\n        primes = primes.clone() + &sentence[i..i];\n        result\
    \ += &primes;\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpttihtqfh.rs:20:22\n   |\n\
    17 |     let mut primes = String::new();\n   |                      -------------\
    \ expected due to this value\n...\n20 |             primes = &sentence[i..i];\n\
    \   |                      ^^^^^^^^^^^^^^^ expected struct `String`, found `&str`\n\
    \   |\nhelp: try using a conversion method\n   |\n20 |             primes = (&sentence[i..i]).to_string();\n\
    \   |                      +               +++++++++++++\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_word = \"\";\n    let mut prime_word_count\
    \ = 1;\n    let mut result = String::from(\"\");\n    for &letter in sentence.chars()\
    \ {\n        let len = String::from(\"\");\n        let mut i = String::from(\"\
    \");\n        if letter.is_ascii() {\n            i = letter;\n        } else\
    \ {\n            i = String::from(letter.to_string());\n        }\n        for\
    \ i in i.chars() {\n            let mut count = 0;\n            len = i.to_string();\n\
    \            for &letter in i.chars() {\n                if len.contains(&letter)\
    \ {\n                    count += 1;\n                }\n            }\n     \
    \       if count > 1 && count % 2 == 0 {\n                prime_word = String::from(prime_word.to_owned()\
    \ + i.to_owned());\n                prime_word_count += 1;\n                if\
    \ prime_word_count == 3 {\n                    prime_word_count += 2;\n      \
    \          }\n            }\n        }\n    }\n    for &letter in prime_word.chars()\
    \ {\n        result = String::from(result.to_owned() + letter.to_owned());\n \
    \   }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzlk9o79_.rs:19:9\n   |\n\
    19 |     for &letter in sentence.chars() {\n   |         ^^^^^^^    ----------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `letter`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpzlk9o79_.rs:30:30\n   |\n30 |          \
    \   for &letter in i.chars() {\n   |                              ^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpzlk9o79_.rs:36:67\n\
    \   |\n36 |                 prime_word = String::from(prime_word.to_owned() +\
    \ i.to_owned());\n   |                                                       \
    \            ^^^^^^^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpzlk9o79_.rs:36:30\n   |\n16 |     let mut prime_word =\
    \ \"\";\n   |                          -- expected due to this value\n...\n36\
    \ |                 prime_word = String::from(prime_word.to_owned() + i.to_owned());\n\
    \   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                              |\n   |                              expected\
    \ `&str`, found struct `String`\n   |                              help: consider\
    \ borrowing here: `&String::from(prime_word.to_owned() + i.to_owned())`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzlk9o79_.rs:44:9\n   |\n44 |     for &letter\
    \ in prime_word.chars() {\n   |         ^^^^^^^    ------------------ this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `letter`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split(' ').map(|x| x.to_string()).filter(|x|\
    \ is_prime(x)).collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpk_xr67vz.rs:16:59\n\
    \   |\n16 |     sentence.split(' ').map(|x| x.to_string()).filter(|x| is_prime(x)).collect()\n\
    \   |                                                           ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.is_empty() {\n        String::from(\"\"\
    )\n    } else {\n        let mut prime_numbers = Vec::new();\n        for c in\
    \ sentence.chars() {\n            if !prime_numbers_is_prime_number(c, &mut prime_numbers)\
    \ {\n                return String::from(\"\");\n            }\n        }\n  \
    \      String::from_iter(prime_numbers.into_iter().filter(|x| x < sentence.len()).map(|x|\
    \ sentence.chars().nth(x).unwrap()).collect())\n    }\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_numbers_is_prime_number` in this\
    \ scope\n  --> /tmp/tmp1o3bp641.rs:21:17\n   |\n21 |             if !prime_numbers_is_prime_number(c,\
    \ &mut prime_numbers) {\n   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0599]: no function or associated item named `from_iter`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp1o3bp641.rs:25:17\n\
    \   |\n25 |         String::from_iter(prime_numbers.into_iter().filter(|x| x <\
    \ sentence.len()).map(|x| sentence.chars().nth(x).unwrap()).collect())\n   | \
    \                ^^^^^^^^^ function or associated item not found in `String`\n\
    \   |\n   = help: items from traits can only be used if the trait is in scope\n\
    help: the following trait is implemented but not in scope; perhaps add a `use`\
    \ for it:\n   |\n1  | use std::iter::FromIterator;\n   |\nhelp: there is an associated\
    \ function with a similar name\n   |\n25 |         String::from_utf8(prime_numbers.into_iter().filter(|x|\
    \ x < sentence.len()).map(|x| sentence.chars().nth(x).unwrap()).collect())\n \
    \  |                 ~~~~~~~~~\n\nerror[E0277]: can't compare `&_` with `usize`\n\
    \  --> /tmp/tmp1o3bp641.rs:25:66\n   |\n25 |         String::from_iter(prime_numbers.into_iter().filter(|x|\
    \ x < sentence.len()).map(|x| sentence.chars().nth(x).unwrap()).collect())\n \
    \  |                                                                  ^ no implementation\
    \ for `&_ < usize` and `&_ > usize`\n   |\n   = help: the trait `PartialOrd<usize>`\
    \ is not implemented for `&_`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split(' ').collect::<Vec<_>>();\n\
    \    let mut primes = primes(&mut words).iter().cloned();\n    let mut new_words\
    \ = String::new();\n\n    for prime in primes {\n        if words.len() >= prime\
    \ {\n            let mut new_word_start = new_words.as_str().len() as i32;\n \
    \           new_words.clear();\n            for i in 1..=prime {\n           \
    \     let word = &words[(i - 1) as usize];\n                new_words.push_str(word);\n\
    \            }\n            new_words.push(&new_words[new_word_start - 1]);\n\
    \        }\n    }\n    return new_words.clone();\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmpuvipo9bv.rs:17:22\n\
    \   |\n17 |     let mut primes = primes(&mut words).iter().cloned();\n   |   \
    \                   ^^^^^^ not found in this scope\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `i32`\n  --> /tmp/tmpuvipo9bv.rs:28:29\n   |\n28 |    \
    \         new_words.push(&new_words[new_word_start - 1]);\n   |              \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed by `i32`\n\
    \   |\n   = help: the trait `Index<i32>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuvipo9bv.rs:28:28\n\
    \   |\n28 |             new_words.push(&new_words[new_word_start - 1]);\n   |\
    \                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found\
    \ reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\nhelp: consider removing the borrow\n   |\n28 -             new_words.push(&new_words[new_word_start\
    \ - 1]);\n28 +             new_words.push(new_words[new_word_start - 1]);\n  \
    \ | \n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace();\n    let\
    \ mut prime_words: Vec<String> = Vec::new();\n    let mut prime_words_len: usize\
    \ = 0;\n\n    for word in words {\n        if !is_prime_word(word) {\n       \
    \     prime_words.push(word);\n            prime_words_len += 1;\n        }\n\
    \    }\n\n    String::from(prime_words[0..prime_words_len].join(\" \"))\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_word` in this scope\n  -->\
    \ /tmp/tmpvjhjcff1.rs:21:13\n   |\n21 |         if !is_prime_word(word) {\n  \
    \ |             ^^^^^^^^^^^^^ help: a local variable with a similar name exists:\
    \ `prime_words`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvjhjcff1.rs:22:30\n\
    \   |\n22 |             prime_words.push(word);\n   |                        \
    \      ^^^^- help: try using a conversion method: `.to_string()`\n   |       \
    \                       |\n   |                              expected struct `String`,\
    \ found `&str`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    let mut words = String::new();\n\
    \    let mut s = String::from(\"0\");\n    let mut p = 1;\n    let mut is_prime\
    \ = true;\n    for _char in sentence.chars() {\n        if s.is_empty() {\n  \
    \          s = String::from(_char.to_string());\n        }\n        if p == s.len()\
    \ {\n            p += 1;\n        } else {\n            is_prime = true;\n   \
    \         for _ in 0..s.len() {\n                if s[_] == 0 && p != 1 {\n  \
    \                  is_prime = false;\n                }\n            }\n     \
    \       if is_prime {\n                words.push(s);\n            }\n       \
    \     p = 1;\n            s = String::from(_char.to_string());\n        }\n  \
    \  }\n    words.push(s);\n    words.trim_end_matches(\"0\");\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: in expressions, `_` can only be used on the left-hand side of an\
    \ assignment\n  --> /tmp/tmp0rx4lgo9.rs:30:22\n   |\n30 |                 if s[_]\
    \ == 0 && p != 1 {\n   |                      ^ `_` not allowed here\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0rx4lgo9.rs:35:28\n   |\n35 |              \
    \   words.push(s);\n   |                            ^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rx4lgo9.rs:41:16\n\
    \   |\n41 |     words.push(s);\n   |                ^ expected `char`, found struct\
    \ `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0rx4lgo9.rs:15:43\n\
    \   |\n15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = String::new();\n    for &letter in\
    \ sentence.chars() {\n        primes += &letter + (sentence.chars().filter(|&c|\
    \ *c > 'A' && *c < 'Z').count() * \" \");\n    }\n    primes.split_whitespace().filter(|&x|\
    \ x.is_prime()).collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyojqy6hf.rs:17:9\n   |\n\
    17 |     for &letter in sentence.chars() {\n   |         ^^^^^^^    ----------------\
    \ this expression has type `Option<char>`\n   |         |\n   |         expected\
    \ `char`, found reference\n   |         help: you can probably remove the explicit\
    \ borrow: `letter`\n   |\n   = note:   expected type `char`\n           found\
    \ reference `&_`\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpyojqy6hf.rs:18:59\n\
    \   |\n18 |         primes += &letter + (sentence.chars().filter(|&c| *c > 'A'\
    \ && *c < 'Z').count() * \" \");\n   |                                       \
    \                    ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpyojqy6hf.rs:18:71\n   |\n18 |         primes += &letter + (sentence.chars().filter(|&c|\
    \ *c > 'A' && *c < 'Z').count() * \" \");\n   |                              \
    \                                         ^^\n\nerror[E0277]: cannot multiply\
    \ `usize` by `&str`\n  --> /tmp/tmpyojqy6hf.rs:18:89\n   |\n18 |         primes\
    \ += &letter + (sentence.chars().filter(|&c| *c > 'A' && *c < 'Z').count() * \"\
    \ \");\n   |                                                                 \
    \                        ^ no implementation for `usize * &str`\n   |\n   = help:\
    \ the trait `Mul<&str>` is not implemented for `usize`\n   = help: the following\
    \ other types implement trait `Mul<Rhs>`:\n             <&'a f32 as Mul<f32>>\n\
    \             <&'a f64 as Mul<f64>>\n             <&'a i128 as Mul<i128>>\n  \
    \           <&'a i16 as Mul<i16>>\n             <&'a i32 as Mul<i32>>\n      \
    \       <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n            \
    \ <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0599]: no method\
    \ named `is_prime` found for reference `&str` in the current scope\n  --> /tmp/tmpyojqy6hf.rs:20:45\n\
    \   |\n20 |     primes.split_whitespace().filter(|&x| x.is_prime()).collect()\n\
    \   |                                             ^^^^^^^^ method not found in\
    \ `&str`\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E027"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug!(\"words_in_sentence: {:?}\", sentence);\n  \
    \  let mut words = sentence.split_whitespace();\n    let mut new_sentence = \"\
    \";\n\n    for word in words {\n        let mut len: i32 = 1;\n        for _ in\
    \ 0..word.len() {\n            len *= 2;\n        }\n        if len % 2 != 0 {\n\
    \            new_sentence += &*word.as_bytes();\n        }\n    }\n\n    String::from(new_sentence)\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmp1qgchozd.rs:16:5\n\
    \   |\n16 |     debug!(\"words_in_sentence: {:?}\", sentence);\n   |     ^^^^^\n\
    \nerror[E0368]: binary assignment operation `+=` cannot be applied to type `&str`\n\
    \  --> /tmp/tmp1qgchozd.rs:26:13\n   |\n26 |             new_sentence += &*word.as_bytes();\n\
    \   |             ------------^^^^^^^^^^^^^^^^^^^^^\n   |             |\n   |\
    \             cannot use `+=` on type `&str`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    solution::words_in_sentence_solution(sentence.as_bytes())\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `solution`\n\
    \  --> /tmp/tmp3d4tcvdf.rs:16:5\n   |\n16 |     solution::words_in_sentence_solution(sentence.as_bytes())\n\
    \   |     ^^^^^^^^ use of undeclared crate or module `solution`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 101
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    for (i, word)\
    \ in sentence.split_whitespace().into_iter().enumerate() {\n        if i % 2 ==\
    \ 0 {\n            result.push_str(&word);\n        } else {\n            result.push_str(&\"\
    \ \");\n            result.push_str(&word);\n        }\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"This isa test\"`,\n right: `\"is\"`', /tmp/tmpstlmcwl1.rs:30:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut buffer = String::new();\n    buffer.push_str(\"\
    \\0\".to_string());\n    buffer.push_str(\"\\0\".to_string());\n    for letter\
    \ in sentence.chars() {\n        buffer.push_str(&(letter).to_string());\n   \
    \ }\n    let mut primes = primes(buffer.chars().map(|x| x.unwrap()).collect::<Vec<_>>());\n\
    \    primes.sort();\n    for i in 0..primes.len() {\n        let mut buffer =\
    \ String::new();\n        for j in i..primes.len() {\n            let current\
    \ = buffer.clone();\n            buffer.push_str(&(primes[j].to_string()));\n\
    \            if buffer.len() > i {\n                buffer.push_str(&(buffer.chars().filter(|c|\
    \ c != ' ').count().unwrap()));\n                buffer.push_str(&(buffer.chars().filter(|c|\
    \ c != ' ').collect::<String>()));\n                buffer.push_str(&(buffer.chars().filter(|c|\
    \ c != ' ').count().unwrap()));\n                if buffer.len() > primes.len()\
    \ {\n                    buffer.push_str(&(buffer.chars().filter(|c| c != ' ').count().unwrap()));\n\
    \                    buffer.push_str(&(buffer.chars().filter(|c| c != ' ').collect::<String>()));\n\
    \                    buffer.push_str(&(buffer.chars().filter(|c| c != ' ').count().unwrap()));\n\
    \                }\n            }\n        }\n        buffer.push_str(\"\\0\"\
    .to_string());\n        buffer.push_str(\"\\0\".to_string());\n    }\n    buffer\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmpgvj7lcsr.rs:22:22\n\
    \   |\n22 |     let mut primes = primes(buffer.chars().map(|x| x.unwrap()).collect::<Vec<_>>());\n\
    \   |                      ^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpgvj7lcsr.rs:17:21\n   |\n17 |     buffer.push_str(\"\\\
    0\".to_string());\n   |                     ^^^^^^^^^^^^^^^^\n   |           \
    \          |\n   |                     expected `&str`, found struct `String`\n\
    \   |                     help: consider borrowing here: `&\"\\0\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpgvj7lcsr.rs:18:21\n   |\n18 |\
    \     buffer.push_str(\"\\0\".to_string());\n   |                     ^^^^^^^^^^^^^^^^\n\
    \   |                     |\n   |                     expected `&str`, found struct\
    \ `String`\n   |                     help: consider borrowing here: `&\"\\0\"\
    .to_string()`\n\nerror[E0599]: no method named `unwrap` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpgvj7lcsr.rs:22:54\n   |\n22 |     let mut\
    \ primes = primes(buffer.chars().map(|x| x.unwrap()).collect::<Vec<_>>());\n \
    \  |                                                      ^^^^^^ method not found\
    \ in `char`\n\nerror[E0277]: can't compare `&char` with `char`\n  --> /tmp/tmpgvj7lcsr.rs:30:63\n\
    \   |\n30 |                 buffer.push_str(&(buffer.chars().filter(|c| c != '\
    \ ').count().unwrap()));\n   |                                               \
    \                ^^ no implementation for `&char == char`\n   |\n   = help: the\
    \ trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0599]: no method named `unwrap`\
    \ found for type `usize` in the current scope\n  --> /tmp/tmpgvj7lcsr.rs:30:79\n\
    \   |\n30 |                 buffer.push_str(&(buffer.chars().filter(|c| c != '\
    \ ').count().unwrap()));\n   |                                               \
    \                                ^^^^^^ method not found in `usize`\n\nerror[E0277]:\
    \ can't compare `&char` with `char`\n  --> /tmp/tmpgvj7lcsr.rs:31:63\n   |\n31\
    \ |             "
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(1 <= sentence.len() <= 100);\n\n    let mut\
    \ new_sentence = \"\".to_string();\n    for c in sentence.chars() {\n        if\
    \ new_sentence.is_empty() || (new_sentence[new_sentence.len()-1] != c.to_string())\
    \ {\n            new_sentence += c.to_string();\n        }\n    }\n\n    new_sentence\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: comparison operators cannot be chained\n  --> /tmp/tmpwuh4g15j.rs:16:15\n\
    \   |\n16 |     assert!(1 <= sentence.len() <= 100);\n   |               ^^  \
    \              ^^\n   |\nhelp: split the comparison into two\n   |\n16 |     assert!(1\
    \ <= sentence.len() && sentence.len() <= 100);\n   |                         \
    \        +++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwuh4g15j.rs:16:36\n\
    \   |\n16 |     assert!(1 <= sentence.len() <= 100);\n   |                   \
    \                 ^^^ expected `bool`, found integer\n\nerror[E0277]: the type\
    \ `String` cannot be indexed by `usize`\n  --> /tmp/tmpwuh4g15j.rs:20:40\n   |\n\
    20 |         if new_sentence.is_empty() || (new_sentence[new_sentence.len()-1]\
    \ != c.to_string()) {\n   |                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwuh4g15j.rs:21:29\n\
    \   |\n21 |             new_sentence += c.to_string();\n   |                 \
    \            ^^^^^^^^^^^^^\n   |                             |\n   |         \
    \                    expected `&str`, found struct `String`\n   |            \
    \                 help: consider borrowing here: `&c.to_string()`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0308.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.length() == 0 {\n        String::new()\n\
    \    } else {\n        let mut prime_words: Vec<&str> = vec![];\n        let mut\
    \ prime_length: usize = 0;\n        let mut words: Vec<&str> = vec![];\n     \
    \   for w in sentence.split_whitespace() {\n            if prime_length > 1 {\n\
    \                prime_words.push(*w);\n                prime_length += w.len()\
    \ + 1;\n            }\n            if prime_length >= w.len() {\n            \
    \    words.push(*w);\n            }\n        }\n        prime_words.sort_by_key(|&x|\
    \ x.len());\n        prime_length -= 1;\n        words.sort_by_key(|&x| x.len());\n\
    \        words.insert(0, prime_words.clone());\n        String::from(words.iter().collect::<Vec<&str>>().join(\"\
    \ \"))\n    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp8gtx78no.rs:16:17\n   |\n16 |     if sentence.length()\
    \ == 0 {\n   |                 ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8gtx78no.rs:24:34\n\
    \   |\n24 |                 prime_words.push(*w);\n   |                      \
    \            ^^\n   |                                  |\n   |               \
    \                   expected `&str`, found `str`\n   |                       \
    \           help: consider borrowing here: `&*w`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp8gtx78no.rs:28:28\n   |\n28 |                 words.push(*w);\n\
    \   |                            ^^\n   |                            |\n   | \
    \                           expected `&str`, found `str`\n   |               \
    \             help: consider borrowing here: `&*w`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp8gtx78no.rs:34:25\n   |\n34 |         words.insert(0, prime_words.clone());\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^ expected `&str`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&str`\n                 found struct\
    \ `Vec<&str>`\n\nerror[E0277]: a value of type `Vec<&str>` cannot be built from\
    \ an iterator over elements of type `&&str`\n    --> /tmp/tmp8gtx78no.rs:35:35\n\
    \     |\n35   |         String::from(words.iter().collect::<Vec<&str>>().join(\"\
    \ \"))\n     |                                   ^^^^^^^ value of type `Vec<&str>`\
    \ cannot be built from `std::iter::Iterator<Item=&&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&&str>` is not implemented for `Vec<&str>`\n     = help:\
    \ the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a\
    \ bound in `collect`\n\nerror: aborting due to 5 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prime_factors:\
    \ Vec<i32> = vec![];\n    let mut prime_factors_counter: i64 = 0;\n    let mut\
    \ prime_factor_counter: usize = 0;\n    let mut i = 1;\n\n    for word in sentence.split_whitespace()\
    \ {\n        let split_word = word.chars().nth(2).unwrap();\n        let split_word:\
    \ usize = split_word.to_string().len();\n        let mut prime_factors_counter\
    \ = split_word as i64;\n\n        for prime in prime_factors_counter {\n     \
    \       if prime_factors_counter == prime {\n                prime_factors.push(prime);\n\
    \                break;\n            } else {\n                prime_factors_counter\
    \ += i;\n            }\n        }\n\n        if prime_factors_counter != split_word\
    \ {\n            prime_factors.push(split_word);\n        }\n\n        i += prime_factors[prime_factor_counter];\n\
    \    }\n\n    for i in prime_factors.iter().rev() {\n        for word in sentence.split_whitespace()\
    \ {\n            if i == word.chars().nth(2).unwrap().to_string().len() {\n  \
    \              result += word + \" \"\n            }\n        }\n    }\n\n   \
    \ result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `i64` is not an iterator\n  --> /tmp/tmpyvmzsf1j.rs:27:22\n\
    \   |\n27 |         for prime in prime_factors_counter {\n   |               \
    \       ^^^^^^^^^^^^^^^^^^^^^ `i64` is not an iterator\n   |\n   = help: the trait\
    \ `Iterator` is not implemented for `i64`\n   = note: if you want to iterate between\
    \ `start` until a value `end`, use the exclusive range syntax `start..end` or\
    \ the inclusive range syntax `start..=end`\n   = note: required because of the\
    \ requirements on the impl of `IntoIterator` for `i64`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpyvmzsf1j.rs:29:36\n   |\n29 |                 prime_factors.push(prime);\n\
    \   |                                    ^^^^^ expected `i32`, found `i64`\n \
    \  |\nhelp: you can convert an `i64` to an `i32` and panic if the converted value\
    \ doesn't fit\n   |\n29 |                 prime_factors.push(prime.try_into().unwrap());\n\
    \   |                                         ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvmzsf1j.rs:36:37\n   |\n36 |         if prime_factors_counter\
    \ != split_word {\n   |                                     ^^^^^^^^^^ expected\
    \ `i64`, found `usize`\n   |\nhelp: you can convert a `usize` to an `i64` and\
    \ panic if the converted value doesn't fit\n   |\n36 |         if prime_factors_counter\
    \ != split_word.try_into().unwrap() {\n   |                                  \
    \             ++++++++++++++++++++\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpyvmzsf1j.rs:37:32\n\
    \   |\n37 |             prime_factors.push(split_word);\n   |                \
    \                ^^^^^^^^^^ expected `i32`, found `usize`\n   |\nhelp: you can\
    \ convert a `usize` to an `i32` and panic if the converted value doesn't fit\n\
    \   |\n37 |             prime_factors.push(split_word.try_into().unwrap());\n\
    \   |                                          ++++++++++++++++++++\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpyvmzsf1j.rs:40:14\n   |\n40 |         i += prime_factors[prime_factor_counter];\n\
    \   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i64`, found `i32`\n\
    \nerror[E0277]: cannot add-a"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    if sentence == \"\" {\n\
    \        return String::from(\"\");\n    }\n    let mut primes = vec![2, 3];\n\
    \    let mut strings = vec![];\n    let mut len = sentence.len();\n    let mut\
    \ i = 1;\n    while i <= len {\n        for i in 2..=len {\n            if i %\
    \ i == 0 {\n                primes.push(i as u64);\n                strings.push(String::from(sentence.split_whitespace()[i\
    \ - 1].to_lowercase()));\n                strings.pop();\n                break;\n\
    \            }\n        }\n        i += 1;\n    }\n    if primes.len() == 0 {\n\
    \        return String::from(\"\");\n    }\n    let mut s = String::from(\"\"\
    );\n    for i in primes.iter() {\n        s.push(i.to_string());\n    }\n    s.push('\
    \ ');\n    for x in strings.iter() {\n        s.push(x);\n    }\n    s\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0608]: cannot index into a value of type `SplitWhitespace<'_>`\n\
    \  --> /tmp/tmpdtt5y1lj.rs:28:43\n   |\n28 |                 strings.push(String::from(sentence.split_whitespace()[i\
    \ - 1].to_lowercase()));\n   |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdtt5y1lj.rs:40:16\n   |\n40 |\
    \         s.push(i.to_string());\n   |                ^^^^^^^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdtt5y1lj.rs:44:16\n\
    \   |\n44 |         s.push(x);\n   |                ^ expected `char`, found `&String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0608.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split(' ').collect::<Vec<_>>();\n\
    \    let len = words.len();\n    for i in 2..len {\n        if words[0] % i ==\
    \ 0 && words[1] % i == 0 {\n            words.pop();\n        }\n    }\n    words.join('\
    \ ')\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&str` by `usize`\n  --> /tmp/tmpsnykjgph.rs:19:21\n\
    \   |\n19 |         if words[0] % i == 0 && words[1] % i == 0 {\n   |        \
    \    -------- ^ - usize\n   |            |\n   |            &str\n\nerror[E0369]:\
    \ cannot mod `&str` by `usize`\n  --> /tmp/tmpsnykjgph.rs:19:42\n   |\n19 |  \
    \       if words[0] % i == 0 && words[1] % i == 0 {\n   |                    \
    \             -------- ^ - usize\n   |                                 |\n   |\
    \                                 &str\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpsnykjgph.rs:23:16\n   |\n23 |     words.join(' ')\n   |            \
    \    ^^^ expected `&str`, found `char`\n   |\nhelp: if you meant to write a `str`\
    \ literal, use double quotes\n   |\n23 |     words.join(\" \")\n   |         \
    \       ~~~\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence_aux(sentence.chars().collect::<Vec<_>>(),\
    \ 1)\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence_aux` in this scope\n\
    \  --> /tmp/tmpwlyyegrf.rs:16:5\n   |\n16 |     words_in_sentence_aux(sentence.chars().collect::<Vec<_>>(),\
    \ 1)\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Initialize an empty string\n    let mut ans = String::new();\n\
    \n    // Iterate through the letters in the sentence\n    for c in sentence.chars()\
    \ {\n        // Iterate through the words in the dictionary\n        for word\
    \ in word_list.iter().take(sentence.len()) {\n            // Find the word in\
    \ the sentence\n            if c == word {\n                // If the word is\
    \ in the sentence, append it to ans string\n                ans.push_str(&word);\n\
    \                break;\n            }\n        }\n    }\n\n    ans\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `word_list` in this scope\n  --> /tmp/tmpnd0p4bod.rs:22:21\n\
    \   |\n22 |         for word in word_list.iter().take(sentence.len()) {\n   |\
    \                     ^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpnd0p4bod.rs:26:30\n   |\n26 |                 ans.push_str(&word);\n\
    \   |                              ^^^^^ expected `str`, found `char`\n   |\n\
    \   = note: expected reference `&str`\n              found reference `&char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 101
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![2, 3];\n    let mut words: Vec<&str>\
    \ = sentence.split_whitespace().collect();\n    let mut prime_words: Vec<String>\
    \ = vec![];\n    for &word in &words {\n        primes.iter().for_each(|p| {\n\
    \            if word.len() % p == 0 {\n                prime_words.push(String::from(word));\n\
    \            }\n        });\n    }\n    prime_words.join(\" \").to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"This is test\"`,\n right: `\"is\"`', /tmp/tmpb3_lgio4.rs:31:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.is_empty() {\n        return String::from(\"\
    no word in the sentence\");\n    }\n\n    let mut result: Vec<usize> = vec![false;\
    \ sentence.chars().map(|c| *c).filter(|&c| *c).count()];\n    let mut len: usize\
    \ = 0;\n    let mut i = sentence.length();\n\n    while i >= 0 {\n        let\
    \ c: Char = sentence.chars().nth(i).unwrap();\n        result.push(i);\n     \
    \   len += 1;\n\n        if len % _primes[c] == 0 {\n            i += 1;\n   \
    \     }\n    }\n\n    result.sort_unstable();\n    let mut j = 0;\n    let mut\
    \ result = String::new();\n    while j < result.len() {\n        if j == 0 ||\
    \ !(result.len() >= _primes[result[j-1]] || result[j-1] == false) {\n        \
    \    result.push_str(&sentence[j..]);\n        }\n        i += 1;\n        j +=\
    \ i;\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpjsxqk34w.rs:25:16\n\
    \   |\n25 |         let c: Char = sentence.chars().nth(i).unwrap();\n   |    \
    \            ^^^^ help: a builtin type with a similar name exists (notice the\
    \ capitalization): `char`\n\nerror[E0425]: cannot find value `_primes` in this\
    \ scope\n  --> /tmp/tmpjsxqk34w.rs:29:18\n   |\n29 |         if len % _primes[c]\
    \ == 0 {\n   |                  ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `_primes` in this scope\n  --> /tmp/tmpjsxqk34w.rs:38:40\n\
    \   |\n38 |         if j == 0 || !(result.len() >= _primes[result[j-1]] || result[j-1]\
    \ == false) {\n   |                                        ^^^^^^^ not found in\
    \ this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpjsxqk34w.rs:20:39\n\
    \   |\n20 |     let mut result: Vec<usize> = vec![false; sentence.chars().map(|c|\
    \ *c).filter(|&c| *c).count()];\n   |                                       ^^^^^\
    \ expected `usize`, found `bool`\n\nerror[E0614]: type `char` cannot be dereferenced\n\
    \  --> /tmp/tmpjsxqk34w.rs:20:71\n   |\n20 |     let mut result: Vec<usize> =\
    \ vec![false; sentence.chars().map(|c| *c).filter(|&c| *c).count()];\n   |   \
    \                                                                    ^^\n\nerror[E0599]:\
    \ no method named `length` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpjsxqk34w.rs:22:26\n   |\n22 |     let mut i = sentence.length();\n \
    \  |                          ^^^^^^ help: there is an associated function with\
    \ a similar name: `len`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpjsxqk34w.rs:38:48\n   |\n38 |         if j == 0 || !(result.len()\
    \ >= _primes[result[j-1]] || result[j-1] == false) {\n   |                   \
    \                             ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as I"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result: Vec<usize> = sentence.split(' ').map(|x|\
    \ x.len()).collect();\n    result.sort();\n    result = result.iter().filter(|&x|\
    \ x % 2 != 0).collect();\n    let mut result = String::new();\n    for i in result\
    \ {\n        result.push(i);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<usize>` cannot be built from an iterator\
    \ over elements of type `&usize`\n    --> /tmp/tmpo2j5t_2e.rs:18:52\n     |\n\
    18   |     result = result.iter().filter(|&x| x % 2 != 0).collect();\n     | \
    \                                                   ^^^^^^^ value of type `Vec<usize>`\
    \ cannot be built from `std::iter::Iterator<Item=&usize>`\n     |\n     = help:\
    \ the trait `FromIterator<&usize>` is not implemented for `Vec<usize>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0277]: `String` is not an iterator\n  -->\
    \ /tmp/tmpo2j5t_2e.rs:20:14\n   |\n20 |     for i in result {\n   |          \
    \    ^^^^^^ `String` is not an iterator; try calling `.chars()` or `.bytes()`\n\
    \   |\n   = help: the trait `Iterator` is not implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `IntoIterator` for `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59];\n    let mut new_sentence = String::new();\n\
    \    let mut index = 0;\n    let mut j = 0;\n    while index < sentence.len()\
    \ {\n        if primes[index] == sentence[index].chars().count() {\n         \
    \   new_sentence += &sentence[index];\n            primes.remove(index);\n   \
    \         index += 1;\n        } else {\n            primes.insert(index + 1,\
    \ primes[index] + 1);\n            j += 1;\n            index += 1\n        }\n\
    \    }\n    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp78damhwz.rs:21:29\n\
    \   |\n21 |         if primes[index] == sentence[index].chars().count() {\n  \
    \ |                             ^^^^^^^^^^^^^^^ `String` cannot be indexed by\
    \ `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp78damhwz.rs:22:30\n   |\n22 |             new_sentence += &sentence[index];\n\
    \   |                              ^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    helper(sentence, set())\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `helper` in this scope\n  --> /tmp/tmpecib0eh8.rs:16:5\n\
    \   |\n16 |     helper(sentence, set())\n   |     ^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `set` in this scope\n  --> /tmp/tmpecib0eh8.rs:16:22\n\
    \   |\n16 |     helper(sentence, set())\n   |                      ^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjhq8etac.rs:15:43\n   |\n\
    15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace();\n    let\
    \ mut prime_numbers = Vec::new();\n    let mut string = \"\";\n\n    for (i, word)\
    \ in words.iter().enumerate() {\n        for num in (1..).rev() {\n          \
    \  if i % num == 0 {\n                prime_numbers.push(num);\n             \
    \   break;\n            }\n        }\n        string += &word;\n        if prime_numbers.len()\
    \ > 0 {\n            prime_numbers.pop();\n        }\n    }\n\n    string\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmpjbfg1do2.rs:20:28\n   |\n20 |     for (i,\
    \ word) in words.iter().enumerate() {\n   |                            ^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0277]: the trait bound `RangeFrom<{integer}>:\
    \ DoubleEndedIterator` is not satisfied\n    --> /tmp/tmpjbfg1do2.rs:21:26\n \
    \    |\n21   |         for num in (1..).rev() {\n     |                      \
    \    ^^^ the trait `DoubleEndedIterator` is not implemented for `RangeFrom<{integer}>`\n\
    \     |\nnote: required by a bound in `rev`\n\nerror[E0277]: the trait bound `RangeFrom<{integer}>:\
    \ DoubleEndedIterator` is not satisfied\n  --> /tmp/tmpjbfg1do2.rs:21:20\n   |\n\
    21 |         for num in (1..).rev() {\n   |                    ^^^^^^^^^^^ the\
    \ trait `DoubleEndedIterator` is not implemented for `RangeFrom<{integer}>`\n\
    \   |\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Rev<RangeFrom<{integer}>>`\n   = note: required because of the requirements\
    \ on the impl of `IntoIterator` for `Rev<RangeFrom<{integer}>>`\n\nerror[E0368]:\
    \ binary assignment operation `+=` cannot be applied to type `&str`\n  --> /tmp/tmpjbfg1do2.rs:27:9\n\
    \   |\n27 |         string += &word;\n   |         ------^^^^^^^^^\n   |     \
    \    |\n   |         cannot use `+=` on type `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpjbfg1do2.rs:33:5\n   |\n15 | fn words_in_sentence(sentence:\
    \ String) -> String {\n   |                                           ------ expected\
    \ `String` because of return type\n...\n33 |     string\n   |     ^^^^^^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0277, E0308, E0368, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_numbers = vec![];\n    let mut string\
    \ = String::new();\n    let mut len = sentence.len();\n    let mut index = len\
    \ - 1;\n    prime_numbers.push(2);\n    while index >= 1 {\n        if index ==\
    \ 1 {\n            string.push_str(&sentence[index]);\n        } else {\n    \
    \        let mut prime_factors = 2;\n            let mut factor = prime_numbers[index\
    \ - 1];\n            while factor < index {\n                let mut prime_factor\
    \ = 1;\n                while factor < index {\n                    if index ==\
    \ 1 {\n                        prime_numbers.push(prime_factor + 1);\n       \
    \             } else {\n                        let mut flag = true;\n       \
    \                 let mut prime_factors_2 = 2;\n                        let mut\
    \ prime_factor = prime_factors_2 - 1;\n                        while prime_factor\
    \ < prime_factors_2 {\n                            if index == 1 {\n         \
    \                       prime_numbers.push(prime_factor + 1);\n              \
    \              } else {\n                                let mut flag = true;\n\
    \                                let mut prime_factors_2 = 2;\n              \
    \                  let mut prime_factor = prime_factors_2 - 1;\n             \
    \                   while prime_factor < prime_factors_2 {\n                 \
    \                   if index == 1 {\n                                        prime_numbers.push(prime_factor\
    \ + 1);\n                                    } else {\n                      \
    \                  prime_factor += 1;\n                                      \
    \  if index == prime_factors_2 {\n                                           \
    \ flag = false;\n                                            break;\n        \
    \                                }\n                                    }\n  \
    \                              }\n                                prime_factors_2\
    \ = prime_factor;\n                            }\n                           \
    \ prime_factors_2 += 1;\n                        }\n                        prime_factor\
    \ = prime_factors_2;\n                        if flag {\n                    \
    \        break;\n                        }\n                    }\n          \
    \          prime_factor += 1;\n                }\n                prime_factors\
    \ += 1;\n            }\n            string.push_str(&sentence[index]);\n     \
    \   }\n        index -= 1;\n    }\n    string\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwaul9glo.rs:23:30\n\
    \   |\n23 |             string.push_str(&sentence[index]);\n   |             \
    \                 ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpwaul9glo.rs:67:30\n\
    \   |\n67 |             string.push_str(&sentence[index]);\n   |             \
    \                 ^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n   |\n\
    \   = help: the trait `Index<usize>` is not implemented for `String`\n   = help:\
    \ the following other types implement trait `Index<Idx>`:\n             <String\
    \ as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n   \
    \          <String as Index<RangeInclusive<usize>>>\n             <String as Index<RangeTo<usize>>>\n\
    \             <String as Index<RangeToInclusive<usize>>>\n             <String\
    \ as Index<std::ops::Range<usize>>>\n             <str as Index<I>>\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence\n        .split_whitespace()\n        .map(|word|\
    \ {\n            let len: i64 = word.chars().filter(|c| c.is_alphabetic()).count();\n\
    \            if is_prime_number(len) {\n                word.to_string()\n   \
    \         } else {\n                format!(\"{}\", word)\n            }\n   \
    \     })\n        .collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_number` in this scope\n  -->\
    \ /tmp/tmpwnldrjp5.rs:20:16\n   |\n20 |             if is_prime_number(len) {\n\
    \   |                ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwnldrjp5.rs:19:28\n   |\n19 |             let\
    \ len: i64 = word.chars().filter(|c| c.is_alphabetic()).count();\n   |       \
    \               ---   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `i64`, found `usize`\n   |                      |\n   |                    \
    \  expected due to this\n   |\nhelp: you can convert a `usize` to an `i64` and\
    \ panic if the converted value doesn't fit\n   |\n19 |             let len: i64\
    \ = word.chars().filter(|c| c.is_alphabetic()).count().try_into().unwrap();\n\
    \   |                                                                        \
    \      ++++++++++++++++++++\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence\n        .lines()\n        .map(|s| s.to_lowercase())\n\
    \        .filter(|s| s.chars().all(|c| c < ' '))\n        .map(|s| s.chars().filter(|c|\
    \ c.is_ascii_letter()).collect::<Vec<_>>())\n        .filter(|s| s.iter().all(|&c|\
    \ c.is_prime()))\n        .collect::<Vec<_>>()\n        .to_string()\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for reference `&char`\
    \ in the current scope\n  --> /tmp/tmp31_2mjns.rs:20:41\n   |\n20 |         .map(|s|\
    \ s.chars().filter(|c| c.is_ascii_letter()).collect::<Vec<_>>())\n   |       \
    \                                  ^^^^^^^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `is_ascii`\n\nerror[E0599]: no method named `is_prime`\
    \ found for type `char` in the current scope\n  --> /tmp/tmp31_2mjns.rs:21:41\n\
    \   |\n21 |         .filter(|s| s.iter().all(|&c| c.is_prime()))\n   |       \
    \                                  ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ `Vec<Vec<char>>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmp31_2mjns.rs:23:10\n\
    \    |\n23  |           .to_string()\n    |            ^^^^^^^^^ `Vec<Vec<char>>`\
    \ cannot be formatted with the default formatter\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `Vec<Vec<char>>: std::fmt::Display`\n\
    \            which is required by `Vec<Vec<char>>: ToString`\n            `[Vec<char>]:\
    \ std::fmt::Display`\n            which is required by `[Vec<char>]: ToString`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut chars = sentence.split(' ').collect::<Vec<&str>>();\n\
    \    chars.sort_unstable();\n    let mut result = String::new();\n    for &c in\
    \ chars.iter() {\n        let mut flag = true;\n        for c in &chars {\n  \
    \          if c == c {\n                flag = false;\n            }\n       \
    \ }\n        if flag {\n            result.push(c);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpzupfk5bx.rs:27:25\n   |\n\
    27 |             result.push(c);\n   |                         ^ expected `char`,\
    \ found `&str`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence_impl(sentence.chars()).to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence_impl` in this scope\n\
    \  --> /tmp/tmpwfktqe0_.rs:16:5\n   |\n16 |     words_in_sentence_impl(sentence.chars()).to_string()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split(\" \").filter(|word| is_prime(word.len())).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpix2babdr.rs:16:39\n\
    \   |\n16 |     sentence.split(\" \").filter(|word| is_prime(word.len())).collect()\n\
    \   |                                       ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result: String = \"\";\n    let mut word_count\
    \ = 1;\n    let mut char_len = 1;\n    sentence.chars().for_each(|c| {\n     \
    \   if c == ' ' {\n            word_count = word_count + 1;\n        } else if\
    \ char_len == word_count {\n            char_len = char_len + 1;\n        } else\
    \ {\n            result = &result[..char_len];\n            char_len = 1;\n  \
    \          word_count = 1;\n            result = &result[..];\n        }\n   \
    \ });\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpujsvgxit.rs:16:30\n   |\n\
    16 |     let mut result: String = \"\";\n   |                     ------   ^^-\
    \ help: try using a conversion method: `.to_string()`\n   |                  \
    \   |        |\n   |                     |        expected struct `String`, found\
    \ `&str`\n   |                     expected due to this\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpujsvgxit.rs:25:22\n   |\n16 |     let mut result: String\
    \ = \"\";\n   |                     ------ expected due to this type\n...\n25\
    \ |             result = &result[..char_len];\n   |                      ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n\
    \   |\n25 |             result = (&result[..char_len]).to_string();\n   |    \
    \                  +                   +++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpujsvgxit.rs:28:22\n   |\n16 |     let mut result: String\
    \ = \"\";\n   |                     ------ expected due to this type\n...\n28\
    \ |             result = &result[..];\n   |                      ^^^^^^^^^^^ expected\
    \ struct `String`, found `&str`\n   |\nhelp: try using a conversion method\n \
    \  |\n28 |             result = (&result[..]).to_string();\n   |             \
    \         +           +++++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    solve(sentence).to_string()\n}\n\nfn main() {\n   \
    \ let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve` in this scope\n  --> /tmp/tmphsehck_u.rs:16:5\n\
    \   |\n16 |     solve(sentence).to_string()\n   |     ^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug!(\"words_in_sentence\");\n\n    match sentence.chars().size_hint()\
    \ {\n        None => String::new(),\n        Some((a, b)) => if b == 0 { String::from(a)\
    \ } else { String::from(a) },\n    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmp0pmptxjh.rs:16:5\n\
    \   |\n16 |     debug!(\"words_in_sentence\");\n   |     ^^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0pmptxjh.rs:19:9\n   |\n18 |     match sentence.chars().size_hint()\
    \ {\n   |           ---------------------------- this expression has type `(usize,\
    \ Option<usize>)`\n19 |         None => String::new(),\n   |         ^^^^ expected\
    \ tuple, found enum `Option`\n   |\n   = note: expected tuple `(usize, Option<usize>)`\n\
    \               found enum `Option<_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0pmptxjh.rs:20:9\n   |\n18 |     match sentence.chars().size_hint()\
    \ {\n   |           ---------------------------- this expression has type `(usize,\
    \ Option<usize>)`\n19 |         None => String::new(),\n20 |         Some((a,\
    \ b)) => if b == 0 { String::from(a) } else { String::from(a) },\n   |       \
    \  ^^^^^^^^^^^^ expected tuple, found enum `Option`\n   |\n   = note: expected\
    \ tuple `(usize, Option<usize>)`\n               found enum `Option<_>`\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter_map(|x| x.to_lowercase()).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0jsznd13.rs:16:48\n   |\n\
    16 |     sentence.split_whitespace().filter_map(|x| x.to_lowercase()).collect()\n\
    \   |                                                ^^^^^^^^^^^^^^^^ expected\
    \ enum `Option`, found struct `String`\n   |\n   = note: expected enum `Option<_>`\n\
    \            found struct `String`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |     sentence.split_whitespace().filter_map(|x| Some(x.to_lowercase())).collect()\n\
    \   |                                                +++++                +\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().map(|s| s.chars().filter(|c|\
    \ c.is_letter()).collect::<Vec<_>>()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmp9ibo96a1.rs:16:64\n   |\n16 |     sentence.split_whitespace().map(|s|\
    \ s.chars().filter(|c| c.is_letter()).collect::<Vec<_>>()).collect()\n   |   \
    \                                                             ^^^^^^^^^ method\
    \ not found in `&char`\n\nerror[E0277]: a value of type `String` cannot be built\
    \ from an iterator over elements of type `Vec<char>`\n    --> /tmp/tmp9ibo96a1.rs:16:98\n\
    \     |\n16   |     sentence.split_whitespace().map(|s| s.chars().filter(|c| c.is_letter()).collect::<Vec<_>>()).collect()\n\
    \     |                                                                      \
    \                            ^^^^^^^ value of type `String` cannot be built from\
    \ `std::iter::Iterator<Item=Vec<char>>`\n     |\n     = help: the trait `FromIterator<Vec<char>>`\
    \ is not implemented for `String`\n     = help: the following other types implement\
    \ trait `FromIterator<A>`:\n               <String as FromIterator<&'a char>>\n\
    \               <String as FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![];\n    let mut prime_counter\
    \ = vec![];\n    let mut prime_count_in_sentence = vec![];\n    for c in sentence.chars()\
    \ {\n        if c < 'a' || c > 'z' {\n            continue;\n        }\n     \
    \   if primes.contains(&c){\n            prime_counter.push(c);\n            primes.push(c);\n\
    \        } else {\n            if prime_counter.contains(&c){\n              \
    \  prime_count_in_sentence.push(c);\n            }\n        }\n    }\n    prime_counter.sort();\n\
    \    prime_count_in_sentence.sort();\n    for p in primes.clone() {\n        if\
    \ prime_counter.contains(&p){\n            let mut prime_count_p = prime_counter.clone();\n\
    \            prime_count_p.pop(p);\n            prime_counter.push(prime_count_p);\n\
    \        }\n    }\n    let mut prime_counter_string = String::new();\n    for\
    \ p in prime_counter {\n        if prime_counter_string.len() > 0 {\n        \
    \    prime_counter_string.push(\" \");\n        }\n        prime_counter_string.push(p);\n\
    \    }\n    let mut prime_count_in_sentence_string = String::new();\n    for p\
    \ in prime_count_in_sentence {\n        if prime_count_in_sentence_string.len()\
    \ > 0 {\n            prime_count_in_sentence_string.push(\" \");\n        }\n\
    \        prime_count_in_sentence_string.push(p);\n    }\n    prime_counter_string\n\
    \        .as_str()\n        .clone()\n        .into_iter()\n        .map(|c| char::from_digit(c\
    \ - '0').unwrap())\n        .collect::<Vec<u8>>()\n        .to_string()\n    \
    \    .as_str()\n        .clone()\n        .into_iter()\n        .map(|c| c.to_string().clone())\n\
    \        .collect::<Vec<String>>()\n        .to_string()\n        .clone()\n \
    \       .into_iter()\n        .map(|c| c.to_string().clone())\n        .collect::<Vec<String>>()\n\
    \        .to_string()\n        .clone()\n        .into_iter()\n        .map(|c|\
    \ c.to_string().clone())\n        .collect::<Vec<String>>()\n        .to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 0 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp6dhz3xqr.rs:37:27\n     |\n37   |             prime_count_p.pop(p);\n\
    \     |                           ^^^ - supplied 1 argument\n     |          \
    \                 |\n     |                           expected 0 arguments\n \
    \    |\nnote: associated function defined here\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp6dhz3xqr.rs:38:32\n   |\n38 |             prime_counter.push(prime_count_p);\n\
    \   |                                ^^^^^^^^^^^^^ expected `char`, found struct\
    \ `Vec`\n   |\n   = note: expected type `char`\n            found struct `Vec<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp6dhz3xqr.rs:44:39\n   |\n44 |\
    \             prime_counter_string.push(\" \");\n   |                        \
    \               ^^^ expected `char`, found `&str`\n   |\nhelp: if you meant to\
    \ write a `char` literal, use single quotes\n   |\n44 |             prime_counter_string.push('\
    \ ');\n   |                                       ~~~\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp6dhz3xqr.rs:51:49\n   |\n51 |             prime_count_in_sentence_string.push(\"\
    \ \");\n   |                                                 ^^^ expected `char`,\
    \ found `&str`\n   |\nhelp: if you meant to write a `char` literal, use single\
    \ quotes\n   |\n51 |             prime_count_in_sentence_string.push(' ');\n \
    \  |                                                 ~~~\n\nerror[E0599]: the\
    \ method `into_iter` exists for reference `&str`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmp6dhz3xqr.rs:58:10\n   |\n58 |         .into_iter()\n\
    \   |          ^^^^^^^^^ method cannot be called on `&str` due to unsatisfied\
    \ trait bounds\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `&str: Iterator`\n           which is required by `&str: IntoIterator`\n\
    \           `&&str: Iterator`\n           which is required by `&&str: IntoIterator`\n\
    \           `&mut &str: Iterator`\n           which is required by `&mut &str:\
    \ IntoIterator`\n           `str: Sized`\n           which is required by `str:\
    \ IntoIte"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    let mut output = String::from(\"\
    (\");\n    sentence.split_whitespace().for_each(|word| {\n        let word = word.to_string();\n\
    \        let letter = word.chars().filter(|c| c.is_ascii_lowercase()).collect::<Vec<char>>().join();\n\
    \        if !is_prime(letter.len()) {\n            let mut iter = word.chars().enumerate();\n\
    \            iter.next().unwrap();\n            let mut primes = vec![];\n   \
    \         let mut last = iter.next().unwrap().1;\n            let mut cur = last;\n\
    \            while cur != 0 {\n                if cur % prime == 0 {\n       \
    \             primes.push(cur);\n                }\n                cur /= prime;\n\
    \            }\n            primes.sort_unstable();\n            let mut output\
    \ = String::from(\"\");\n            primes.for_each(|x| {\n                let\
    \ x = &x.to_string();\n                output = &output.insert(output.len() -\
    \ 1, x);\n            });\n        } else {\n            let mut iter = word.chars().enumerate();\n\
    \            iter.next().unwrap();\n            let mut primes = vec![];\n   \
    \         let mut last = iter.next().unwrap().1;\n            let mut cur = last;\n\
    \            while cur != 0 {\n                if cur % prime == 0 {\n       \
    \             primes.push(cur);\n                }\n                cur /= prime;\n\
    \            }\n            primes.sort_unstable();\n            let mut output\
    \ = String::from(\"\");\n            primes.for_each(|x| {\n                let\
    \ x = &x.to_string();\n                output = &output.insert(output.len() -\
    \ 1, x);\n            });\n        }\n        output = &output.insert(output.len()\
    \ - 1, \")\");\n    });\n    output\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp24xnwagy.rs:21:13\n\
    \   |\n21 |         if !is_prime(letter.len()) {\n   |             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `prime` in this scope\n\
    \  --> /tmp/tmp24xnwagy.rs:28:26\n   |\n28 |                 if cur % prime ==\
    \ 0 {\n   |                          ^^^^^ help: a local variable with a similar\
    \ name exists: `primes`\n\nerror[E0425]: cannot find value `prime` in this scope\n\
    \  --> /tmp/tmp24xnwagy.rs:31:24\n   |\n31 |                 cur /= prime;\n \
    \  |                        ^^^^^ help: a local variable with a similar name exists:\
    \ `primes`\n\nerror[E0425]: cannot find value `prime` in this scope\n  --> /tmp/tmp24xnwagy.rs:46:26\n\
    \   |\n46 |                 if cur % prime == 0 {\n   |                      \
    \    ^^^^^ help: a local variable with a similar name exists: `primes`\n\nerror[E0425]:\
    \ cannot find value `prime` in this scope\n  --> /tmp/tmp24xnwagy.rs:49:24\n \
    \  |\n49 |                 cur /= prime;\n   |                        ^^^^^ help:\
    \ a local variable with a similar name exists: `primes`\n\nerror[E0599]: the method\
    \ `join` exists for struct `Vec<char>`, but its trait bounds were not satisfied\n\
    \  --> /tmp/tmp24xnwagy.rs:20:93\n   |\n20 |         let letter = word.chars().filter(|c|\
    \ c.is_ascii_lowercase()).collect::<Vec<char>>().join();\n   |               \
    \                                                                            \
    \  ^^^^ method cannot be called on `Vec<char>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `[char]:\
    \ Join<_>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp24xnwagy.rs:27:26\n\
    \   |\n27 |             while cur != 0 {\n   |                          ^ expected\
    \ `char`, found `u8`\n\nerror[E0599]: `Vec<char>` is not an iterator\n   --> /tmp/tmp24xnwagy.rs:35:20\n\
    \    |\n35  |               primes.for_each(|x| {\n    |                     \
    \ ^^^^^^^^ `Vec<char>` is not an iterator\n    |\n    = note: the following trait\
    \ bounds were not satisfied:\n            `Vec<char>"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut buffer = Vec::new();\n    let mut is_prime\
    \ = true;\n    let mut pos = 0;\n    while pos < sentence.len() && is_prime {\n\
    \        buffer.clear();\n        let mut word: String;\n        for &c in sentence.chars()\
    \ {\n            if pos == 0 {\n                word = String::from(&c);\n   \
    \         } else {\n                if buffer.contains(&c) && c.len() == pos {\n\
    \                    continue;\n                } else {\n                   \
    \ buffer.push(&c);\n                }\n            }\n        }\n        if buffer.len()\
    \ == 1 {\n            buffer.push(c);\n        }\n        is_prime = false;\n\
    \        for &c in buffer {\n            if c.len() != pos {\n               \
    \ is_prime = true;\n                break;\n            }\n        }\n       \
    \ pos += 1;\n    }\n    buffer.into_iter().filter(|&c| c.len() == pos).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpthv5jo73.rs:34:25\n\
    \   |\n34 |             buffer.push(c);\n   |                         ^ not found\
    \ in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpthv5jo73.rs:22:13\n\
    \   |\n22 |         for &c in sentence.chars() {\n   |             ^^    ----------------\
    \ this expression has type `Option<char>`\n   |             |\n   |          \
    \   expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror: aborting due to 2 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut s = sentence.to_string();\n    let mut prime_chars\
    \ = vec![];\n    let mut prev_char: Char = s.chars().next().unwrap();\n    loop\
    \ {\n        if s.starts_with(prev_char) {\n            prime_chars.push(prev_char);\n\
    \            prime_chars.push(prev_char.to_string());\n        } else {\n    \
    \        break;\n        }\n        s = s.to_string();\n        prev_char = (s.chars().next().unwrap()).to_string();\n\
    \    }\n    prime_chars\n        .iter()\n        .cloned()\n        .sort();\n\
    \    String::from(prime_chars.iter().cloned().collect::<Vec<_>>().join())\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmptom2_xam.rs:18:24\n\
    \   |\n18 |     let mut prev_char: Char = s.chars().next().unwrap();\n   |   \
    \                     ^^^^ help: a builtin type with a similar name exists (notice\
    \ the capitalization): `char`\n\nerror[E0599]: no method named `sort` found for\
    \ struct `Cloned` in the current scope\n  --> /tmp/tmptom2_xam.rs:32:10\n   |\n\
    32 |         .sort();\n   |          ^^^^ method not found in `Cloned<std::slice::Iter<'_,\
    \ _>>`\n\nerror[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \   --> /tmp/tmptom2_xam.rs:33:66\n    |\n33  |     String::from(prime_chars.iter().cloned().collect::<Vec<_>>().join())\n\
    \    |                                                                  ^^^^-\
    \ supplied 0 arguments\n    |                                                \
    \                  |\n    |                                                  \
    \                expected 1 argument\n    |\nnote: associated function defined\
    \ here\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0061, E0412, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.splitn(\" \").map(|word| word.to_string());\n\
    \    let mut primes = vec![];\n    let mut n = 1;\n    for word in words {\n \
    \       if n % 2 == 0 {\n            primes.push(word.len());\n        }\n   \
    \     n += 1;\n    }\n    String::from(words.join(\" \")).split_str(&primes).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmp4lnjs4cp.rs:16:30\n     |\n16   |     let mut words = sentence.splitn(\"\
    \ \").map(|word| word.to_string());\n     |                              ^^^^^^\
    \ --- supplied 1 argument\n     |                              |\n     |     \
    \                         expected 2 arguments\n     |\nnote: associated function\
    \ defined here\n\nerror[E0599]: no method named `join` found for struct `Map`\
    \ in the current scope\n  --> /tmp/tmp4lnjs4cp.rs:25:24\n   |\n25 |     String::from(words.join(\"\
    \ \")).split_str(&primes).collect()\n   |                        ^^^^ method not\
    \ found in `Map<std::str::SplitN<'_, _>, [closure@/tmp/tmp4lnjs4cp.rs:16:46: 16:69]>`\n\
    \nerror[E0599]: no method named `split_str` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmp4lnjs4cp.rs:25:35\n   |\n25 |     String::from(words.join(\"\
    \ \")).split_str(&primes).collect()\n   |                                   ^^^^^^^^^\
    \ help: there is an associated function with a similar name: `split`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0061, E0599.\nFor more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_numbers = String::new();\n    let mut\
    \ length = 0;\n    let mut words = String::new();\n\n    for character in sentence.chars()\
    \ {\n        if length <= 0 {\n            prime_numbers += \"0\".to_string();\n\
    \        }\n        if character == ' ' {\n            prime_numbers += prime_numbers.to_string();\n\
    \            length += 1;\n            words = String::new();\n        } else\
    \ {\n            prime_numbers += &format!(\"{}{}\", prime_numbers.to_string(),\
    \ character.to_string());\n        }\n    }\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_numbers.to_string();\n\
    \    prime_numbers += prime_numbers.to_string();\n    prime_numbers += prime_\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `prime_` in this scope\n  --> /tmp/tmp4hwj7krx.rs:68:22\n\
    \   |\n68 |     prime_numbers += prime_\n   |                      ^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7krx.rs:22:30\n\
    \   |\n22 |             prime_numbers += \"0\".to_string();\n   |            \
    \                  ^^^^^^^^^^^^^^^\n   |                              |\n   |\
    \                              expected `&str`, found struct `String`\n   |  \
    \                            help: consider borrowing here: `&\"0\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7krx.rs:25:30\n   |\n25 |\
    \             prime_numbers += prime_numbers.to_string();\n   |              \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                             \
    \ |\n   |                              expected `&str`, found struct `String`\n\
    \   |                              help: consider borrowing here: `&prime_numbers.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7krx.rs:32:22\n   |\n32 |\
    \     prime_numbers += prime_numbers.to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&prime_numbers.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7krx.rs:33:22\n   |\n33 |\
    \     prime_numbers += prime_numbers.to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&prime_numbers.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7krx.rs:34:22\n   |\n34 |\
    \     prime_numbers += prime_numbers.to_string();\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                      |\n   |                      expected `&str`, found\
    \ struct `String`\n   |                      help: consider borrowing here: `&prime_numbers.to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp4hwj7"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.splitn(2, \" \").to_vec())\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for struct `std::str::SplitN`\
    \ in the current scope\n  --> /tmp/tmpi7zixw3i.rs:16:47\n   |\n16 |     words_in_sentence(sentence.splitn(2,\
    \ \" \").to_vec())\n   |                                               ^^^^^^\
    \ method not found in `std::str::SplitN<'_, &str>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Step 1: calculate the length of the new string\n\
    \    let mut length_of_new_string = 1;\n    for i in 0..sentence.len() {\n   \
    \     if length_of_new_string % i != 0 {\n            length_of_new_string +=\
    \ 1;\n        }\n    }\n\n    // Step 2: create a new string with the same length\n\
    \    let mut new_string = \"\";\n    for i in 0..length_of_new_string {\n    \
    \    new_string += sentence[i % sentence.len()].to_string();\n    }\n\n    //\
    \ Step 3: calculate the number of words from the original string\n    // and append\
    \ to new string\n    let mut num_words_from_original = 0;\n    for i in 0..sentence.len()\
    \ {\n        if length_of_new_string % i == 0 {\n            num_words_from_original\
    \ += 1;\n        }\n    }\n\n    for i in 0..num_words_from_original {\n     \
    \   new_string += sentence[i % sentence.len()].to_string();\n    }\n\n    new_string\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp7_12of8t.rs:27:23\n\
    \   |\n27 |         new_string += sentence[i % sentence.len()].to_string();\n\
    \   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp7_12of8t.rs:40:23\n   |\n40 |         new_string += sentence[i\
    \ % sentence.len()].to_string();\n   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp7_12of8t.rs:43:5\n\
    \   |\n15 | fn words_in_sentence(sentence: String) -> String {\n   |         \
    \                                  ------ expected `String` because of return\
    \ type\n...\n43 |     new_string\n   |     ^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter(|w| is_prime(w.len())).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpl4sw4twd.rs:16:44\n\
    \   |\n16 |     sentence.split_whitespace().filter(|w| is_prime(w.len())).collect()\n\
    \   |                                            ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence: Vec<usize> = sentence.split_whitespace().collect();\n\
    \    new_sentence.sort();\n    new_sentence.dedup();\n    new_sentence.dedup();\n\
    \    new_sentence\n        .iter()\n        .take_while(|&x| x.is_prime())\n \
    \       .collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<usize>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpcv51x6a_.rs:16:68\n     |\n16\
    \   |     let mut new_sentence: Vec<usize> = sentence.split_whitespace().collect();\n\
    \     |                                                                    ^^^^^^^\
    \ value of type `Vec<usize>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<usize>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `is_prime` found for\
    \ reference `&usize` in the current scope\n  --> /tmp/tmpcv51x6a_.rs:22:28\n \
    \  |\n22 |         .take_while(|&x| x.is_prime())\n   |                      \
    \      ^^^^^^^^ method not found in `&usize`\n\nerror[E0277]: a value of type\
    \ `String` cannot be built from an iterator over elements of type `&usize`\n \
    \   --> /tmp/tmpcv51x6a_.rs:23:10\n     |\n23   |         .collect()\n     | \
    \         ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=&usize>`\n\
    \     |\n     = help: the trait `FromIterator<&usize>` is not implemented for\
    \ `String`\n     = help: the following other types implement trait `FromIterator<A>`:\n\
    \               <String as FromIterator<&'a char>>\n               <String as\
    \ FromIterator<&'a str>>\n               <String as FromIterator<Box<str>>>\n\
    \               <String as FromIterator<Cow<'a, str>>>\n               <String\
    \ as FromIterator<String>>\n               <String as FromIterator<char>>\nnote:\
    \ required by a bound in `collect`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.split(' ').collect::<Vec<_>>())\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjk0pybe1.rs:16:23\n   |\n\
    16 |     words_in_sentence(sentence.split(' ').collect::<Vec<_>>())\n   |    \
    \                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found struct `Vec`\n   |\n   = note: expected struct `String`\n            \
    \  found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n\n    for word\
    \ in sentence.split_whitespace() {\n        if is_prime(word.len()) {\n      \
    \      result.push_str(&*word);\n        }\n    }\n\n    result\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmplmeifa4p.rs:19:12\n\
    \   |\n19 |         if is_prime(word.len()) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(1 <= sentence.length());\n    assert!(sentence.length()\
    \ <= 100);\n    assert!(sentence.chars().all(|c| c <= ' '));\n    if sentence.length()\
    \ == 1 { return \"\".to_string(); }\n    let mut chars = sentence.chars().collect::<Vec<char>>();\n\
    \    let mut prime_chars = chars.clone();\n    prime_chars.sort();\n    for i\
    \ in 2..=sentence.length() {\n        for char in prime_chars.clone() {\n    \
    \        if char == i {\n                prime_chars.remove(char);\n         \
    \       break;\n            }\n        }\n    }\n    let mut result = String::from(\"\
    \    \");\n    for word in &prime_chars {\n        result.push_str(&chars[word]);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpt3frqmfp.rs:16:27\n   |\n16 |     assert!(1 <=\
    \ sentence.length());\n   |                           ^^^^^^ help: there is an\
    \ associated function with a similar name: `len`\n\nerror[E0599]: no method named\
    \ `length` found for struct `String` in the current scope\n  --> /tmp/tmpt3frqmfp.rs:17:22\n\
    \   |\n17 |     assert!(sentence.length() <= 100);\n   |                     \
    \ ^^^^^^ help: there is an associated function with a similar name: `len`\n\n\
    error[E0599]: no method named `length` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpt3frqmfp.rs:19:17\n   |\n19 |     if sentence.length()\
    \ == 1 { return \"\".to_string(); }\n   |                 ^^^^^^ help: there is\
    \ an associated function with a similar name: `len`\n\nerror[E0599]: no method\
    \ named `length` found for struct `String` in the current scope\n  --> /tmp/tmpt3frqmfp.rs:23:27\n\
    \   |\n23 |     for i in 2..=sentence.length() {\n   |                       \
    \    ^^^^^^ help: there is an associated function with a similar name: `len`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpt3frqmfp.rs:25:24\n   |\n25 |\
    \             if char == i {\n   |                        ^ expected `char`, found\
    \ integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpt3frqmfp.rs:26:36\n\
    \   |\n26 |                 prime_chars.remove(char);\n   |                  \
    \                  ^^^^ expected `usize`, found `char`\n\nerror[E0277]: the type\
    \ `[char]` cannot be indexed by `&char`\n  --> /tmp/tmpt3frqmfp.rs:33:26\n   |\n\
    33 |         result.push_str(&chars[word]);\n   |                          ^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[char]>` is not implemented for `&char`\n   = note: required\
    \ because of the requirements on the impl of `Index<&char>` for `Vec<char>`\n\n\
    error: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in sentence.chars().filter_map(|c|\
    \ c < ' ').filter(|c| c != '\\n').filter(|c| c != '\\t') {\n        let mut n\
    \ = 1;\n        let mut prime = true;\n        for _ in 0..(word.len() - 1) {\n\
    \            if !is_prime(word.as_bytes().nth(word.len() - 1).unwrap(), n) &&\
    \ prime {\n                prime = false;\n            }\n            n *= 2;\n\
    \        }\n        if prime {\n            result.push_str(&word.as_bytes());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpe1ts13yl.rs:21:17\n\
    \   |\n21 |             if !is_prime(word.as_bytes().nth(word.len() - 1).unwrap(),\
    \ n) && prime {\n   |                 ^^^^^^^^ not found in this scope\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpe1ts13yl.rs:17:49\n   |\n17 |     for word in\
    \ sentence.chars().filter_map(|c| c < ' ').filter(|c| c != '\\n').filter(|c| c\
    \ != '\\t') {\n   |                                                 ^^^^^^^ expected\
    \ enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |     for word in sentence.chars().filter_map(|c| Some(c < ' ')).filter(|c|\
    \ c != '\\n').filter(|c| c != '\\t') {\n   |                                 \
    \                +++++       +\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmpe1ts13yl.rs:17:71\n   |\n17 |     for word in sentence.chars().filter_map(|c|\
    \ c < ' ').filter(|c| c != '\\n').filter(|c| c != '\\t') {\n   |             \
    \                                                          ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror[E0277]: can't compare `&_` with `char`\n  --> /tmp/tmpe1ts13yl.rs:17:93\n\
    \   |\n17 |     for word in sentence.chars().filter_map(|c| c < ' ').filter(|c|\
    \ c != '\\n').filter(|c| c != '\\t') {\n   |                                 \
    \                                                            ^^ no implementation\
    \ for `&_ == char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented\
    \ for `&_`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter(|w| w[w.len() -\
    \ 1] == ' ').collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmp0p28vpuv.rs:16:44\n\
    \   |\n16 |     sentence.split_whitespace().filter(|w| w[w.len() - 1] == ' ').collect()\n\
    \   |                                            ^^^^^^^^^^^^^^ string indices\
    \ are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>` is not implemented\
    \ for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n\
    \   = note: required because of the requirements on the impl of `Index<usize>`\
    \ for `str`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = String::new();\n    let mut sentence\
    \ = sentence.replace(\"\\n\", \" \").to_owned();\n    let mut words = Vec::new();\n\
    \    let mut len = String::new();\n    primes.clear();\n    words.clear();\n \
    \   while sentence.len() > 0 {\n        words.clear();\n        for c in sentence.chars()\
    \ {\n            if c.is_whitespace() {\n                continue;\n         \
    \   }\n            let mut prime = primes.clone();\n            let mut n = String::new();\n\
    \            let mut prime_len = String::new();\n            prime_len = primes.clone();\n\
    \            n = prime_len;\n            if prime == n {\n                if c\
    \ != ' ' {\n                    prime = prime_len;\n                }\n      \
    \          prime = prime_len;\n            }\n            prime = prime_len;\n\
    \            prime = prime_len;\n            if c.is_lowercase() {\n         \
    \       n = c.to_lowercase();\n            }\n            if prime != n {\n  \
    \              prime = prime_len;\n                prime = prime_len;\n      \
    \      }\n            prime = prime_len;\n            if prime != n {\n      \
    \          prime = prime_len;\n                prime = prime_len;\n          \
    \  }\n            prime = prime_len;\n            if prime != n {\n          \
    \      prime = prime_len;\n                prime = prime_len;\n            }\n\
    \            prime = prime_len;\n            if prime != n {\n               \
    \ prime = prime_len;\n                prime = prime_len;\n            }\n    \
    \        prime = prime_len;\n            prime = prime_len;\n            prime\
    \ = prime_len;\n            prime = prime_len;\n            prime = prime_len;\n\
    \            prime = prime_len;\n            prime = prime_len;\n            if\
    \ prime != n {\n                prime = prime_len;\n                prime = prime_len;\n\
    \            }\n            prime = prime_len;\n            prime = prime_len;\n\
    \            prime = prime_len;\n            prime = prime_len;\n            prime\
    \ = prime_len;\n            prime = prime_len;\n            prime = prime_len;\n\
    \            prime = prime_len;\n            prime = prime_len;\n            prime\
    \ = prime_len;\n            prime = prime_len;\n            prime = prime_len;\n\
    \            prime = prime_len;\n            prime = prime_len;\n            prime\
    \ = prime_len;\n            prime = prime_len;\n            prime = prime_len;\n\
    \            prime = prime_len;\n            prime = prime_len;\n            prime\
    \ = prime_len;\n            prime = prime_len;\n            prime = \n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n   --> /tmp/tmpgmv6_51t.rs:107:3\n\
    \    |\n15  | fn words_in_sentence(sentence: String) -> String {\n    |      \
    \                                            - unclosed delimiter\n...\n22  |\
    \     while sentence.len() > 0 {\n    |                              - unclosed\
    \ delimiter\n23  |         words.clear();\n24  |         for c in sentence.chars()\
    \ {\n    |                                   - this delimiter might not be properly\
    \ closed...\n...\n96  | }\n    | - ...as it matches this but it has different\
    \ indentation\n...\n107 | }\n    |   ^\n\nerror: expected expression, found `}`\n\
    \  --> /tmp/tmpgmv6_51t.rs:96:1\n   |\n96 | }\n   | ^ expected expression\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpgmv6_51t.rs:42:21\n   |\n29 |  \
    \           let mut n = String::new();\n   |                         -------------\
    \ expected due to this value\n...\n42 |                 n = c.to_lowercase();\n\
    \   |                     ^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |                     |\n   |                     expected\
    \ struct `String`, found struct `ToLowercase`\n\nerror[E0308]: mismatched types\n\
    \   --> /tmp/tmpgmv6_51t.rs:22:5\n    |\n15  |   fn words_in_sentence(sentence:\
    \ String) -> String {\n    |                                             ------\
    \ expected `String` because of return type\n...\n22  | /     while sentence.len()\
    \ > 0 {\n23  | |         words.clear();\n24  | |         for c in sentence.chars()\
    \ {\n25  | |             if c.is_whitespace() {\n...   |\n106 | |     assert_eq!(candidate(String::from(\"\
    here is\")), String::from(\"is\"));\n107 | | }\n    | |__^ expected struct `String`,\
    \ found `()`\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut str: Vec<&str> = sentence.split_whitespace().collect();\n\
    \    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43,\
    \ 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut result = String::new();\n\
    \    for p in primes {\n        if p.is_multiple_of(3) {\n            if p !=\
    \ str.len() {\n                let p = str[p];\n                let r = str.split_at(p\
    \ / 3).collect();\n                result = result.into_iter().extend(r).collect();\n\
    \                str = &str[p % 3..];\n            }\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_multiple_of` found for type `{integer}`\
    \ in the current scope\n  --> /tmp/tmp_07k3ych.rs:20:14\n   |\n20 |         if\
    \ p.is_multiple_of(3) {\n   |              ^^^^^^^^^^^^^^ method not found in\
    \ `{integer}`\n\nerror[E0369]: cannot divide `&str` by `{integer}`\n  --> /tmp/tmp_07k3ych.rs:23:40\n\
    \   |\n23 |                 let r = str.split_at(p / 3).collect();\n   |     \
    \                                 - ^ - {integer}\n   |                      \
    \                |\n   |                                      &str\n\nerror[E0599]:\
    \ `(&[&str], &[&str])` is not an iterator\n  --> /tmp/tmp_07k3ych.rs:23:45\n \
    \  |\n23 |                 let r = str.split_at(p / 3).collect();\n   |      \
    \                                       ^^^^^^^ `(&[&str], &[&str])` is not an\
    \ iterator\n   |\n   = note: the following trait bounds were not satisfied:\n\
    \           `(&[&str], &[&str]): Iterator`\n           which is required by `&mut\
    \ (&[&str], &[&str]): Iterator`\n\nerror[E0599]: the method `into_iter` exists\
    \ for struct `String`, but its trait bounds were not satisfied\n   --> /tmp/tmp_07k3ych.rs:24:33\n\
    \    |\n24  |                   result = result.into_iter().extend(r).collect();\n\
    \    |                                   ^^^^^^^^^\n    |\n    = note: the following\
    \ trait bounds were not satisfied:\n            `String: Iterator`\n         \
    \   which is required by `String: IntoIterator`\n            `&String: Iterator`\n\
    \            which is required by `&String: IntoIterator`\n            `&mut String:\
    \ Iterator`\n            which is required by `&mut String: IntoIterator`\n  \
    \          `str: Sized`\n            which is required by `str: IntoIterator`\n\
    \            `str: Iterator`\n            which is required by `str: IntoIterator`\n\
    \            `&str: Iterator`\n            which is required by `&str: IntoIterator`\n\
    \            `&mut str: Iterator`\n            which is required by `&mut str:\
    \ IntoIterator`\n\nerror[E0369]: cannot mod `&str` by `{integer}`\n  --> /tmp/tmp_07k3ych.rs:25:30\n\
    \   |\n25 |                 str = &str[p % 3..];\n   |                        "
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace();\n    let\
    \ mut prime_words: Vec<String> = Vec::new();\n\n    // find prime words\n    while\
    \ !words.is_empty() {\n        prime_words.push(\n            prime_word()\n \
    \               .iter()\n                .filter(|&x| x.is_prime())\n        \
    \        .collect::<Vec<String>>(),\n        );\n        words.pop();\n    }\n\
    \n    let mut result = String::from(\"no\");\n    for word in prime_words {\n\
    \        if words_in_word(word).is_empty() {\n            result = result.concat(\"\
    , \");\n            result = result.concat(word.clone());\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_word` in this scope\n  --> /tmp/tmpp7s7ymf_.rs:22:13\n\
    \   |\n22 |             prime_word()\n   |             ^^^^^^^^^^ help: a local\
    \ variable with a similar name exists: `prime_words`\n\nerror[E0425]: cannot find\
    \ function `words_in_word` in this scope\n  --> /tmp/tmpp7s7ymf_.rs:32:12\n  \
    \ |\n32 |         if words_in_word(word).is_empty() {\n   |            ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `is_empty` found for\
    \ struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpp7s7ymf_.rs:20:18\n\
    \   |\n20 |     while !words.is_empty() {\n   |                  ^^^^^^^^ method\
    \ not found in `SplitWhitespace<'_>`\n\nerror[E0599]: no method named `pop` found\
    \ for struct `SplitWhitespace` in the current scope\n  --> /tmp/tmpp7s7ymf_.rs:27:15\n\
    \   |\n27 |         words.pop();\n   |               ^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpp7s7ymf_.rs:33:29\n   |\n33 |             result = result.concat(\"\
    , \");\n   |                             ^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `concat` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpp7s7ymf_.rs:34:29\n   |\n34 |             result = result.concat(word.clone());\n\
    \   |                             ^^^^^^ method not found in `String`\n\nerror:\
    \ aborting due to 6 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence_aux(sentence, false)\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence_aux` in this scope\n\
    \  --> /tmp/tmp52bk50qq.rs:16:5\n   |\n16 |     words_in_sentence_aux(sentence,\
    \ false)\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    match sentence\n        .chars()\n        .filter(|c|\
    \ !c.is_whitespace())\n        .filter(|c| !c.is_ascii_lowercase())\n        .filter(|c|\
    \ !c.is_ascii_uppercase())\n        .filter(|c| c.is_ascii_digit())\n        .filter(|c|\
    \ c > Character('a'))\n        .filter(|c| c < Character('z'))\n        .filter(|c|\
    \ c > Character('A'))\n        .filter(|c| c < Character('Z'))\n        .filter(|c|\
    \ c > Character('0'))\n        .filter(|c| c < Character('9'))\n    {\n      \
    \  None => \"\",\n        Some(sentence) => sentence.clone(),\n    }\n}\n\nfn\
    \ main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:22:25\n   |\n22 |         .filter(|c|\
    \ c > Character('a'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:23:25\n   |\n23 |         .filter(|c|\
    \ c < Character('z'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:24:25\n   |\n24 |         .filter(|c|\
    \ c > Character('A'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:25:25\n   |\n25 |         .filter(|c|\
    \ c < Character('Z'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:26:25\n   |\n26 |         .filter(|c|\
    \ c > Character('0'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function, tuple struct or tuple variant `Character`\
    \ in this scope\n  --> /tmp/tmpy3w1luai.rs:27:25\n   |\n27 |         .filter(|c|\
    \ c < Character('9'))\n   |                         ^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpy3w1luai.rs:29:9\n  \
    \ |\n16 |       match sentence\n   |  ___________-\n17 | |         .chars()\n\
    18 | |         .filter(|c| !c.is_whitespace())\n   | |                 ----------------------\
    \ one of the expected closures\n19 | |         .filter(|c| !c.is_ascii_lowercase())\n\
    \   | |                 --------------------------- one of the expected closures\n\
    20 | |         .filter(|c| !c.is_ascii_uppercase())\n   | |                 ---------------------------\
    \ one of the expected closures\n21 | |         .filter(|c| c.is_ascii_digit())\n\
    \   | |                 ---------------------- one o"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    use num_bigint::{BigInt, One};\n    let mut primes\
    \ = Vec::new();\n    primes.push(1);\n\n    while primes.len() < sentence.len()\
    \ {\n        for prime in &primes {\n            if let Some(_) = &sentence[prime.one()..].chars().filter(|c|\
    \ !c.is_alphanumeric()) {\n                break;\n            }\n\n         \
    \   if prime.is_prime() {\n                primes.push(prime.clone());\n     \
    \       }\n        }\n    }\n\n    let mut result = String::with_capacity(sentence.len());\n\
    \n    for &prime in &primes {\n        let mut prime_string = sentence.chars().filter(|c|\
    \ !c.is_alphanumeric()).collect::<String>();\n        prime_string.push(&char!('0'));\n\
    \        prime_string.push(&char!('9'));\n\n        for &c in &prime_string {\n\
    \            if prime == (c as BigInt).sqrt() {\n                result.push_str(&c);\n\
    \            }\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0432]: unresolved import `num_bigint`\n  --> /tmp/tmpvbuf1450.rs:16:9\n\
    \   |\n16 |     use num_bigint::{BigInt, One};\n   |         ^^^^^^^^^^ maybe\
    \ a missing crate `num_bigint`?\n\nerror: cannot find macro `char` in this scope\n\
    \  --> /tmp/tmpvbuf1450.rs:36:28\n   |\n36 |         prime_string.push(&char!('0'));\n\
    \   |                            ^^^^\n   |\n   = note: `char` is in scope, but\
    \ it is a builtin type, not a macro\n\nerror: cannot find macro `char` in this\
    \ scope\n  --> /tmp/tmpvbuf1450.rs:37:28\n   |\n37 |         prime_string.push(&char!('9'));\n\
    \   |                            ^^^^\n   |\n   = note: `char` is in scope, but\
    \ it is a builtin type, not a macro\n\nerror[E0599]: no method named `one` found\
    \ for reference `&{integer}` in the current scope\n  --> /tmp/tmpvbuf1450.rs:22:46\n\
    \   |\n22 |             if let Some(_) = &sentence[prime.one()..].chars().filter(|c|\
    \ !c.is_alphanumeric()) {\n   |                                              ^^^\
    \ method not found in `&{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvbuf1450.rs:22:20\n\
    \   |\n22 |             if let Some(_) = &sentence[prime.one()..].chars().filter(|c|\
    \ !c.is_alphanumeric()) {\n   |                    ^^^^^^^   -----------------------------------------------------------------\n\
    \   |                    |         |                                       |\n\
    \   |                    |         |                                       the\
    \ expected closure\n   |                    |         this expression has type\
    \ `&Filter<Chars<'_>, [closure@/tmp/tmpvbuf1450.rs:22:70: 22:94]>`\n   |     \
    \               expected struct `Filter`, found enum `Option`\n   |\n   = note:\
    \ expected struct `Filter<Chars<'_>, [closure@/tmp/tmpvbuf1450.rs:22:70: 22:94]>`\n\
    \                found enum `Option<_>`\n\nerror[E0599]: no method named `is_prime`\
    \ found for reference `&{integer}` in the current scope\n  --> /tmp/tmpvbuf1450.rs:26:22\n\
    \   |\n26 |             if prime.is_prime() {\n   |                      ^^^^^^^^\
    \ method not found in `&{integer}`\n\nerror[E0277]: `&String` is not an iterator\n\
    \  --> /tmp/tmpv"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    use std::cmp::Ordering;\n    let mut primes = vec![true;\
    \ 100];\n    let mut prime_index = 0;\n    let mut prime_words: Vec<_> = Vec::new();\n\
    \    for word in sentence.split_whitespace() {\n        if primes[prime_index]\
    \ {\n            prime_words.push(word);\n        }\n        primes[prime_index\
    \ % primes.len()] = false;\n        prime_index += 1;\n    }\n    prime_words.sort_by_key(|word|\
    \ word.len());\n    let mut new_sentence = String::with_capacity(sentence.len());\n\
    \    for word in prime_words {\n        new_sentence.push_str(word);\n    }\n\
    \    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpczy_5hj4.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0502]: cannot borrow\
    \ `primes` as immutable because it is also borrowed as mutable\n  --> /tmp/tmpczy_5hj4.rs:24:30\n\
    \   |\n24 |         primes[prime_index % primes.len()] = false;\n   |        \
    \ ---------------------^^^^^^^^^^^^-\n   |         |                    |\n  \
    \ |         |                    immutable borrow occurs here\n   |         mutable\
    \ borrow occurs here\n   |         mutable borrow later used here\n   |\nhelp:\
    \ try adding a local storing this...\n  --> /tmp/tmpczy_5hj4.rs:24:30\n   |\n\
    24 |         primes[prime_index % primes.len()] = false;\n   |               \
    \               ^^^^^^^^^^^^\nhelp: ...and then using that local here\n  --> /tmp/tmpczy_5hj4.rs:24:9\n\
    \   |\n24 |         primes[prime_index % primes.len()] = false;\n   |        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting due to previous error;\
    \ 1 warning emitted\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(\n        sentence.chars().all(|c| c <= char::MAX\
    \ as i8),\n        \"The sentence must contain only letters.\"\n    );\n    let\
    \ mut prime_words_list = vec![];\n    let mut prime_words_count = 0;\n    let\
    \ mut i = 2; // the index of the next prime\n    while i < sentence.len() {\n\
    \        // checks if the word is prime or not\n        if sentence.chars().any(|c|\
    \ *c % i as i32 != 0) {\n            return String::new();\n        }\n      \
    \  // if word is prime then adds the prime to the list\n        prime_words_list.append(&sentence[i..i]);\n\
    \        i += 1;\n        prime_words_count += 1;\n    }\n    String::from(\n\
    \        prime_words_list\n            .iter()\n            .filter(|word| word.chars().all(|c|\
    \ c <= char::MAX as i8))\n            .collect::<String>(),\n    )\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxhu969h6.rs:17:39\n   |\n\
    17 |         sentence.chars().all(|c| c <= char::MAX as i8),\n   |           \
    \                            ^^^^^^^^^^^^^^^ expected `char`, found `i8`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpxhu969h6.rs:25:37\n   |\n\
    25 |         if sentence.chars().any(|c| *c % i as i32 != 0) {\n   |         \
    \                            ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpxhu969h6.rs:29:33\n\
    \   |\n29 |         prime_words_list.append(&sentence[i..i]);\n   |          \
    \                       ^^^^^^^^^^^^^^^ types differ in mutability\n   |\n   =\
    \ note: expected mutable reference `&mut Vec<_>`\n                      found\
    \ reference `&str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut word = String::new();\n\
    \    for ch in sentence.chars() {\n        if ch.is_ascii_letter() {\n       \
    \     res += ch;\n        } else {\n            if !word.eq(\"0\") {\n       \
    \         res.push('_');\n            }\n            word += ch;\n        }\n\
    \    }\n    if !word.eq(\"0\") {\n        res.push('_');\n    }\n    res += \"\
    _\";\n    return res;\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmph0d3fzj1.rs:19:15\n   |\n19 |         if ch.is_ascii_letter()\
    \ {\n   |               ^^^^^^^^^^^^^^^ help: there is an associated function\
    \ with a similar name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph0d3fzj1.rs:20:20\n\
    \   |\n20 |             res += ch;\n   |                    ^^ expected `&str`,\
    \ found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph0d3fzj1.rs:25:21\n\
    \   |\n25 |             word += ch;\n   |                     ^^ expected `&str`,\
    \ found `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::new();\n    let mut\
    \ prime_numbers = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,\
    \ 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227,\
    \ 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313,\
    \ 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,\
    \ 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509,\
    \ 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617,\
    \ 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727,\
    \ 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,\
    \ 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947,\
    \ 953, 967, 971, 977, 983, 991, 997];\n    for _ in 0..sentence.split(' ').len()\
    \ {\n        let mut new_word = \"\";\n        for &c in sentence.chars() {\n\
    \            if prime_numbers.contains(c.len()) {\n                new_word +=\
    \ c;\n            }\n        }\n        new_sentence += new_word + \" \";\n  \
    \  }\n    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmpfjkv_zcl.rs:18:37\n   |\n18 |     for _\
    \ in 0..sentence.split(' ').len() {\n   |                                    \
    \ ^^^ method not found in `std::str::Split<'_, char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpfjkv_zcl.rs:20:13\n   |\n20 |         for &c in sentence.chars()\
    \ {\n   |             ^^    ---------------- this expression has type `Option<char>`\n\
    \   |             |\n   |             expected `char`, found reference\n   | \
    \            help: you can probably remove the explicit borrow: `c`\n   |\n  \
    \ = note:   expected type `char`\n           found reference `&_`\n\nerror[E0369]:\
    \ cannot add `&str` to `&str`\n  --> /tmp/tmpfjkv_zcl.rs:25:34\n   |\n25 |   \
    \      new_sentence += new_word + \" \";\n   |                         --------\
    \ ^ --- &str\n   |                         |        |\n   |                  \
    \       |        `+` cannot be used to concatenate two `&str` strings\n   |  \
    \                       &str\n   |\n   = note: string concatenation requires an\
    \ owned `String` on the left\nhelp: create an owned `String` from a string reference\n\
    \   |\n25 |         new_sentence += new_word.to_owned() + \" \";\n   |       \
    \                          +++++++++++\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace();\n\n  \
    \  let mut result = String::new();\n\n    while let Some(word) = words.pop() {\n\
    \        let len = count_prime_numbers_in_word(word);\n        if len == 1 {\n\
    \            result.push_str(word);\n        } else {\n            result.push_str(word);\n\
    \            result.push_str(\" \");\n            result.push_str(&format!(\"\
    {}\", len));\n        }\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `count_prime_numbers_in_word` in this\
    \ scope\n  --> /tmp/tmpae_xxbmz.rs:21:19\n   |\n21 |         let len = count_prime_numbers_in_word(word);\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `pop` found for struct `SplitWhitespace` in the\
    \ current scope\n  --> /tmp/tmpae_xxbmz.rs:20:34\n   |\n20 |     while let Some(word)\
    \ = words.pop() {\n   |                                  ^^^ method not found\
    \ in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug::assert_valid_input(sentence);\n    // Find the\
    \ first space after a letter.\n    let mut index = 0;\n    let mut current = sentence.chars().nth(1).unwrap();\n\
    \    while let Some(c) = (current as u32).chr() {\n        if c < 'A' || c > 'Z'\
    \ {\n            break;\n        }\n        index += 1;\n        current = sentence.chars().nth(index).unwrap();\n\
    \    }\n    // Create a substring including all the words up to that point.\n\
    \    let mut result = String::new();\n    for start in 0..index {\n        result.push_str(sentence.chars().nth(start\
    \ as usize).unwrap());\n    }\n    // Find the last space before that point.\n\
    \    let mut last = 0;\n    let mut current = sentence.chars().nth(index).unwrap();\n\
    \    while let Some(c) = (current as u32).chr() {\n        if c < 'A' || c > 'Z'\
    \ {\n            break;\n        }\n        last = index;\n        index += 1;\n\
    \        current = sentence.chars().nth(index).unwrap();\n    }\n    // Add the\
    \ remaining words.\n    while last < index {\n        result.push_str(sentence.chars().nth(last\
    \ as usize).unwrap());\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `debug`\n\
    \  --> /tmp/tmplykac32b.rs:16:5\n   |\n16 |     debug::assert_valid_input(sentence);\n\
    \   |     ^^^^^ use of undeclared crate or module `debug`\n\nerror[E0599]: no\
    \ method named `chr` found for type `u32` in the current scope\n  --> /tmp/tmplykac32b.rs:20:42\n\
    \   |\n20 |     while let Some(c) = (current as u32).chr() {\n   |           \
    \                               ^^^ method not found in `u32`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmplykac32b.rs:30:25\n   |\n30 |         result.push_str(sentence.chars().nth(start\
    \ as usize).unwrap());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror[E0599]: no method named `chr` found for\
    \ type `u32` in the current scope\n  --> /tmp/tmplykac32b.rs:35:42\n   |\n35 |\
    \     while let Some(c) = (current as u32).chr() {\n   |                     \
    \                     ^^^ method not found in `u32`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmplykac32b.rs:45:25\n   |\n45 |         result.push_str(sentence.chars().nth(last\
    \ as usize).unwrap());\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `char`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0433, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::from(\"\");\n    let\
    \ mut prime_numbers = vec![2, 3];\n    for i in 0..sentence.len() {\n        let\
    \ mut current_prime_number = 1;\n        let mut current_word = \"\";\n      \
    \  match sentence[i] {\n            'a' => {\n                new_sentence.push_str(\"\
    a\");\n            }\n            'e' => {\n                new_sentence.push_str(\"\
    e\");\n            }\n            'i' => {\n                new_sentence.push_str(\"\
    i\");\n            }\n            'o' => {\n                new_sentence.push_str(\"\
    o\");\n            }\n            'u' => {\n                new_sentence.push_str(\"\
    u\");\n            }\n            'A' => {\n                new_sentence.push_str(\"\
    A\");\n            }\n            'E' => {\n                new_sentence.push_str(\"\
    E\");\n            }\n            'I' => {\n                new_sentence.push_str(\"\
    I\");\n            }\n            'O' => {\n                new_sentence.push_str(\"\
    O\");\n            }\n            'U' => {\n                new_sentence.push_str(\"\
    U\");\n            }\n            _ => {\n                current_word.push(sentence[i]);\n\
    \            }\n        }\n        let mut first_prime_number = prime_numbers.first();\n\
    \        while first_prime_number <= current_prime_number {\n            prime_numbers.remove(&first_prime_number);\n\
    \            current_prime_number *= prime_numbers.last() + 1;\n        }\n  \
    \      while current_prime_number <= 100 {\n            new_sentence += &current_word;\n\
    \            current_prime_number *= prime_numbers.last() + 1;\n        }\n  \
    \  }\n    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpnv_gaynt.rs:21:15\n\
    \   |\n21 |         match sentence[i] {\n   |               ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `push` found for reference `&str`\
    \ in the current scope\n  --> /tmp/tmpnv_gaynt.rs:53:30\n   |\n53 |          \
    \       current_word.push(sentence[i]);\n   |                              ^^^^\
    \ method not found in `&str`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpnv_gaynt.rs:53:35\n   |\n53 |                 current_word.push(sentence[i]);\n\
    \   |                                   ^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnv_gaynt.rs:57:37\n\
    \   |\n57 |         while first_prime_number <= current_prime_number {\n   | \
    \                                    ^^^^^^^^^^^^^^^^^^^^ expected enum `Option`,\
    \ found integer\n   |\n   = note: expected enum `Option<&{integer}>`\n       \
    \       found type `{integer}`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnv_gaynt.rs:58:34\n\
    \   |\n58 |             prime_numb"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.chars().filter(|c| c < 'a' || c > 'z').map(|c|\
    \ {\n        c.to_string().chars().filter(|c| c != 'a' && c != 'e' && c != 'i'\
    \ && c != 'o'\n                                              && c != 'u' && c\
    \ != 'y').collect::<Vec<_>>()\n    }).collect::<Vec<_>>()\n        .iter()\n \
    \       .filter(|w| *w.len() == 3).collect::<Vec<_>>()\n        .iter()\n    \
    \    .cloned()\n        .sort();\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpocc2f_8e.rs:16:37\n   |\n\
    16 |     sentence.chars().filter(|c| c < 'a' || c > 'z').map(|c| {\n   |     \
    \                                ^^^\n   |                                   \
    \  |\n   |                                     expected `&char`, found `char`\n\
    \   |                                     help: consider borrowing here: `&'a'`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpocc2f_8e.rs:16:48\n   |\n16 |\
    \     sentence.chars().filter(|c| c < 'a' || c > 'z').map(|c| {\n   |        \
    \                                        ^^^\n   |                           \
    \                     |\n   |                                                expected\
    \ `&char`, found `char`\n   |                                                help:\
    \ consider borrowing here: `&'z'`\n\nerror[E0277]: can't compare `&char` with\
    \ `char`\n  --> /tmp/tmpocc2f_8e.rs:17:44\n   |\n17 |         c.to_string().chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o'\n   |                         \
    \                   ^^ no implementation for `&char == char`\n   |\n   = help:\
    \ the trait `PartialEq<char>` is not implemented for `&char`\n   = help: the trait\
    \ `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare `&char`\
    \ with `char`\n  --> /tmp/tmpocc2f_8e.rs:17:56\n   |\n17 |         c.to_string().chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o'\n   |                         \
    \                               ^^ no implementation for `&char == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&char`\n   = help:\
    \ the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can't compare\
    \ `&char` with `char`\n  --> /tmp/tmpocc2f_8e.rs:17:68\n   |\n17 |         c.to_string().chars().filter(|c|\
    \ c != 'a' && c != 'e' && c != 'i' && c != 'o'\n   |                         \
    \                                           ^^ no implementation for `&char ==\
    \ char`\n   |\n   = help: the trait `PartialEq<char>` is not implemented for `&char`\n\
    \   = help: the trait `PartialEq` is implemented for `char`\n\nerror[E0277]: can'"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Fill this in.\n    let mut new_string = \"\";\n\
    \    for word in sentence.split_whitespace() {\n        if new_string.is_empty()\
    \ {\n            new_string = word;\n        } else {\n            for next_word\
    \ in new_string.split_whitespace() {\n                if next_word == word {\n\
    \                    new_string += &next_word;\n                    break;\n \
    \               }\n            }\n        }\n    }\n    new_string\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0368]: binary assignment operation `+=` cannot be applied to type\
    \ `&str`\n  --> /tmp/tmpefdpv9uv.rs:24:21\n   |\n24 |                     new_string\
    \ += &next_word;\n   |                     ----------^^^^^^^^^^^^^^\n   |    \
    \                 |\n   |                     cannot use `+=` on type `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpefdpv9uv.rs:30:5\n   |\n15 | fn\
    \ words_in_sentence(sentence: String) -> String {\n   |                      \
    \                     ------ expected `String` because of return type\n...\n30\
    \ |     new_string\n   |     ^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0368.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = Vec::new();\n    let mut ans = String::new();\n\
    \    let mut prime = &0;\n    let mut i = 2;\n    while i < sentence.len() {\n\
    \        let mut k = i;\n        while k >= 2 && primes.contains(&k) {\n     \
    \       k -= 2;\n        }\n        ans.push_str(&sentence[k]);\n        primes.push(k);\n\
    \        i += 2;\n    }\n    ans.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpqdoc88xq.rs:25:23\n\
    \   |\n25 |         ans.push_str(&sentence[k]);\n   |                       ^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut counter = HashMap::new();\n    let mut temp_words:\
    \ Vec<&str> = sentence.split_whitespace().collect();\n\n    while temp_words.len()\
    \ > 0 {\n        let word = temp_words.remove(0).unwrap();\n        if !counter.contains_key(&word)\
    \ {\n            counter.insert(word, 1);\n        } else {\n            let old_len\
    \ = counter.get(&word).unwrap();\n            if old_len == 2 {\n            \
    \    counter.insert(word, 1);\n            } else if old_len > 2 {\n         \
    \       counter.insert(word, old_len + 1);\n            }\n        }\n    }\n\n\
    \    let mut new_words = String::with_capacity(sentence.len());\n    for (word,\
    \ _) in counter.iter() {\n        new_words.push_str(word);\n    }\n\n    new_words\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpza37x9zn.rs:16:23\n   |\n16 |     let mut counter = HashMap::new();\n\
    \   |                       ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `unwrap` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpza37x9zn.rs:20:41\n   |\n20 |         let word = temp_words.remove(0).unwrap();\n\
    \   |                                         ^^^^^^ method not found in `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0433, E0599.\nFor more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    for word in sentence.split_whitespace()\
    \ {\n        if check_capitalization(word) {\n            result.push(capitalization(word));\n\
    \        } else {\n            result.push(word);\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_capitalization` in this scope\n\
    \  --> /tmp/tmperm76aif.rs:18:12\n   |\n18 |         if check_capitalization(word)\
    \ {\n   |            ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `capitalization` in this scope\n  --> /tmp/tmperm76aif.rs:19:25\n\
    \   |\n19 |             result.push(capitalization(word));\n   |             \
    \            ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmperm76aif.rs:21:25\n   |\n21 |             result.push(word);\n\
    \   |                         ^^^^ expected `char`, found `&str`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![1];\n    for i in 1..sentence.len()\
    \ {\n        let mut temp = 1;\n        for j in 0..i.i*i {\n            if !temp%j\
    \ {\n                temp += 1;\n            }\n        }\n        primes.push(temp);\n\
    \    }\n    let mut result = String::new();\n    for i in 1..sentence.len() {\n\
    \        if primes[sentence.len() - i] == primes.last() {\n            result\
    \ += &sentence[i..];\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0610]: `usize` is a primitive type and therefore doesn't have fields\n\
    \  --> /tmp/tmp0aeu1i78.rs:19:23\n   |\n19 |         for j in 0..i.i*i {\n   |\
    \                       ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0aeu1i78.rs:20:16\n\
    \   |\n20 |             if !temp%j {\n   |                ^^^^^^^ expected `bool`,\
    \ found integer\n\nerror[E0277]: can't compare `{integer}` with `Option<&{integer}>`\n\
    \  --> /tmp/tmp0aeu1i78.rs:28:39\n   |\n28 |         if primes[sentence.len()\
    \ - i] == primes.last() {\n   |                                       ^^ no implementation\
    \ for `{integer} == Option<&{integer}>`\n   |\n   = help: the trait `PartialEq<Option<&{integer}>>`\
    \ is not implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0610.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // TODO\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpg5_c2ad1.rs:15:43\n   |\n\
    15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Split sentence into words\n    let words = sentence.split_whitespace();\n\
    \n    // Return the result string\n    String::from(words.collect::<Vec<String>>().iter().filter_map(|word|\
    \ is_prime(word.len())).collect::<String>().join(\" \"))\n}\n\nfn main() {\n \
    \   let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpajekr7fs.rs:20:74\n\
    \   |\n20 |     String::from(words.collect::<Vec<String>>().iter().filter_map(|word|\
    \ is_prime(word.len())).collect::<String>().join(\" \"))\n   |               \
    \                                                           ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0277]: a value of type `Vec<String>` cannot be built\
    \ from an iterator over elements of type `&str`\n    --> /tmp/tmpajekr7fs.rs:20:24\n\
    \     |\n20   |     String::from(words.collect::<Vec<String>>().iter().filter_map(|word|\
    \ is_prime(word.len())).collect::<String>().join(\" \"))\n     |             \
    \           ^^^^^^^ value of type `Vec<String>` cannot be built from `std::iter::Iterator<Item=&str>`\n\
    \     |\n     = help: the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `join` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpajekr7fs.rs:20:116\n   |\n20 |\
    \     String::from(words.collect::<Vec<String>>().iter().filter_map(|word| is_prime(word.len())).collect::<String>().join(\"\
    \ \"))\n   |                                                                 \
    \                                                   ^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::with_capacity(sentence.len());\n\
    \    let mut char_count = char_counts(&sentence);\n    let mut primes = prime_factors(char_count.value());\n\
    \    let mut prime_iter = primes.into_iter().chain(char_count.iter());\n    let\
    \ mut char_iter = sentence.chars().chain(&prime_iter);\n\n    let mut current_word\
    \ = \"\";\n\n    for c in char_iter {\n        if primes.contains(c) && (primes.len()\
    \ == 1 || c == '_') {\n            result.push_str(&current_word);\n         \
    \   current_word = \"\";\n        } else {\n            current_word.push(c);\n\
    \        }\n    }\n\n    if current_word.len() > 0 {\n        result.push_str(&current_word);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_counts` in this scope\n  --> /tmp/tmpxn1suy3e.rs:17:26\n\
    \   |\n17 |     let mut char_count = char_counts(&sentence);\n   |           \
    \               ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `prime_factors` in this scope\n  --> /tmp/tmpxn1suy3e.rs:18:22\n  \
    \ |\n18 |     let mut primes = prime_factors(char_count.value());\n   |      \
    \                ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `push` found for reference `&str` in the current scope\n  --> /tmp/tmpxn1suy3e.rs:29:26\n\
    \   |\n29 |             current_word.push(c);\n   |                          ^^^^\
    \ method not found in `&str`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.split_whitespace())\n}\n\
    \nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpn6fal14n.rs:16:23\n   |\n\
    16 |     words_in_sentence(sentence.split_whitespace())\n   |                \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found struct `SplitWhitespace`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = String::new();\n    let mut length\
    \ = sentence.len();\n    loop {\n        match length {\n            0 => return\
    \ words,\n            _ => (),\n        }\n        let mut lengths = Vec::new();\n\
    \        let mut s = String::new();\n        for i in 0..(length - 1) {\n    \
    \        let mut temp = String::new();\n            temp.resize(length, ' ');\n\
    \            temp[i] = sentence[i];\n            temp[length - 1] = '\\n';\n \
    \           s.push(temp);\n            lengths.push(s.len());\n        }\n   \
    \     let mut new_s = String::new();\n        for i in lengths.iter() {\n    \
    \        let mut new_sb = String::new();\n            new_sb.resize(i, ' ');\n\
    \            new_sb[i - 1] = '\\n';\n            new_s.push(new_sb);\n       \
    \ }\n        words.push(new_s);\n        length -= 1;\n    }\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `resize` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpxktxekcx.rs:27:18\n   |\n27 |             temp.resize(length,\
    \ ' ');\n   |                  ^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxktxekcx.rs:28:13\n\
    \   |\n28 |             temp[i] = sentence[i];\n   |             ^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxktxekcx.rs:28:23\n   |\n28 |             temp[i] = sentence[i];\n\
    \   |                       ^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpxktxekcx.rs:29:13\n   |\n29 |             temp[length - 1] = '\\\
    n';\n   |             ^^^^^^^^^^^^^^^^ `String` cannot be indexed by `usize`\n\
    \   |\n   = help: the trait `Index<usize>` is not implemented for `String`\n \
    \  = help: the following other types implement trait `Index<Idx>`:\n         \
    \    <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![2, 3];\n    let mut res = String::from(\"\
    1\");\n    let mut len = sentence.size();\n    for i in 0..len {\n        if primes.iter().any(|&x|\
    \ *x == len % x) {\n            primes.push(len % primes.iter().max().unwrap()\
    \ + 1);\n        }\n        res += sentence.chars().nth(i).unwrap().to_string();\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n  \
    \  assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `size` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmprnbud1jf.rs:18:28\n   |\n18 |     let mut len = sentence.size();\n\
    \   |                            ^^^^ method not found in `String`\n\nerror[E0614]:\
    \ type `{integer}` cannot be dereferenced\n  --> /tmp/tmprnbud1jf.rs:20:35\n \
    \  |\n20 |         if primes.iter().any(|&x| *x == len % x) {\n   |          \
    \                         ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmprnbud1jf.rs:23:16\n\
    \   |\n23 |         res += sentence.chars().nth(i).unwrap().to_string();\n   |\
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |          \
    \      |\n   |                expected `&str`, found struct `String`\n   |   \
    \             help: consider borrowing here: `&sentence.chars().nth(i).unwrap().to_string()`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.len() <= 0 {\n        return String::from(\"\
    \\n\");\n    }\n    let mut prime_numbers = Vec::new();\n    let mut prime_numbers_count\
    \ = 0;\n    let mut prime_numbers_sum = 0;\n    for letter in sentence.chars()\
    \ {\n        let letter_index: usize = sentence\n            .char_indices()\n\
    \            .position(|&(_, letter)| letter == letter)\n            .unwrap();\n\
    \        let prime_number = if letter_index == 0 {\n            1\n        } else\
    \ {\n            prime_numbers[letter_index - 1] + 1\n        };\n        if prime_number\
    \ > 100 {\n            break;\n        }\n        prime_numbers_sum += prime_number;\n\
    \        if prime_numbers_count > prime_numbers_sum {\n            prime_numbers\
    \ = prime_numbers[prime_numbers_count..].clone();\n            prime_numbers_count\
    \ = prime_numbers_sum;\n        }\n    }\n    if prime_numbers_count == prime_numbers_sum\
    \ {\n        prime_numbers.clone()\n    } else {\n        let mut index = 0;\n\
    \        let mut new_prime_numbers = prime_numbers.clone();\n        while new_prime_numbers[index]\
    \ != index {\n            index += 1;\n        }\n        let mut new_prime_numbers_set\
    \ = prime_numbers.to_set();\n        let mut new_prime_numbers_vec = prime_numbers.iter().cloned().collect();\n\
    \        let mut new_prime_numbers_string = String::new();\n        for prime_number\
    \ in &new_prime_numbers {\n            new_prime_numbers_string\n            \
    \    .push_str(&new_prime_numbers_vec[prime_number]);\n        }\n        new_prime_numbers_string\n\
    \    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmph3ki63fr.rs:25:24\n   |\n\
    25 |             .position(|&(_, letter)| letter == letter)\n   |            \
    \            ^^^^^^^^^^^-\n   |                        |          |\n   |    \
    \                    |          expected due to this\n   |                   \
    \     expected tuple, found reference\n   |\n   = note:  expected tuple `(usize,\
    \ char)`\n           found reference `&_`\n\nerror[E0599]: no method named `clone`\
    \ found for slice `[_]` in the current scope\n  --> /tmp/tmph3ki63fr.rs:37:66\n\
    \   |\n37 |             prime_numbers = prime_numbers[prime_numbers_count..].clone();\n\
    \   |                                                                  ^^^^^ method\
    \ not found in `[_]`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmph3ki63fr.rs:42:9\n\
    \   |\n15 | fn words_in_sentence(sentence: String) -> String {\n   |         \
    \                                  ------ expected `String` because of return\
    \ type\n...\n42 |         prime_numbers.clone()\n   |         ^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found struct `Vec`\n   |\n   = note: expected struct\
    \ `String`\n              found struct `Vec<_>`\n\nerror[E0599]: no method named\
    \ `to_set` found for struct `Vec<_>` in the current scope\n  --> /tmp/tmph3ki63fr.rs:49:55\n\
    \   |\n49 |         let mut new_prime_numbers_set = prime_numbers.to_set();\n\
    \   |                                                       ^^^^^^ help: there\
    \ is an associated function with a similar name: `to_vec`\n\nerror: aborting due\
    \ to 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.chars().filter(|c| !c.is_letter()).count()\
    \ > 1 {\n        String::from(\"No Primes\")\n    } else {\n        let mut primes\
    \ = Vec::new();\n        let mut words = String::new();\n        let mut i = 1;\n\
    \        let mut j = 0;\n        for c in sentence.chars().cloned() {\n      \
    \      if i % j == 0 {\n                primes.push(j);\n            }\n     \
    \       i += 1;\n            j += 1;\n        }\n        for prime in &primes\
    \ {\n            words += &sentence[i..i+prime].join(\" \");\n            i +=\
    \ prime;\n        }\n        words\n    }\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for reference `&char` in\
    \ the current scope\n  --> /tmp/tmpf80qsm85.rs:16:39\n   |\n16 |     if sentence.chars().filter(|c|\
    \ !c.is_letter()).count() > 1 {\n   |                                       ^^^^^^^^^\
    \ method not found in `&char`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n    --> /tmp/tmpf80qsm85.rs:23:35\n     |\n23   |\
    \         for c in sentence.chars().cloned() {\n     |                       \
    \            ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item\
    \ == &_`\n  --> /tmp/tmpf80qsm85.rs:23:18\n   |\n23 |         for c in sentence.chars().cloned()\
    \ {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmpf80qsm85.rs:23:18\n   |\n23 |     \
    \    for c in sentence.chars().cloned() {\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror[E0599]: no method\
    \ named `join` found for type `str` in the current scope\n  --> /tmp/tmpf80qsm85.rs:31:44\n\
    \   |\n31 |             words += &sentence[i..i+prime].join(\" \");\n   |    \
    \                                        ^^^^ method not found in `str`\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = HashSet::new();\n    let mut sentence\
    \ = sentence.split_whitespace();\n    for word in sentence {\n        if primes.contains(word)\
    \ {\n            primes.remove(word);\n        } else {\n            primes.insert(word);\n\
    \        }\n    }\n    sentence.iter().map(|w| w.to_string()).collect::<String>().to_string()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashSet`\n  -->\
    \ /tmp/tmp3hl71xm1.rs:16:22\n   |\n16 |     let mut primes = HashSet::new();\n\
    \   |                      ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror[E0599]:\
    \ no method named `iter` found for struct `SplitWhitespace` in the current scope\n\
    \  --> /tmp/tmp3hl71xm1.rs:25:14\n   |\n25 |     sentence.iter().map(|w| w.to_string()).collect::<String>().to_string()\n\
    \   |              ^^^^ method not found in `SplitWhitespace<'_>`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0433, E0599.\n\
    For more information about an error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut counter = 1;\n    let mut prime_words = [0;\
    \ 100];\n\n    for c in sentence.chars() {\n        if c == ' ' || c == '.' {\n\
    \            counter = 1;\n        } else {\n            if counter % 2 == 0 {\n\
    \                prime_words[counter as usize] = 1;\n            } else {\n  \
    \              prime_words[counter as usize] = prime_words[counter as usize] +\
    \ 1;\n            }\n            counter = counter + 1;\n        }\n    }\n\n\
    \    let mut new_sentence = \"\";\n    for idx in prime_words {\n        if idx\
    \ == 0 {\n            new_sentence.push_str(\" \");\n        } else {\n      \
    \      new_sentence.push_str(&sentence[idx as usize - 1]);\n        }\n    }\n\
    \n    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push_str` found for reference `&str` in\
    \ the current scope\n  --> /tmp/tmpoikhvpsn.rs:35:26\n   |\n35 |             new_sentence.push_str(\"\
    \ \");\n   |                          ^^^^^^^^ method not found in `&str`\n\n\
    error[E0599]: no method named `push_str` found for reference `&str` in the current\
    \ scope\n  --> /tmp/tmpoikhvpsn.rs:37:26\n   |\n37 |             new_sentence.push_str(&sentence[idx\
    \ as usize - 1]);\n   |                          ^^^^^^^^ method not found in\
    \ `&str`\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n  -->\
    \ /tmp/tmpoikhvpsn.rs:37:36\n   |\n37 |             new_sentence.push_str(&sentence[idx\
    \ as usize - 1]);\n   |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoikhvpsn.rs:41:5\n\
    \   |\n15 | fn words_in_sentence(sentence: String) -> String {\n   |         \
    \                                  ------ expected `String` because of return\
    \ type\n...\n41 |     new_sentence\n   |     ^^^^^^^^^^^^- help: try using a conversion\
    \ method: `.to_string()`\n   |     |\n   |     expected struct `String`, found\
    \ `&str`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n    sentence.split_whitespace().filter(|x|\
    \ x.chars().all(|c| c.is_letter())).collect::<Vec<_>>().join(\" \")\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_letter` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpxmty00bq.rs:17:64\n   |\n17 |     sentence.split_whitespace().filter(|x|\
    \ x.chars().all(|c| c.is_letter())).collect::<Vec<_>>().join(\" \")\n   |    \
    \                                                            ^^^^^^^^^ method\
    \ not found in `char`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = sentence.split_whitespace().collect::<Vec<_>>();\n\
    \    let mut answer = String::with_capacity(sentence.len());\n    for word in\
    \ words {\n        let mut prime = true;\n        for c in word.chars() {\n  \
    \          if !prime.checked_mul(c.len_utf8()) {\n                prime = false;\n\
    \                break;\n            }\n        }\n        if prime {\n      \
    \      answer.push_str(&word);\n        }\n    }\n    answer\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `checked_mul` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmpda4_1u51.rs:21:23\n   |\n21 |             if !prime.checked_mul(c.len_utf8())\
    \ {\n   |                       ^^^^^^^^^^^ method not found in `bool`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    solve(sentence, 2)\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve` in this scope\n  --> /tmp/tmpfljpzijf.rs:16:5\n\
    \   |\n16 |     solve(sentence, 2)\n   |     ^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    require(1 <= sentence.len(), \"Invalid Input: sentence\
    \ cannot have more or less than 1 character\");\n    let mut prime_number_word\
    \ = String::from(\"\");\n    let mut prime_number_sentence = String::from(\"\"\
    );\n    for word in sentence.split_whitespace() {\n        let mut prime_number_word\
    \ = String::from(\"\");\n        let mut prime_number_sentence = String::from(\"\
    \");\n        let mut prime_number = 2;\n        for letter in word.chars() {\n\
    \            if !prime_number_word.contains(letter) {\n                prime_number_word\
    \ += letter;\n                if prime_number % prime_number_sentence.len() ==\
    \ 0 {\n                    prime_number_sentence += letter;\n                }\n\
    \                prime_number += 1;\n            }\n        }\n        prime_number_word\
    \ = prime_number_word.to_string();\n        prime_number_sentence = prime_number_sentence.to_string();\n\
    \        prime_number_sentence.push(prime_number_word);\n    }\n    prime_number_sentence\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `require` in this scope\n  --> /tmp/tmpdpimjhzr.rs:16:5\n\
    \   |\n16 |     require(1 <= sentence.len(), \"Invalid Input: sentence cannot\
    \ have more or less than 1 character\");\n   |     ^^^^^^^ not found in this scope\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdpimjhzr.rs:25:38\n   |\n25 |\
    \                 prime_number_word += letter;\n   |                         \
    \             ^^^^^^ expected `&str`, found `char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpdpimjhzr.rs:27:46\n   |\n27 |                     prime_number_sentence\
    \ += letter;\n   |                                              ^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpdpimjhzr.rs:34:36\n\
    \   |\n34 |         prime_number_sentence.push(prime_number_word);\n   |     \
    \                               ^^^^^^^^^^^^^^^^^ expected `char`, found struct\
    \ `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425.\nFor more information about an error, try `rustc\
    \ --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().map(|word| is_prime(word.len()))\n\
    \        .flatten().collect::<Vec<&str>>()\n        .collect::<String>()\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvqty5qj1.rs:16:44\n\
    \   |\n16 |     sentence.split_whitespace().map(|word| is_prime(word.len()))\n\
    \   |                                            ^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: `Vec<&str>` is not an iterator\n   --> /tmp/tmpvqty5qj1.rs:18:10\n\
    \    |\n18  |           .collect::<String>()\n    |            ^^^^^^^ `Vec<&str>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<&str>: Iterator`\n            which is required by `&mut Vec<&str>:\
    \ Iterator`\n            `[&str]: Iterator`\n            which is required by\
    \ `&mut [&str]: Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    match is_prime_string(sentence) {\n        Ok(true)\
    \ => sentence,\n        Ok(false) => panic!(\"The sentence must have at least\
    \ one prime number\"),\n        Err(e) => {\n            eprintln!(\"is_prime_string():\
    \ {}\", e);\n            String::new()\n        }\n    }\n}\n\nfn main() {\n \
    \   let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime_string` in this scope\n  -->\
    \ /tmp/tmpwhkucp1t.rs:16:11\n   |\n16 |     match is_prime_string(sentence) {\n\
    \   |           ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence\n        .split(' ')\n        .iter()\n  \
    \      .filter(|&x| x.is_ascii_lowercase())\n        .map(|x| x.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp4w_ailhc.rs:18:10\n   |\n18 |         .iter()\n\
    \   |          ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    solve(sentence)\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `solve` in this scope\n  --> /tmp/tmpmk8zq59o.rs:16:5\n\
    \   |\n16 |     solve(sentence)\n   |     ^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut primes\
    \ = vec![2, 3];\n\n    for i in 0..sentence.len() {\n        let s = sentence[i..].as_str();\n\
    \        let mut is_prime = true;\n        for p in primes.iter() {\n        \
    \    if s.len() < p {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n        if is_prime {\n            result.push_str(&s);\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `as_str` found for type `str` in the current\
    \ scope\n  --> /tmp/tmpcmcr_066.rs:20:31\n   |\n20 |         let s = sentence[i..].as_str();\n\
    \   |                              -^^^^^^-- help: remove this method call\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_words: Vec<i64> = vec![1; sentence.chars().count()];\n\
    \    for prime_word in prime_words.iter_mut() {\n        if prime_word % 2 ==\
    \ 0 {\n            for word in sentence.split(\" \").iter() {\n              \
    \  *word += prime_word % 10;\n            }\n        }\n    }\n    let mut result\
    \ = String::new();\n    for word in sentence.split(\" \").iter() {\n        if\
    \ prime_words[word.chars().count()-1] == 0 {\n            result.push_str(\" \"\
    );\n        } else {\n            result.push_str(word);\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot mod `&mut i64` by `{integer}`\n  --> /tmp/tmpq6y_jr81.rs:18:23\n\
    \   |\n18 |         if prime_word % 2 == 0 {\n   |            ---------- ^ - {integer}\n\
    \   |            |\n   |            &mut i64\n   |\nhelp: `%` can be used on `i64`,\
    \ you can dereference `prime_word`\n   |\n18 |         if *prime_word % 2 == 0\
    \ {\n   |            +\n\nerror[E0599]: no method named `iter` found for struct\
    \ `std::str::Split` in the current scope\n  --> /tmp/tmpq6y_jr81.rs:19:45\n  \
    \ |\n19 |             for word in sentence.split(\" \").iter() {\n   |       \
    \                                      ^^^^ method not found in `std::str::Split<'_,\
    \ &str>`\n\nerror[E0369]: cannot mod `&mut i64` by `{integer}`\n  --> /tmp/tmpq6y_jr81.rs:20:37\n\
    \   |\n20 |                 *word += prime_word % 10;\n   |                  \
    \        ---------- ^ -- {integer}\n   |                          |\n   |    \
    \                      &mut i64\n   |\nhelp: `%` can be used on `i64`, you can\
    \ dereference `prime_word`\n   |\n20 |                 *word += *prime_word %\
    \ 10;\n   |                          +\n\nerror[E0599]: no method named `iter`\
    \ found for struct `std::str::Split` in the current scope\n  --> /tmp/tmpq6y_jr81.rs:25:37\n\
    \   |\n25 |     for word in sentence.split(\" \").iter() {\n   |             \
    \                        ^^^^ method not found in `std::str::Split<'_, &str>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0369, E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::new();\n    let mut prime_nums\
    \ = vec![];\n    for n in 0..100 {\n        if n%2 == 0 || n%3 == 0 {\n      \
    \      let s = primes(n, &sentence).unwrap();\n            prime_nums.push(s.len());\n\
    \            for (idx, item) in s.into_iter().zip(sentence.chars().filter(|&x|\
    \ x != ' ')) {\n                res.push(item.to_string());\n            }\n \
    \       }\n    }\n    res += \"\\n\";\n    for (idx, item) in prime_nums.into_iter().enumerate()\
    \ {\n        res.push_str(&item.to_string());\n        res.push_str(\",\");\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n  \
    \  assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `primes` in this scope\n  --> /tmp/tmpfvxmh4n_.rs:20:21\n\
    \   |\n20 |             let s = primes(n, &sentence).unwrap();\n   |         \
    \            ^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = Vec::new();\n\n    for i in 1..sentence.len()\
    \ {\n        for &c in sentence[i - 1..i].chars() {\n            primes.contains(&c.to_string());\n\
    \        }\n    }\n\n    sentence.chars().filter(|c| primes.contains(c.to_string())).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpw2pnlv3r.rs:19:13\n   |\n\
    19 |         for &c in sentence[i - 1..i].chars() {\n   |             ^^    --------------------------\
    \ this expression has type `Option<char>`\n   |             |\n   |          \
    \   expected `char`, found reference\n   |             help: you can probably\
    \ remove the explicit borrow: `c`\n   |\n   = note:   expected type `char`\n \
    \          found reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpw2pnlv3r.rs:24:49\n\
    \   |\n24 |     sentence.chars().filter(|c| primes.contains(c.to_string())).collect()\n\
    \   |                                                 ^^^^^^^^^^^^^\n   |    \
    \                                             |\n   |                        \
    \                         expected reference, found struct `String`\n   |    \
    \                                             help: consider borrowing here: `&c.to_string()`\n\
    \   |\n   = note: expected reference `&_`\n                 found struct `String`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::with_capacity(sentence.length());\n\
    \    sentence.split(' ').for_each(|word| {\n        if !new_sentence.contains(&word)\
    \ {\n            new_sentence.push_str(&word);\n            new_sentence.push_str(&\"\
    \ \");\n        }\n    });\n    new_sentence\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `length` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmp6lc45zid.rs:16:59\n   |\n16 |     let mut new_sentence\
    \ = String::with_capacity(sentence.length());\n   |                          \
    \                                 ^^^^^^ help: there is an associated function\
    \ with a similar name: `len`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut res = String::with_capacity(sentence.len());\n\
    \    for char in sentence.chars() {\n        if char.ascii_is_alphabetic() {\n\
    \            let len = char.len_utf8();\n            if len == 1 || len == 2 ||\
    \ len == 3 || len == 4 || len == 5 || len == 6 || len == 7 || len == 8 || len\
    \ == 9 {\n                let remainder = len % 2;\n                if remainder\
    \ == 0 {\n                    let mut new = (char.as_bytes().rev()[0] + char.as_bytes().rev()[1]).to_string();\n\
    \                    new.push(' ');\n                    for _ in 0..((len - 1)\
    \ / 2) {\n                        new.push(*char.as_bytes().nth(len));\n     \
    \               }\n                    res.push_str(new);\n                } else\
    \ {\n                    res.push_str(&char.as_bytes().rev()[0]);\n          \
    \      }\n            } else {\n                res.push_str(&char);\n       \
    \     }\n        } else {\n            res.push_str(&char);\n        }\n    }\n\
    \    return res;\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n \
    \   assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `ascii_is_alphabetic` found for type `char`\
    \ in the current scope\n  --> /tmp/tmp5zedxz9u.rs:18:17\n   |\n18 |         if\
    \ char.ascii_is_alphabetic() {\n   |                 ^^^^^^^^^^^^^^^^^^^ help:\
    \ there is an associated function with a similar name: `is_alphabetic`\n\nerror[E0599]:\
    \ no method named `as_bytes` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp5zedxz9u.rs:23:41\n   |\n23 |                     let mut new = (char.as_bytes().rev()[0]\
    \ + char.as_bytes().rev()[1]).to_string();\n   |                             \
    \            ^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method named\
    \ `as_bytes` found for type `char` in the current scope\n  --> /tmp/tmp5zedxz9u.rs:23:68\n\
    \   |\n23 |                     let mut new = (char.as_bytes().rev()[0] + char.as_bytes().rev()[1]).to_string();\n\
    \   |                                                                    ^^^^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `as_bytes` found\
    \ for type `char` in the current scope\n  --> /tmp/tmp5zedxz9u.rs:26:40\n   |\n\
    26 |                         new.push(*char.as_bytes().nth(len));\n   |      \
    \                                  ^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `as_bytes` found for type `char` in the current scope\n  -->\
    \ /tmp/tmp5zedxz9u.rs:30:40\n   |\n30 |                     res.push_str(&char.as_bytes().rev()[0]);\n\
    \   |                                        ^^^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp5zedxz9u.rs:33:30\n   |\n33 |\
    \                 res.push_str(&char);\n   |                              ^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp5zedxz9u.rs:36:26\n   |\n36 |             res.push_str(&char);\n   |\
    \                          ^^^^^ expected `str`, found `char`\n   |\n   = note:\
    \ expected reference `&str`\n              found reference `&char`\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have de"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // write your code here\n    let mut s = String::from(\"\
    \");\n    for c in sentence.chars().collect::<Vec<_>>() {\n        if c.is_whitespace()\
    \ {\n            continue;\n        }\n        let mut n = 1;\n        while n\
    \ % c.len_utf8() > 0 {\n            n = n+1;\n        }\n        if n == 2 {\n\
    \            s += c.to_string();\n        }\n        if n == c.len_utf8()+1 {\n\
    \            s += \" \";\n        }\n        if n % c.len_utf8() > 0 {\n     \
    \       s += \"a\";\n        }\n    }\n    \n    return s;\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmptxampbej.rs:27:18\n   |\n\
    27 |             s += c.to_string();\n   |                  ^^^^^^^^^^^^^\n  \
    \ |                  |\n   |                  expected `&str`, found struct `String`\n\
    \   |                  help: consider borrowing here: `&c.to_string()`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    let mut prime_nums\
    \ = Vec::new();\n    let mut prime_words: Vec<bool> = Vec::new();\n    let mut\
    \ word_list = sentence.split_whitespace().to_vec();\n    for i in (0..word_list.len()).rev()\
    \ {\n        for j in (0..i).rev() {\n            if prime_words[j] {\n      \
    \          break;\n            }\n            if i == j {\n                continue;\n\
    \            }\n            let mut prime = false;\n            for num in prime_nums.iter().rev()\
    \ {\n                if num % word_list[i] == 0 {\n                    prime =\
    \ true;\n                    break;\n                }\n            }\n      \
    \      if prime {\n                continue;\n            }\n            prime_nums.push(word_list[i]);\n\
    \            prime_words.push(true);\n            result.push((word_list[i]).to_string());\n\
    \        }\n    }\n    if prime_nums.len() <= 1 {\n        prime_nums.sort();\n\
    \        prime_words.sort();\n    }\n    result.push_str(prime_nums.to_ascii_lowercase());\n\
    \    result.push_str(\", \");\n    result.push_str(prime_words.to_ascii_lowercase());\n\
    \    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_vec` found for struct `SplitWhitespace`\
    \ in the current scope\n  --> /tmp/tmp8dy7qrc5.rs:19:53\n   |\n19 |     let mut\
    \ word_list = sentence.split_whitespace().to_vec();\n   |                    \
    \                                 ^^^^^^ method not found in `SplitWhitespace<'_>`\n\
    \nerror[E0599]: no method named `to_ascii_lowercase` found for struct `Vec<bool>`\
    \ in the current scope\n  --> /tmp/tmp8dy7qrc5.rs:49:33\n   |\n49 |     result.push_str(prime_words.to_ascii_lowercase());\n\
    \   |                                 ^^^^^^^^^^^^^^^^^^ method not found in `Vec<bool>`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    let mut primes:\
    \ Vec<_> = vec![];\n    for &s in sentence.split_whitespace() {\n        let word\
    \ = s.to_lowercase();\n        if prime_length(word) < 3 {\n            result.push_str(word);\n\
    \            continue;\n        }\n        for &c in word.chars().filter(|&c|\
    \ c > 'a' && c < 'z').count() {\n            let mut prime = true;\n         \
    \   for &i in primes.iter().rev() {\n                if c % i == 0 {\n       \
    \             prime = false;\n                    break;\n                }\n\
    \            }\n            if prime {\n                primes.push(c);\n    \
    \        }\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_length` in this scope\n  -->\
    \ /tmp/tmpdqxqdnz5.rs:20:12\n   |\n20 |         if prime_length(word) < 3 {\n\
    \   |            ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]: the size\
    \ for values of type `str` cannot be known at compilation time\n  --> /tmp/tmpdqxqdnz5.rs:18:10\n\
    \   |\n18 |     for &s in sentence.split_whitespace() {\n   |          ^ doesn't\
    \ have a size known at compile-time\n   |\n   = help: the trait `Sized` is not\
    \ implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpdqxqdnz5.rs:21:29\n   |\n21 |             result.push_str(word);\n\
    \   |                             ^^^^\n   |                             |\n \
    \  |                             expected `&str`, found struct `String`\n   |\
    \                             help: consider borrowing here: `&word`\n\nerror[E0277]:\
    \ `usize` is not an iterator\n  --> /tmp/tmpdqxqdnz5.rs:24:19\n   |\n24 |    \
    \     for &c in word.chars().filter(|&c| c > 'a' && c < 'z').count() {\n   | \
    \                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `usize`\
    \ is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(1 <= sentence.len());\n    assert!(sentence.len()\
    \ <= 100);\n    assert!(sentence.chars().all(|&x| x >= 'a' && x <= 'z'));\n\n\
    \    // Find the prime number count from 2 to length of sentence\n    let mut\
    \ prime_count = String::new();\n    for i in 2..sentence.len() {\n        if is_prime(i)\
    \ {\n            prime_count = prime_count.push_str(&sentence[i - 2]);\n     \
    \   }\n    }\n\n    let mut words: Vec<String> = sentence.split_whitespace().collect();\n\
    \    words.sort_unstable();\n\n    prime_count.push_str(&words[0..words.len()\
    \ - 1].join(\" \"))\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpus527d83.rs:23:12\n\
    \   |\n23 |         if is_prime(i) {\n   |            ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpus527d83.rs:18:35\n \
    \  |\n18 |     assert!(sentence.chars().all(|&x| x >= 'a' && x <= 'z'));\n   |\
    \                                   ^--\n   |                                \
    \   ||\n   |                                   |expected due to this\n   |   \
    \                                expected `char`, found reference\n   |      \
    \                             help: did you mean `x`: `&char`\n   |\n   = note:\
    \   expected type `char`\n           found reference `&_`\n\nerror[E0277]: the\
    \ type `String` cannot be indexed by `usize`\n  --> /tmp/tmpus527d83.rs:24:49\n\
    \   |\n24 |             prime_count = prime_count.push_str(&sentence[i - 2]);\n\
    \   |                                                 ^^^^^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpus527d83.rs:24:27\n\
    \   |\n21 |     let mut prime_count = String::new();\n   |                   \
    \        ------------- expected due to this value\n...\n24 |             prime_count\
    \ = prime_count.push_str(&sentence[i - 2]);\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push_str` modifies\
    \ its receiver in-place\n  --> /tmp/tmpus527d83.rs:24:39\n   |\n24 |         \
    \    prime_count = prime_count.push_str(&sentence[i - 2]);\n   |             \
    \              ----------- ^^^^^^^^ this call modifies `prime_count` in-"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug!(\"words_in_sentence\");\n    let mut new_sentence\
    \ = String::new();\n    let mut primes_array = [true; 100];\n\n    for word_index\
    \ in 0..sentence.len() {\n        if primes_array[word_index] {\n            new_sentence.append(&sentence[word_index]);\n\
    \            primes_array[word_index] = false;\n        }\n    }\n    return new_sentence;\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `debug` in this scope\n  --> /tmp/tmpxbf13rab.rs:16:5\n\
    \   |\n16 |     debug!(\"words_in_sentence\");\n   |     ^^^^^\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpxbf13rab.rs:22:26\n   |\n22 |             new_sentence.append(&sentence[word_index]);\n\
    \   |                          ^^^^^^ method not found in `String`\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpxbf13rab.rs:22:34\n\
    \   |\n22 |             new_sentence.append(&sentence[word_index]);\n   |    \
    \                              ^^^^^^^^^^^^^^^^^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let words = sentence.split_whitespace();\n    words_in_sentence1(words)\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence1` in this scope\n\
    \  --> /tmp/tmpz3wdehyf.rs:17:5\n   |\n17 |     words_in_sentence1(words)\n  \
    \ |     ^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.chars().any(|c| !c.is_ascii_letter()) {\n\
    \        \"\".to_string()\n    } else {\n        sentence.chars().filter(|c| c.is_ascii_letter()).map(String::from).collect()\n\
    \    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `is_ascii_letter` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpv2cpxgs0.rs:16:36\n   |\n16 |     if sentence.chars().any(|c|\
    \ !c.is_ascii_letter()) {\n   |                                    ^^^^^^^^^^^^^^^\
    \ help: there is an associated function with a similar name: `is_ascii`\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpv2cpxgs0.rs:19:39\n   |\n19 |         sentence.chars().filter(|c|\
    \ c.is_ascii_letter()).map(String::from).collect()\n   |                     \
    \                  ^^^^^^^^^^^^^^^ help: there is an associated function with\
    \ a similar name: `is_ascii`\n\nerror: aborting due to 2 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prime_numbers\
    \ = Vec::new();\n    prime_numbers.push(2);\n    for _ in 2..100 {\n        for\
    \ n in &prime_numbers {\n            let mut flag = true;\n            for (i,\
    \ c) in sentence.chars().enumerate() {\n                if i % n == 0 {\n    \
    \                flag = false;\n                    break;\n                }\n\
    \            }\n            if flag {\n                result.push_str(&sentence[i\
    \ as usize]);\n            }\n        }\n        prime_numbers.push(prime_numbers[0]+2);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `i` in this scope\n  --> /tmp/tmps24gcral.rs:29:43\n\
    \   |\n29 |                 result.push_str(&sentence[i as usize]);\n   |    \
    \                                       ^ help: a local variable with a similar\
    \ name exists: `n`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut counts: Vec<_> = sentence\n        .chars()\n\
    \        .filter_map(|c| c.is_ascii())\n        .take_while(|c| c != ' ')\n  \
    \      .count();\n    let mut prime: usize = 2;\n    while prime*prime <= counts.len()\
    \ {\n        if counts[prime as usize] == 0 {\n            prime+=1;\n       \
    \ }\n        else {\n            break;\n        }\n    }\n    let mut builder\
    \ = String::with_capacity(sentence.len());\n    for &(i, c) in sentence.chars().enumerate().rev()\
    \ {\n        if counts[i as usize] == 0 {\n            continue;\n        }\n\
    \        builder.push_str(sentence.chars()[i].to_ascii_lowercase());\n       \
    \ builder.push_str(\" \");\n        builder.push_str(sentence.chars()[c].to_ascii_lowercase());\n\
    \    }\n    builder\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0v44aurz.rs:18:25\n   |\n\
    18 |         .filter_map(|c| c.is_ascii())\n   |                         ^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n18 |         .filter_map(|c| Some(c.is_ascii()))\n   |                \
    \         +++++            +\n\nerror[E0277]: can't compare `&_` with `char`\n\
    \  --> /tmp/tmp0v44aurz.rs:19:27\n   |\n19 |         .take_while(|c| c != ' ')\n\
    \   |                           ^^ no implementation for `&_ == char`\n   |\n\
    \   = help: the trait `PartialEq<char>` is not implemented for `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0v44aurz.rs:16:30\n   |\n16 |       let mut\
    \ counts: Vec<_> = sentence\n   |  _____________________------___^\n   | |   \
    \                  |\n   | |                     expected due to this\n17 | |\
    \         .chars()\n18 | |         .filter_map(|c| c.is_ascii())\n19 | |     \
    \    .take_while(|c| c != ' ')\n20 | |         .count();\n   | |________________^\
    \ expected struct `Vec`, found `usize`\n   |\n   = note: expected struct `Vec<_>`\n\
    \                found type `usize`\n\nerror[E0277]: the trait bound `Chars<'_>:\
    \ ExactSizeIterator` is not satisfied\n    --> /tmp/tmp0v44aurz.rs:31:49\n   \
    \  |\n31   |     for &(i, c) in sentence.chars().enumerate().rev() {\n     | \
    \                                                ^^^ the trait `ExactSizeIterator`\
    \ is not implemented for `Chars<'_>`\n     |\n     = help: the following other\
    \ types implement trait `ExactSizeIterator`:\n               &mut I\n        \
    \       Args\n               ArgsOs\n               ArrayChunks<'_, T, N>\n  \
    \             ArrayChunksMut<'_, T, N>\n               ArrayWindows<'_, T, N>\n\
    \               Box<I, A>\n               Chunks<'_, T>\n             and 109\
    \ others\n     = note: required because of the requirements on the impl of `DoubleEndedIterator`\
    \ for `Enumerate<Chars<'_>>`\nnote: required by a bound in `rev`\n\nerror[E0277]:\
    \ the trait bound `Chars<'_>: ExactSizeIterator` is not satis"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = Vec::new();\n    let mut string =\
    \ String::from(\"words\");\n\n    for prime in prime_numbers(sentence.len()) {\n\
    \        primes.push((sentence.len() - prime).unwrap());\n    }\n\n    while let\
    \ Some(last_prime) = primes.pop() {\n        string = string.replace(\"_\", \"\
    \ \");\n\n        for p in primes {\n            string = string.replace(\"_\"\
    , \" \");\n            if p > last_prime {\n                string = string.replace(p.to_string(),\
    \ p.to_string() + \" \");\n            }\n        }\n    }\n\n    string\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_numbers` in this scope\n  -->\
    \ /tmp/tmps5i2paa_.rs:19:18\n   |\n19 |     for prime in prime_numbers(sentence.len())\
    \ {\n   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence\n        .split(' ')\n        .iter()\n  \
    \      .map(|s| s.to_string())\n        .filter_map(|s| {\n            s.chars().count(|c|\
    \ c.is_ascii_letter())\n        })\n        .filter(|s| s.is_prime())\n      \
    \  .collect::<Vec<_>>()\n        .join(\" \")\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `std::str::Split`\
    \ in the current scope\n  --> /tmp/tmp8y5zdi7w.rs:18:10\n   |\n18 |         .iter()\n\
    \   |          ^^^^ method not found in `std::str::Split<'_, char>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_string = String::with_capacity(sentence.len());\n\
    \    words_in_sentence(sentence, &mut new_string).to_string()\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmp3oywxyy9.rs:17:5\n   |\n17 |     words_in_sentence(sentence, &mut\
    \ new_string).to_string()\n   |     ^^^^^^^^^^^^^^^^^ --------  ---------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmp3oywxyy9.rs:15:4\n   |\n15 | fn words_in_sentence(sentence:\
    \ String) -> String {\n   |    ^^^^^^^^^^^^^^^^^ ----------------\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut words = String::new();\n    let mut prime =\
    \ String::new();\n\n    for ch in sentence.chars() {\n        if char_is_prime(ch)\
    \ {\n            if let Ok(prime_str) = prime_number(ch) {\n                prime\
    \ = prime_str;\n            } else {\n                prime = prime_number;\n\
    \            }\n        } else {\n            prime = prime_number;\n        }\n\
    \    }\n\n    let mut i = 0;\n    let mut num_primes = String::new();\n\n    while\
    \ i < sentence.len() {\n        let mut is_prime = true;\n        if let Ok(prime_str)\
    \ = prime_number(sentence.chars()[i..].next().unwrap()) {\n            num_primes\
    \ = num_primes + \" \" + prime_str;\n            i += 1;\n        } else {\n \
    \           is_prime = false;\n        }\n\n        if !is_prime {\n         \
    \   words += sentence.chars()[i..].next().unwrap() + \" \" + num_primes;\n   \
    \         i += 1;\n            num_primes = String::new();\n        }\n    }\n\
    \n    words\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `char_is_prime` in this scope\n  -->\
    \ /tmp/tmp9qud8y9t.rs:20:12\n   |\n20 |         if char_is_prime(ch) {\n   | \
    \           ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `prime_number` in this scope\n  --> /tmp/tmp9qud8y9t.rs:21:36\n   |\n\
    21 |             if let Ok(prime_str) = prime_number(ch) {\n   |             \
    \                       ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `prime_number` in this scope\n  --> /tmp/tmp9qud8y9t.rs:24:25\n\
    \   |\n24 |                 prime = prime_number;\n   |                      \
    \   ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `prime_number`\
    \ in this scope\n  --> /tmp/tmp9qud8y9t.rs:27:21\n   |\n27 |             prime\
    \ = prime_number;\n   |                     ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `prime_number` in this scope\n  --> /tmp/tmp9qud8y9t.rs:36:32\n\
    \   |\n36 |         if let Ok(prime_str) = prime_number(sentence.chars()[i..].next().unwrap())\
    \ {\n   |                                ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp9qud8y9t.rs:36:45\n\
    \   |\n36 |         if let Ok(prime_str) = prime_number(sentence.chars()[i..].next().unwrap())\
    \ {\n   |                                             ^^^^^^^^^^^^^^^^^^^^^\n\n\
    error[E0608]: cannot index into a value of type `Chars<'_>`\n  --> /tmp/tmp9qud8y9t.rs:44:22\n\
    \   |\n44 |             words += sentence.chars()[i..].next().unwrap() + \" \"\
    \ + num_primes;\n   |                      ^^^^^^^^^^^^^^^^^^^^^\n\nerror: aborting\
    \ due to 7 previous errors\n\nSome errors have detailed explanations: E0425, E0608.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence, \"\".to_string())\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 2 arguments were supplied\n\
    \  --> /tmp/tmparxn6vps.rs:16:5\n   |\n16 |     words_in_sentence(sentence, \"\
    \".to_string())\n   |     ^^^^^^^^^^^^^^^^^ --------  -------------- supplied\
    \ 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote: function\
    \ defined here\n  --> /tmp/tmparxn6vps.rs:15:4\n   |\n15 | fn words_in_sentence(sentence:\
    \ String) -> String {\n   |    ^^^^^^^^^^^^^^^^^ ----------------\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0061`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // code here\n}\n\nfn main() {\n    let candidate =\
    \ words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp9q_jhm1s.rs:15:43\n   |\n\
    15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    match sentence {\n        sentence if !sentence.contains(\"\
    \ \").unwrap_or(sentence.len() <= 1) => String::new(),\n        _ => {\n     \
    \       let mut words = sentence.split_whitespace();\n            let mut primes\
    \ = vec![];\n            let mut counter = 1;\n            for w in words {\n\
    \                let wlen = (w.len() as i64).sqrt() as i64;\n                if\
    \ wlen > 1 {\n                    let _ = counter.pow(wlen).unwrap();\n      \
    \              counter = 1;\n                } else {\n                    primes.push(w);\n\
    \                    counter = 1;\n                }\n            }\n        \
    \    let mut result = String::with_capacity(sentence.len());\n            for\
    \ w in primes {\n                result.push_str(w);\n            }\n        \
    \    result\n        }\n    }\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap_or` found for type `bool` in the\
    \ current scope\n  --> /tmp/tmp79xmex3n.rs:17:45\n   |\n17 |         sentence\
    \ if !sentence.contains(\" \").unwrap_or(sentence.len() <= 1) => String::new(),\n\
    \   |                                             ^^^^^^^^^ method not found in\
    \ `bool`\n\nerror[E0599]: no method named `sqrt` found for type `i64` in the current\
    \ scope\n  --> /tmp/tmp79xmex3n.rs:23:45\n   |\n23 |                 let wlen\
    \ = (w.len() as i64).sqrt() as i64;\n   |                                    \
    \         ^^^^ method not found in `i64`\n\nerror[E0689]: can't call method `pow`\
    \ on ambiguous numeric type `{integer}`\n  --> /tmp/tmp79xmex3n.rs:25:37\n   |\n\
    25 |                     let _ = counter.pow(wlen).unwrap();\n   |           \
    \                          ^^^\n   |\nhelp: you must specify a type for this binding,\
    \ like `i32`\n   |\n21 |             let mut counter: i32 = 1;\n   |         \
    \        ~~~~~~~~~~~~~~~~\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0689.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence(sentence.as_bytes())\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgg3a6qp_.rs:16:23\n   |\n\
    16 |     words_in_sentence(sentence.as_bytes())\n   |                       ^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&[u8]`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Write your code here.\n    // let mut words = sentence.split_whitespace();\n\
    \    let words = sentence.split_whitespace();\n    \n    let mut primes = Vec::new();\n\
    \    for word in words {\n        if !primes.contains(&word.len() + 1) {\n   \
    \         primes.push(word.len() + 1);\n        }\n    }\n    let mut result =\
    \ String::new();\n    \n    for prime in primes {\n        result.push_str(&words[prime]);\n\
    \    }\n    \n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi1jj8wc3.rs:22:29\n   |\n\
    22 |         if !primes.contains(&word.len() + 1) {\n   |                    \
    \         ^^^^^^^^^^^^^^^\n   |                             |\n   |          \
    \                   expected reference, found `usize`\n   |                  \
    \           help: consider borrowing here: `&(&word.len() + 1)`\n   |\n   = note:\
    \ expected reference `&_`\n                   found type `usize`\n\nerror[E0608]:\
    \ cannot index into a value of type `SplitWhitespace<'_>`\n  --> /tmp/tmpi1jj8wc3.rs:29:26\n\
    \   |\n29 |         result.push_str(&words[prime]);\n   |                    \
    \      ^^^^^^^^^^^^\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0608.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // split sentence into words\n    let words = sentence.split_whitespace();\n\
    \    let mut new_sentence = String::new();\n    // prime number\n    let mut prime_numbers\
    \ = Vec::new();\n\n    // sort words to check if they have the correct order\n\
    \    words.sort(); \n\n    // remove every number in the array\n    for word in\
    \ words {\n        // check if current word is prime\n        if check_if_prime(word)\
    \ {\n            prime_numbers.push(word);\n        }\n    }\n\n    // concatenate\
    \ prime numbers in new sentence\n    for number in prime_numbers {\n        new_sentence.push_str(number);\n\
    \    }\n\n    new_sentence\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `check_if_prime` in this scope\n  -->\
    \ /tmp/tmp63fs3y_c.rs:28:12\n   |\n28 |         if check_if_prime(word) {\n  \
    \ |            ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `sort` found for struct `SplitWhitespace` in the current scope\n  -->\
    \ /tmp/tmp63fs3y_c.rs:23:11\n   |\n23 |     words.sort(); \n   |           ^^^^\
    \ method not found in `SplitWhitespace<'_>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::from(\"\");\n    let mut prime_numbers\
    \ = Vec::new();\n    let mut len_prime_numbers = Vec::new();\n    let mut index\
    \ = 0;\n\n    let mut char_str = sentence.chars().collect::<String>();\n    let\
    \ char_len = char_str.len();\n    let mut temp_str = String::from(\"\");\n   \
    \ for &c in char_str {\n        let number = if c.is_uppercase() {\n         \
    \   c.to_digit(10)\n        } else {\n            c.to_digit(32)\n        };\n\
    \        if number < 2 {\n            prime_numbers.push(number);\n        } else\
    \ {\n            if number in prime_numbers {\n                len_prime_numbers.push(index);\n\
    \            }\n            prime_numbers.push(number);\n            len_prime_numbers.push(index);\n\
    \        }\n        temp_str.append(&c);\n        index += 1;\n    }\n    for\
    \ num_len in len_prime_numbers {\n        result.push_str(&temp_str[num_len..]);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `{`, found keyword `in`\n  --> /tmp/tmpg8k2wr3s.rs:33:23\n\
    \   |\n33 |             if number in prime_numbers {\n   |             --    \
    \    ^^ expected `{`\n   |             |\n   |             this `if` expression\
    \ has a condition, but no block\n\nerror[E0277]: `String` is not an iterator\n\
    \  --> /tmp/tmpg8k2wr3s.rs:24:15\n   |\n24 |     for &c in char_str {\n   |  \
    \             ^^^^^^^^ `String` is not an iterator; try calling `.chars()` or\
    \ `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented for `String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `String`\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpg8k2wr3s.rs:39:18\n   |\n39 |         temp_str.append(&c);\n\
    \   |                  ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    // Your code here\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjhq8etac.rs:15:43\n   |\n\
    15 | fn words_in_sentence(sentence: String) -> String {\n   |    -----------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    use std::cmp::Ordering;\n    use std::collections::HashSet;\n\
    \n    let mut primes: Vec<_> = sentence\n        .split_whitespace()\n       \
    \ .map(|word| word.chars().take_while(|c| c.is_ascii_letter()).count())\n    \
    \    .filter(|&n| n % 2 == 0)\n        .collect();\n\n    for i in 2..=(sentence.len()\
    \ + 1) {\n        for j in 2..=primes.len() {\n            if j == i {\n     \
    \           continue;\n            }\n\n            if primes[j] == i {\n    \
    \            primes.swap(j, j + 1);\n                break;\n            }\n \
    \       }\n    }\n\n    let mut prime_string = String::new();\n\n    for i in\
    \ primes.iter().cloned() {\n        let mut string = String::new();\n\n      \
    \  for (index, word) in sentence.split_whitespace().enumerate().take(i + 1) {\n\
    \            string.push(word);\n\n            if index == i {\n             \
    \   prime_string.push(string);\n            }\n        }\n    }\n\n    prime_string\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmpuw5elxna.rs:16:9\n\
    \   |\n16 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nwarning: unused import:\
    \ `std::collections::HashSet`\n  --> /tmp/tmpuw5elxna.rs:17:9\n   |\n17 |    \
    \ use std::collections::HashSet;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]:\
    \ no method named `is_ascii_letter` found for reference `&char` in the current\
    \ scope\n  --> /tmp/tmpuw5elxna.rs:21:51\n   |\n21 |         .map(|word| word.chars().take_while(|c|\
    \ c.is_ascii_letter()).count())\n   |                                        \
    \           ^^^^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `is_ascii`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuw5elxna.rs:44:25\n\
    \   |\n44 |             string.push(word);\n   |                         ^^^^\
    \ expected `char`, found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpuw5elxna.rs:47:35\n\
    \   |\n47 |                 prime_string.push(string);\n   |                 \
    \                  ^^^^^^ expected `char`, found struct `String`\n\nerror: aborting\
    \ due to 3 previous errors; 2 warnings emitted\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut primes = vec![2, 3, 5, 7, 11, 13, 17, 19, 23,\
    \ 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    for i\
    \ in 1..sentence.len() {\n        for j in primes.iter().rev() {\n           \
    \ if i % j == 0 {\n                return sentence.split_whitespace().nth(i);\n\
    \            }\n        }\n    }\n    String::from(\"No primes found\")\n}\n\n\
    fn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5wuap5bn.rs:20:24\n   |\n\
    20 |                 return sentence.split_whitespace().nth(i);\n   |        \
    \                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found enum `Option`\n   |\n   = note: expected struct `String`\n           \
    \     found enum `Option<&str>`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().map(|x| x.len() as i32).filter_map(|x|\
    \ x > 1)\n        .collect()\n        .join(\"\\n\")\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpjiyz2pwi.rs:16:72\n   |\n\
    16 |     sentence.split_whitespace().map(|x| x.len() as i32).filter_map(|x| x\
    \ > 1)\n   |                                                                 \
    \       ^^^^^ expected enum `Option`, found `bool`\n   |\n   = note: expected\
    \ enum `Option<_>`\n              found type `bool`\nhelp: try wrapping the expression\
    \ in `Some`\n   |\n16 |     sentence.split_whitespace().map(|x| x.len() as i32).filter_map(|x|\
    \ Some(x > 1))\n   |                                                         \
    \               +++++     +\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut new_sentence = String::with_capacity(sentence.len());\n\
    \    let mut lengths = vec![true, false, false, false, false, false, false, false,\
    \ false, false];\n    for c in sentence.chars() {\n        if lengths[*c] {\n\
    \            new_sentence.append(c);\n            lengths[*c] = false;\n     \
    \   } else {\n            lengths[*c] = true;\n        }\n    }\n    new_sentence\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp9pcg3mqm.rs:19:20\n\
    \   |\n19 |         if lengths[*c] {\n   |                    ^^\n\nerror[E0599]:\
    \ no method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmp9pcg3mqm.rs:20:26\n   |\n20 |             new_sentence.append(c);\n\
    \   |                          ^^^^^^ method not found in `String`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp9pcg3mqm.rs:21:21\n   |\n\
    21 |             lengths[*c] = false;\n   |                     ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmp9pcg3mqm.rs:23:21\n   |\n\
    23 |             lengths[*c] = true;\n   |                     ^^\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    words_in_sentence_helper(sentence, String::new(), 0)\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `words_in_sentence_helper` in this scope\n\
    \  --> /tmp/tmp0e1xeyuj.rs:16:5\n   |\n16 |     words_in_sentence_helper(sentence,\
    \ String::new(), 0)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut chars = sentence.split(' ').collect::<Vec<_>>();\n\
    \    let mut primes = Vec::new();\n    let mut primes_strings = Vec::new();\n\
    \    for char in chars.iter() {\n        if char.len() > 1 {\n            let\
    \ result = factors(char.len());\n            for prime in result.iter() {\n  \
    \              primes.push(prime);\n            }\n        }\n    }\n    for prime\
    \ in primes.iter() {\n        if primes.iter().any(|&x| *x == prime) {\n     \
    \       let mut string = String::from(\"(\");\n            for char in chars.iter_mut()\
    \ {\n                if char.len() == prime {\n                    string.push_str(char);\n\
    \                }\n            }\n            string.push_str(\")\");\n     \
    \       primes_strings.push(string);\n        }\n    }\n    primes_strings.iter().cloned().collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `factors` in this scope\n  --> /tmp/tmpsptv5t_u.rs:21:26\n\
    \   |\n21 |             let result = factors(char.len());\n   |              \
    \            ^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpsptv5t_u.rs:39:5\n   |\n15 | fn words_in_sentence(sentence: String)\
    \ -> String {\n   |                                           ------ expected\
    \ `String` because of return type\n...\n39 |     primes_strings.iter().cloned().collect::<Vec<String>>()\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct\
    \ `String`, found struct `Vec`\n   |\n   = note: expected struct `String`\n  \
    \            found struct `Vec<String>`\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_words: Vec<u64> = Vec::new();\n    let\
    \ mut str: String = String::new();\n\n    for word in sentence.split_whitespace()\
    \ {\n        let word = word.to_string();\n        if word.len() == 1 && char::is_alpha(word.chars().next().unwrap())\
    \ {\n            str.push(word);\n        } else {\n            let len = u64::from_str_radix(word,\
    \ 2).unwrap();\n            prime_words.push_back(len);\n        }\n    }\n\n\
    \    for p in prime_words {\n        if p * p > prime_words.len() as u64 {\n \
    \           break;\n        }\n\n        if str.len() >= p {\n            let\
    \ start_index = str.len() - p - 1;\n            let end_index = str.len() - 1;\n\
    \n            if start_index >= end_index {\n                str.clear();\n  \
    \          } else {\n                let mut new_str = String::new();\n      \
    \          new_str.push_str(&str[start_index..end_index]);\n                str.clear();\n\
    \                str.push_str(&new_str);\n            }\n        }\n    }\n\n\
    \    str\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no function or associated item named `is_alpha` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpud28tdz8.rs:21:37\n   |\n21\
    \ |         if word.len() == 1 && char::is_alpha(word.chars().next().unwrap())\
    \ {\n   |                                     ^^^^^^^^\n   |                 \
    \                    |\n   |                                     function or associated\
    \ item not found in `char`\n   |                                     help: there\
    \ is an associated function with a similar name: `is_alphabetic`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpud28tdz8.rs:22:22\n   |\n22 |             str.push(word);\n\
    \   |                      ^^^^ expected `char`, found struct `String`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpud28tdz8.rs:24:43\n   |\n24 |             let\
    \ len = u64::from_str_radix(word, 2).unwrap();\n   |                         \
    \                  ^^^^\n   |                                           |\n  \
    \ |                                           expected `&str`, found struct `String`\n\
    \   |                                           help: consider borrowing here:\
    \ `&word`\n\nerror[E0599]: no method named `push_back` found for struct `Vec<u64>`\
    \ in the current scope\n  --> /tmp/tmpud28tdz8.rs:25:25\n   |\n25 |          \
    \   prime_words.push_back(len);\n   |                         ^^^^^^^^^ method\
    \ not found in `Vec<u64>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpud28tdz8.rs:34:25\n\
    \   |\n34 |         if str.len() >= p {\n   |                         ^ expected\
    \ `usize`, found `u64`\n   |\nhelp: you can convert a `u64` to a `usize` and panic\
    \ if the converted value doesn't fit\n   |\n34 |         if str.len() >= p.try_into().unwrap()\
    \ {\n   |                          ++++++++++++++++++++\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpud28tdz8.rs:35:43\n   |\n35 |             let start_index\
    \ = str.len() - p - 1;\n   |                                           ^ expected\
    \ `usize`, found `u64`\n\nerror[E0277]: cannot subtract `u64` from `usize`\n \
    \ --> /tmp/tmpud28tdz8.rs:35:41\n   |\n35 |             let start_index = str.len()\
    \ - p"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(sentence.len() >= 1);\n    assert!(sentence.len()\
    \ <= 100);\n\n    use std::io;\n    let mut result = String::new();\n    let mut\
    \ primes = prime_factors(sentence.len());\n    let mut prime = primes.next().unwrap();\n\
    \    for word in sentence.split_whitespace() {\n        if prime % 2 == 0 {\n\
    \            prime = primes.next().unwrap();\n            result.push_str(&word.to_string());\n\
    \        } else {\n            result.push_str(&word.to_string());\n         \
    \   prime = prime - 1;\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This\
    \ is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factors` in this scope\n  -->\
    \ /tmp/tmpqk5whtx2.rs:21:22\n   |\n21 |     let mut primes = prime_factors(sentence.len());\n\
    \   |                      ^^^^^^^^^^^^^ not found in this scope\n\nwarning: unused\
    \ import: `std::io`\n  --> /tmp/tmpqk5whtx2.rs:19:9\n   |\n19 |     use std::io;\n\
    \   |         ^^^^^^^\n   |\n   = note: `#[warn(unused_imports)]` on by default\n\
    \nerror: aborting due to previous error; 1 warning emitted\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 101
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut buffer = String::new();\n    let mut prime:\
    \ usize = 2;\n    let mut prime_prime: usize = 2;\n\n    let mut prime_prime_last_index\
    \ = 0;\n\n    let mut current_index = 1;\n    let mut is_prime = true;\n\n   \
    \ buffer.push_str(&sentence[current_index..]);\n\n    while prime_prime <= buffer.len()\
    \ {\n        if buffer.len() % prime == 0 {\n            if buffer.len() / prime\
    \ == prime {\n                if is_prime {\n                    prime_prime_last_index\
    \ = current_index;\n                    is_prime = false;\n                }\n\
    \                current_index += 1;\n            } else {\n                prime_prime\
    \ = prime_prime_last_index+1;\n            }\n        } else {\n            prime_prime\
    \ += 1;\n        }\n    }\n\n    let mut result = String::new();\n\n    for _\
    \ in 0..(prime_prime_last_index - current_index) {\n        buffer.push_str(&\"\
    \ \");\n    }\n\n    for word in sentence.split_whitespace() {\n        result.push_str(&word);\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: Exception
  stderr: 'thread ''main'' panicked at ''attempt to subtract with overflow'', /tmp/tmpa9pxpxli.rs:45:17

    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

    '
  stdout: ''
  timestamp: 1659978465
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace()\n        .filter_map(|w|\
    \ {\n            if !is_prime(w.len()) {\n                None\n            }\
    \ else {\n                Some(w)\n            }\n        })\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpo85s6ng_.rs:18:17\n\
    \   |\n18 |             if !is_prime(w.len()) {\n   |                 ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.chars().filter(|c| chars::is_letter(c)).collect()\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmp6fu_lsrw.rs:16:33\n   |\n16 |     sentence.chars().filter(|c| chars::is_letter(c)).collect()\n\
    \   |                                 ^^^^^ use of undeclared crate or module\
    \ `chars`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    String::from(\n        sentence\n            .lines()\n\
    \            .filter(|s| s.chars().count() >= 2)\n            .collect::<Vec<_>>()\n\
    \            .iter()\n            .filter(|s| s.chars().count() > 1)\n       \
    \     .collect::<Vec<_>>()\n            .iter()\n            .filter(|s| s.chars().count()\
    \ == s.iter().map(|c| *c).count())\n            .collect::<Vec<_>>()\n       \
    \     .cloned()\n            .collect::<Vec<_>>()\n            .iter()\n     \
    \       .cloned()\n            .map(|s| s.to_string())\n            .collect::<Vec<_>>()\n\
    \            .join(\"  \"),\n    )\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for reference `&&&&str` in the\
    \ current scope\n  --> /tmp/tmp1jbjpn2a.rs:25:48\n   |\n25 |             .filter(|s|\
    \ s.chars().count() == s.iter().map(|c| *c).count())\n   |                   \
    \                             ^^^^ method not found in `&&&&str`\n\nerror[E0599]:\
    \ the method `cloned` exists for struct `Vec<&&&str>`, but its trait bounds were\
    \ not satisfied\n   --> /tmp/tmp1jbjpn2a.rs:27:14\n    |\n27  |              \
    \ .cloned()\n    |                ^^^^^^ method cannot be called on `Vec<&&&str>`\
    \ due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds\
    \ were not satisfied:\n            `Vec<&&&str>: Iterator`\n            which\
    \ is required by `&mut Vec<&&&str>: Iterator`\n            `[&&&str]: Iterator`\n\
    \            which is required by `&mut [&&&str]: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    debug_assert!(sentence.chars().all(|c| c.is_letter()));\n\
    \    let mut primes = Vec::new();\n    for c in sentence.chars() {\n        if\
    \ c < '0' || c > '9' {\n            break;\n        }\n        let digit = c -\
    \ '0';\n        if !primes.contains(&digit) {\n            primes.push(digit);\n\
    \        }\n    }\n    primes\n        .iter()\n        .map(|prime| if prime.is_power_of_two()\
    \ {\n            let mut m = 2u64;\n            for _ in 0..prime {\n        \
    \        let a = next_prime(m);\n                if a == 1 {\n               \
    \     break;\n                }\n                m = a;\n            }\n     \
    \       String::from(m.to_string())\n        } else {\n            String::from(prime.to_string())\n\
    \        })\n        .collect()\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n\
    \    assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `next_prime` in this scope\n  --> /tmp/tmpweo28sy3.rs:32:25\n\
    \   |\n32 |                 let a = next_prime(m);\n   |                     \
    \    ^^^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `is_letter`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpweo28sy3.rs:16:46\n\
    \   |\n16 |     debug_assert!(sentence.chars().all(|c| c.is_letter()));\n   |\
    \                                              ^^^^^^^^^ method not found in `char`\n\
    \nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpweo28sy3.rs:22:23\n\
    \   |\n22 |         let digit = c - '0';\n   |                     - ^ --- char\n\
    \   |                     |\n   |                     char\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0369, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.len() < 2 {\n        return String::new();\n\
    \    }\n    let mut prime_numbers = Vec::new();\n    let mut prime_numbers_string\
    \ = String::new();\n    let mut words_string = String::new();\n    let mut current_number\
    \ = 0;\n    let mut current_index = 0;\n    for &item in &sentence.chars() {\n\
    \        if current_number % item != 0 {\n            current_number = current_number\
    \ / item;\n            current_index += 1;\n            prime_numbers.push(current_number);\n\
    \            prime_numbers_string.push_str(&prime_numbers[current_index].to_string());\n\
    \        } else {\n            current_number = current_number / item;\n     \
    \       current_index += 1;\n            words_string.push_str(&(item - 1).to_string());\n\
    \        }\n    }\n    prime_numbers_string.push_str(&(current_index - 1).to_string());\n\
    \    words_string.push_str(&(sentence.len() - 1).to_string());\n    prime_numbers_string\n\
    }\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `&Chars<'_>` is not an iterator\n  --> /tmp/tmpxwkai2t_.rs:24:18\n\
    \   |\n24 |     for &item in &sentence.chars() {\n   |                  -^^^^^^^^^^^^^^^^\n\
    \   |                  |\n   |                  `&Chars<'_>` is not an iterator\n\
    \   |                  help: consider removing the leading `&`-reference\n   |\n\
    \   = help: the trait `Iterator` is not implemented for `&Chars<'_>`\n   = note:\
    \ `Iterator` is implemented for `&mut std::str::Chars<'_>`, but not for `&std::str::Chars<'_>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&Chars<'_>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    sentence.split_whitespace().filter_map(|s| s.chars().all(|c|\
    \ *c >= 'a' && *c <= 'z') && *c != '-').collect()\n}\n\nfn main() {\n    let candidate\
    \ = words_in_sentence;\n    assert_eq!(candidate(String::from(\"This is a test\"\
    )), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"lets go for\
    \ swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c` in this scope\n  --> /tmp/tmpsu5ae3fr.rs:16:94\n\
    \   |\n16 |     sentence.split_whitespace().filter_map(|s| s.chars().all(|c| *c\
    \ >= 'a' && *c <= 'z') && *c != '-').collect()\n   |                         \
    \                                                                     ^ help:\
    \ a local variable with a similar name exists: `s`\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpsu5ae3fr.rs:16:66\n   |\n16 |     sentence.split_whitespace().filter_map(|s|\
    \ s.chars().all(|c| *c >= 'a' && *c <= 'z') && *c != '-').collect()\n   |    \
    \                                                              ^^\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpsu5ae3fr.rs:16:79\n   |\n\
    16 |     sentence.split_whitespace().filter_map(|s| s.chars().all(|c| *c >= 'a'\
    \ && *c <= 'z') && *c != '-').collect()\n   |                                \
    \                                               ^^\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpsu5ae3fr.rs:16:48\n   |\n16 |     sentence.split_whitespace().filter_map(|s|\
    \ s.chars().all(|c| *c >= 'a' && *c <= 'z') && *c != '-').collect()\n   |    \
    \                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected enum `Option`, found `bool`\n   |\n   = note: expected enum `Option<_>`\n\
    \              found type `bool`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |     sentence.split_whitespace().filter_map(|s| Some(s.chars().all(|c|\
    \ *c >= 'a' && *c <= 'z') && *c != '-')).collect()\n   |                     \
    \                           +++++                                            \
    \          +\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0425, E0614.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    if sentence.chars().count() < 3 {\n        return String::from(\"\
    \");\n    }\n\n    let mut prime_len = String::from(\"\");\n\n    for c in sentence.chars()\
    \ {\n        prime_len.push(c);\n        let mut counter = 1;\n        for _ in\
    \ 0..c {\n            counter += 2;\n        }\n        if counter != c {\n  \
    \          prime_len.push('_');\n        }\n    }\n    prime_len\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpeer1k0vj.rs:25:21\n   |\n\
    25 |         for _ in 0..c {\n   |                     ^ expected integer, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpeer1k0vj.rs:28:23\n\
    \   |\n28 |         if counter != c {\n   |                       ^ expected integer,\
    \ found `char`\n\nerror[E0277]: can't compare `{integer}` with `char`\n  --> /tmp/tmpeer1k0vj.rs:28:20\n\
    \   |\n28 |         if counter != c {\n   |                    ^^ no implementation\
    \ for `{integer} == char`\n   |\n   = help: the trait `PartialEq<char>` is not\
    \ implemented for `{integer}`\n   = help: the following other types implement\
    \ trait `PartialEq<Rhs>`:\n             f32\n             f64\n             i128\n\
    \             i16\n             i32\n             i64\n             i8\n     \
    \        isize\n           and 6 others\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    solve::words_in_sentence(sentence)\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `solve`\n\
    \  --> /tmp/tmp_bw69sly.rs:16:5\n   |\n16 |     solve::words_in_sentence(sentence)\n\
    \   |     ^^^^^ use of undeclared crate or module `solve`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime = vec![true; sentence.len()];\n    let\
    \ mut new_str = String::from(\"\");\n    let mut index = 0;\n    let mut char_array:\
    \ Vec<char> = sentence.chars().collect();\n    for i in char_array.len() {\n \
    \       if prime[index] == false {\n            new_str.append(&char_array[index..i]);\n\
    \            prime[index] = false;\n            index = i;\n        }\n    }\n\
    \    new_str\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: `usize` is not an iterator\n  --> /tmp/tmp82h2xdae.rs:20:14\n\
    \   |\n20 |     for i in char_array.len() {\n   |              ^^^^^^^^^^^^^^^^\
    \ `usize` is not an iterator\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `usize`\n   = note: if you want to iterate between `start` until a value\
    \ `end`, use the exclusive range syntax `start..end` or the inclusive range syntax\
    \ `start..=end`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `usize`\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp82h2xdae.rs:22:21\n   |\n\
    22 |             new_str.append(&char_array[index..i]);\n   |                \
    \     ^^^^^^ method not found in `String`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut prime_words_in_sentence:\
    \ HashSet<String> = HashSet::new();\n    let mut sentence = sentence.split_whitespace().collect::<Vec<_>>();\n\
    \    for w in sentence {\n        if !prime_words_in_sentence.insert(w).unwrap()\
    \ {\n            result.push_str(&w);\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpy4zqqpg0.rs:17:38\n\
    \   |\n17 |     let mut prime_words_in_sentence: HashSet<String> = HashSet::new();\n\
    \   |                                      ^^^^^^^ not found in this scope\n \
    \  |\nhelp: consider importing this struct\n   |\n1  | use std::collections::HashSet;\n\
    \   |\n\nerror[E0433]: failed to resolve: use of undeclared type `HashSet`\n \
    \ --> /tmp/tmpy4zqqpg0.rs:17:56\n   |\n17 |     let mut prime_words_in_sentence:\
    \ HashSet<String> = HashSet::new();\n   |                                    \
    \                    ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    let mut prime_numbers = Vec::new();\n    for i in 1..sentence.len()\
    \ {\n        if &sentence[i] == \" \" {\n            prime_numbers.push(prime_factor(i).unwrap());\n\
    \        }\n    }\n    prime_numbers.push(prime_factor(sentence.len()).unwrap());\n\
    \    let mut result = String::from(\"\");\n    for i in prime_numbers {\n    \
    \    result = result.push(sentence[i]);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = words_in_sentence;\n    assert_eq!(candidate(String::from(\"\
    This is a test\")), String::from(\"is\"));\n    assert_eq!(candidate(String::from(\"\
    lets go for swimming\")), String::from(\"go for\"));\n    assert_eq!(candidate(String::from(\"\
    there is no place available here\")), String::from(\"there is no place\"));\n\
    \    assert_eq!(candidate(String::from(\"Hi I am Hussein\")), String::from(\"\
    Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"go for it\")), String::from(\"\
    go for it\"));\n    assert_eq!(candidate(String::from(\"here\")), String::from(\"\
    \"));\n    assert_eq!(candidate(String::from(\"here is\")), String::from(\"is\"\
    ));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `prime_factor` in this scope\n  -->\
    \ /tmp/tmp8s9_qvxx.rs:19:32\n   |\n19 |             prime_numbers.push(prime_factor(i).unwrap());\n\
    \   |                                ^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `prime_factor` in this scope\n  --> /tmp/tmp8s9_qvxx.rs:22:24\n\
    \   |\n22 |     prime_numbers.push(prime_factor(sentence.len()).unwrap());\n \
    \  |                        ^^^^^^^^^^^^ not found in this scope\n\nerror[E0277]:\
    \ the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8s9_qvxx.rs:18:13\n\
    \   |\n18 |         if &sentence[i] == \" \" {\n   |             ^^^^^^^^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp8s9_qvxx.rs:25:18\n\
    \   |\n23 |     let mut result = String::from(\"\");\n   |                   \
    \   ---------------- expected due to this value\n24 |     for i in prime_numbers\
    \ {\n25 |         result = result.push(sentence[i]);\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `()`\n   |\nnote: method `push` modifies its\
    \ receiver in-place\n  --> /tmp/tmp8s9_qvxx.rs:25:25\n   |\n25 |         result\
    \ = result.push(sentence[i]);\n   |                  ------ ^^^^ this call modifies\
    \ `result` in-place\n   |                  |\n   |                  you probably\
    \ want to use this value after calling the method...\n   = note: ...instead of\
    \ the `()` output of method `push`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0277`."
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    fn is_prime_number(n: usize) -> bool {\n        //\
    \ A prime number is a natural number greater than 1, so if n is less than 2, it's\
    \ not prime.\n        match n % 2 {\n            1 => false,  // Only even numbers\n\
    \            _ => n > 1 // Odd numbers can be tested for primeness\n        }\n\
    \    }\n\n    let mut new_string = \"\";\n\n    let mut last_word_index = 0;\n\
    \n    // Split the sentence into words\n    for word in sentence.split_whitespace()\
    \ {\n        // Check if the word is prime\n        if is_prime_number(word.len())\
    \ {\n            // If yes, append the word to the new string\n            new_string.append(&sentence[last_word_index..word.len()]);\n\
    \            last_word_index = word.len();\n        }\n    }\n\n    new_string.append(&sentence[last_word_index..sentence.len()]);\n\
    \n    new_string\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n \
    \   assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `append` found for reference `&str` in the\
    \ current scope\n  --> /tmp/tmpg09easrs.rs:33:24\n   |\n33 |             new_string.append(&sentence[last_word_index..word.len()]);\n\
    \   |                        ^^^^^^ method not found in `&str`\n\nerror[E0599]:\
    \ no method named `append` found for reference `&str` in the current scope\n \
    \ --> /tmp/tmpg09easrs.rs:38:16\n   |\n38 |     new_string.append(&sentence[last_word_index..sentence.len()]);\n\
    \   |                ^^^^^^ method not found in `&str`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpg09easrs.rs:40:5\n   |\n15 | fn words_in_sentence(sentence:\
    \ String) -> String {\n   |                                           ------ expected\
    \ `String` because of return type\n...\n40 |     new_string\n   |     ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
- exit_code: 1
  program: "/// You are given a string representing a sentence,\n/// the sentence\
    \ contains some words separated by a space,\n/// and you have to return a string\
    \ that contains the words from the original sentence,\n/// whose lengths are prime\
    \ numbers,\n/// the order of the words in the new string should be the same as\
    \ the original one.\n/// Example 1:\n/// >>> words_in_sentence(String::from(\"\
    This is a test\"))\n/// String::from(\"is\")\n/// Example 2:\n/// >>> words_in_sentence(String::from(\"\
    lets go for swimming\"))\n/// String::from(\"go for\")\n/// Constraints:\n///\
    \ * 1 <= len(sentence) <= 100\n/// * sentence contains only letters\nfn words_in_sentence(sentence:\
    \ String) -> String {\n    assert!(sentence.chars().all(|c| *c >= 'a' && *c <=\
    \ 'z'));\n    assert!(sentence.chars().all(|c| *c >= 'A' && *c <= 'Z'));\n   \
    \ assert!(sentence.chars().all(|c| *c >= '0' && *c <= '9'));\n    let mut primes\
    \ = Vec::new();\n    let mut new_string = String::from(\"_\");\n    let mut index\
    \ = 0;\n    while index != sentence.len() {\n        let word = String::from(&sentence[index..]);\n\
    \        let length: usize = word.len();\n        if primes.contains(&length)\
    \ == false {\n            primes.push(length);\n        }\n        for prime in\
    \ &primes[..] {\n            if length % prime == 0 {\n                new_string.push_str(word);\n\
    \                break;\n            }\n        }\n        index += 1;\n    }\n\
    \    new_string\n}\n\nfn main() {\n    let candidate = words_in_sentence;\n  \
    \  assert_eq!(candidate(String::from(\"This is a test\")), String::from(\"is\"\
    ));\n    assert_eq!(candidate(String::from(\"lets go for swimming\")), String::from(\"\
    go for\"));\n    assert_eq!(candidate(String::from(\"there is no place available\
    \ here\")), String::from(\"there is no place\"));\n    assert_eq!(candidate(String::from(\"\
    Hi I am Hussein\")), String::from(\"Hi am Hussein\"));\n    assert_eq!(candidate(String::from(\"\
    go for it\")), String::from(\"go for it\"));\n    assert_eq!(candidate(String::from(\"\
    here\")), String::from(\"\"));\n    assert_eq!(candidate(String::from(\"here is\"\
    )), String::from(\"is\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:16:38\n\
    \   |\n16 |     assert!(sentence.chars().all(|c| *c >= 'a' && *c <= 'z'));\n \
    \  |                                      ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:16:51\n   |\n16 |     assert!(sentence.chars().all(|c|\
    \ *c >= 'a' && *c <= 'z'));\n   |                                            \
    \       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:17:38\n\
    \   |\n17 |     assert!(sentence.chars().all(|c| *c >= 'A' && *c <= 'Z'));\n \
    \  |                                      ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:17:51\n   |\n17 |     assert!(sentence.chars().all(|c|\
    \ *c >= 'A' && *c <= 'Z'));\n   |                                            \
    \       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:18:38\n\
    \   |\n18 |     assert!(sentence.chars().all(|c| *c >= '0' && *c <= '9'));\n \
    \  |                                      ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmp6d9ksua5.rs:18:51\n   |\n18 |     assert!(sentence.chars().all(|c|\
    \ *c >= '0' && *c <= '9'));\n   |                                            \
    \       ^^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp6d9ksua5.rs:30:37\n\
    \   |\n30 |                 new_string.push_str(word);\n   |                 \
    \                    ^^^^\n   |                                     |\n   |  \
    \                                   expected `&str`, found struct `String`\n \
    \  |                                     help: consider borrowing here: `&word`\n\
    \nerror: aborting due to 7 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0614.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659978464
