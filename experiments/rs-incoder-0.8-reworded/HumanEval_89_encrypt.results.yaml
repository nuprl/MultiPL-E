language: rs
name: HumanEval_89_encrypt
results:
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    use std::io::Write;\n    let alphabet: [i32; 26] =\
    \ [2, 7, 9, 1, 6, 3, 10, 5, 8, 4, 11, 13, 12, 14, 15, 16, 17, 18];\n    let mut\
    \ cipher = String::new();\n    for c in s.chars() {\n        let index = alphabet.iter().find(|&k|\
    \ k == c as u8);\n        if index != alphabet.none {\n            cipher.append(alphabet.iter()[index].clone());\n\
    \        } else {\n            cipher.append(c);\n        }\n    }\n    cipher\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unused import: `std::io::Write`\n  --> /tmp/tmp87svj_at.rs:15:9\n\
    \   |\n15 |     use std::io::Write;\n   |         ^^^^^^^^^^^^^^\n   |\n   = note:\
    \ `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp87svj_at.rs:16:31\n   |\n16 |     let alphabet: [i32; 26] = [2,\
    \ 7, 9, 1, 6, 3, 10, 5, 8, 4, 11, 13, 12, 14, 15, 16, 17, 18];\n   |         \
    \          ---------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected an array with a fixed size of 26 elements, found one with 18 elements\n\
    \   |                   |\n   |                   expected due to this\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp87svj_at.rs:19:52\n   |\n19 |         let index\
    \ = alphabet.iter().find(|&k| k == c as u8);\n   |                           \
    \                         ^^^^^^^ expected `i32`, found `u8`\n\nerror[E0277]:\
    \ can't compare `&i32` with `u8`\n  --> /tmp/tmp87svj_at.rs:19:49\n   |\n19 |\
    \         let index = alphabet.iter().find(|&k| k == c as u8);\n   |         \
    \                                        ^^ no implementation for `&i32 == u8`\n\
    \   |\n   = help: the trait `PartialEq<u8>` is not implemented for `&i32`\n  \
    \ = help: the following other types implement trait `PartialEq<Rhs>`:\n      \
    \       f32\n             f64\n             i128\n             i16\n         \
    \    i32\n             i64\n             i8\n             isize\n           and\
    \ 6 others\n\nerror[E0609]: no field `none` on type `[i32; 26]`\n  --> /tmp/tmp87svj_at.rs:20:30\n\
    \   |\n20 |         if index != alphabet.none {\n   |                        \
    \      ^^^^\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp87svj_at.rs:21:20\n   |\n21 |          \
    \   cipher.append(alphabet.iter()[index].clone());\n   |                    ^^^^^^\
    \ method not found in `String`\n\nerror[E0608]: cannot index into a value of type\
    \ `std::slice::Iter<'_, i32>`\n  --> /tmp/tmp87svj_at.rs:21:27\n   |\n21 |   \
    \          cipher.append(alphabet.iter()[index].clone());\n   |              \
    \             ^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0599]: no metho"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut news = String::new();\n    for c in s.chars()\
    \ {\n        news.push(c * 2);\n    }\n    news.rotate_left(2);\n    news.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot multiply `char` by `{integer}`\n  --> /tmp/tmpo10awcal.rs:17:21\n\
    \   |\n17 |         news.push(c * 2);\n   |                   - ^ - {integer}\n\
    \   |                   |\n   |                   char\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpo10awcal.rs:19:10\n\
    \   |\n19 |     news.rotate_left(2);\n   |          ^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.rotate_left()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpu1p_p43u.rs:15:7\n   |\n15 |     s.rotate_left()\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alpha = [0;26];\n    alpha[26] = 'a';\n   \
    \ alpha[27] = 'b';\n    alpha[28] = 'c';\n    alpha[29] = 'd';\n    alpha[30]\
    \ = 'e';\n    alpha[31] = 'f';\n    alpha[32] = 'g';\n    alpha[33] = 'h';\n \
    \   alpha[34] = 'i';\n    alpha[35] = 'j';\n    alpha[36] = 'k';\n    alpha[37]\
    \ = 'l';\n    alpha[38] = 'm';\n    alpha[39] = 'n';\n    alpha[40] = 'o';\n \
    \   alpha[41] = 'p';\n    alpha[42] = 'q';\n    alpha[43] = 'r';\n    alpha[44]\
    \ = 's';\n    alpha[45] = 't';\n    alpha[46] = 'u';\n    alpha[47] = 'v';\n \
    \   alpha[48] = 'w';\n    alpha[49] = 'x';\n    alpha[50] = 'y';\n    alpha[51]\
    \ = 'z';\n    alpha[52] = 0;\n    alpha[53] = 0;\n    alpha[54] = 0;\n    alpha[55]\
    \ = 0;\n    alpha[56] = 0;\n    alpha[57] = 0;\n    alpha[58] = 0;\n    alpha[59]\
    \ = 0;\n    alpha[60] = 0;\n    alpha[61] = 0;\n    alpha[62] = 0;\n    alpha[63]\
    \ = 0;\n    alpha[64] = 'a';\n    alpha[65] = 'b';\n    alpha[66] = 'c';\n   \
    \ alpha[67] = 'd';\n    alpha[68] = 'e';\n    alpha[69] = 'f';\n    alpha[70]\
    \ = 'g';\n    alpha[71] = 'h';\n    alpha[72] = 'i';\n    alpha[73] = 'j';\n \
    \   alpha[74] = 'k';\n    alpha[75] = 'l';\n    alpha[76] = 'm';\n    alpha[77]\
    \ = 'n';\n    alpha[78] = 'o';\n    alpha[79] = 'p';\n    alpha[80] = 'q';\n \
    \   alpha[81] = 'r';\n    alpha[82] = 's';\n    alpha[83] = 't';\n    alpha[84]\
    \ = 'u';\n    alpha[85] = 'v';\n    alpha[86] = 'w';\n    alpha[87] = 'x';\n \
    \   alpha[88] = 'y';\n    alpha[89] = 'z';\n    alpha[90] = 0;\n    alpha[91]\
    \ = 0;\n    alpha[92] = 0;\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpb1kltc_0.rs:16:17\n   |\n\
    16 |     alpha[26] = 'a';\n   |     ---------   ^^^ expected integer, found `char`\n\
    \   |     |\n   |     expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb1kltc_0.rs:17:17\n   |\n17 |     alpha[27]\
    \ = 'b';\n   |     ---------   ^^^ expected integer, found `char`\n   |     |\n\
    \   |     expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb1kltc_0.rs:18:17\n   |\n18 |     alpha[28] = 'c';\n  \
    \ |     ---------   ^^^ expected integer, found `char`\n   |     |\n   |     expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kltc_0.rs:19:17\n\
    \   |\n19 |     alpha[29] = 'd';\n   |     ---------   ^^^ expected integer, found\
    \ `char`\n   |     |\n   |     expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb1kltc_0.rs:20:17\n   |\n20 |     alpha[30]\
    \ = 'e';\n   |     ---------   ^^^ expected integer, found `char`\n   |     |\n\
    \   |     expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb1kltc_0.rs:21:17\n   |\n21 |     alpha[31] = 'f';\n  \
    \ |     ---------   ^^^ expected integer, found `char`\n   |     |\n   |     expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kltc_0.rs:22:17\n\
    \   |\n22 |     alpha[32] = 'g';\n   |     ---------   ^^^ expected integer, found\
    \ `char`\n   |     |\n   |     expected due to the type of this binding\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpb1kltc_0.rs:23:17\n   |\n23 |     alpha[33]\
    \ = 'h';\n   |     ---------   ^^^ expected integer, found `char`\n   |     |\n\
    \   |     expected due to the type of this binding\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb1kltc_0.rs:24:17\n   |\n24 |     alpha[34] = 'i';\n  \
    \ |     ---------   ^^^ expected integer, found `char`\n   |     |\n   |     expected\
    \ due to the type of this binding\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpb1kltc_0.rs:25:17\n\
    \   |\n25 |     alpha[35] = 'j';\n   |     ---------   ^^^ expected integer, fou"
  stdout: ''
  timestamp: 1659976153
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    \n    // Rotate\
    \ the alphabet by 2\n    for c in s.chars() {\n        cipher.push((c as u32 +\
    \ 2) * 2 % 26);\n    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2y_fklor.rs:19:21\n   |\n\
    19 |         cipher.push((c as u32 + 2) * 2 % 26);\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `u32`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n    for c in s.chars()\
    \ {\n        let pos = c as usize - 'a' as usize;\n        res.push_str(&ALPHABET[pos..pos+2])\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpl3fz4npd.rs:18:23\n\
    \   |\n18 |         res.push_str(&ALPHABET[pos..pos+2])\n   |                \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut i = 0;\n    let mut l = s.len();\n    let mut\
    \ result = \"\";\n    loop {\n        // check if there are any more characters\
    \ to rotate\n        if l == 0 {\n            break;\n        }\n        // get\
    \ the current letter and shift it down\n        let curr_letter = s[i];\n    \
    \    i += 1;\n        let curr_letter2 = s[i];\n        let next_letter = s[i\
    \ - 1];\n        // shift each letter down by 2\n        s[i - 1] = curr_letter2;\n\
    \        s[i] = curr_letter;\n        // shift each letter up by 2\n        s[i\
    \ + 1] = next_letter;\n        // put the letters together\n        result = String::from_utf8(s);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpnjy0xh59.rs:24:27\n   |\n24 |         let curr_letter = s[i];\n   |\
    \                           ^^^^ `String` cannot be indexed by `{integer}`\n \
    \  |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpnjy0xh59.rs:26:28\n   |\n26 |         let curr_letter2 = s[i];\n\
    \   |                            ^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `{integer}`\n\
    \  --> /tmp/tmpnjy0xh59.rs:27:27\n   |\n27 |         let next_letter = s[i - 1];\n\
    \   |                           ^^^^^^^^ `String` cannot be indexed by `{integer}`\n\
    \   |\n   = help: the trait `Index<{integer}>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::op"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alpha: Vec<u8> = vec![0x1, 0x2, 0x3, 0x4, 0x5,\
    \ 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF];\n    let mut count = 2;\n\
    \    let mut result = String::new();\n    for c in s.chars() {\n        let mut\
    \ new_c = c;\n        alpha.rotate_right(count).unwrap();\n        while alpha[alpha.len()\
    \ - 1 - count] != 0 {\n            alpha.push((*alpha[alpha.len() - 1 - count]\
    \ + 1) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 2) %\
    \ 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 3) % 26);\n\
    \            alpha.push((*alpha[alpha.len() - 1 - count] + 4) % 26);\n       \
    \     alpha.push((*alpha[alpha.len() - 1 - count] + 5) % 26);\n            alpha.push((*alpha[alpha.len()\
    \ - 1 - count] + 6) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count]\
    \ + 7) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 8) %\
    \ 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 9) % 26);\n\
    \            alpha.push((*alpha[alpha.len() - 1 - count] + 10) % 26);\n      \
    \      alpha.push((*alpha[alpha.len() - 1 - count] + 11) % 26);\n            alpha.push((*alpha[alpha.len()\
    \ - 1 - count] + 12) % 26);\n            alpha.push((*alpha[alpha.len() - 1 -\
    \ count] + 13) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count]\
    \ + 14) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 15)\
    \ % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count] + 16) % 26);\n\
    \            alpha.push((*alpha[alpha.len() - 1 - count] + 17) % 26);\n      \
    \      alpha.push((*alpha[alpha.len() - 1 - count] + 18) % 26);\n            alpha.push((*alpha[alpha.len()\
    \ - 1 - count] + 19) % 26);\n            alpha.push((*alpha[alpha.len() - 1 -\
    \ count] + 20) % 26);\n            alpha.push((*alpha[alpha.len() - 1 - count]\
    \ + 21) % 26);\n            \n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpgv7uj8x8.rs:56:3\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n18 |     for c in s.chars() {\n   |       \
    \                 - unclosed delimiter\n...\n21 |         while alpha[alpha.len()\
    \ - 1 - count] != 0 {\n   |                                                  \
    \ - this delimiter might not be properly closed...\n...\n44 | }\n   | - ...as\
    \ it matches this but it has different indentation\n...\n56 | }\n   |   ^\n\n\
    error[E0599]: no method named `unwrap` found for unit type `()` in the current\
    \ scope\n  --> /tmp/tmpgv7uj8x8.rs:20:35\n   |\n20 |         alpha.rotate_right(count).unwrap();\n\
    \   |                                   ^^^^^^ method not found in `()`\n\nerror[E0614]:\
    \ type `u8` cannot be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:22:25\n   |\n22\
    \ |             alpha.push((*alpha[alpha.len() - 1 - count] + 1) % 26);\n   |\
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type\
    \ `u8` cannot be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:23:25\n   |\n23 |   \
    \          alpha.push((*alpha[alpha.len() - 1 - count] + 2) % 26);\n   |     \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `u8`\
    \ cannot be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:24:25\n   |\n24 |        \
    \     alpha.push((*alpha[alpha.len() - 1 - count] + 3) % 26);\n   |          \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]: type `u8` cannot\
    \ be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:25:25\n   |\n25 |             alpha.push((*alpha[alpha.len()\
    \ - 1 - count] + 4) % 26);\n   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0614]: type `u8` cannot be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:26:25\n\
    \   |\n26 |             alpha.push((*alpha[alpha.len() - 1 - count] + 5) % 26);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror[E0614]:\
    \ type `u8` cannot be dereferenced\n  --> /tmp/tmpgv7uj8x8.rs:27:25\n   |\n27\
    \ |             alpha.push((*alpha[alpha.len() - 1 - count] + 6) % 26);\n   |\
    \                         ^"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(rotate_alphabet(s, 1), 2)\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp7b4jed5w.rs:15:5\n   |\n15 |     rotate_alphabet(rotate_alphabet(s,\
    \ 1), 2)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `rotate_alphabet` in this scope\n  --> /tmp/tmp7b4jed5w.rs:15:21\n\
    \   |\n15 |     rotate_alphabet(rotate_alphabet(s, 1), 2)\n   |              \
    \       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut l = s.chars().take(s.len() - 1).collect::<Vec<_>>();\n\
    \    for &v in l {\n        l = rotate_down(v, 2, l);\n    }\n    s.from_chars(l).to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_down` in this scope\n  --> /tmp/tmpup4budjc.rs:17:13\n\
    \   |\n17 |         l = rotate_down(v, 2, l);\n   |             ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpup4budjc.rs:16:9\n\
    \   |\n16 |     for &v in l {\n   |         ^^    - this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `v`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `from_chars` found for struct `String` in the current scope\n  --> /tmp/tmpup4budjc.rs:19:7\n\
    \   |\n19 |     s.from_chars(l).to_string()\n   |       ^^^^^^^^^^ help: there\
    \ is an associated function with a similar name: `chars`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0308, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = String::from(*s);\n    let mut alphabet\
    \ = [97u8, 65u8, 97u8, 65u8];\n    \n    for x in alphabet {\n        s.push_str(&x.to_string());\n\
    \        let mut c = x % 26;\n        c += 26 - c as usize;\n        let mut k\
    \ = c % 26; // k should be an index in the alphabet array\n        k += 26 - k\
    \ as usize; // k should be an index in the alphabet array\n        alphabet.swap(k,\
    \ v);\n    }\n    \n    for x in alphabet {\n        s.push_str(&x.to_string());\n\
    \        let mut c = x % 26;\n        c += 26 - c as usize;\n        let mut k\
    \ = c % 26; // k should be an index in the alphabet array\n        k += 26 - k\
    \ as usize; // k should be an index in the alphabet array\n        alphabet.swap(k,\
    \ v);\n    }\n    \n    s.clone()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `v` in this scope\n  --> /tmp/tmpsrl659dk.rs:24:26\n\
    \   |\n24 |         alphabet.swap(k, v);\n   |                          ^ help:\
    \ a local variable with a similar name exists: `c`\n\nerror[E0425]: cannot find\
    \ value `v` in this scope\n  --> /tmp/tmpsrl659dk.rs:33:26\n   |\n33 |       \
    \  alphabet.swap(k, v);\n   |                          ^ help: a local variable\
    \ with a similar name exists: `c`\n\nerror[E0277]: the size for values of type\
    \ `str` cannot be known at compilation time\n   --> /tmp/tmpsrl659dk.rs:15:30\n\
    \    |\n15  |     let mut s = String::from(*s);\n    |                 ------------\
    \ ^^ doesn't have a size known at compile-time\n    |                 |\n    |\
    \                 required by a bound introduced by this call\n    |\n    = help:\
    \ the trait `Sized` is not implemented for `str`\nnote: required by a bound in\
    \ `from`\n\nerror[E0277]: the trait bound `String: From<str>` is not satisfied\n\
    \  --> /tmp/tmpsrl659dk.rs:15:17\n   |\n15 |     let mut s = String::from(*s);\n\
    \   |                 ^^^^^^^^^^^^ the trait `From<str>` is not implemented for\
    \ `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpsrl659dk.rs:21:14\n   |\n21 |\
    \         c += 26 - c as usize;\n   |              ^^^^^^^^^^^^^^^ expected `u8`,\
    \ found `usize`\n\nerror[E0277]: cannot add-assign `usize` to `u8`\n  --> /tmp/tmpsrl659dk.rs:21:11\n\
    \   |\n21 |         c += 26 - c as usize;\n   |           ^^ no implementation\
    \ for `u8 += usize`\n   |\n   = help: the trait `AddAssign<usize>` is not implemented\
    \ for `u8`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // First rotate the alphabet by two.\n    let mut cipher\
    \ = s.chars().cloned().rotate_left(2).collect();\n    // Shift each character\
    \ by two positions.\n    for (i, c) in cipher.iter().enumerate() {\n        if\
    \ c == c.to_ascii_lowercase().unwrap_or('z') {\n            cipher.insert(i, c.to_ascii_lowercase().unwrap_or('z'));\n\
    \        }\n    }\n    // Reverse the order of characters and add them to the\
    \ result.\n    cipher.reverse();\n    cipher.extend(s.chars().cloned().rotate_left(2).collect());\n\
    \    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpg9qqp3c8.rs:16:32\n     |\n16   |     let mut cipher =\
    \ s.chars().cloned().rotate_left(2).collect();\n     |                       \
    \         ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: no method named `rotate_left` found for struct\
    \ `Cloned` in the current scope\n  --> /tmp/tmpg9qqp3c8.rs:16:41\n   |\n16 | \
    \    let mut cipher = s.chars().cloned().rotate_left(2).collect();\n   |     \
    \                                    ^^^^^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \    --> /tmp/tmpg9qqp3c8.rs:25:29\n     |\n25   |     cipher.extend(s.chars().cloned().rotate_left(2).collect());\n\
    \     |                             ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0599]: no method named\
    \ `rotate_left` found for struct `Cloned` in the current scope\n  --> /tmp/tmpg9qqp3c8.rs:25:38\n\
    \   |\n25 |     cipher.extend(s.chars().cloned().rotate_left(2).collect());\n\
    \   |                                      ^^^^^^^^^^^ method not found in `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0271, E0599.\nFor more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [&\"a\", \"b\", \"c\", \"d\", \"\
    e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"\
    p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n\
    \    alphabet[alphabet.len() - 1] = &alphabet[0];\n    alphabet.sort();\n    let\
    \ mut new_alphabet = alphabet.clone();\n    new_alphabet.push(\"a\");\n    new_alphabet.push(\"\
    b\");\n    new_alphabet.push(\"c\");\n    new_alphabet.push(\"d\");\n    new_alphabet.push(\"\
    e\");\n    new_alphabet.push(\"f\");\n    new_alphabet.push(\"g\");\n    new_alphabet.push(\"\
    h\");\n    new_alphabet.push(\"i\");\n    new_alphabet.push(\"j\");\n    new_alphabet.push(\"\
    k\");\n    new_alphabet.push(\"l\");\n    new_alphabet.push(\"m\");\n    new_alphabet.push(\"\
    n\");\n    new_alphabet.push(\"o\");\n    new_alphabet.push(\"p\");\n    new_alphabet.push(\"\
    q\");\n    new_alphabet.push(\"r\");\n    new_alphabet.push(\"s\");\n    new_alphabet.push(\"\
    t\");\n    new_alphabet.push(\"u\");\n    new_alphabet.push(\"v\");\n    new_alphabet.push(\"\
    w\");\n    new_alphabet.push(\"x\");\n    new_alphabet.push(\"y\");\n    new_alphabet.push(\"\
    z\");\n\n    let mut result = String::new();\n    result.push_str(&new_alphabet);\n\
    \    for i in s.chars() {\n        let n = alphabet.iter().position(|&x| x ==\
    \ i).unwrap();\n        result[n - 2] = &new_alphabet[n + 1];\n        result[n\
    \ - 1] = &new_alphabet[n];\n    }\n\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for array `[&str; 26]` in the\
    \ current scope\n  --> /tmp/tmpkoh99c7k.rs:19:18\n   |\n19 |     new_alphabet.push(\"\
    a\");\n   |                  ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[&str; 26]` in the current scope\n \
    \ --> /tmp/tmpkoh99c7k.rs:20:18\n   |\n20 |     new_alphabet.push(\"b\");\n  \
    \ |                  ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]: no\
    \ method named `push` found for array `[&str; 26]` in the current scope\n  -->\
    \ /tmp/tmpkoh99c7k.rs:21:18\n   |\n21 |     new_alphabet.push(\"c\");\n   |  \
    \                ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]: no method\
    \ named `push` found for array `[&str; 26]` in the current scope\n  --> /tmp/tmpkoh99c7k.rs:22:18\n\
    \   |\n22 |     new_alphabet.push(\"d\");\n   |                  ^^^^ method not\
    \ found in `[&str; 26]`\n\nerror[E0599]: no method named `push` found for array\
    \ `[&str; 26]` in the current scope\n  --> /tmp/tmpkoh99c7k.rs:23:18\n   |\n23\
    \ |     new_alphabet.push(\"e\");\n   |                  ^^^^ method not found\
    \ in `[&str; 26]`\n\nerror[E0599]: no method named `push` found for array `[&str;\
    \ 26]` in the current scope\n  --> /tmp/tmpkoh99c7k.rs:24:18\n   |\n24 |     new_alphabet.push(\"\
    f\");\n   |                  ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]:\
    \ no method named `push` found for array `[&str; 26]` in the current scope\n \
    \ --> /tmp/tmpkoh99c7k.rs:25:18\n   |\n25 |     new_alphabet.push(\"g\");\n  \
    \ |                  ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]: no\
    \ method named `push` found for array `[&str; 26]` in the current scope\n  -->\
    \ /tmp/tmpkoh99c7k.rs:26:18\n   |\n26 |     new_alphabet.push(\"h\");\n   |  \
    \                ^^^^ method not found in `[&str; 26]`\n\nerror[E0599]: no method\
    \ named `push` found for array `[&str; 26]` in the current scope\n  --> /tmp/tmpkoh99c7k.rs:27:18\n\
    \   |\n27 |     new_alphabet.push(\"i\");\n   |                  ^^^^ method not\
    \ found in `[&str; 26]`\n\nerror[E0599]: no method named `push` found for array\
    \ `[&str; 26]` in the current scope"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = ROTATE_TABLE;\n    alphabet.insert(0,\
    \ ROTATE_TABLE[alphabet.len()]);\n    let mut result = String::from(\"\");\n \
    \   for c in s.chars() {\n        let position = alphabet.index(ROTATE_TABLE[alphabet.len()]);\n\
    \        result += c.to_ascii_uppercase().chars().fold(\"\".to_string(), |acc,\
    \ &b| acc + &alphabet[position] + &b);\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ROTATE_TABLE` in this scope\n  --> /tmp/tmpq355nafo.rs:15:24\n\
    \   |\n15 |     let mut alphabet = ROTATE_TABLE;\n   |                       \
    \ ^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ROTATE_TABLE`\
    \ in this scope\n  --> /tmp/tmpq355nafo.rs:16:24\n   |\n16 |     alphabet.insert(0,\
    \ ROTATE_TABLE[alphabet.len()]);\n   |                        ^^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `ROTATE_TABLE` in this\
    \ scope\n  --> /tmp/tmpq355nafo.rs:19:39\n   |\n19 |         let position = alphabet.index(ROTATE_TABLE[alphabet.len()]);\n\
    \   |                                       ^^^^^^^^^^^^ not found in this scope\n\
    \nerror[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpq355nafo.rs:20:42\n   |\n20 |         result += c.to_ascii_uppercase().chars().fold(\"\
    \".to_string(), |acc, &b| acc + &alphabet[position] + &b);\n   |             \
    \                             ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().filter(|c| c >= 'a' && c <= 'z').map(|c|\
    \ c - 'a' + 2).collect::<String>()\n        .iter()\n        .map(|c| 'a' + c).collect::<String>()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpuwbccl_k.rs:15:31\n   |\n\
    15 |     s.chars().filter(|c| c >= 'a' && c <= 'z').map(|c| c - 'a' + 2).collect::<String>()\n\
    \   |                               ^^^\n   |                               |\n\
    \   |                               expected `&char`, found `char`\n   |     \
    \                          help: consider borrowing here: `&'a'`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpuwbccl_k.rs:15:43\n   |\n15 |     s.chars().filter(|c|\
    \ c >= 'a' && c <= 'z').map(|c| c - 'a' + 2).collect::<String>()\n   |       \
    \                                    ^^^\n   |                               \
    \            |\n   |                                           expected `&char`,\
    \ found `char`\n   |                                           help: consider\
    \ borrowing here: `&'z'`\n\nerror[E0369]: cannot subtract `char` from `char`\n\
    \  --> /tmp/tmpuwbccl_k.rs:15:58\n   |\n15 |     s.chars().filter(|c| c >= 'a'\
    \ && c <= 'z').map(|c| c - 'a' + 2).collect::<String>()\n   |                \
    \                                        - ^ --- char\n   |                  \
    \                                      |\n   |                               \
    \                         char\n\nerror[E0599]: no method named `iter` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpuwbccl_k.rs:16:10\n   |\n\
    16 |         .iter()\n   |          ^^^^ method not found in `String`\n   |\n\
    help: because of the in-memory representation of `&str`, to obtain an `Iterator`\
    \ over each of its codepoint use method `chars`\n   |\n16 |         .chars()\n\
    \   |          ~~~~~\n\nerror[E0369]: cannot add `_` to `char`\n  --> /tmp/tmpuwbccl_k.rs:17:22\n\
    \   |\n17 |         .map(|c| 'a' + c).collect::<String>()\n   |              \
    \    --- ^ - _\n   |                  |\n   |                  char\n\nerror:\
    \ aborting due to 5 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.rotate_left()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpu1p_p43u.rs:15:7\n   |\n15 |     s.rotate_left()\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(s.chars(), 2, 2)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpc_khuwof.rs:15:5\n   |\n15 |     rotate_alphabet(s.chars(), 2, 2)\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(ROTATE_ALPHABET, s.chars());\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpo69pn22x.rs:15:5\n   |\n15 |     rotate_alphabet(ROTATE_ALPHABET, s.chars());\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROTATE_ALPHABET` in this scope\n  --> /tmp/tmpo69pn22x.rs:15:21\n   |\n\
    15 |     rotate_alphabet(ROTATE_ALPHABET, s.chars());\n   |                  \
    \   ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = alphabet.clone();\n    for c in\
    \ &alphabet {\n        alphabet[c] = c - 2 if alphabet.contains(c) ^ alphabet.contains(c\
    \ - 2);\n    }\n    let mut result = s.clone();\n    alphabet.iter().for_each(|c|\
    \ result.insert(c, c));\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmpwy6bcf11.rs:17:29\n   |\n17 |         alphabet[c] = c -\
    \ 2 if alphabet.contains(c) ^ alphabet.contains(c - 2);\n   |                \
    \             ^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmpwy6bcf11.rs:15:24\n\
    \   |\n15 |     let mut alphabet = alphabet.clone();\n   |                   \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpwy6bcf11.rs:20:51\n   |\n20 |     alphabet.iter().for_each(|c| result.insert(c,\
    \ c));\n   |                                                   ^ expected `char`,\
    \ found `usize`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut rotated_alphabet = Alphabet::new(Alphabet::AlphabetType::Rotated);\n\
    \    let mut input = s;\n    let mut output: Vec<u8> = vec![];\n    let mut i\
    \ = 1;\n\n    loop {\n        let c = input.chars().nth(i).unwrap();\n       \
    \ rotated_alphabet.push(c);\n        i += 2;\n        if i < input.len() {\n \
    \           output.push(rotated_alphabet.last().unwrap());\n            i += 1;\n\
    \        }\n    }\n\n    String::from_utf8_lossy(&output)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpvmgitw8z.rs:15:32\n   |\n15 |     let mut rotated_alphabet = Alphabet::new(Alphabet::AlphabetType::Rotated);\n\
    \   |                                ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpvmgitw8z.rs:15:46\n\
    \   |\n15 |     let mut rotated_alphabet = Alphabet::new(Alphabet::AlphabetType::Rotated);\n\
    \   |                                              ^^^^^^^^ use of undeclared\
    \ type `Alphabet`\n\nwarning: unreachable expression\n  --> /tmp/tmpvmgitw8z.rs:30:5\n\
    \   |\n20 | /     loop {\n21 | |         let c = input.chars().nth(i).unwrap();\n\
    22 | |         rotated_alphabet.push(c);\n23 | |         i += 2;\n...  |\n27 |\
    \ |         }\n28 | |     }\n   | |_____- any code following this expression is\
    \ unreachable\n29 | \n30 |       String::from_utf8_lossy(&output)\n   |      \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable expression\n   |\n   = note: `#[warn(unreachable_code)]`\
    \ on by default\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpvmgitw8z.rs:30:5\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n30 |     String::from_utf8_lossy(&output)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- help: try using a conversion method:\
    \ `.to_string()`\n   |     |\n   |     expected struct `String`, found enum `Cow`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Cow<'_,\
    \ str>`\n\nerror: aborting due to 3 previous errors; 1 warning emitted\n\nSome\
    \ errors have detailed explanations: E0308, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c = 0;\n    \n    for ch in s.chars() {\n \
    \       if c*2 < 64 {\n            c *= 2;\n        }\n        \n        if c\
    \ >= 65 {\n            c -= 65;\n        }\n        \n        c += ch;\n    }\n\
    \    \n    String::from(c)\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add-assign `char` to `{integer}`\n  --> /tmp/tmpoew3fl5o.rs:26:11\n\
    \   |\n26 |         c += ch;\n   |           ^^ no implementation for `{integer}\
    \ += char`\n   |\n   = help: the trait `AddAssign<char>` is not implemented for\
    \ `{integer}`\n   = help: the following other types implement trait `AddAssign<Rhs>`:\n\
    \             <f32 as AddAssign<&f32>>\n             <f32 as AddAssign>\n    \
    \         <f64 as AddAssign<&f64>>\n             <f64 as AddAssign>\n        \
    \     <i128 as AddAssign<&i128>>\n             <i128 as AddAssign>\n         \
    \    <i16 as AddAssign<&i16>>\n             <i16 as AddAssign>\n           and\
    \ 20 others\n\nerror[E0277]: the trait bound `String: From<{integer}>` is not\
    \ satisfied\n  --> /tmp/tmpoew3fl5o.rs:29:5\n   |\n29 |     String::from(c)\n\
    \   |     ^^^^^^^^^^^^ the trait `From<{integer}>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![s.chars().skip(2).collect::<Vec<_>>(),\
    \ s.chars().skip(2).collect::<Vec<_>>()];\n    alphabet.swap(alphabet.iter_mut());\n\
    \    encrypt2(&alphabet).into()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt2` in this scope\n  --> /tmp/tmppok_kxwt.rs:17:5\n\
    \   |\n17 |     encrypt2(&alphabet).into()\n   |     ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmppok_kxwt.rs:16:14\n    |\n16  |     alphabet.swap(alphabet.iter_mut());\n\
    \    |              ^^^^ ------------------- supplied 1 argument\n    |      \
    \        |\n    |              expected 2 arguments\n    |\nnote: associated function\
    \ defined here\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0061, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = s.clone();\n    let mut new_cipher\
    \ = \"\";\n    for (i, c) in cipher.chars().enumerate() {\n        let mut new_char\
    \ = \"?\".to_string();\n        let mut n = c + 2;\n        while n < 26 {\n \
    \           new_char = new_char.chars().next().unwrap().to_string().to_string();\n\
    \            new_char = new_char.concat(new_char.chars().next().unwrap().to_string());\n\
    \            n += 2;\n        }\n        new_cipher = new_cipher.to_string() +\
    \ new_char;\n    }\n    new_cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `{integer}` to `char`\n  --> /tmp/tmpmulnw7bm.rs:19:23\n\
    \   |\n19 |         let mut n = c + 2;\n   |                     - ^ - {integer}\n\
    \   |                     |\n   |                     char\n\nerror[E0599]: no\
    \ method named `concat` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpmulnw7bm.rs:22:33\n   |\n22 |             new_char = new_char.concat(new_char.chars().next().unwrap().to_string());\n\
    \   |                                 ^^^^^^ method not found in `String`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpmulnw7bm.rs:25:47\n   |\n25 |  \
    \       new_cipher = new_cipher.to_string() + new_char;\n   |                \
    \                               ^^^^^^^^\n   |                               \
    \                |\n   |                                               expected\
    \ `&str`, found struct `String`\n   |                                        \
    \       help: consider borrowing here: `&new_char`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmulnw7bm.rs:25:22\n   |\n16 |     let mut new_cipher =\
    \ \"\";\n   |                          -- expected due to this value\n...\n25\
    \ |         new_cipher = new_cipher.to_string() + new_char;\n   |            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |                      |\n  \
    \ |                      expected `&str`, found struct `String`\n   |        \
    \              help: consider borrowing here: `&(new_cipher.to_string() + new_char)`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpmulnw7bm.rs:27:5\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n27 |     new_cipher\n   |     ^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 5 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut i = 0;\n\
    \    for c in s.chars() {\n        if i == 0 || i == 2 {\n            result.push((*c\
    \ as u8) + 4);\n        } else if i == 1 {\n            result.push((*c as u8)\
    \ - 2);\n        } else {\n            result.push(*c);\n        }\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpol34stf7.rs:19:26\n\
    \   |\n19 |             result.push((*c as u8) + 4);\n   |                   \
    \       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpol34stf7.rs:21:26\n\
    \   |\n21 |             result.push((*c as u8) - 2);\n   |                   \
    \       ^^\n\nerror[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpol34stf7.rs:23:25\n\
    \   |\n23 |             result.push(*c);\n   |                         ^^\n\n\
    error: aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0614`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    cipher (s)\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `cipher` in this scope\n  --> /tmp/tmpee9v5tyf.rs:15:5\n\
    \   |\n15 |     cipher (s)\n   |     ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut ciphertext = s.to_string();\n\n    ciphertext.rotate_left(2);\n\
    \    ciphertext.rotate_left(2);\n\n    ciphertext\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp_xnz9wee.rs:17:16\n   |\n17 |     ciphertext.rotate_left(2);\n\
    \   |                ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]:\
    \ no method named `rotate_left` found for struct `String` in the current scope\n\
    \  --> /tmp/tmp_xnz9wee.rs:18:16\n   |\n18 |     ciphertext.rotate_left(2);\n\
    \   |                ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().collect::<Vec<u8>>();\n\
    \    alphabet.sort_unstable();\n    alphabet.iter_mut().for_each(|&c| c += 2);\n\
    \    alphabet.iter_mut().for_each(|&c| c -= 2);\n    alphabet = alphabet.join(\"\
    \");\n    let mut enc = s.to_lowercase();\n    for c in alphabet {\n        enc\
    \ = enc.insert(c, c+1);\n    }\n    enc\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<u8>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpwz_ws65n.rs:15:34\n     |\n15\
    \   |     let mut alphabet = s.chars().collect::<Vec<u8>>();\n     |         \
    \                         ^^^^^^^ value of type `Vec<u8>` cannot be built from\
    \ `std::iter::Iterator<Item=char>`\n     |\n     = help: the trait `FromIterator<char>`\
    \ is not implemented for `Vec<u8>`\n     = help: the trait `FromIterator<T>` is\
    \ implemented for `Vec<T>`\nnote: required by a bound in `collect`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwz_ws65n.rs:17:35\n   |\n17 |     alphabet.iter_mut().for_each(|&c|\
    \ c += 2);\n   |                                   ^--\n   |                 \
    \                  ||\n   |                                   |expected due to\
    \ this\n   |                                   types differ in mutability\n  \
    \ |                                   help: did you mean `c`: `&&mut u8`\n   |\n\
    \   = note: expected mutable reference `&mut u8`\n                      found\
    \ reference `&_`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpwz_ws65n.rs:18:35\n\
    \   |\n18 |     alphabet.iter_mut().for_each(|&c| c -= 2);\n   |             \
    \                      ^--\n   |                                   ||\n   |  \
    \                                 |expected due to this\n   |                \
    \                   types differ in mutability\n   |                         \
    \          help: did you mean `c`: `&&mut u8`\n   |\n   = note: expected mutable\
    \ reference `&mut u8`\n                      found reference `&_`\n\nerror[E0599]:\
    \ the method `join` exists for struct `Vec<u8>`, but its trait bounds were not\
    \ satisfied\n  --> /tmp/tmpwz_ws65n.rs:19:25\n   |\n19 |     alphabet = alphabet.join(\"\
    \");\n   |                         ^^^^ method cannot be called on `Vec<u8>` due\
    \ to unsatisfied trait bounds\n   |\n   = note: the following trait bounds were\
    \ not satisfied:\n           `[u8]: Join<_>`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpwz_ws65n.rs:22:26\n   |\n22 |         enc = enc.insert(c, c+1);\n\
    \   |                          ^ expected"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::with_capacity(s.len());\n\
    \    for(i, c) in s.chars().enumerate() {\n        cipher.push((c + i * 2).to_string());\n\
    \    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `usize` to `char`\n  --> /tmp/tmp41i9vsp0.rs:17:24\n\
    \   |\n17 |         cipher.push((c + i * 2).to_string());\n   |              \
    \        - ^ ----- usize\n   |                      |\n   |                  \
    \    char\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt(s.chars().collect::<Vec<_>>().as_slice())\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3iomw2ao.rs:15:13\n   |\n\
    15 |     encrypt(s.chars().collect::<Vec<_>>().as_slice())\n   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `String`, found `&[char]`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = ALPHABET.clone();\n    alphabet.rotate_left(2);\n\
    \    alphabet.rotate_left(4);\n\n    let mut cipher = s.clone();\n    cipher.rotate_left(1);\n\
    \n    let mut result = String::new();\n    for c in &cipher {\n        result.push(*alphabet.borrow().check(c));\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmp2bh1m5ux.rs:15:24\n\
    \   |\n15 |     let mut alphabet = ALPHABET.clone();\n   |                   \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method named `rotate_left`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmp2bh1m5ux.rs:20:12\n\
    \   |\n20 |     cipher.rotate_left(1);\n   |            ^^^^^^^^^^^ method not\
    \ found in `String`\n\nerror[E0277]: `&String` is not an iterator\n  --> /tmp/tmp2bh1m5ux.rs:23:14\n\
    \   |\n23 |     for c in &cipher {\n   |              ^^^^^^^ `&String` is not\
    \ an iterator\n   |\n   = help: the trait `Iterator` is not implemented for `&String`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `&String`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0277, E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| {\n        let mut letter = c.to_string();\n\
    \        letter = rotl_d(letter);\n        letter = rotl_a(letter);\n        letter\
    \ = rotl_c(letter);\n        letter\n    }).collect()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotl_d` in this scope\n  --> /tmp/tmpljtspn_q.rs:17:18\n\
    \   |\n17 |         letter = rotl_d(letter);\n   |                  ^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `rotl_a` in this scope\n\
    \  --> /tmp/tmpljtspn_q.rs:18:18\n   |\n18 |         letter = rotl_a(letter);\n\
    \   |                  ^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `rotl_c` in this scope\n  --> /tmp/tmpljtspn_q.rs:19:18\n   |\n\
    19 |         letter = rotl_c(letter);\n   |                  ^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt2(s.chars().collect::<String>(), s.len())\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt2` in this scope\n  --> /tmp/tmpzurh6skx.rs:15:5\n\
    \   |\n15 |     encrypt2(s.chars().collect::<String>(), s.len())\n   |     ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut n = String::from(\"z\");\n    n += s.chars().skip_while(|&c|\
    \ c != 'a').count();\n    n += s.chars().skip_while(|&c| c != 'b').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'c').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'd').count();\n    n += s.chars().skip_while(|&c| c != 'e').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'f').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'g').count();\n    n += s.chars().skip_while(|&c| c != 'h').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'j').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'k').count();\n    n += s.chars().skip_while(|&c| c != 'l').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'm').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'n').count();\n    n += s.chars().skip_while(|&c| c != 'o').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'p').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'q').count();\n    n += s.chars().skip_while(|&c| c != 'r').count();\n\
    \    n += s.chars().skip_while(|&c| c != 's').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 't').count();\n    n += s.chars().skip_while(|&c| c != 'u').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'v').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'w').count();\n    n += s.chars().skip_while(|&c| c != 'x').count();\n\
    \    n += s.chars().skip_while(|&c| c != 'y').count();\n    n += s.chars().skip_while(|&c|\
    \ c != 'z').count();\n    n\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:16:10\n   |\n\
    16 |     n += s.chars().skip_while(|&c| c != 'a').count();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:17:10\n\
    \   |\n17 |     n += s.chars().skip_while(|&c| c != 'b').count();\n   |      \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:18:10\n   |\n18 |\
    \     n += s.chars().skip_while(|&c| c != 'c').count();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:19:10\n\
    \   |\n19 |     n += s.chars().skip_while(|&c| c != 'd').count();\n   |      \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:20:10\n   |\n20 |\
    \     n += s.chars().skip_while(|&c| c != 'e').count();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:21:10\n\
    \   |\n21 |     n += s.chars().skip_while(|&c| c != 'f').count();\n   |      \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:22:10\n   |\n22 |\
    \     n += s.chars().skip_while(|&c| c != 'g').count();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:23:10\n\
    \   |\n23 |     n += s.chars().skip_while(|&c| c != 'h').count();\n   |      \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:24:10\n   |\n24 |\
    \     n += s.chars().skip_while(|&c| c != 'j').count();\n   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `&str`, found `usize`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpu1asajhu.rs:25:10\n\
    \   |\n25 |     n += s.chars().ski"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c = s.chars();\n\n    let mut l = c.len();\n\
    \    let mut x = l;\n    let mut y = l;\n\n    while x > 0 {\n        if *x %\
    \ 2 == 1 {\n            *y = *y;\n            *x = *x / *x;\n        } else {\n\
    \            *y = *y / 2;\n            *x = *x / 2;\n        }\n        y = x\
    \ + 1;\n    }\n\n    String::from_utf8_lossy(c.iter().cloned())\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmpmzwag8h2.rs:17:19\n   |\n17 |     let mut l = c.len();\n\
    \   |                   ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no\
    \ method named `iter` found for struct `Chars` in the current scope\n  --> /tmp/tmpmzwag8h2.rs:32:31\n\
    \   |\n32 |     String::from_utf8_lossy(c.iter().cloned())\n   |             \
    \                  ^^^^ private field, not a method\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpmzwag8h2.rs:32:5\n   |\n14 | fn encrypt(s: String) -> String\
    \ {\n   |                          ------ expected `String` because of return\
    \ type\n...\n32 |     String::from_utf8_lossy(c.iter().cloned())\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^-\
    \ help: try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found enum `Cow`\n   |\n   = note: expected struct `String`\n\
    \                found enum `Cow<'_, str>`\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c ^ 0xAE).collect::<Vec<_>>();\n\
    \    let mut rotations = 1;\n\n    while alphabet.len() % 4 != 0 {\n        alphabet\
    \ = alphabet.iter().cloned().enumerate().map(|(i, &c)| {\n            if i % 4\
    \ == 0 {\n                alphabet.insert(i, c ^ 0xAE);\n            }\n\n   \
    \         alphabet.insert(i, c);\n        }).collect::<Vec<_>>();\n\n        rotations\
    \ *= 2;\n    }\n\n    alphabet\n        .into_iter()\n        .map(|c| c ^ 0xAE)\n\
    \        .collect::<Vec<_>>()\n        .iter()\n        .map(|c| c.to_string())\n\
    \        .collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ {integer}`\n  --> /tmp/tmpr99d3miv.rs:15:44\n\
    \   |\n15 |     let mut alphabet = s.chars().map(|c| c ^ 0xAE).collect::<Vec<_>>();\n\
    \   |                                          - ^ ---- {integer}\n   |      \
    \                                    |\n   |                                 \
    \         char\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr99d3miv.rs:24:32\n\
    \   |\n24 |             alphabet.insert(i, c);\n   |                         \
    \       ^\n   |                                |\n   |                       \
    \         cyclic type of infinite size\n   |                                help:\
    \ consider borrowing here: `&c`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpr99d3miv.rs:19:20\n\
    \   |\n15 |       let mut alphabet = s.chars().map(|c| c ^ 0xAE).collect::<Vec<_>>();\n\
    \   |                          -----------------------------------------------\
    \ expected due to this value\n...\n19 |           alphabet = alphabet.iter().cloned().enumerate().map(|(i,\
    \ &c)| {\n   |  ____________________^\n20 | |             if i % 4 == 0 {\n21\
    \ | |                 alphabet.insert(i, c ^ 0xAE);\n22 | |             }\n23\
    \ | |\n24 | |             alphabet.insert(i, c);\n25 | |         }).collect::<Vec<_>>();\n\
    \   | |______________________________^ expected reference, found `()`\n   |\n\
    \   = note: expected struct `Vec<&_>`\n              found struct `Vec<()>`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0369.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().cloned().collect::<Vec<_>>();\n\
    \    alphabet.rotate_left(1);\n    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n\
    \    alphabet.push(alphabet.last());\n    alphabet.push(alphabet.last());\n  \
    \  alphabet\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpehw9_60l.rs:15:34\n     |\n15   |     let mut alphabet\
    \ = s.chars().cloned().collect::<Vec<_>>();\n     |                          \
    \        ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpehw9_60l.rs:15:43\n \
    \  |\n15 |       let mut alphabet = s.chars().cloned().collect::<Vec<_>>();\n\
    \   |                                             ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encryptImpl(s, &mut alphabet)\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encryptImpl` in this scope\n  --> /tmp/tmpa08s1l0q.rs:15:5\n\
    \   |\n15 |     encryptImpl(s, &mut alphabet)\n   |     ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmpa08s1l0q.rs:15:25\n   |\n15 |     encryptImpl(s, &mut alphabet)\n\
    \   |                         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    for c in s.chars()\
    \ {\n        let a = c.to_ascii_uppercase();\n        let mut b = a.clone();\n\
    \        b.rotate_left(2);\n        b.push(0);\n        cipher.push(b);\n    }\n\
    \    return cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for type `char` in the\
    \ current scope\n  --> /tmp/tmp7whecebo.rs:19:11\n   |\n19 |         b.rotate_left(2);\n\
    \   |           ^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]: no method\
    \ named `push` found for type `char` in the current scope\n  --> /tmp/tmp7whecebo.rs:20:11\n\
    \   |\n20 |         b.push(0);\n   |           ^^^^ method not found in `char`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| if c == 'z' { c - 'a' + 2 } else\
    \ { c })\n        .collect()\n        .to_string()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmp4nri1i1m.rs:15:39\n\
    \   |\n15 |     s.chars().map(|c| if c == 'z' { c - 'a' + 2 } else { c })\n  \
    \ |                                     - ^ --- char\n   |                   \
    \                  |\n   |                                     char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(s, 2);\n    s\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpyvv3e58v.rs:15:5\n   |\n15 |     rotate_alphabet(s, 2);\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet_down(s, 2);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet_down` in this scope\n\
    \  --> /tmp/tmpklrharlz.rs:15:5\n   |\n15 |     rotate_alphabet_down(s, 2);\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars()\n        .filter(|c| c.is_alphanumeric())\n\
    \        .map(|c| if c == 'A' { ('A'.to_char() + (*c - 'A').to_char()).to_string()\
    \ } else { c })\n        .collect::<String>()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `to_char` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpwvm03gix.rs:17:37\n   |\n17 |         .map(|c| if c ==\
    \ 'A' { ('A'.to_char() + (*c - 'A').to_char()).to_string() } else { c })\n   |\
    \                                     ^^^^^^^ method not found in `char`\n\nerror[E0614]:\
    \ type `char` cannot be dereferenced\n  --> /tmp/tmpwvm03gix.rs:17:50\n   |\n\
    17 |         .map(|c| if c == 'A' { ('A'.to_char() + (*c - 'A').to_char()).to_string()\
    \ } else { c })\n   |                                                  ^^\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0599, E0614.\nFor more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let alphabet =\
    \ chars::alphabet();\n    for c in s {\n        let idx = alphabet.index(c);\n\
    \        let two = idx % 2;\n        let idx2 = idx + two;\n        result.push_char(alphabet[alphabet.len()\
    \ - idx2].unwrap());\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmpl76vkrei.rs:16:20\n   |\n16 |     let alphabet = chars::alphabet();\n\
    \   |                    ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmpl76vkrei.rs:17:14\n   |\n17 |   \
    \  for c in s {\n   |              ^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0599]: no method named `push_char` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpl76vkrei.rs:21:16\n\
    \   |\n21 |         result.push_char(alphabet[alphabet.len() - idx2].unwrap());\n\
    \   |                ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `push_str`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0277, E0433, E0599.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().enumerate().map(|(i, c)| {\n        c + (i\
    \ % 2 == 0 ? 0 : (c - 2) * (c - 2))\n    }).fold(String::new(), |res, c| {\n \
    \       res + encode(&c, ALPHABET)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `!`, `(`, `)`, `+`, `,`, `::`, or `<`, found `-`\n\
    \  --> /tmp/tmp3cv8log1.rs:16:34\n   |\n16 |         c + (i % 2 == 0 ? 0 : (c\
    \ - 2) * (c - 2))\n   |                             -    ^ expected one of 7 possible\
    \ tokens\n   |                             |\n   |                           \
    \  tried to parse a type due to this\n\nerror: expected one of `)`, `,`, `.`,\
    \ `?`, or an operator, found `0`\n  --> /tmp/tmp3cv8log1.rs:16:27\n   |\n16 |\
    \         c + (i % 2 == 0 ? 0 : (c - 2) * (c - 2))\n   |                     \
    \     -^ expected one of `)`, `,`, `.`, `?`, or an operator\n   |            \
    \              |\n   |                          help: missing `,`\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `)`\n  --> /tmp/tmp3cv8log1.rs:16:48\n\
    \   |\n16 |         c + (i % 2 == 0 ? 0 : (c - 2) * (c - 2))\n   |           \
    \                                     ^ expected one of `.`, `;`, `?`, `}`, or\
    \ an operator\n\nerror[E0425]: cannot find function `encode` in this scope\n \
    \ --> /tmp/tmp3cv8log1.rs:18:15\n   |\n18 |         res + encode(&c, ALPHABET)\n\
    \   |               ^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ALPHABET` in this scope\n  --> /tmp/tmp3cv8log1.rs:18:26\n   |\n18 |\
    \         res + encode(&c, ALPHABET)\n   |                          ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    cipher.reserve(s.size());\n\
    \    for (i, c) in s.chars().enumerate() {\n        cipher.push((c as i32 + 2)\
    \ % alphabet.len());\n    }\n    cipher\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpb96avgw6.rs:18:38\n\
    \   |\n18 |         cipher.push((c as i32 + 2) % alphabet.len());\n   |      \
    \                                ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `size` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpb96avgw6.rs:16:22\n   |\n16 |     cipher.reserve(s.size());\n   |  \
    \                    ^^^^ method not found in `String`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpb96avgw6.rs:18:21\n   |\n18 |         cipher.push((c as\
    \ i32 + 2) % alphabet.len());\n   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `i32`\n\nerror: aborting due to 3 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c1 = s.chars().filter_map(|c| *c >= 'a' &&\
    \ *c <= 'z').count();\n    let mut c2 = s.chars().filter_map(|c| *c >= 'A' &&\
    \ *c <= 'Z').count();\n    c1.unwrap() %= (26 - 2);\n    c2.unwrap() %= (26 -\
    \ 2);\n    let mut c3 = s.chars().filter_map(|c| *c >= 'a' && *c <= 'z').count();\n\
    \    let mut c4 = s.chars().filter_map(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \    c3.unwrap() %= (26 - 2);\n    c4.unwrap() %= (26 - 2);\n    let mut c5 =\
    \ s.chars().filter_map(|c| *c >= 'a' && *c <= 'z').count();\n    let mut c6 =\
    \ s.chars().filter_map(|c| *c >= 'A' && *c <= 'Z').count();\n    c5.unwrap() %=\
    \ (26 - 2);\n    c6.unwrap() %= (26 - 2);\n    let mut c7 = s.chars().filter_map(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n    let mut c8 = s.chars().filter_map(|c|\
    \ *c >= 'A' && *c <= 'Z').count();\n    c7.unwrap() %= (26 - 2);\n    c8.unwrap()\
    \ %= (26 - 2);\n    let mut c9 = s.chars().filter_map(|c| *c >= 'a' && *c <= 'z').count();\n\
    \    let mut c10 = s.chars().filter_map(|c| *c >= 'A' && *c <= 'Z').count();\n\
    \    c9.unwrap() %= (26 - 2);\n    c10.unwrap() %= (26 - 2);\n    let mut c11\
    \ = s.chars().filter_map(|c| *c >= 'a' && *c <= 'z').count();\n    let mut c12\
    \ = s.chars().filter_map(|c| *c >= 'A' && *c <= 'Z').count();\n    c11.unwrap()\
    \ %= (26 - 2);\n    c12.unwrap() %= (26 - 2);\n    let mut c13 = s.chars().filter_map(|c|\
    \ *c >= 'a' && *c <= 'z').count();\n    let mut c14 = s.chars().filter_map(|c|\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected expression, found `)`\n  --> /tmp/tmp2j4d793d.rs:41:1\n\
    \   |\n41 | }\n   | ^ expected expression\n\nerror: mismatched closing delimiter:\
    \ `}`\n  --> /tmp/tmp2j4d793d.rs:40:39\n   |\n14 | fn encrypt(s: String) -> String\
    \ {\n   |                                 - closing delimiter possibly meant for\
    \ this\n...\n40 |     let mut c14 = s.chars().filter_map(|c|\n   |           \
    \                            ^ unclosed delimiter\n41 | }\n   | ^ mismatched closing\
    \ delimiter\n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp2j4d793d.rs:17:20\n\
    \   |\n17 |     c1.unwrap() %= (26 - 2);\n   |                    ^      ^\n \
    \  |\n   = note: `#[warn(unused_parens)]` on by default\nhelp: remove these parentheses\n\
    \   |\n17 -     c1.unwrap() %= (26 - 2);\n17 +     c1.unwrap() %= 26 - 2;\n  \
    \ | \n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp2j4d793d.rs:18:20\n\
    \   |\n18 |     c2.unwrap() %= (26 - 2);\n   |                    ^      ^\n \
    \  |\nhelp: remove these parentheses\n   |\n18 -     c2.unwrap() %= (26 - 2);\n\
    18 +     c2.unwrap() %= 26 - 2;\n   | \n\nwarning: unnecessary parentheses around\
    \ assigned value\n  --> /tmp/tmp2j4d793d.rs:21:20\n   |\n21 |     c3.unwrap()\
    \ %= (26 - 2);\n   |                    ^      ^\n   |\nhelp: remove these parentheses\n\
    \   |\n21 -     c3.unwrap() %= (26 - 2);\n21 +     c3.unwrap() %= 26 - 2;\n  \
    \ | \n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp2j4d793d.rs:22:20\n\
    \   |\n22 |     c4.unwrap() %= (26 - 2);\n   |                    ^      ^\n \
    \  |\nhelp: remove these parentheses\n   |\n22 -     c4.unwrap() %= (26 - 2);\n\
    22 +     c4.unwrap() %= 26 - 2;\n   | \n\nwarning: unnecessary parentheses around\
    \ assigned value\n  --> /tmp/tmp2j4d793d.rs:25:20\n   |\n25 |     c5.unwrap()\
    \ %= (26 - 2);\n   |                    ^      ^\n   |\nhelp: remove these parentheses\n\
    \   |\n25 -     c5.unwrap() %= (26 - 2);\n25 +     c5.unwrap() %= 26 - 2;\n  \
    \ | \n\nwarning: unnecessary parentheses around assigned value\n  --> /tmp/tmp2j4d793d.rs:26:20\n\
    \   |\n26 |     c6.unwrap() %= (26 - 2);\n   |                    ^      ^\n \
    \  |\nhe"
  stdout: ''
  timestamp: 1659976151
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    fn rotate(a: &[u8]) -> Vec<u8> {\n        let mut b\
    \ = a.to_owned();\n        b.rotate_left(2);\n        b.rotate_left(2);\n    \
    \    return b;\n    }\n    let mut enc = s.as_bytes().to_owned();\n    enc.rotate_left(2);\n\
    \    enc.rotate_left(2);\n    String::from_utf8(enc.to_vec()).unwrap()\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\"`,\n right: `\"lm\"`', /tmp/tmpqyxlr0ng.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s.to_string();\n    let mut l = s.len();\n\
    \    let mut i = 0;\n    while i < l {\n        let mut j = i;\n        while\
    \ j < l {\n            s[j] += 1;\n            if s[j] > 'z' - 2 {\n         \
    \       s[j] -= 2 + 'z';\n                break;\n            }\n            j\
    \ += 1;\n        }\n        let mut char = s.chars().nth(i).unwrap();\n      \
    \  char = char.rotate_right(2).unwrap();\n        s = s.insert(i, char).unwrap();\n\
    \        i += 1;\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy5ngo3sv.rs:21:13\n\
    \   |\n21 |             s[j] += 1;\n   |             ^^^^ `String` cannot be indexed\
    \ by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented for\
    \ `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpy5ngo3sv.rs:22:16\n   |\n22 |             if s[j] > 'z' - 2 {\n\
    \   |                ^^^^ `String` cannot be indexed by `usize`\n   |\n   = help:\
    \ the trait `Index<usize>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpy5ngo3sv.rs:22:27\n\
    \   |\n22 |             if s[j] > 'z' - 2 {\n   |                       --- ^\
    \ - {integer}\n   |                       |\n   |                       char\n\
    \nerror[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmpy5ngo3sv.rs:23:17\n\
    \   |\n23 |                 s[j] -= 2 + 'z';\n   |                 ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usi"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet: [Char; 26] = [0u8; 26];\n    let\
    \ mut j = 0;\n    for c in s.chars() {\n        let index = c - 'a' as usize;\n\
    \        alphabet[index] = alphabet[index] | (2 << j);\n        alphabet[index\
    \ + 26] = alphabet[index + 26] | (2 << (j + 1));\n        j += 1;\n    }\n   \
    \ let mut result = String::with_capacity(s.len());\n    let mut i = 0;\n    let\
    \ mut index = 0;\n    while i < s.len() {\n        let c = (s.charAt(i) - 'a'\
    \ as usize) + 26;\n        result.push((alphabet[index] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 1] >> i & 255).to_string());\n        result.push((alphabet[index\
    \ + 2] >> i & 255).to_string());\n        result.push((alphabet[index + 3] >>\
    \ i & 255).to_string());\n        result.push((alphabet[index + 4] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 5] >> i & 255).to_string());\n        result.push((alphabet[index\
    \ + 6] >> i & 255).to_string());\n        result.push((alphabet[index + 7] >>\
    \ i & 255).to_string());\n        result.push((alphabet[index + 8] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 9] >> i & 255).to_string());\n        result.push((alphabet[index\
    \ + 10] >> i & 255).to_string());\n        result.push((alphabet[index + 11] >>\
    \ i & 255).to_string());\n        result.push((alphabet[index + 12] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 13] >> i & 255).to_string());\n       \
    \ result.push((alphabet[index + 14] >> i & 255).to_string());\n        result.push((alphabet[index\
    \ + 15] >> i & 255).to_string());\n        result.push((alphabet[index + 16] >>\
    \ i & 255).to_string());\n        result.push((alphabet[index + 17] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 18] >> i & 255).to_string());\n       \
    \ result.push((alphabet[index + 19] >> i & 255).to_string());\n        result.push((alphabet[index\
    \ + 20] >> i & 255).to_string());\n        result.push((alphabet[index + 21] >>\
    \ i & 255).to_string());\n        result.push((alphabet[index + 22] >> i & 255).to_string());\n\
    \        result.push((alphabet[index + 23] >> i & 255).to_string());\n       \
    \ result.push((alphabet[index + 24] >> i & 255).\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpdn7u5x50.rs:65:3\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - unclosed delimiter\n...\n26 |     while i < s.len() {\n   |        \
    \               - this delimiter might not be properly closed...\n...\n53 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n65 | }\n\
    \   |   ^\n\nerror: mismatched closing delimiter: `}`\n  --> /tmp/tmpdn7u5x50.rs:52:20\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n...\n52 |         result.push((alphabet[index\
    \ + 24] >> i & 255).\n   |                    ^ unclosed delimiter\n53 | }\n \
    \  | ^ mismatched closing delimiter\n\nerror: unexpected token: `)`\n  --> /tmp/tmpdn7u5x50.rs:53:1\n\
    \   |\n53 | }\n   | ^\n\nerror[E0412]: cannot find type `Char` in this scope\n\
    \  --> /tmp/tmpdn7u5x50.rs:15:24\n   |\n15 |     let mut alphabet: [Char; 26]\
    \ = [0u8; 26];\n   |                        ^^^^ help: a builtin type with a similar\
    \ name exists (notice the capitalization): `char`\n\nwarning: unnecessary parentheses\
    \ around method argument\n  --> /tmp/tmpdn7u5x50.rs:52:21\n   |\n52 |        \
    \ result.push((alphabet[index + 24] >> i & 255).\n   |                     ^ \
    \                              ^\n   |\n   = note: `#[warn(unused_parens)]` on\
    \ by default\nhelp: remove these parentheses\n   |\n52 -         result.push((alphabet[index\
    \ + 24] >> i & 255).\n52 +         result.push(alphabet[index + 24] >> i & 255.\n\
    \   | \n\nerror[E0369]: cannot subtract `usize` from `char`\n  --> /tmp/tmpdn7u5x50.rs:18:23\n\
    \   |\n18 |         let index = c - 'a' as usize;\n   |                     -\
    \ ^ ------------ usize\n   |                     |\n   |                     char\n\
    \nerror[E0599]: no method named `charAt` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpdn7u5x50.rs:27:20\n   |\n27 |         let c = (s.charAt(i)\
    \ - 'a' as usize) + 26;\n   |                    ^^^^^^ help: there is an associated\
    \ function with a similar name: `chars`\n\nerror[E0308]: mismatched types\n  "
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    ];\n    alphabet.iter().for_each(|c| {\n        alphabet.push(alphabet.iter().next().unwrap());\n\
    \        alphabet.push(alphabet.iter().next().unwrap());\n    });\n    let mut\
    \ result = String::new();\n    for i in s.chars() {\n        let mut k = alphabet.iter().next().unwrap();\n\
    \        k.rotate_left(1);\n        result.push_str(&k);\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for reference `&&str`\
    \ in the current scope\n  --> /tmp/tmpacpbtwaf.rs:23:11\n   |\n23 |         k.rotate_left(1);\n\
    \   |           ^^^^^^^^^^^ method not found in `&&str`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    for &c in s.chars().skip_while(|c|\
    \ *c != 'a') {\n        *c = rotate_letters(*c, 2);\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_letters` in this scope\n  -->\
    \ /tmp/tmp3rf1g3tg.rs:17:14\n   |\n17 |         *c = rotate_letters(*c, 2);\n\
    \   |              ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3rf1g3tg.rs:16:9\n   |\n16 |     for &c in s.chars().skip_while(|c|\
    \ *c != 'a') {\n   |         ^^    ----------------------------------- this expression\
    \ has type `Option<char>`\n   |         |\n   |         expected `char`, found\
    \ reference\n   |         help: you can probably remove the explicit borrow: `c`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt2(s.as_bytes())\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt2` in this scope\n  --> /tmp/tmp8ql8ywm6.rs:15:5\n\
    \   |\n15 |     encrypt2(s.as_bytes())\n   |     ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    if s.len() <= 2 {\n        return s.to_owned();\n \
    \   }\n    let mut t = s.clone();\n    let mut a = vec![None; 26];\n    for i\
    \ in 0..26 {\n        a[i] = t.chars().nth(i).collect();\n    }\n    for i in\
    \ a.iter_mut() {\n        *i += None;\n    }\n    \n    let mut re = vec![None;\
    \ 26];\n    for i in 0..26 {\n        let mut j = i;\n        if i % 2 == 0 {\n\
    \            j += 2;\n        }\n        let a = a[i];\n        let b = a[j];\n\
    \        *re[i] = b.to_owned();\n    }\n    String::from(re)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: `Option<char>` is not an iterator\n   --> /tmp/tmpffdvu2z5.rs:21:33\n\
    \    |\n21  |           a[i] = t.chars().nth(i).collect();\n    |            \
    \                       ^^^^^^^ `Option<char>` is not an iterator\n    |\n   \
    \ = note: the following trait bounds were not satisfied:\n            `Option<char>:\
    \ Iterator`\n            which is required by `&mut Option<char>: Iterator`\n\n\
    error[E0368]: binary assignment operation `+=` cannot be applied to type `Option<_>`\n\
    \  --> /tmp/tmpffdvu2z5.rs:24:9\n   |\n24 |         *i += None;\n   |        \
    \ --^^^^^^^^\n   |         |\n   |         cannot use `+=` on type `Option<_>`\n\
    \nerror[E0608]: cannot index into a value of type `Option<_>`\n  --> /tmp/tmpffdvu2z5.rs:34:17\n\
    \   |\n34 |         let b = a[j];\n   |                 ^^^^\n\nerror[E0614]:\
    \ type `Option<_>` cannot be dereferenced\n  --> /tmp/tmpffdvu2z5.rs:35:9\n  \
    \ |\n35 |         *re[i] = b.to_owned();\n   |         ^^^^^^\n\nerror[E0277]:\
    \ the trait bound `String: From<Vec<Option<_>>>` is not satisfied\n  --> /tmp/tmpffdvu2z5.rs:37:5\n\
    \   |\n37 |     String::from(re)\n   |     ^^^^^^^^^^^^ the trait `From<Vec<Option<_>>>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0368, E0599, E0608, E0614.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // Rotate the alphabet twice in a manner such that\
    \ the letters \n    // shift down by two multiplied to two places. \n    let mut\
    \ rotated_alphabet = alphabet.clone();\n    rotated_alphabet[0] = alphabet.len();\n\
    \    rotated_alphabet[rotated_alphabet.len() - 1] = alphabet.len() - 1;\n    let\
    \ mut result = [0u8; (alphabet.len() * 2) + 1];\n\n    // Calculate the number\
    \ of times the alphabet has been rotated by \n    // two to shift the letters\
    \ down by two positions.\n    let mut rotate_amount = 0;\n    for letter in rotated_alphabet\
    \ {\n        if letter == 0 {\n            rotate_amount++;\n        }\n    }\n\
    \    // Rotate the alphabet twice in a manner such that the letters \n    // shift\
    \ down by two multiplied to two places.\n    if rotate_amount == 2 {\n       \
    \ let mut alphabet = alphabet.clone();\n        alphabet[0] = alphabet.len() -\
    \ 1;\n        alphabet[alphabet.len() - 1] = alphabet.len() - 1;\n        let\
    \ mut rotated_alphabet = alphabet.clone();\n        rotated_alphabet[0] = alphabet.len()\
    \ - 1;\n        rotated_alphabet[rotated_alphabet.len() - 1] = alphabet.len()\
    \ - 1;\n    }\n\n    // For each character in the input string move the encrypted\
    \ \n    // character into the correct position in the rotated alphabet \n    //\
    \ and decrypt it before placing it in the result string.\n    for (i, c) in s.chars().enumerate()\
    \ {\n        let mut encrypted = rotated_alphabet[i % rotated_alphabet.len()];\n\
    \        encrypted -= 1;\n        encrypted *= 2;\n        if encrypted < alphabet.len()\
    \ {\n            encrypted += 1;\n        }\n        result[encrypted] = c;\n\
    \    }\n\n    String::from_utf8_lossy(&result[0..result.len()]).to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: Rust has no postfix increment operator\n  --> /tmp/tmp4pspik5s.rs:27:26\n\
    \   |\n27 |             rotate_amount++;\n   |                          ^^ not\
    \ a valid postfix operator\n   |\nhelp: use `+= 1` instead\n   |\n27 |       \
    \      { let tmp = rotate_amount; rotate_amount += 1; tmp };\n   |           \
    \  +++++++++++              ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n27 -             rotate_amount++;\n\
    27 +             rotate_amount += 1;\n   | \n\nerror[E0425]: cannot find value\
    \ `alphabet` in this scope\n  --> /tmp/tmp4pspik5s.rs:17:32\n   |\n17 |     let\
    \ mut rotated_alphabet = alphabet.clone();\n   |                             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `alphabet`\
    \ in this scope\n  --> /tmp/tmp4pspik5s.rs:18:27\n   |\n18 |     rotated_alphabet[0]\
    \ = alphabet.len();\n   |                           ^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp4pspik5s.rs:19:52\n\
    \   |\n19 |     rotated_alphabet[rotated_alphabet.len() - 1] = alphabet.len()\
    \ - 1;\n   |                                                    ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `alphabet` in this scope\n\
    \  --> /tmp/tmp4pspik5s.rs:20:29\n   |\n20 |     let mut result = [0u8; (alphabet.len()\
    \ * 2) + 1];\n   |                             ^^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmp4pspik5s.rs:33:28\n\
    \   |\n33 |         let mut alphabet = alphabet.clone();\n   |               \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `alphabet` in this scope\n  --> /tmp/tmp4pspik5s.rs:48:24\n   |\n48 |      \
    \   if encrypted < alphabet.len() {\n   |                        ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 7 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    ROTATE[s.chars()]\n        .iter()\n        .cloned()\n\
    \        .map(|c| c.to_string())\n        .collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ROTATE` in this scope\n  --> /tmp/tmp7pzyp93b.rs:15:5\n\
    \   |\n15 |     ROTATE[s.chars()]\n   |     ^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt_with_padding(s, rotate_alphabet_down)\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt_with_padding` in this scope\n\
    \  --> /tmp/tmp8o5c57an.rs:15:5\n   |\n15 |     encrypt_with_padding(s, rotate_alphabet_down)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `rotate_alphabet_down` in this scope\n  --> /tmp/tmp8o5c57an.rs:15:29\n\
    \   |\n15 |     encrypt_with_padding(s, rotate_alphabet_down)\n   |          \
    \                   ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    crypt::encrypt::<crypt::aead::ChaCha20Poly1305>(s,\
    \ &b\"1234567890abcdefghijklmnopqrstuvwxyz\", &b\"abcdefghijklmnopqrstuvwxyz234567890\"\
    , &b\"1234567890abcdefghijklmnopqrstuvwxyz\", &b\"abcdefghijklmnopqrstuvwxyz\"\
    )\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `crypt`\n\
    \  --> /tmp/tmpf6b2sfdh.rs:15:5\n   |\n15 |     crypt::encrypt::<crypt::aead::ChaCha20Poly1305>(s,\
    \ &b\"1234567890abcdefghijklmnopqrstuvwxyz\", &b\"abcdefghijklmnopqrstuvwxyz234567890\"\
    ,...\n   |     ^^^^^ use of undeclared crate or module `crypt`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `crypt`\n  --> /tmp/tmpf6b2sfdh.rs:15:22\n\
    \   |\n15 |     crypt::encrypt::<crypt::aead::ChaCha20Poly1305>(s, &b\"1234567890abcdefghijklmnopqrstuvwxyz\"\
    , &b\"abcdefghijklmnopqrstuvwxyz234567890\",...\n   |                      ^^^^^\
    \ use of undeclared crate or module `crypt`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt(&s, Alphabet::ROTATE)\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpzdtk1jgi.rs:15:17\n   |\n15 |     encrypt(&s, Alphabet::ROTATE)\n  \
    \ |                 ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpzdtk1jgi.rs:15:5\n\
    \   |\n15 |     encrypt(&s, Alphabet::ROTATE)\n   |     ^^^^^^^ --  ----------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpzdtk1jgi.rs:14:4\n   |\n14 | fn encrypt(s:\
    \ String) -> String {\n   |    ^^^^^^^ ---------\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [0u8; 26];\n    let mut n = s.len();\n\
    \    let mut i = 0;\n    for c in s.chars() {\n        alphabet[(c as u8) - 97]\
    \ = (n-i)/2;\n        alphabet[(c as u8) - 97] %= 26;\n        i += 1;\n    }\n\
    \n    let mut s = String::new();\n    for c in s.chars() {\n        c += alphabet[(c\
    \ as u8) - 97];\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `u8`\n  --> /tmp/tmpl8y1sfhc.rs:19:9\n\
    \   |\n19 |         alphabet[(c as u8) - 97] = (n-i)/2;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^\
    \ slice indices are of type `usize` or ranges of `usize`\n   |\n   = help: the\
    \ trait `SliceIndex<[u8]>` is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>`\
    \ is implemented for `usize`\n   = note: required because of the requirements\
    \ on the impl of `Index<u8>` for `[u8]`\n\nerror[E0277]: the type `[u8]` cannot\
    \ be indexed by `u8`\n  --> /tmp/tmpl8y1sfhc.rs:20:9\n   |\n20 |         alphabet[(c\
    \ as u8) - 97] %= 26;\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are\
    \ of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u8>` for `[u8]`\n\nerror[E0277]: the type `[u8]` cannot be indexed by\
    \ `u8`\n  --> /tmp/tmpl8y1sfhc.rs:26:14\n   |\n26 |         c += alphabet[(c as\
    \ u8) - 97];\n   |              ^^^^^^^^^^^^^^^^^^^^^^^^ slice indices are of\
    \ type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u8>` for `[u8]`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `char`\n  --> /tmp/tmpl8y1sfhc.rs:26:9\n   |\n26 |      \
    \   c += alphabet[(c as u8) - 97];\n   |         -^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `char`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0277, E0368.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    shift_alphabet(&s, &ALPHABET, 2)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `shift_alphabet` in this scope\n  -->\
    \ /tmp/tmp6ifu3grn.rs:15:5\n   |\n15 |     shift_alphabet(&s, &ALPHABET, 2)\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ALPHABET` in this scope\n  --> /tmp/tmp6ifu3grn.rs:15:25\n   |\n15 |\
    \     shift_alphabet(&s, &ALPHABET, 2)\n   |                         ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    assert!(s.len() <= ROTATION_CHARACTERS);\n    let mut\
    \ alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n  \
    \  alphabet.insert(0, &ROTATION_CHARACTERS[s.len()]);\n    alphabet.push(&ROTATION_CHARACTERS[ROTATION_CHARACTERS.len()\
    \ - 1]);\n    let alphabet: Vec<_> = alphabet.into_iter().collect();\n    let\
    \ mut encrypted_string = \"\";\n    for c in &s {\n        if alphabet.iter().any(|&a|\
    \ a == c.char()) {\n            encrypted_string += c.char().to_digit(ROTATION_DIGITS);\n\
    \        } else {\n            encrypted_string += c;\n        }\n    }\n    return\
    \ encrypted_string;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: borrow expressions cannot be annotated with lifetimes\n  --> /tmp/tmpkw656cjx.rs:16:24\n\
    \   |\n16 |     let mut alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n\
    \   |                        ^-------^^^^\n   |                         |\n  \
    \ |                         annotated with lifetime here\n   |               \
    \          help: remove the lifetime annotation\n\nerror: expected one of `!`,\
    \ `(`, `::`, `;`, `<`, or `]`, found `,`\n  --> /tmp/tmpkw656cjx.rs:16:36\n  \
    \ |\n16 |     let mut alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n\
    \   |         -------------              ^ expected one of `!`, `(`, `::`, `;`,\
    \ `<`, or `]`\n   |         |           |\n   |         |           help: use\
    \ `=` if you meant to assign\n   |         while parsing the type for `mut alphabet`\n\
    \nerror[E0425]: cannot find value `ROTATION_CHARACTERS` in this scope\n  --> /tmp/tmpkw656cjx.rs:15:24\n\
    \   |\n15 |     assert!(s.len() <= ROTATION_CHARACTERS);\n   |               \
    \         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0423]: expected\
    \ value, found builtin type `str`\n  --> /tmp/tmpkw656cjx.rs:16:33\n   |\n16 |\
    \     let mut alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n\
    \   |                                 ^^^ not a value\n\nerror[E0423]: expected\
    \ value, found builtin type `usize`\n  --> /tmp/tmpkw656cjx.rs:16:38\n   |\n16\
    \ |     let mut alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n\
    \   |                                      ^^^^^ not a value\n\nerror[E0425]:\
    \ cannot find value `ROTATION_CHARACTERS` in this scope\n  --> /tmp/tmpkw656cjx.rs:16:47\n\
    \   |\n16 |     let mut alphabet: [&'static str, usize] = ROTATION_CHARACTERS.iter().collect();\n\
    \   |                                               ^^^^^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROTATION_CHARACTERS` in this\
    \ scope\n  --> /tmp/tmpkw656cjx.rs:17:25\n   |\n17 |     alphabet.insert(0, &ROTATION_CHARACTERS[s.len()]);\n\
    \   |                         ^^^^^^^^^^^^^^^^^^^ not found in this scope\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![];\n    alphabet.push('a');\n\
    \    alphabet.push('s');\n    alphabet.push('m');\n    alphabet.push('e');\n \
    \   alphabet.push('t');\n    alphabet.push('a');\n    alphabet.push('n');\n  \
    \  alphabet.push('o');\n    alphabet.push('h');\n    alphabet.push('j');\n   \
    \ alphabet.push('n');\n    alphabet.push('p');\n    alphabet.push('e');\n    alphabet.push('x');\n\
    \    alphabet.push('g');\n    alphabet.push('f');\n    alphabet.push('k');\n \
    \   alphabet.push('j');\n    alphabet.push('l');\n    alphabet.push('o');\n  \
    \  alphabet.push('h');\n    alphabet.push('k');\n    alphabet.push('j');\n   \
    \ alphabet.push('n');\n    alphabet.push('p');\n    alphabet.push('e');\n    alphabet.push('t');\n\
    \    alphabet.push('a');\n    alphabet.push('s');\n    alphabet.push('m');\n \
    \   alphabet.push('e');\n    alphabet.push('x');\n    alphabet.push('g');\n  \
    \  alphabet.push('f');\n    alphabet.push('k');\n    alphabet.push('j');\n   \
    \ alphabet.push('l');\n    alphabet.push('o');\n    alphabet.push('h');\n    alphabet.push('k');\n\
    \    alphabet.push('j');\n    alphabet.push('n');\n    alphabet.push('p');\n \
    \   alphabet.push('e');\n    alphabet.push('t');\n    alphabet.push('a');\n  \
    \  alphabet.push('s');\n    alphabet.push('m');\n    alphabet.push('e');\n   \
    \ alphabet.push('x');\n    alphabet.push('g');\n    alphabet.push('f');\n    alphabet.push('k');\n\
    \    alphabet.push('j');\n    alphabet.push('l');\n    alphabet.push('o');\n \
    \   alphabet.push('h');\n    alphabet.push('k');\n    alphabet.push('j');\n  \
    \  alphabet.push('n');\n    alphabet.push('p');\n    alphabet.push('e');\n   \
    \ alphabet.push('t');\n    alphabet.push('a');\n    alphabet.push('s');\n    alphabet.push('m');\n\
    \    alphabet.push('e');\n    alphabet.push('x');\n    alphabet.push('g');\n \
    \   alphabet.push('f');\n    alphabet.push('k');\n    alphabet.push('j');\n  \
    \  alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n  --> /tmp/tmp4j_3hbyu.rs:89:1\n   |\n89\
    \ | }\n   | ^\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp4j_3hbyu.rs:88:5\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n88 |     alphabet.\n   |    \
    \ ^^^^^^^^ expected struct `String`, found struct `Vec`\n   |\n   = note: expected\
    \ struct `String`\n              found struct `Vec<char>`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().filter_map(|c| {\n        c.rotate_left(2).map(c2.chr()).collect::<String>()\n\
    \    }).collect::<String>()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `c2` in this scope\n  --> /tmp/tmpie_5qj7m.rs:16:30\n\
    \   |\n16 |         c.rotate_left(2).map(c2.chr()).collect::<String>()\n   | \
    \                             ^^ help: a local variable with a similar name exists:\
    \ `c`\n\nerror[E0599]: no method named `rotate_left` found for type `char` in\
    \ the current scope\n  --> /tmp/tmpie_5qj7m.rs:16:11\n   |\n16 |         c.rotate_left(2).map(c2.chr()).collect::<String>()\n\
    \   |           ^^^^^^^^^^^ method not found in `char`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().filter_map(|c| {\n        match c {\n   \
    \         'A' => ('A', 'B'),\n            'B' => ('B', 'C'),\n            'C'\
    \ => ('C', 'D'),\n            'D' => ('D', 'E'),\n            'E' => ('E', 'F'),\n\
    \            'F' => ('F', 'G'),\n            'G' => ('G', 'H'),\n            'H'\
    \ => ('H', 'I'),\n            'I' => ('I', 'J'),\n            'J' => ('J', 'K'),\n\
    \            'K' => ('K', 'L'),\n            'L' => ('L', 'M'),\n            'M'\
    \ => ('M', 'N'),\n            'N' => ('N', 'O'),\n            'O' => ('O', 'P'),\n\
    \            'P' => ('P', 'Q'),\n            'Q' => ('Q', 'R'),\n            'R'\
    \ => ('R', 'S'),\n            'S' => ('S', 'T'),\n            'T' => ('T', 'U'),\n\
    \            'U' => ('U', 'V'),\n            'V' => ('V', 'W'),\n            'W'\
    \ => ('W', 'X'),\n            'X' => ('X', 'Y'),\n            'Y' => ('Y', 'Z'),\n\
    \            'Z' => ('Z', 'A'),\n            _ => unreachable!(),\n        }\n\
    \    }).collect::<String>().into()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpnnsc7jpe.rs:17:20\n   |\n\
    17 |             'A' => ('A', 'B'),\n   |                    ^^^^^^^^^^ expected\
    \ enum `Option`, found tuple\n   |\n   = note: expected enum `Option<_>`\n   \
    \          found tuple `(char, char)`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n17 |             'A' => Some(('A', 'B')),\n   |                    +++++\
    \          +\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut letters = String::new();\n    let mut j = 0;\n\
    \    let mut i = 0;\n    \n    for c in s.chars() {\n        \n        // For\
    \ every letter, we need to rotate it twice and then add it to\n        // our\
    \ new encrypted string.\n        letters.push((c * 2) + (letters[j % letters.len()]))\n\
    \            \n        // The letter we just added will be at the next spot in\
    \ the alphabet.\n        // So increment the letter to move it down.\n       \
    \ letters.push_str(\"z\");\n        \n        // Increment our counter for our\
    \ new letter\n        j = j + 1;\n        \n        // Reset the counter for our\
    \ new letter\n        i++;\n    }\n    \n    return letters\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `letters`\n  --> /tmp/tmpcnydp43c.rs:23:61\n\
    \   |\n23 |         letters.push((c * 2) + (letters[j % letters.len()]))\n   |\
    \                                                             ^ help: add `;`\
    \ here\n...\n27 |         letters.push_str(\"z\");\n   |         ------- unexpected\
    \ token\n\nerror: Rust has no postfix increment operator\n  --> /tmp/tmpcnydp43c.rs:33:10\n\
    \   |\n33 |         i++;\n   |          ^^ not a valid postfix operator\n   |\n\
    help: use `+= 1` instead\n   |\n33 |         { let tmp = i; i += 1; tmp };\n \
    \  |         +++++++++++  ~~~~~~~~~~~~~~~\n33 -         i++;\n33 +         i +=\
    \ 1;\n   | \n\nerror[E0369]: cannot multiply `char` by `{integer}`\n  --> /tmp/tmpcnydp43c.rs:23:25\n\
    \   |\n23 |         letters.push((c * 2) + (letters[j % letters.len()]))\n   |\
    \                       - ^ - {integer}\n   |                       |\n   |  \
    \                     char\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `usize`\n  --> /tmp/tmpcnydp43c.rs:23:32\n   |\n23 |         letters.push((c\
    \ * 2) + (letters[j % letters.len()]))\n   |                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0369.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    for (i, char)\
    \ in s.chars().enumerate() {\n        if i % 2 != 0 {\n            cipher.push_str(&char);\n\
    \        } else {\n            let mut c = char.to_ascii_lowercase();\n      \
    \      c.rotate_right(2);\n            cipher.push_str(&c);\n        }\n    }\n\
    \    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpgvpv8mvu.rs:18:29\n   |\n\
    18 |             cipher.push_str(&char);\n   |                             ^^^^^\
    \ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n \
    \             found reference `&char`\n\nerror[E0599]: no method named `rotate_right`\
    \ found for type `char` in the current scope\n  --> /tmp/tmpgvpv8mvu.rs:21:15\n\
    \   |\n21 |             c.rotate_right(2);\n   |               ^^^^^^^^^^^^ method\
    \ not found in `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpgvpv8mvu.rs:22:29\n\
    \   |\n22 |             cipher.push_str(&c);\n   |                           \
    \  ^^ expected `str`, found `char`\n   |\n   = note: expected reference `&str`\n\
    \              found reference `&char`\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(rotate_alphabet(s, rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: mismatched closing delimiter: `}`\n  --> /tmp/tmpnjxik0w4.rs:15:2296\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          \
    \       - closing delimiter possibly meant for this\n15 |     rotate_alphabet(rotate_alphabet(s,\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.chars(), rotate_alphabet(s.chars(), rotate_alphabet(s.chars(),\
    \ rotate_alphabet(s.char"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    loop {\n     \
    \   cipher.push( s.chars().nth(s.len() / 2).unwrap());\n        s = s.rotate_left(2).unwrap();\n\
    \        \n        if s.len() == 0 {\n            break;\n        }\n    }\n \
    \   cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp32jg3mlb.rs:18:15\n   |\n18 |         s = s.rotate_left(2).unwrap();\n\
    \   |               ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut rotated_alphabet\
    \ = alphabet.clone();\n    rotated_alphabet.rotate_left(2);\n    rotated_alphabet.rotate_left(2);\n\
    \    for ch in s.chars() {\n        match ch {\n            ch => result.append(&rotated_alphabet[ch]),\n\
    \            _ => result.append(ch),\n        }\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpwshidco_.rs:16:32\n\
    \   |\n16 |     let mut rotated_alphabet = alphabet.clone();\n   |           \
    \                     ^^^^^^^^ not found in this scope\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpwshidco_.rs:21:26\n\
    \   |\n21 |             ch => result.append(&rotated_alphabet[ch]),\n   |    \
    \                      ^^^^^^ method not found in `String`\n\nerror[E0599]: no\
    \ method named `append` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpwshidco_.rs:22:25\n   |\n22 |             _ => result.append(ch),\n\
    \   |                         ^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to 3 previous errors\n\nSome errors have detailed explanations: E0425, E0599.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [\n        'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', \n        'n', 'o', 'p', 'q', 'r', 's',\
    \ 't', 'u', 'v', 'w', 'x', 'y', 'z'\n    ];\n    for index in 0..alphabet.len()\
    \ {\n        let mut pos = 0;\n        while pos < alphabet.len() {\n        \
    \    alphabet[index] = alphabet[(index + pos) % alphabet.len()];\n           \
    \ pos = pos + 1;\n        }\n    }\n    let mut cipher = String::new();\n    let\
    \ mut position = s.len() - 1;\n    while position >= 0 {\n        cipher = format!(\"\
    {}{}\", cipher, alphabet[(s.as_bytes()[position] as u8 + 2) % alphabet.len()]);\n\
    \        position = position - 1;\n    }\n    cipher\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpd8sy1a6d.rs:29:88\n   |\n\
    29 |         cipher = format!(\"{}{}\", cipher, alphabet[(s.as_bytes()[position]\
    \ as u8 + 2) % alphabet.len()]);\n   |                                       \
    \                                                 ^^^^^^^^^^^^^^ expected `u8`,\
    \ found `usize`\n\nerror[E0277]: cannot mod `u8` by `usize`\n  --> /tmp/tmpd8sy1a6d.rs:29:86\n\
    \   |\n29 |         cipher = format!(\"{}{}\", cipher, alphabet[(s.as_bytes()[position]\
    \ as u8 + 2) % alphabet.len()]);\n   |                                       \
    \                                               ^ no implementation for `u8 %\
    \ usize`\n   |\n   = help: the trait `Rem<usize>` is not implemented for `u8`\n\
    \   = help: the following other types implement trait `Rem<Rhs>`:\n          \
    \   <&'a f32 as Rem<f32>>\n             <&'a f64 as Rem<f64>>\n             <&'a\
    \ i128 as Rem<i128>>\n             <&'a i16 as Rem<i16>>\n             <&'a i32\
    \ as Rem<i32>>\n             <&'a i64 as Rem<i64>>\n             <&'a i8 as Rem<i8>>\n\
    \             <&'a isize as Rem<isize>>\n           and 54 others\n\nerror[E0277]:\
    \ the type `[char]` cannot be indexed by `u8`\n  --> /tmp/tmpd8sy1a6d.rs:29:42\n\
    \   |\n29 |         cipher = format!(\"{}{}\", cipher, alphabet[(s.as_bytes()[position]\
    \ as u8 + 2) % alphabet.len()]);\n   |                                       \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[char]>`\
    \ is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u8>` for `[char]`\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0277, E0308.\nFor more information about\
    \ an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = s.to_string();\n    for c in cipher.chars()\
    \ {\n        *c = get_rotation(*c, 2);\n    }\n    cipher\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `get_rotation` in this scope\n  -->\
    \ /tmp/tmpn5cas6pj.rs:17:14\n   |\n17 |         *c = get_rotation(*c, 2);\n  \
    \ |              ^^^^^^^^^^^^ not found in this scope\n\nerror[E0614]: type `char`\
    \ cannot be dereferenced\n  --> /tmp/tmpn5cas6pj.rs:17:9\n   |\n17 |         *c\
    \ = get_rotation(*c, 2);\n   |         ^^\n\nerror[E0614]: type `char` cannot\
    \ be dereferenced\n  --> /tmp/tmpn5cas6pj.rs:17:27\n   |\n17 |         *c = get_rotation(*c,\
    \ 2);\n   |                           ^^\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0425, E0614.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| c.to_ascii_lowercase().unwrap()).collect::<Vec<_>>();\n\
    \    alphabet.rotate_by(1);\n    alphabet.rotate_by(2);\n    let mut cipher =\
    \ s.chars().map(|c| {\n        alphabet[(alphabet.len() - alphabet.iter().rev().nth(alphabet.len()\
    \ - 1).unwrap()).cmp(&c) as usize]\n    }).collect::<String>();\n    cipher.push(0);\n\
    \    cipher.push(1);\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpv50jw0hr.rs:15:65\n   |\n15 |     let mut alphabet = s.chars().map(|c|\
    \ c.to_ascii_lowercase().unwrap()).collect::<Vec<_>>();\n   |                \
    \                                                 ^^^^^^ method not found in `char`\n\
    \nerror[E0599]: no method named `rotate_by` found for struct `Vec<_>` in the current\
    \ scope\n  --> /tmp/tmpv50jw0hr.rs:16:14\n   |\n16 |     alphabet.rotate_by(1);\n\
    \   |              ^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `rotate_by` found for struct\
    \ `Vec<_>` in the current scope\n  --> /tmp/tmpv50jw0hr.rs:17:14\n   |\n17 | \
    \    alphabet.rotate_by(2);\n   |              ^^^^^^^^^ help: there is an associated\
    \ function with a similar name: `rotate_left`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpv50jw0hr.rs:19:96\n   |\n19 |         alphabet[(alphabet.len()\
    \ - alphabet.iter().rev().nth(alphabet.len() - 1).unwrap()).cmp(&c) as usize]\n\
    \   |                                                                        \
    \                        ^^ expected `usize`, found `char`\n   |\n   = note: expected\
    \ reference `&usize`\n              found reference `&char`\n\nerror[E0277]: a\
    \ value of type `String` cannot be built from an iterator over elements of type\
    \ `usize`\n    --> /tmp/tmpv50jw0hr.rs:20:8\n     |\n20   |     }).collect::<String>();\n\
    \     |        ^^^^^^^ value of type `String` cannot be built from `std::iter::Iterator<Item=usize>`\n\
    \     |\n     = help: the trait `FromIterator<usize>` is not implemented for `String`\n\
    \     = help: the following other types implement trait `FromIterator<A>`:\n \
    \              <String as FromIterator<&'a char>>\n               <String as FromIterator<&'a\
    \ str>>\n               <String as FromIterator<Box<str>>>\n               <String\
    \ as FromIterator<Cow<'a, str>>>\n               <String as FromIterator<String>>\n\
    \               <String as FromIterator<char>>\nnote: required by a bound in `collect`\n\
    \nerror[E0308]: mismatched types\n  -"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.rotate_left(2).rotate_left(2).into_iter().collect().join()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpg1593rnk.rs:15:7\n   |\n15 |     s.rotate_left(2).rotate_left(2).into_iter().collect().join()\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    assert!(s.len() >= 2);\n    let mut alphabet = vec![String::from(\"\
    \"), String::from(\"\")];\n    alphabet.swap(0);\n    let mut n = 0;\n    for\
    \ (i, ch) in s.chars().enumerate() {\n        if i > 0 {\n            alphabet.swap(n);\n\
    \            n += 2;\n        }\n        alphabet.swap(n);\n        alphabet.push(String::from(ch.to_string()));\n\
    \        n += 1;\n    }\n    alphabet.swap(0);\n    let mut s = String::from(s);\n\
    \    s.to_ascii_lowercase();\n    let mut rs = String::from(s);\n    rs.rotate_right(2);\n\
    \    for (i, ch) in rs.chars().enumerate() {\n        if i > 0 {\n           \
    \ s.insert(i, ch);\n        }\n    }\n    s\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \   --> /tmp/tmpejht7ja0.rs:17:14\n    |\n17  |     alphabet.swap(0);\n    | \
    \             ^^^^ - supplied 1 argument\n    |              |\n    |        \
    \      expected 2 arguments\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 2 arguments but 1 argument was supplied\n  \
    \ --> /tmp/tmpejht7ja0.rs:21:22\n    |\n21  |             alphabet.swap(n);\n\
    \    |                      ^^^^ - supplied 1 argument\n    |                \
    \      |\n    |                      expected 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0061]: this function takes 2 arguments but 1\
    \ argument was supplied\n   --> /tmp/tmpejht7ja0.rs:24:18\n    |\n24  |      \
    \   alphabet.swap(n);\n    |                  ^^^^ - supplied 1 argument\n   \
    \ |                  |\n    |                  expected 2 arguments\n    |\nnote:\
    \ associated function defined here\n\nerror[E0061]: this function takes 2 arguments\
    \ but 1 argument was supplied\n   --> /tmp/tmpejht7ja0.rs:28:14\n    |\n28  |\
    \     alphabet.swap(0);\n    |              ^^^^ - supplied 1 argument\n    |\
    \              |\n    |              expected 2 arguments\n    |\nnote: associated\
    \ function defined here\n\nerror[E0599]: no method named `rotate_right` found\
    \ for struct `String` in the current scope\n  --> /tmp/tmpejht7ja0.rs:32:8\n \
    \  |\n32 |     rs.rotate_right(2);\n   |        ^^^^^^^^^^^^ help: there is an\
    \ associated function with a similar name: `trim_right`\n\nerror: aborting due\
    \ to 5 previous errors\n\nSome errors have detailed explanations: E0061, E0599.\n\
    For more information about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().enumerate().map(|(i, ch)| {\n        let\
    \ rot_ch = if i % 2 == 0 {\n            ch + 2\n        } else {\n           \
    \ ch - 2\n        }\n        String::from(rot_ch)\n    })\n    .collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected `;`, found `String`\n  --> /tmp/tmppr_3bqog.rs:20:10\n\
    \   |\n20 |         }\n   |          ^ help: add `;` here\n21 |         String::from(rot_ch)\n\
    \   |         ------ unexpected token\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmppr_3bqog.rs:17:16\n   |\n17 |             ch + 2\n\
    \   |             -- ^ - {integer}\n   |             |\n   |             char\n\
    \nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmppr_3bqog.rs:19:16\n\
    \   |\n19 |             ch - 2\n   |             -- ^ - {integer}\n   |      \
    \       |\n   |             char\n\nerror: aborting due to 3 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = alphabet_string();\n\n    alphabet.sort();\n\
    \n    let mut encrypted = String::new();\n    for i in s.chars().skip(alphabet.len())\
    \ {\n        let a = alphabet.chars().skip(alphabet.len() - 1).next().unwrap();\n\
    \        encrypted.push(format!(\"{}{}\", a, i.unwrap()));\n    }\n\n    return\
    \ encrypted;\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `alphabet_string` in this scope\n  -->\
    \ /tmp/tmp7msqfj_b.rs:15:24\n   |\n15 |     let mut alphabet = alphabet_string();\n\
    \   |                        ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmp7msqfj_b.rs:22:45\n\
    \   |\n22 |         encrypted.push(format!(\"{}{}\", a, i.unwrap()));\n   |  \
    \                                           ^^^^^^ method not found in `char`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmp7msqfj_b.rs:22:24\n   |\n22 |\
    \         encrypted.push(format!(\"{}{}\", a, i.unwrap()));\n   |            \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\
    \   |\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().map(|c| 'a' as char |\
    \ 'z' as char | 'A' as char | 'Z' as char);\n    alphabet.push(alphabet.last());\n\
    \    alphabet = alphabet.map(|c| c + 1);\n    let mut alphabet = alphabet.collect();\n\
    \    alphabet.push(alphabet.last());\n    alphabet = alphabet.map(|c| c - 1);\n\
    \    alphabet = alphabet.collect();\n    alphabet.push(alphabet.last());\n   \
    \ alphabet = alphabet.map(|c| c + 2);\n    alphabet = alphabet.collect();\n  \
    \  alphabet.push(alphabet.last());\n    alphabet = alphabet.map(|c| c - 2);\n\
    \    alphabet = alphabet.collect();\n    let mut cipher = s.chars().map(|c| 0);\n\
    \    for i in 0..s.len() {\n        cipher[i] = alphabet.index(&s[(s.len() - 1)\
    \ - i].unwrap());\n    }\n    cipher.collect_unique()\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char | char`\n  --> /tmp/tmpiqcxpl7l.rs:15:54\n\
    \   |\n15 |     let mut alphabet = s.chars().map(|c| 'a' as char | 'z' as char\
    \ | 'A' as char | 'Z' as char);\n   |                                        \
    \  ----------- ^ ----------- char\n   |                                      \
    \    |\n   |                                          char\n\nerror[E0599]: no\
    \ method named `push` found for struct `Map` in the current scope\n  --> /tmp/tmpiqcxpl7l.rs:16:14\n\
    \   |\n16 |     alphabet.push(alphabet.last());\n   |              ^^^^ method\
    \ not found in `Map<Chars<'_>, _>`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpiqcxpl7l.rs:17:16\n\
    \   |\n15 |     let mut alphabet = s.chars().map(|c| 'a' as char | 'z' as char\
    \ | 'A' as char | 'Z' as char);\n   |                        ------------------------------------------------------------------------\
    \ expected due to this value\n16 |     alphabet.push(alphabet.last());\n17 | \
    \    alphabet = alphabet.map(|c| c + 1);\n   |                ^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Chars`, found struct `Map`\n   |\n   = note: expected struct\
    \ `Map<Chars<'_>, _>`\n              found struct `Map<Map<Chars<'_>, _>, [closure@/tmp/tmpiqcxpl7l.rs:17:29:\
    \ 17:38]>`\n\nerror[E0608]: cannot index into a value of type `Map<Chars<'_>,\
    \ [closure@/tmp/tmpiqcxpl7l.rs:28:36: 28:41]>`\n  --> /tmp/tmpiqcxpl7l.rs:30:9\n\
    \   |\n30 |         cipher[i] = alphabet.index(&s[(s.len() - 1) - i].unwrap());\n\
    \   |         ^^^^^^^^^\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpiqcxpl7l.rs:30:37\n   |\n30 |         cipher[i] = alphabet.index(&s[(s.len()\
    \ - 1) - i].unwrap());\n   |                                     ^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<us"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut shift\
    \ = 1;\n    for c in s.chars() {\n        result += \"z\".to_string();\n     \
    \   let mut new = c as u16;\n        new = (((new + shift) % 26) + 26) as char;\n\
    \        result.push_str(&new);\n        shift += 1;\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmplnqchddl.rs:18:19\n   |\n\
    18 |         result += \"z\".to_string();\n   |                   ^^^^^^^^^^^^^^^\n\
    \   |                   |\n   |                   expected `&str`, found struct\
    \ `String`\n   |                   help: consider borrowing here: `&\"z\".to_string()`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmplnqchddl.rs:20:15\n   |\n19 |\
    \         let mut new = c as u16;\n   |                       -------- expected\
    \ due to this value\n20 |         new = (((new + shift) % 26) + 26) as char;\n\
    \   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `u16`, found\
    \ `char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmplnqchddl.rs:21:25\n\
    \   |\n21 |         result.push_str(&new);\n   |                         ^^^^\
    \ expected `str`, found `u16`\n   |\n   = note: expected reference `&str`\n  \
    \            found reference `&u16`\n\nerror[E0604]: only `u8` can be cast as\
    \ `char`, not `u16`\n  --> /tmp/tmplnqchddl.rs:20:15\n   |\n20 |         new =\
    \ (((new + shift) % 26) + 26) as char;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ invalid cast\n   |\nhelp: try `char::from_u32` instead (via a `u32`)\n  -->\
    \ /tmp/tmplnqchddl.rs:20:15\n   |\n20 |         new = (((new + shift) % 26) +\
    \ 26) as char;\n   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\nerror:\
    \ aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0604.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    use std::iter;\n    let mut cipher = String::new();\n\
    \    iter::zip(s.chars(), s.chars().cloned())\n        .filter(|&(a, b)| a !=\
    \ b)\n        .for_each(|(a, b)| {\n            if a < b {\n                cipher.push(a);\n\
    \                cipher.push(b);\n            } else {\n                cipher.push(b);\n\
    \                cipher.push(a);\n            }\n        });\n    cipher\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpg1yiv2bb.rs:17:36\n     |\n17   |     iter::zip(s.chars(),\
    \ s.chars().cloned())\n     |                                    ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpg1yiv2bb.rs:17:26\n   |\n17 |     iter::zip(s.chars(), s.chars().cloned())\n\
    \   |     ---------            ^^^^^^^^^^^^^^^^^^ expected reference, found `char`\n\
    \   |     |\n   |     required by a bound introduced by this call\n   |\n   =\
    \ note: expected reference `&_`\n                   found type `char`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\nnote: required by a bound in `std::iter::zip`\n\nerror[E0599]:\
    \ the method `filter` exists for struct `Zip<Chars<'_>, Cloned<Chars<'_>>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpg1yiv2bb.rs:18:10\n   |\n\
    18 |            .filter(|&(a, b)| a != b)\n   |             ^^^^^^ method cannot\
    \ be called on `Zip<Chars<'_>, Cloned<Chars<'_>>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `Cloned<Chars<'_>>:\
    \ Iterator`\n           which is required by `Zip<Chars<'_>, Cloned<Chars<'_>>>:\
    \ Iterator`\n           `Zip<Chars<'_>, Cloned<Chars<'_>>>: Iterator`\n      \
    \     which is required by `&mut Zip<Chars<'_>, Cloned<Chars<'_>>>: Iterator`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpg1yiv2bb.rs:17:5\n   |\n17 |     iter::zip(s.chars(), s.chars().cloned())\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` fo"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![0; 26];\n    alphabet.iter().for_each(|c|\
    \ alphabet[c] = c + 2);\n    let mut t = s.to_ascii_lowercase();\n    loop {\n\
    \        let mut encrypted = String::new();\n        for c in t.chars() {\n  \
    \          if alphabet[c as usize - 1] < alphabet.len() {\n                encrypted.push((alphabet[c\
    \ as usize - 1] + alphabet[alphabet[c as usize - 1]]) % 26 + 'a');\n         \
    \   } else {\n                encrypted.push((alphabet[c as usize - 1] + alphabet[alphabet[c\
    \ as usize - 1]]) % 26 + 'a');\n            }\n        }\n        if encrypted\
    \ != t {\n            break;\n        }\n        t = encrypted;\n    }\n    return\
    \ String::from(encrypted);\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `encrypted` in this scope\n  --> /tmp/tmprn4echgc.rs:32:25\n\
    \   |\n32 |     return String::from(encrypted);\n   |                        \
    \ ^^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `[{integer}]` cannot\
    \ be indexed by `&{integer}`\n  --> /tmp/tmprn4echgc.rs:16:34\n   |\n16 |    \
    \ alphabet.iter().for_each(|c| alphabet[c] = c + 2);\n   |                   \
    \               ^^^^^^^^^^^ slice indices are of type `usize` or ranges of `usize`\n\
    \   |\n   = help: the trait `SliceIndex<[{integer}]>` is not implemented for `&{integer}`\n\
    \   = help: the trait `SliceIndex<[T]>` is implemented for `usize`\n   = note:\
    \ required because of the requirements on the impl of `Index<&{integer}>` for\
    \ `Vec<{integer}>`\n\nerror[E0277]: cannot add `char` to `usize`\n  --> /tmp/tmprn4echgc.rs:22:101\n\
    \   |\n22 |                 encrypted.push((alphabet[c as usize - 1] + alphabet[alphabet[c\
    \ as usize - 1]]) % 26 + 'a');\n   |                                         \
    \                                                            ^ no implementation\
    \ for `usize + char`\n   |\n   = help: the trait `Add<char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Add<f64>>\n    \
    \         <&'a i128 as Add<i128>>\n             <&'a i16 as Add<i16>>\n      \
    \       <&'a i32 as Add<i32>>\n             <&'a i64 as Add<i64>>\n          \
    \   <&'a i8 as Add<i8>>\n             <&'a isize as Add<isize>>\n           and\
    \ 48 others\n\nerror[E0277]: cannot add `char` to `usize`\n  --> /tmp/tmprn4echgc.rs:24:101\n\
    \   |\n24 |                 encrypted.push((alphabet[c as usize - 1] + alphabet[alphabet[c\
    \ as usize - 1]]) % 26 + 'a');\n   |                                         \
    \                                                            ^ no implementation\
    \ for `usize + char`\n   |\n   = help: the trait `Add<char>` is not implemented\
    \ for `usize`\n   = help: the following other types implement trait `Add<Rhs>`:\n\
    \             <&'a f32 as Add<f32>>\n             <&'a f64 as Ad"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet: [Char; 27] = [\n        'a', 'b',\
    \ 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r',\
    \ 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n        'A', 'B', 'C', 'D', 'E', 'F',\
    \ 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V',\
    \ 'W', 'X', 'Y', 'Z',\n    ];\n    alphabet.rotate(2);\n    let mut s = String::from(s);\n\
    \    alphabet.iter().for_each(|&c| {\n        s.insert(s.len() - 1, c);\n    });\n\
    \    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmpogcei62m.rs:15:24\n\
    \   |\n15 |     let mut alphabet: [Char; 27] = [\n   |                       \
    \ ^^^^ help: a builtin type with a similar name exists (notice the capitalization):\
    \ `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rot();\n\
    \    alphabet.map(|c| c.to_string()).chain(s.chars().map(|c| c.to_string()))\n\
    \        .map(|s| alphabet.to_bytes(&s))\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp9v2_6q5d.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // Rotate the alphabet by two each iteration\n    let\
    \ mut alphabet = s.chars().cloned().collect::<Vec<_>>();\n    for (i, c) in alphabet.iter_mut().enumerate()\
    \ {\n        match i {\n            0 => c.rotate_left(2),\n            _ => c.rotate_right(2)\n\
    \        }\n    }\n    let mut output: String = String::from(\"$\");\n    for\
    \ c in alphabet {\n        match c {\n            c @ _ => output += \"#\",\n\
    \            c => output.push(c),\n        }\n    }\n    output\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpn7ctos93.rs:16:34\n     |\n16   |     let mut alphabet\
    \ = s.chars().cloned().collect::<Vec<_>>();\n     |                          \
    \        ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpn7ctos93.rs:16:43\n \
    \  |\n16 |       let mut alphabet = s.chars().cloned().collect::<Vec<_>>();\n\
    \   |                                             ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = String::new();\n    alphabet.push_str(\"\
    abcdefghijklmnopqrstuvwxyz\");\n    alphabet.push_str(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    alphabet.push_str(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    alphabet.push_str(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n\n    let mut s = String::from(s);\n    let len = s.len();\n    for i in 0..len\
    \ - 2 {\n        let c = s.chars().next().unwrap();\n        let ii = alphabet.chars().nth(i).unwrap();\n\
    \        let jj = alphabet.chars().nth(i + 1).unwrap();\n        s.push_str(&ii\
    \ + &jj + &c);\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `&char` to `&char`\n  --> /tmp/tmpqoztx3if.rs:27:24\n\
    \   |\n27 |         s.push_str(&ii + &jj + &c);\n   |                    --- ^\
    \ --- &char\n   |                    |\n   |                    &char\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // TODO: this only works for alphabet size 26. \n \
    \   // Could be extended to work for any alphabet size by simply \n    // changing\
    \ the constant 26 to whatever alphabet size you \n    // would like.\n    let\
    \ alphabet = &\"abcdefghijklmnopqrstuvwxyz\";\n    let mut result = String::new();\n\
    \    \n    let mut i = s.len();\n    \n    // shift the letters down by 2\n  \
    \  while i > 0{\n        let j = alphabet.len();\n        let char = alphabet[i\
    \ / 2];\n        alphabet[i] = alphabet[j];\n        alphabet[j] = char;\n   \
    \     i -= 2;\n    }\n    // rotate through the alphabet until i is zero\n   \
    \ loop{\n        let index = alphabet.len();\n        let char = alphabet[i as\
    \ usize];\n        alphabet[i] = alphabet[index];\n        alphabet[index] = char;\n\
    \        i -= 1;\n        if i == 0{\n            break;\n        }\n    }\n \
    \   result.push_str(&alphabet);\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `str` cannot be indexed by `usize`\n  --> /tmp/tmpex93vfsy.rs:27:20\n\
    \   |\n27 |         let char = alphabet[i / 2];\n   |                    ^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpex93vfsy.rs:28:9\n   |\n28 |         alphabet[i] = alphabet[j];\n\
    \   |         ^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmpex93vfsy.rs:28:23\n \
    \  |\n28 |         alphabet[i] = alphabet[j];\n   |                       ^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<usize>` for `str`\n\nerror[E0277]: the type `str` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpex93vfsy.rs:29:9\n   |\n29 |         alphabet[j] = char;\n\
    \   |         ^^^^^^^^^^^ string indices are ranges of `usize`\n   |\n   = help:\
    \ the trait `SliceIndex<str>` is not implemented for `usize`\n   = help: the trait\
    \ `SliceIndex<[T]>` is implemented for `usize`\n   = note: required because of\
    \ the requirements on the impl of `Index<usize>` for `str`\n\nerror[E0277]: the\
    \ type `str` cannot be indexed by `usize`\n  --> /tmp/tmpex93vfsy.rs:35:20\n \
    \  |\n35 |         let char = alphabet[i as usize];\n   |                    ^^^^^^^^^^^^^^^^^^^^\
    \ string indices are ranges of `usize`\n   |\n   = help: the trait `SliceIndex<str>`\
    \ is not implemented for `usize`\n   = help: the trait "
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = s.chars().collect::<Vec<_>>();\n\n\
    \    cipher.sort_by(|&a, &b| a.cmp(b));\n\n    let mut new_cipher = vec![];\n\
    \    let mut i = 2;\n    while i < cipher.len() {\n        if cipher[i-2] >= cipher[i-1]\
    \ + 2 {\n            new_cipher.push(cipher[i-1]);\n        } else {\n       \
    \     new_cipher.push(cipher[i-2] + 2);\n        }\n        i += 1;\n    }\n\n\
    \    String::from(new_cipher.collect::<Vec<_>>().join())\n}\n\nfn main() {\n \
    \   let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0hlp8vj_.rs:17:35\n   |\n\
    17 |     cipher.sort_by(|&a, &b| a.cmp(b));\n   |                            \
    \       ^\n   |                                   |\n   |                    \
    \               expected `&char`, found `char`\n   |                         \
    \          help: consider borrowing here: `&b`\n\nerror[E0369]: cannot add `{integer}`\
    \ to `char`\n  --> /tmp/tmp0hlp8vj_.rs:22:39\n   |\n22 |         if cipher[i-2]\
    \ >= cipher[i-1] + 2 {\n   |                           ----------- ^ - {integer}\n\
    \   |                           |\n   |                           char\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmp0hlp8vj_.rs:25:41\n   |\n25\
    \ |             new_cipher.push(cipher[i-2] + 2);\n   |                      \
    \       ----------- ^ - {integer}\n   |                             |\n   |  \
    \                           char\n\nerror[E0599]: `Vec<char>` is not an iterator\n\
    \   --> /tmp/tmp0hlp8vj_.rs:30:29\n    |\n30  |       String::from(new_cipher.collect::<Vec<_>>().join())\n\
    \    |                               ^^^^^^^ `Vec<char>` is not an iterator\n\
    \    |\n    = note: the following trait bounds were not satisfied:\n         \
    \   `Vec<char>: Iterator`\n            which is required by `&mut Vec<char>: Iterator`\n\
    \            `[char]: Iterator`\n            which is required by `&mut [char]:\
    \ Iterator`\n\nerror: aborting due to 4 previous errors\n\nSome errors have detailed\
    \ explanations: E0308, E0369, E0599.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet: Vec<u32> = vec!['a', 'b', 'c'];\n\
    \    for _ in 1..s.len() {\n        alphabet.push((alphabet[alphabet.len()-1].iter().map(|a|\
    \ a+1).sum() as u32));\n    }\n    let mut ciphertext = s.clone();\n    for (i,\
    \ c) in alphabet.iter().enumerate() {\n        let idx = ciphertext.find(|&x|\
    \ x == c);\n        if idx != String::npos {\n            ciphertext.insert(idx,\
    \ ciphertext.len() - i);\n        }\n    }\n    String::from(ciphertext)\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "warning: unnecessary parentheses around method argument\n  --> /tmp/tmpc9xgiere.rs:17:23\n\
    \   |\n17 |         alphabet.push((alphabet[alphabet.len()-1].iter().map(|a| a+1).sum()\
    \ as u32));\n   |                       ^                                    \
    \                       ^\n   |\n   = note: `#[warn(unused_parens)]` on by default\n\
    help: remove these parentheses\n   |\n17 -         alphabet.push((alphabet[alphabet.len()-1].iter().map(|a|\
    \ a+1).sum() as u32));\n17 +         alphabet.push(alphabet[alphabet.len()-1].iter().map(|a|\
    \ a+1).sum() as u32);\n   | \n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc9xgiere.rs:15:39\n\
    \   |\n15 |     let mut alphabet: Vec<u32> = vec!['a', 'b', 'c'];\n   |      \
    \                                 ^^^ expected `u32`, found `char`\n   |\nhelp:\
    \ you can cast a `char` to a `u32`, since a `char` always occupies 4 bytes\n \
    \  |\n15 |     let mut alphabet: Vec<u32> = vec!['a' as u32, 'b', 'c'];\n   |\
    \                                           ++++++\n\nerror[E0599]: no method\
    \ named `iter` found for type `u32` in the current scope\n  --> /tmp/tmpc9xgiere.rs:17:51\n\
    \   |\n17 |         alphabet.push((alphabet[alphabet.len()-1].iter().map(|a| a+1).sum()\
    \ as u32));\n   |                                                   ^^^^ method\
    \ not found in `u32`\n\nerror[E0631]: type mismatch in closure arguments\n   \
    \ --> /tmp/tmpc9xgiere.rs:21:30\n     |\n21   |         let idx = ciphertext.find(|&x|\
    \ x == c);\n     |                              ^^^^ ----------- found signature\
    \ of `fn(&_) -> _`\n     |                              |\n     |            \
    \                  expected signature of `fn(char) -> _`\n     |\n     = note:\
    \ required because of the requirements on the impl of `Pattern<'_>` for `[closure@/tmp/tmpc9xgiere.rs:21:35:\
    \ 21:46]`\nnote: required by a bound in `core::str::<impl str>::find`\n\nerror[E0599]:\
    \ no function or associated item named `npos` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpc9xgiere.rs:22:27\n   |\n22 |         if idx !=\
    \ String::npos {\n   |                           ^^^^ function or associated item\
    \ not foun"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate!(s.chars(), 0, 2)\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: cannot find macro `rotate` in this scope\n  --> /tmp/tmpnpbx6wvy.rs:15:5\n\
    \   |\n15 |     rotate!(s.chars(), 0, 2)\n   |     ^^^^^^\n\nerror: aborting due\
    \ to previous error\n\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate();\n\
    \    alphabet.rotate();\n    alphabet.rotate();\n    let mut encryptor = Encryptor::new(alphabet,\
    \ s.len() / 3);\n    encryptor.encrypt_all(s.bytes());\n    encryptor.encrypt_all(s.bytes().clone());\n\
    \    let mut buf = Vec::new();\n    for i in encryptor.reveal() {\n        buf.push(i);\n\
    \    }\n    String::from(buf)\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpprkz0rdk.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Encryptor`\n  --> /tmp/tmpprkz0rdk.rs:19:25\n\
    \   |\n19 |     let mut encryptor = Encryptor::new(alphabet, s.len() / 3);\n \
    \  |                         ^^^^^^^^^ use of undeclared type `Encryptor`\n\n\
    error[E0277]: the trait bound `String: From<Vec<_>>` is not satisfied\n  --> /tmp/tmpprkz0rdk.rs:26:5\n\
    \   |\n26 |     String::from(buf)\n   |     ^^^^^^^^^^^^ the trait `From<Vec<_>>`\
    \ is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [0; 26];\n    alphabet.push(0);\
    \ // first letter\n    for &c in s.chars() {\n        alphabet[c - 97] %= 26;\n\
    \    }\n    let mut result = String::new();\n    for &c in alphabet {\n      \
    \  result.append(&*c as char);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for array `[{integer}; 26]`\
    \ in the current scope\n  --> /tmp/tmpzvxa7frp.rs:16:14\n   |\n16 |     alphabet.push(0);\
    \ // first letter\n   |              ^^^^ method not found in `[{integer}; 26]`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpzvxa7frp.rs:17:9\n   |\n17 | \
    \    for &c in s.chars() {\n   |         ^^    --------- this expression has type\
    \ `Option<char>`\n   |         |\n   |         expected `char`, found reference\n\
    \   |         help: you can probably remove the explicit borrow: `c`\n   |\n \
    \  = note:   expected type `char`\n           found reference `&_`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpzvxa7frp.rs:21:9\n   |\n21 |     for &c in alphabet\
    \ {\n   |         ^^    -------- this expression has type `Option<{integer}>`\n\
    \   |         |\n   |         expected integer, found reference\n   |        \
    \ help: you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `{integer}`\n           found reference `&_`\n\nerror[E0599]: no method\
    \ named `append` found for struct `String` in the current scope\n  --> /tmp/tmpzvxa7frp.rs:22:16\n\
    \   |\n22 |         result.append(&*c as char);\n   |                ^^^^^^ method\
    \ not found in `String`\n\nerror: aborting due to 4 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().fold(String::new(), |mut acc, &c| {\n   \
    \     let mut current = acc.clone();\n        let shift = [\n            2, //\
    \ \"a\"\n            0, // \"b\"\n            -2, // \"c\"\n            -2, //\
    \ \"d\"\n            4, // \"e\"\n            0, // \"f\"\n            0, // \"\
    g\"\n            4, // \"h\"\n            -2, // \"i\"\n            2, // \"j\"\
    \n            4, // \"k\"\n            0, // \"l\"\n            4, // \"m\"\n\
    \            4, // \"n\"\n            0, // \"o\"\n            4, // \"p\"\n \
    \           0, // \"q\"\n            0, // \"r\"\n            0, // \"s\"\n  \
    \          0, // \"t\"\n            0, // \"u\"\n            0, // \"v\"\n   \
    \         0, // \"w\"\n            0, // \"x\"\n            0, // \"y\"\n    \
    \        0, // \"z\"\n        ][c - 'a'];\n        current.push_str(&*shift);\n\
    \        acc\n    });\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpigdmi1se.rs:15:45\n   |\n\
    15 |     s.chars().fold(String::new(), |mut acc, &c| {\n   |                 \
    \                            ^--\n   |                                       \
    \      ||\n   |                                             |expected due to this\n\
    \   |                                             expected `char`, found reference\n\
    \   |                                             help: did you mean `c`: `&char`\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpigdmi1se.rs:14:26\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n...\n47 |     });\n   |       - help:\
    \ remove this semicolon\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for c in s.chars()\
    \ {\n        // get next letter in rotated alphabet\n        let mut nextC = (*c).rotate_left(2);\n\
    \        // move to next letter in alphabet\n        nextC = (nextC + ('a' as\
    \ u8)).rotate_left(2);\n        // shift up one place in alphabet\n        nextC\
    \ = (nextC + 'z' as u8).rotate_left(2);\n        // shift down one place in alphabet\n\
    \        nextC = (nextC - 'a' as u8).rotate_left(2);\n        result.append(nextC);\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmpsxujwemu.rs:18:25\n\
    \   |\n18 |         let mut nextC = (*c).rotate_left(2);\n   |               \
    \          ^^^^\n\nerror[E0599]: no method named `append` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmpsxujwemu.rs:25:16\n   |\n25 |         result.append(nextC);\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0599, E0614.\n\
    For more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut new_s = \"\";\n    s.split_whitespace().for_each(|x|\
    \ {\n        match x {\n            \"a\" => new_s += \"b\",\n            \"b\"\
    \ => new_s += \"c\",\n            \"c\" => new_s += \"d\",\n            \"d\"\
    \ => new_s += \"e\",\n            \"e\" => new_s += \"f\",\n            \"f\"\
    \ => new_s += \"g\",\n            \"g\" => new_s += \"h\",\n            \"h\"\
    \ => new_s += \"i\",\n            \"i\" => new_s += \"j\",\n            \"j\"\
    \ => new_s += \"k\",\n            \"k\" => new_s += \"l\",\n            \"l\"\
    \ => new_s += \"m\",\n            \"m\" => new_s += \"n\",\n            \"n\"\
    \ => new_s += \"o\",\n            \"o\" => new_s += \"p\",\n            \"p\"\
    \ => new_s += \"q\",\n            \"q\" => new_s += \"r\",\n            \"r\"\
    \ => new_s += \"s\",\n            \"s\" => new_s += \"t\",\n            \"t\"\
    \ => new_s += \"u\",\n            \"u\" => new_s += \"v\",\n            \"v\"\
    \ => new_s += \"w\",\n            \"w\" => new_s += \"x\",\n            \"x\"\
    \ => new_s += \"y\",\n            \"y\" => new_s += \"z\",\n            \"z\"\
    \ => new_s += \"a\",\n            \"a\" => new_s += \"b\",\n            \"b\"\
    \ => new_s += \"c\",\n            \"c\" => new_s += \"d\",\n            \"d\"\
    \ => new_s += \"e\",\n            \"e\" => new_s += \"f\",\n            \"f\"\
    \ => new_s += \"g\",\n            \"g\" => new_s += \"h\",\n            \"h\"\
    \ => new_s += \"i\",\n            \"i\" => new_s += \"j\",\n            \"j\"\
    \ => new_s += \"k\",\n            \"k\" => new_s += \"l\",\n            \"l\"\
    \ => new_s += \"m\",\n            \"m\" => new_s += \"n\",\n            \"n\"\
    \ => new_s += \"o\",\n            \"o\" => new_s += \"p\",\n            \"p\"\
    \ => new_s += \"q\",\n            \"q\" => new_s += \"r\",\n            \"r\"\
    \ => new_s += \"s\",\n            \"s\" => new_s += \"t\",\n            \"t\"\
    \ => new_s += \"u\",\n            \"u\" => new_s += \"v\",\n            \"v\"\
    \ => new_s += \"w\",\n            \"w\" => new_s += \"x\",\n            \"x\"\
    \ => new_s += \"y\",\n            \"y\" => new_s += \"z\",\n            \"z\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0765]: unterminated double quote string\n  --> /tmp/tmp8wbli0g2.rs:81:61\n\
    \   |\n81 |       assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"\
    ));\n   |  _____________________________________________________________^\n82\
    \ | | }\n   | |__^\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0765`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = alphabet_of(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    alphabet.rotate_right(2);\n    alphabet.push(alphabet.pop());\n    alphabet.push(alphabet.pop());\n\
    \    alphabet.push(alphabet.pop());\n    let mut cipher = String::new();\n   \
    \ for c in s.chars().cloned() {\n        cipher.push(alphabet[alphabet.index(c)]);\n\
    \    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `alphabet_of` in this scope\n  --> /tmp/tmp6i784hyh.rs:15:24\n\
    \   |\n15 |     let mut alphabet = alphabet_of(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n   |                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0271]:\
    \ type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmp6i784hyh.rs:21:24\n\
    \     |\n21   |     for c in s.chars().cloned() {\n     |                    \
    \    ^^^^^^ expected reference, found `char`\n     |\n     = note: expected reference\
    \ `&_`\n                     found type `char`\nnote: required by a bound in `cloned`\n\
    \nerror[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp6i784hyh.rs:21:14\n   |\n21 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \   = note: required because of the requirements on the impl of `IntoIterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror[E0271]: type mismatch resolving `<Chars<'_>\
    \ as Iterator>::Item == &_`\n  --> /tmp/tmp6i784hyh.rs:21:14\n   |\n21 |     for\
    \ c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^ expected `char`,\
    \ found reference\n   |\n   = note:   expected type `char`\n           found reference\
    \ `&_`\n   = note: required because of the requirements on the impl of `Iterator`\
    \ for `Cloned<Chars<'_>>`\n\nerror: aborting due to 4 previous errors\n\nSome\
    \ errors have detailed explanations: E0271, E0425.\nFor more information about\
    \ an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec!['A'..'Z', 'a'..'z'];\n    alphabet.rotate_left();\n\
    \    alphabet.resize(alphabet.len() - 2);\n\n    let mut ciphertext = String::new();\n\
    \n    for c in s.chars() {\n        let index = alphabet.iter().position(|c| *c\
    \ == c).unwrap();\n        ciphertext.push_str(&alphabet[index]);\n    }\n\n \
    \   ciphertext\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0061]: this function takes 1 argument but 0 arguments were supplied\n\
    \    --> /tmp/tmpl6bdvo0l.rs:16:14\n     |\n16   |     alphabet.rotate_left();\n\
    \     |              ^^^^^^^^^^^- supplied 0 arguments\n     |              |\n\
    \     |              expected 1 argument\n     |\nnote: associated function defined\
    \ here\n\nerror[E0061]: this function takes 2 arguments but 1 argument was supplied\n\
    \    --> /tmp/tmpl6bdvo0l.rs:17:14\n     |\n17   |     alphabet.resize(alphabet.len()\
    \ - 2);\n     |              ^^^^^^ ------------------ supplied 1 argument\n \
    \    |              |\n     |              expected 2 arguments\n     |\nnote:\
    \ associated function defined here\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpl6bdvo0l.rs:22:56\n\
    \   |\n22 |         let index = alphabet.iter().position(|c| *c == c).unwrap();\n\
    \   |                                                        ^ expected struct\
    \ `std::ops::Range`, found reference\n   |\n   = note: expected struct `std::ops::Range<char>`\n\
    \           found reference `&std::ops::Range<char>`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpl6bdvo0l.rs:23:29\n   |\n23 |         ciphertext.push_str(&alphabet[index]);\n\
    \   |                             ^^^^^^^^^^^^^^^^ expected `str`, found struct\
    \ `std::ops::Range`\n   |\n   = note: expected reference `&str`\n            \
    \  found reference `&std::ops::Range<char>`\n\nerror: aborting due to 4 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0308.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().enumerate().filter_map(|(_, c)| {\n     \
    \   if c == 0x65 { c ^ 0x64 } else { c }\n    }).cloned().collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp3hof74ib.rs:16:17\n   |\n\
    16 |         if c == 0x65 { c ^ 0x64 } else { c }\n   |                 ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0369]: no implementation for `char ^ {integer}`\n\
    \  --> /tmp/tmp3hof74ib.rs:16:26\n   |\n16 |         if c == 0x65 { c ^ 0x64 }\
    \ else { c }\n   |                        - ^ ---- {integer}\n   |           \
    \             |\n   |                        char\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp3hof74ib.rs:16:42\n   |\n16 |         if c == 0x65 { c\
    \ ^ 0x64 } else { c }\n   |                                          ^ expected\
    \ enum `Option`, found `char`\n   |\n   = note: expected enum `Option<_>`\n  \
    \            found type `char`\nhelp: try wrapping the expression in `Some`\n\
    \   |\n16 |         if c == 0x65 { c ^ 0x64 } else { Some(c) }\n   |         \
    \                                 +++++ +\n\nerror: aborting due to 3 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0369.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [\n        'a', 'b', 'c', 'd', 'e',\
    \ 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u',\
    \ 'v', 'w', 'x', 'y', 'z'\n    ];\n    alphabet.rotate_left(2);\n    alphabet.iter_mut().for_each(|char|\
    \ {\n        char.swap(alphabet[alphabet.iter().filter(|c| *c == char).next().unwrap()\
    \ as usize]);\n    });\n    let mut cipher = s.chars().map(|c| alphabet[c as usize]).collect::<String>();\n\
    \    cipher.insert(alphabet.len(), 'z');\n    cipher\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `swap` found for mutable reference `&mut\
    \ char` in the current scope\n  --> /tmp/tmphyi02ptk.rs:20:14\n   |\n20 |    \
    \     char.swap(alphabet[alphabet.iter().filter(|c| *c == char).next().unwrap()\
    \ as usize]);\n   |              ^^^^ method not found in `&mut char`\n\nerror[E0606]:\
    \ casting `&char` as `usize` is invalid\n  --> /tmp/tmphyi02ptk.rs:20:28\n   |\n\
    20 |         char.swap(alphabet[alphabet.iter().filter(|c| *c == char).next().unwrap()\
    \ as usize]);\n   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |\n   = help: cast through a raw pointer first\n\nerror: aborting due to 2\
    \ previous errors\n\nSome errors have detailed explanations: E0599, E0606.\nFor\
    \ more information about an error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(s)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp3n1o4m2j.rs:15:5\n   |\n15 |     rotate_alphabet(s)\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(s.chars().clone(), Alphabet::en).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp937wd3a1.rs:15:40\n   |\n15 |     rotate_alphabet(s.chars().clone(),\
    \ Alphabet::en).collect()\n   |                                        ^^^^^^^^\
    \ use of undeclared type `Alphabet`\n\nerror[E0425]: cannot find function `rotate_alphabet`\
    \ in this scope\n  --> /tmp/tmp937wd3a1.rs:15:5\n   |\n15 |     rotate_alphabet(s.chars().clone(),\
    \ Alphabet::en).collect()\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let alphabet = \"abcdefghijklmnopqrstuvwxyz\".to_string();\n\
    \    s.chars()\n        .map(|&c| alphabet.chars().nth((alphabet.len() - 2) -\
    \ alphabet.chars().position(c.to_ascii_lowercase()).unwrap()).unwrap())\n    \
    \    .collect()\n        .join(\"\")\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp8xoqhqkb.rs:17:15\n   |\n\
    17 |         .map(|&c| alphabet.chars().nth((alphabet.len() - 2) - alphabet.chars().position(c.to_ascii_lowercase()).unwrap()).unwrap())\n\
    \   |               ^--\n   |               ||\n   |               |expected due\
    \ to this\n   |               expected `char`, found reference\n   |         \
    \      help: did you mean `c`: `&char`\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::from(\"\");\n    for c in\
    \ s.chars() {\n        cipher = cipher + cipher.rotate_left(2);\n        cipher\
    \ = cipher + c;\n    }\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpnis2dcy1.rs:17:34\n   |\n17 |         cipher\
    \ = cipher + cipher.rotate_left(2);\n   |                                  ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpnis2dcy1.rs:18:27\n\
    \   |\n18 |         cipher = cipher + c;\n   |                           ^ expected\
    \ `&str`, found `char`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut a = s.chars().collect::<Vec<(u8, u8)>>();\n\
    \    for (index, byte) in a.iter().enumerate() {\n        let letter = if byte.is_ascii_lowercase()\
    \ { 1 } else { 2 };\n        a[index] = (byte, letter);\n    }\n    let mut b\
    \ = a.clone();\n    let mut c = b.clone();\n    c.rotate_left(2);\n    String::from_utf8_lossy(&mut\
    \ a).into_owned().append(&mut c);\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: a value of type `Vec<(u8, u8)>` cannot be built from an iterator\
    \ over elements of type `char`\n    --> /tmp/tmpofpmlttw.rs:15:27\n     |\n15\
    \   |     let mut a = s.chars().collect::<Vec<(u8, u8)>>();\n     |          \
    \                 ^^^^^^^ value of type `Vec<(u8, u8)>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<(u8,\
    \ u8)>`\n     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\n\
    note: required by a bound in `collect`\n\nerror[E0599]: no method named `is_ascii_lowercase`\
    \ found for reference `&(u8, u8)` in the current scope\n  --> /tmp/tmpofpmlttw.rs:17:30\n\
    \   |\n17 |         let letter = if byte.is_ascii_lowercase() { 1 } else { 2 };\n\
    \   |                              ^^^^^^^^^^^^^^^^^^ method not found in `&(u8,\
    \ u8)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpofpmlttw.rs:18:21\n  \
    \ |\n18 |         a[index] = (byte, letter);\n   |                     ^^^^ expected\
    \ `u8`, found `&(u8, u8)`\n   |\n   = note:   expected type `u8`\n           found\
    \ reference `&(u8, u8)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpofpmlttw.rs:23:29\n\
    \   |\n23 |     String::from_utf8_lossy(&mut a).into_owned().append(&mut c);\n\
    \   |                             ^^^^^^ expected slice `[u8]`, found struct `Vec`\n\
    \   |\n   = note:      expected reference `&[u8]`\n           found mutable reference\
    \ `&mut Vec<(u8, u8)>`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpofpmlttw.rs:23:50\n   |\n23 | \
    \    String::from_utf8_lossy(&mut a).into_owned().append(&mut c);\n   |      \
    \                                            ^^^^^^ method not found in `String`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpofpmlttw.rs:14:26\n   |\n14 |\
    \ fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to 6 previous\
    \ errors\n\nSome errors have detailed explanations: E027"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().filter(|c| *c >= 'a' && *c <= 'z').map(|c|\
    \ {\n        (*c - 'a' + 2) as i32\n    }).filter(|x| x % 2 == 0).map(|x| x +\
    \ 32).collect::<String>().to_string()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0614]: type `char` cannot be dereferenced\n  --> /tmp/tmp7bbu508v.rs:16:10\n\
    \   |\n16 |         (*c - 'a' + 2) as i32\n   |          ^^\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0614`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rot13(s).to_owned()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rot13` in this scope\n  --> /tmp/tmpr12rhlm3.rs:15:5\n\
    \   |\n15 |     rot13(s).to_owned()\n   |     ^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n    let mut len =\
    \ s.len();\n    let mut i = 1;\n    while i != len {\n        let mut temp = s[i];\n\
    \        if temp != s[len - i] {\n            temp = s[len - i];\n        }\n\
    \        cipher.push(temp);\n        i += 2;\n    }\n    cipher\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp4skbzr2s.rs:19:24\n\
    \   |\n19 |         let mut temp = s[i];\n   |                        ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4skbzr2s.rs:20:20\n   |\n20 |         if temp != s[len - i] {\n\
    \   |                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmp4skbzr2s.rs:21:20\n   |\n21 |             temp = s[len - i];\n\
    \   |                    ^^^^^^^^^^ `String` cannot be indexed by `usize`\n  \
    \ |\n   = help: the trait `Index<usize>` is not implemented for `String`\n   =\
    \ help: the following other types implement trait `Index<Idx>`:\n            \
    \ <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s\n        .chars()\n        .enumerate()\n\
    \        .map(|(idx, ch)| {\n            if idx % 2 == 0 {\n                *ch.wrapping_sub(2).collect::<u8>()\n\
    \            } else {\n                *ch.unwrap()\n            }\n        })\n\
    \        .collect::<Vec<u8>>()\n        .collect::<String>();\n    s.rotate_left(2);\n\
    \    String::from(s)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `wrapping_sub` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpz1hpl2gh.rs:20:21\n   |\n20 |                 *ch.wrapping_sub(2).collect::<u8>()\n\
    \   |                     ^^^^^^^^^^^^ method not found in `char`\n\nerror[E0599]:\
    \ no method named `unwrap` found for type `char` in the current scope\n  --> /tmp/tmpz1hpl2gh.rs:22:21\n\
    \   |\n22 |                 *ch.unwrap()\n   |                     ^^^^^^ method\
    \ not found in `char`\n\nerror[E0599]: `Vec<u8>` is not an iterator\n   --> /tmp/tmpz1hpl2gh.rs:26:10\n\
    \    |\n26  |           .collect::<String>();\n    |            ^^^^^^^ `Vec<u8>`\
    \ is not an iterator\n    |\n    = note: the following trait bounds were not satisfied:\n\
    \            `Vec<u8>: Iterator`\n            which is required by `&mut Vec<u8>:\
    \ Iterator`\n            `[u8]: Iterator`\n            which is required by `&mut\
    \ [u8]: Iterator`\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.iter().map(|c| match c {\n        c if c == c.to_ascii_lowercase()\
    \ => c.to_ascii_uppercase() + c.to_ascii_lowercase(),\n        _ => c,\n    }).collect()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpauma2wef.rs:15:7\n   |\n15 |     s.iter().map(|c| match\
    \ c {\n   |       ^^^^ method not found in `String`\n   |\nhelp: because of the\
    \ in-memory representation of `&str`, to obtain an `Iterator` over each of its\
    \ codepoint use method `chars`\n   |\n15 |     s.chars().map(|c| match c {\n \
    \  |       ~~~~~\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut ret = \"\".to_string();\n    for i in s.chars()\
    \ {\n        let mut tmp = i;\n        tmp = (tmp - 2) as u8;\n        tmp +=\
    \ 2;\n        tmp %= 26 + 'a' as u8;\n        ret += chars::to_string(*tmp);\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `chars`\n\
    \  --> /tmp/tmp9lw1kqu6.rs:21:16\n   |\n21 |         ret += chars::to_string(*tmp);\n\
    \   |                ^^^^^ use of undeclared crate or module `chars`\n\nerror[E0369]:\
    \ cannot subtract `{integer}` from `char`\n  --> /tmp/tmp9lw1kqu6.rs:18:20\n \
    \  |\n18 |         tmp = (tmp - 2) as u8;\n   |                --- ^ - {integer}\n\
    \   |                |\n   |                char\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmp9lw1kqu6.rs:19:9\n\
    \   |\n19 |         tmp += 2;\n   |         ---^^^^^\n   |         |\n   |   \
    \      cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment operation\
    \ `%=` cannot be applied to type `char`\n  --> /tmp/tmp9lw1kqu6.rs:20:9\n   |\n\
    20 |         tmp %= 26 + 'a' as u8;\n   |         ---^^^^^^^^^^^^^^^^^^\n   |\
    \         |\n   |         cannot use `%=` on type `char`\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmp9lw1kqu6.rs:21:33\n   |\n21 | \
    \        ret += chars::to_string(*tmp);\n   |                                \
    \ ^^^^\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0368, E0369, E0433, E0614.\nFor more information about an error,\
    \ try `rustc --explain E0368`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(rotate_alphabet(s, 2), 2)\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp6jnrqwmf.rs:15:5\n   |\n15 |     rotate_alphabet(rotate_alphabet(s,\
    \ 2), 2)\n   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `rotate_alphabet` in this scope\n  --> /tmp/tmp6jnrqwmf.rs:15:21\n\
    \   |\n15 |     rotate_alphabet(rotate_alphabet(s, 2), 2)\n   |              \
    \       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encryp_helper(s.chars().cloned(), 0, s)\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encryp_helper` in this scope\n  -->\
    \ /tmp/tmpu444tjyv.rs:15:5\n   |\n15 |     encryp_helper(s.chars().cloned(), 0,\
    \ s)\n   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpu444tjyv.rs:15:29\n\
    \     |\n15   |     encryp_helper(s.chars().cloned(), 0, s)\n     |          \
    \                   ^^^^^^ expected reference, found `char`\n     |\n     = note:\
    \ expected reference `&_`\n                     found type `char`\nnote: required\
    \ by a bound in `cloned`\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0271, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(rotate_alphabet(s))\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpgdnf8vgw.rs:15:5\n   |\n15 |     rotate_alphabet(rotate_alphabet(s))\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `rotate_alphabet` in this scope\n  --> /tmp/tmpgdnf8vgw.rs:15:21\n\
    \   |\n15 |     rotate_alphabet(rotate_alphabet(s))\n   |                    \
    \ ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c = 0;\n    let mut result = s.to_string();\n\
    \    for i in s.chars() {\n        result = result.rotate_left(2).to_string()\n\
    \             + &mut result[1..];\n        c = c + 1;\n        if c == 2 {\n \
    \           c = 0;\n        }\n        result = result + &mut result[0];\n   \
    \ }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp8jqxscch.rs:18:25\n   |\n18 |         result\
    \ = result.rotate_left(2).to_string()\n   |                         ^^^^^^^^^^^\
    \ method not found in `String`\n\nerror[E0277]: the type `String` cannot be indexed\
    \ by `{integer}`\n  --> /tmp/tmp8jqxscch.rs:24:32\n   |\n24 |         result =\
    \ result + &mut result[0];\n   |                                ^^^^^^^^^ `String`\
    \ cannot be indexed by `{integer}`\n   |\n   = help: the trait `Index<{integer}>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encipher::encrypt_rot13(s.into_bytes())\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `encipher`\n\
    \  --> /tmp/tmpe4mfvfsy.rs:15:5\n   |\n15 |     encipher::encrypt_rot13(s.into_bytes())\n\
    \   |     ^^^^^^^^ use of undeclared crate or module `encipher`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut r = s.clone();\n    r.rotate_right(2);\n  \
    \  r\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_right` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp6_bh6osn.rs:16:7\n   |\n16 |     r.rotate_right(2);\n\
    \   |       ^^^^^^^^^^^^ help: there is an associated function with a similar\
    \ name: `trim_right`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    alphabet\n        .iter()\n        .cloned()\n    \
    \    .enumerate()\n        .filter_map(|(i, ch)| {\n            if *i % 2 == 0\
    \ {\n                Some(ch.to_ascii_lowercase())\n            } else {\n   \
    \             Some(ch.to_ascii_uppercase())\n            }\n        })\n     \
    \   .collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmptbwmn4d3.rs:15:5\n\
    \   |\n15 |     alphabet\n   |     ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s + \"\\0\"\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hi\\0\"`,\n right: `\"lm\"`', /tmp/tmpz99615sd.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    String::from(s.chars().zip(s.chars().map(|c| c.chars().first()\
    \ + 2).collect()).collect())\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpsvzcqfkq.rs:15:52\n   |\n15 |     String::from(s.chars().zip(s.chars().map(|c|\
    \ c.chars().first() + 2).collect()).collect())\n   |                         \
    \                           ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = ALPHABET.clone();\n    alphabet.rotate_left(1);\n\
    \    let mut result = s.clone();\n    for (i, c) in alphabet.iter_mut().zip(s.chars().cloned().collect())\
    \ {\n        result += ALPHABET[alphabet.index(c) + 2 *i];\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmpmkujtlv_.rs:15:24\n\
    \   |\n15 |     let mut alphabet = ALPHABET.clone();\n   |                   \
    \     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `ALPHABET`\
    \ in this scope\n  --> /tmp/tmpmkujtlv_.rs:19:19\n   |\n19 |         result +=\
    \ ALPHABET[alphabet.index(c) + 2 *i];\n   |                   ^^^^^^^^ help: a\
    \ local variable with a similar name exists: `alphabet`\n\nerror[E0271]: type\
    \ mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n    --> /tmp/tmpmkujtlv_.rs:18:53\n\
    \     |\n18   |     for (i, c) in alphabet.iter_mut().zip(s.chars().cloned().collect())\
    \ {\n     |                                                     ^^^^^^ expected\
    \ reference, found `char`\n     |\n     = note: expected reference `&_`\n    \
    \                 found type `char`\nnote: required by a bound in `cloned`\n\n\
    error[E0599]: the method `collect` exists for struct `Cloned<Chars<'_>>`, but\
    \ its trait bounds were not satisfied\n  --> /tmp/tmpmkujtlv_.rs:18:62\n   |\n\
    18 |       for (i, c) in alphabet.iter_mut().zip(s.chars().cloned().collect())\
    \ {\n   |                                                                ^^^^^^^\
    \ method cannot be called on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `<Chars<'_>\
    \ as Iterator>::Item = &_`\n           which is required by `Cloned<Chars<'_>>:\
    \ Iterator`\n           `Cloned<Chars<'_>>: Iterator`\n           which is required\
    \ by `&mut Cloned<Chars<'_>>: Iterator`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0271, E0425, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::new();\n\n    for letter in\
    \ s.chars() {\n        let mut index = cipher.len() % alphabet.len();\n      \
    \  index = alphabet.len() - index - 1;\n        cipher.push_str(&alphabet[index]);\n\
    \    }\n\n    cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmprobekk01.rs:18:40\n\
    \   |\n18 |         let mut index = cipher.len() % alphabet.len();\n   |     \
    \                                   ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmprobekk01.rs:19:17\n\
    \   |\n19 |         index = alphabet.len() - index - 1;\n   |                \
    \ ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value `alphabet`\
    \ in this scope\n  --> /tmp/tmprobekk01.rs:20:26\n   |\n20 |         cipher.push_str(&alphabet[index]);\n\
    \   |                          ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut i = 0;\n    loop {\n        if i >= s.len()\
    \ {\n            break;\n        }\n        // rotate the letter\n        i %=\
    \ s.len();\n        // move the letter to the beginning\n        let l = s[i];\n\
    \        s.swap(i, 0);\n        s.swap(0, i);\n        i += 1;\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `usize`\n  --> /tmp/tmp8336usq6.rs:23:17\n\
    \   |\n23 |         let l = s[i];\n   |                 ^^^^ `String` cannot be\
    \ indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0599]: no method named `swap` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp8336usq6.rs:24:11\n   |\n24 |         s.swap(i,\
    \ 0);\n   |           ^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `swap` found for struct `String` in the current scope\n  --> /tmp/tmp8336usq6.rs:25:11\n\
    \   |\n25 |         s.swap(0, i);\n   |           ^^^^ method not found in `String`\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let alphabet = &[\"a\", \"b\", \"c\", \"d\", \"e\"\
    , \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\"\
    , \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"];\n   \
    \ let mut l = s.chars().enumerate().map(|(i, c)| {\n        c.to_ascii_lowercase();\n\
    \        (i, c ^ alphabet[alphabet.len() - i - 2].to_ascii_lowercase());\n   \
    \ }).collect::<Vec<_>>();\n    l.sort_by_key(|&(i, _)| i);\n    let mut c = \"\
    \";\n    for (_, v) in l.into_iter() {\n        c.push_str(&alphabet[(v >> 1)\
    \ as usize]);\n        c.push_str(&alphabet[(v & 1) as usize]);\n    }\n    c\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: no implementation for `char ^ String`\n  --> /tmp/tmpmf5ls1s9.rs:18:15\n\
    \   |\n18 |         (i, c ^ alphabet[alphabet.len() - i - 2].to_ascii_lowercase());\n\
    \   |             - ^ ----------------------------------------------------- String\n\
    \   |             |\n   |             char\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpmf5ls1s9.rs:20:21\n   |\n20 |     l.sort_by_key(|&(i, _)| i);\n\
    \   |                     ^^^^^-\n   |                     |    |\n   |      \
    \               |    expected due to this\n   |                     expected `()`,\
    \ found tuple\n   |\n   = note: expected unit type `()`\n                  found\
    \ tuple `(_, _)`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf5ls1s9.rs:22:9\n\
    \   |\n22 |     for (_, v) in l.into_iter() {\n   |         ^^^^^^    -------------\
    \ this expression has type `Option<()>`\n   |         |\n   |         expected\
    \ `()`, found tuple\n   |\n   = note: expected unit type `()`\n              \
    \    found tuple `(_, _)`\n\nerror[E0599]: no method named `push_str` found for\
    \ reference `&str` in the current scope\n  --> /tmp/tmpmf5ls1s9.rs:23:11\n   |\n\
    23 |         c.push_str(&alphabet[(v >> 1) as usize]);\n   |           ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0599]: no method named `push_str` found\
    \ for reference `&str` in the current scope\n  --> /tmp/tmpmf5ls1s9.rs:24:11\n\
    \   |\n24 |         c.push_str(&alphabet[(v & 1) as usize]);\n   |           ^^^^^^^^\
    \ method not found in `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpmf5ls1s9.rs:26:5\n\
    \   |\n14 | fn encrypt(s: String) -> String {\n   |                          ------\
    \ expected `String` because of return type\n...\n26 |     c\n   |     ^- help:\
    \ try using a conversion method: `.to_string()`\n   |     |\n   |     expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to 6 previous errors\n\n\
    Some errors have detailed explanations: E0308, E0369, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet: Alphabet = Alphabet::new();\n   \
    \ alphabet.rotate_left(2);\n    alphabet.rotate_left(4);\n    alphabet.rotate_left(5);\n\
    \n    let mut s = String::from(s);\n\n    for i in 0..s.len() {\n        let j\
    \ = s.chars().enumerate().find(|&(_, char)| char == &s[i]);\n        if j != None\
    \ {\n            s.swap(i, j.unwrap());\n        }\n    }\n\n    alphabet.join(s)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpbf4eiwz4.rs:15:34\n   |\n15 |     let mut alphabet: Alphabet = Alphabet::new();\n\
    \   |                                  ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0412]: cannot find type `Alphabet` in this scope\n  --> /tmp/tmpbf4eiwz4.rs:15:23\n\
    \   |\n15 |     let mut alphabet: Alphabet = Alphabet::new();\n   |          \
    \             ^^^^^^^^ not found in this scope\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `usize`\n  --> /tmp/tmpbf4eiwz4.rs:23:66\n   |\n23 |  \
    \       let j = s.chars().enumerate().find(|&(_, char)| char == &s[i]);\n   |\
    \                                                                  ^^^^ `String`\
    \ cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>` is not\
    \ implemented for `String`\n   = help: the following other types implement trait\
    \ `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n          \
    \   <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpbf4eiwz4.rs:23:65\n\
    \   |\n23 |         let j = s.chars().enumerate().find(|&(_, char)| char == &s[i]);\n\
    \   |                                                                 ^^^^^ expected\
    \ `char`, found reference\n   |\n   = note:   expected type `char`\n         \
    \  found reference `&_`\nhelp: consider removing the borrow\n   |\n23 -      \
    \   let j = s.chars().enumerate().find(|&(_, char)| char == &s[i]);\n23 +    \
    \     let j = s.chars().enumerate().find(|&(_, char)| char == s[i]);\n   | \n\n\
    error[E0599]: no method named `swap` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpbf4eiwz4.rs:25:15\n   |\n25 |             s.swap(i, j.unwrap());\n\
    \   |               ^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 5 previous errors\n\nSome errors have detailed explanations: E0277, E0308, "
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().skip_while(|&x| x.is_ascii()).collect::<Vec<Char>>();\n\
    \    let mut shift = alphabet.len();\n    alphabet.rotate_left(shift).unwrap();\n\
    \    let mut result = String::new();\n    for c in alphabet {\n        result.push(c);\n\
    \        shift -= 2;\n    }\n    result\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0412]: cannot find type `Char` in this scope\n  --> /tmp/tmphwwx4r7b.rs:15:78\n\
    \   |\n15 |     let mut alphabet = s.chars().skip_while(|&x| x.is_ascii()).collect::<Vec<Char>>();\n\
    \   |                                                                        \
    \      ^^^^\n   |\nhelp: a builtin type with a similar name exists\n   |\n15 |\
    \     let mut alphabet = s.chars().skip_while(|&x| x.is_ascii()).collect::<Vec<char>>();\n\
    \   |                                                                        \
    \      ~~~~\nhelp: you might be missing a type parameter\n   |\n14 | fn encrypt<Char>(s:\
    \ String) -> String {\n   |           ++++++\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0412`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = String::from(s);\n    rotate_alphabet(s.as_bytes(),\
    \ Alphabet::Alpha);\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp86h3w4ga.rs:16:35\n   |\n16 |     rotate_alphabet(s.as_bytes(), Alphabet::Alpha);\n\
    \   |                                   ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0425]: cannot find function `rotate_alphabet` in this scope\n  --> /tmp/tmp86h3w4ga.rs:16:5\n\
    \   |\n16 |     rotate_alphabet(s.as_bytes(), Alphabet::Alpha);\n   |     ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut a = s.clone();\n    a.rotate_left();\n    a.rotate_left();\n\
    \    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n\
    \    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n\
    \    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n    a.rotate_left();\n\
    \    a.rotate_left();\n    a\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpfixk4yw9.rs:16:7\n   |\n16 |     a.rotate_left();\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpfixk4yw9.rs:17:7\n\
    \   |\n17 |     a.rotate_left();\n   |       ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfixk4yw9.rs:18:7\n   |\n18 |     a.rotate_left();\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpfixk4yw9.rs:19:7\n\
    \   |\n19 |     a.rotate_left();\n   |       ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfixk4yw9.rs:20:7\n   |\n20 |     a.rotate_left();\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpfixk4yw9.rs:21:7\n\
    \   |\n21 |     a.rotate_left();\n   |       ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfixk4yw9.rs:22:7\n   |\n22 |     a.rotate_left();\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpfixk4yw9.rs:23:7\n\
    \   |\n23 |     a.rotate_left();\n   |       ^^^^^^^^^^^ method not found in `String`\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpfixk4yw9.rs:24:7\n   |\n24 |     a.rotate_left();\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpfixk4yw9.rs:25:7\n\
    \   |\n25 |     a.rotate_left();\n   |       ^^^^^^^^^^^ method not found i"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet_down(rotate_alphabet_down(s))\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet_down` in this scope\n\
    \  --> /tmp/tmpv54p3fzp.rs:15:5\n   |\n15 |     rotate_alphabet_down(rotate_alphabet_down(s))\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `rotate_alphabet_down` in this scope\n  --> /tmp/tmpv54p3fzp.rs:15:26\n\
    \   |\n15 |     rotate_alphabet_down(rotate_alphabet_down(s))\n   |          \
    \                ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_alphabet(ROTATE_TABLE, s)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmp7el1i35v.rs:15:5\n   |\n15 |     rotate_alphabet(ROTATE_TABLE, s)\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROTATE_TABLE` in this scope\n  --> /tmp/tmp7el1i35v.rs:15:21\n   |\n\
    15 |     rotate_alphabet(ROTATE_TABLE, s)\n   |                     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    fn rotate_right(x: &mut u8, y: u32) {\n        (*x)\
    \ %= y;\n        if *x > y { *x += y; }\n    }\n\n    fn rotate_left(x: &mut u8,\
    \ y: u32) {\n        (*x) %= y;\n        if *x < y { *x -= y; }\n    }\n\n   \
    \ let mut ret = \"\".to_string();\n    for i in s.chars().iter() {\n        if\
    \ *i == ' ' {\n            if i > ret.len() {\n                ret += &(*i) +\
    \ &*i;\n            }\n        }\n        else {\n            rotate_right(&mut\
    \ i, 2);\n            rotate_left(&mut i, 2);\n            ret += &*i;\n     \
    \   }\n    }\n    ret\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp9aw4ceh7.rs:26:24\n   |\n26 |     for i in s.chars().iter()\
    \ {\n   |                        ^^^^ private field, not a method\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9aw4ceh7.rs:16:17\n   |\n16 |         (*x) %=\
    \ y;\n   |                 ^ expected `u8`, found `u32`\n\nerror[E0277]: cannot\
    \ mod-assign `u8` by `u32``\n  --> /tmp/tmp9aw4ceh7.rs:16:14\n   |\n16 |     \
    \    (*x) %= y;\n   |              ^^ no implementation for `u8 %= u32`\n   |\n\
    \   = help: the trait `RemAssign<u32>` is not implemented for `u8`\n   = help:\
    \ the following other types implement trait `RemAssign<Rhs>`:\n             <f32\
    \ as RemAssign<&f32>>\n             <f32 as RemAssign>\n             <f64 as RemAssign<&f64>>\n\
    \             <f64 as RemAssign>\n             <i128 as RemAssign<&i128>>\n  \
    \           <i128 as RemAssign>\n             <i16 as RemAssign<&i16>>\n     \
    \        <i16 as RemAssign>\n           and 20 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9aw4ceh7.rs:17:17\n   |\n17 |         if *x > y { *x +=\
    \ y; }\n   |                 ^ expected `u8`, found `u32`\n   |\nhelp: you can\
    \ convert `*x` from `u8` to `u32`, matching the type of `y`\n   |\n17 |      \
    \   if u32::from(*x) > y { *x += y; }\n   |            ++++++++++  +\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9aw4ceh7.rs:17:27\n   |\n17 |         if *x\
    \ > y { *x += y; }\n   |                           ^ expected `u8`, found `u32`\n\
    \nerror[E0277]: cannot add-assign `u32` to `u8`\n  --> /tmp/tmp9aw4ceh7.rs:17:24\n\
    \   |\n17 |         if *x > y { *x += y; }\n   |                        ^^ no\
    \ implementation for `u8 += u32`\n   |\n   = help: the trait `AddAssign<u32>`\
    \ is not implemented for `u8`\n   = help: the following other types implement\
    \ trait `AddAssign<Rhs>`:\n             <f32 as AddAssign<&f32>>\n           \
    \  <f32 as AddAssign>\n             <f64 as AddAssign<&f64>>\n             <f64\
    \ as AddAssign>\n             <i128 as AddAssign<&i128>>\n             <i128 as\
    \ AddAssign>\n             <i16 as AddAssign<&i16>>\n             <i1"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().enumerate().map(|(i, c)| {\n        rotate_alphabet(c,\
    \ i);\n    }).collect().to_owned()\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_alphabet` in this scope\n  -->\
    \ /tmp/tmpo9ocdt86.rs:16:9\n   |\n16 |         rotate_alphabet(c, i);\n   |  \
    \       ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [char::MIN..char::MAX];\n    let\
    \ mut i = 0;\n    while i < alphabet.len() {\n        alphabet[i] = alphabet[alphabet.len()\
    \ - i - 1];\n        alphabet[alphabet.len() - i - 1] += 1;\n        i += 2;\n\
    \    }\n    \n    let mut result = [char::MIN..char::MAX];\n    for i in 0..s.len()\
    \ {\n        result[s.len() - i - 1] = alphabet[(result[s.len() - i - 1] + alphabet.len()\
    \ - i) % alphabet.len()];\n    }\n    \n    String::from(result)\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no associated item named `MIN` found for type `char` in the\
    \ current scope\n  --> /tmp/tmpxbp1herm.rs:15:31\n   |\n15 |     let mut alphabet\
    \ = [char::MIN..char::MAX];\n   |                               ^^^ associated\
    \ item not found in `char`\n\nerror[E0368]: binary assignment operation `+=` cannot\
    \ be applied to type `std::ops::Range<char>`\n  --> /tmp/tmpxbp1herm.rs:19:9\n\
    \   |\n19 |         alphabet[alphabet.len() - i - 1] += 1;\n   |         --------------------------------^^^^^\n\
    \   |         |\n   |         cannot use `+=` on type `std::ops::Range<char>`\n\
    \nerror[E0599]: no associated item named `MIN` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpxbp1herm.rs:23:29\n   |\n23 |     let mut result = [char::MIN..char::MAX];\n\
    \   |                             ^^^ associated item not found in `char`\n\n\
    error[E0369]: cannot add `usize` to `std::ops::Range<char>`\n  --> /tmp/tmpxbp1herm.rs:25:69\n\
    \   |\n25 |         result[s.len() - i - 1] = alphabet[(result[s.len() - i - 1]\
    \ + alphabet.len() - i) % alphabet.len()];\n   |                             \
    \                ----------------------- ^ -------------- usize\n   |        \
    \                                     |\n   |                                \
    \             std::ops::Range<char>\n\nerror[E0277]: the trait bound `String:\
    \ From<[std::ops::Range<char>; 1]>` is not satisfied\n  --> /tmp/tmpxbp1herm.rs:28:5\n\
    \   |\n28 |     String::from(result)\n   |     ^^^^^^^^^^^^ the trait `From<[std::ops::Range<char>;\
    \ 1]>` is not implemented for `String`\n   |\n   = help: the following other types\
    \ implement trait `From<T>`:\n             <String as From<&String>>\n       \
    \      <String as From<&mut str>>\n             <String as From<&str>>\n     \
    \        <String as From<Box<str>>>\n             <String as From<Cow<'a, str>>>\n\
    \             <String as From<char>>\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0368, E0369, E0599.\nFor more\
    \ information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    alphabet.rotate_up(Alphabet::alpha_index(\"\
    a\"));\n    alphabet.rotate_down(Alphabet::alpha_index(\"t\"));\n    let alphabet\
    \ = alphabet.get_alphabet();\n    let mut result = s.clone();\n    for (i, &letter)\
    \ in result.chars().enumerate() {\n        result[i] = alphabet[(letter - alphabet.a)\
    \ * 2 - alphabet.t].unwrap();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpqr25fnbc.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpqr25fnbc.rs:16:24\n\
    \   |\n16 |     alphabet.rotate_up(Alphabet::alpha_index(\"a\"));\n   |      \
    \                  ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpqr25fnbc.rs:17:26\n\
    \   |\n17 |     alphabet.rotate_down(Alphabet::alpha_index(\"t\"));\n   |    \
    \                      ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpqr25fnbc.rs:20:13\n   |\n20 |     for (i, &letter)\
    \ in result.chars().enumerate() {\n   |             ^^^^^^^     --------------------------\
    \ this expression has type `Option<(usize, char)>`\n   |             |\n   | \
    \            expected `char`, found reference\n   |             help: you can\
    \ probably remove the explicit borrow: `letter`\n   |\n   = note:   expected type\
    \ `char`\n           found reference `&_`\n\nerror[E0277]: the type `String` cannot\
    \ be indexed by `usize`\n  --> /tmp/tmpqr25fnbc.rs:21:9\n   |\n21 |         result[i]\
    \ = alphabet[(letter - alphabet.a) * 2 - alphabet.t].unwrap();\n   |         ^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror: aborting due to 5 previous errors\n\nSome errors have detailed\
    \ explanations: E0277, E0308, E0433.\nFor more information about an error, try\
    \ `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt_with_repetitions(s, Alphabet::ROTATE, 2)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpgf0skq3n.rs:15:33\n   |\n15 |     encrypt_with_repetitions(s, Alphabet::ROTATE,\
    \ 2)\n   |                                 ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0425]: cannot find function `encrypt_with_repetitions` in this scope\n\
    \  --> /tmp/tmpgf0skq3n.rs:15:5\n   |\n15 |     encrypt_with_repetitions(s, Alphabet::ROTATE,\
    \ 2)\n   |     ^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0425, E0433.\n\
    For more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // Implement the code here\n    let mut alphabet: Vec<&str>\
    \ = [\"a\".to_string(), \"b\".to_string(), \"c\".to_string(), \"d\".to_string(),\
    \ \"e\".to_string(), \"f\".to_string(), \"g\".to_string(), \"h\".to_string(),\
    \ \"i\".to_string(), \"j\".to_string(), \"k\".to_string(), \"l\".to_string(),\
    \ \"m\".to_string(), \"n\".to_string(), \"o\".to_string(), \"p\".to_string(),\
    \ \"q\".to_string(), \"r\".to_string(), \"s\".to_string(), \"t\".to_string(),\
    \ \"u\".to_string(), \"v\".to_string(), \"w\".to_string(), \"x\".to_string(),\
    \ \"y\".to_string(), \"z\".to_string()];\n    let mut char_count = 0;\n    let\
    \ mut encrypted_char_count = 0;\n    let mut encrypted_chars = Vec::new();\n \
    \   \n    let mut encrypted_str = s.clone();\n\n    for i in s.chars() {\n   \
    \     let mut char_val = i[0].to_string();\n        \n        //Encrypts the character\
    \ if char_count <= the length of the alphabet\n        if char_count <= alphabet.len()\
    \ {\n            char_val = alphabet[char_count].to_string();\n            encrypted_char_count\
    \ += 2;\n            \n            char_count += 1;\n        }\n\n        //Encrypts\
    \ the character if char_count > the length of the alphabet\n        if char_count\
    \ > alphabet.len() {\n            char_val = alphabet[char_count].to_string();\n\
    \            encrypted_char_count += 1;\n            \n            char_count\
    \ += 1;\n        }\n        \n        encrypted_chars.push(char_val);\n    }\n\
    \n    encrypted_str.push_str(&encrypted_chars);\n    \n    encrypted_str.to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpxc7y03fw.rs:16:35\n   |\n\
    16 | ...t: Vec<&str> = [\"a\".to_string(), \"b\".to_string(), \"c\".to_string(),\
    \ \"d\".to_string(), \"e\".to_string(), \"f\".to_string(), \"g\".to_string(),\
    \ \"h\".to_string(), \"i\".to_string(), \"j\".to_string(), \"k\".to_string(),\
    \ \"l\".to_string(), \"m\".to_string(), \"n\".to_string(), \"o\".to_string(),\
    \ \"p\".to_string(), \"q\".to_string(), \"r\".to_string(), \"s\".to_string(),\
    \ \"t\".to_string(), \"u\".to_string(), \"v\".to_string(), \"w\".to_string(),\
    \ \"x\".to_string(), \"y\".to_string(), \"z\".to_string(...\n   |       ---------\
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ expected struct `Vec`, found array of 26 elements\n   |       |\n   |      \
    \ expected due to this\n   |\n   = note: expected struct `Vec<&str>`\n       \
    \        found array `[String; 26]`\n\nerror[E0608]: cannot index into a value\
    \ of type `char`\n  --> /tmp/tmpxc7y03fw.rs:24:28\n   |\n24 |         let mut\
    \ char_val = i[0].to_string();\n   |                            ^^^^\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpxc7y03fw.rs:45:28\n   |\n45 |     encrypted_str.push_str(&encrypted_chars);\n\
    \   |                            ^^^^^^^^^^^^^^^^ expected `str`, found struct\
    \ `Vec`\n   |\n   = note: expected reference `&str`\n              found reference\
    \ `&Vec<String>`\n\nerror: aborting due to 3 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0608.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encipher_rotated_string(s, ALPHABET)\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encipher_rotated_string` in this scope\n\
    \  --> /tmp/tmplu1m6xj5.rs:15:5\n   |\n15 |     encipher_rotated_string(s, ALPHABET)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `ALPHABET` in this scope\n  --> /tmp/tmplu1m6xj5.rs:15:32\n   |\n\
    15 |     encipher_rotated_string(s, ALPHABET)\n   |                          \
    \      ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut a = s.chars();\n    let mut b = a;\n    let\
    \ mut shift = 1;\n    while b.next() < a.next() {\n        let letter = b.next().unwrap().to_ascii_uppercase();\n\
    \        let val = shift % 26 + 'A' - 'a';\n        let mut b = a.next().unwrap();\n\
    \        a = b.clone();\n        shift += val;\n    }\n    b.collect().to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: cannot add `char` to `{integer}`\n  --> /tmp/tmp13tr9jef.rs:20:30\n\
    \   |\n20 |         let val = shift % 26 + 'A' - 'a';\n   |                  \
    \            ^ no implementation for `{integer} + char`\n   |\n   = help: the\
    \ trait `Add<char>` is not implemented for `{integer}`\n   = help: the following\
    \ other types implement trait `Add<Rhs>`:\n             <&'a f32 as Add<f32>>\n\
    \             <&'a f64 as Add<f64>>\n             <&'a i128 as Add<i128>>\n  \
    \           <&'a i16 as Add<i16>>\n             <&'a i32 as Add<i32>>\n      \
    \       <&'a i64 as Add<i64>>\n             <&'a i8 as Add<i8>>\n            \
    \ <&'a isize as Add<isize>>\n           and 48 others\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp13tr9jef.rs:22:13\n   |\n15 |     let mut a = s.chars();\n\
    \   |                 --------- expected due to this value\n...\n22 |        \
    \ a = b.clone();\n   |             ^^^^^^^^^ expected struct `Chars`, found `char`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0308.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut rotated_alphabet = alphabet.clone();\n    for\
    \ _ in 0..alphabet.len() {\n        rotated_alphabet = rotated_alphabet.rotate(2);\n\
    \    }\n\n    String::from(&s.chars().zip(rotated_alphabet.clone()).map(|c| c.1).collect())\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpfj44o2pv.rs:15:32\n\
    \   |\n15 |     let mut rotated_alphabet = alphabet.clone();\n   |           \
    \                     ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `alphabet` in this scope\n  --> /tmp/tmpfj44o2pv.rs:16:17\n   |\n\
    16 |     for _ in 0..alphabet.len() {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c: Vec<u8> = vec![0; 256];\n    for i in s.chars().skip(s.len()\
    \ - 1) {\n        let index = i as u8;\n        c[index + 2] += 2u8;\n    }\n\
    \    c.iter().map(|a| a % 0x20).collect();\n    String::from_utf8(c.iter().map(|a|\
    \ a.to_char().to_string()).collect()).unwrap()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `[u8]` cannot be indexed by `u8`\n  --> /tmp/tmpftgpde4d.rs:18:9\n\
    \   |\n18 |         c[index + 2] += 2u8;\n   |         ^^^^^^^^^^^^ slice indices\
    \ are of type `usize` or ranges of `usize`\n   |\n   = help: the trait `SliceIndex<[u8]>`\
    \ is not implemented for `u8`\n   = help: the trait `SliceIndex<[T]>` is implemented\
    \ for `usize`\n   = note: required because of the requirements on the impl of\
    \ `Index<u8>` for `Vec<u8>`\n\nerror[E0599]: no method named `to_char` found for\
    \ reference `&u8` in the current scope\n  --> /tmp/tmpftgpde4d.rs:21:42\n   |\n\
    21 |     String::from_utf8(c.iter().map(|a| a.to_char().to_string()).collect()).unwrap()\n\
    \   |                                          ^^^^^^^ method not found in `&u8`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599.\nFor more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut l = s.chars();\n    let mut r = s.chars();\n\
    \    r.rotate_left(2);\n    let mut c: Vec<&'static str> = l.collect();\n    c.reverse();\n\
    \    for c in c {\n        r.push(c.clone());\n    }\n    r\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmpdecdonma.rs:17:7\n   |\n17 |     r.rotate_left(2);\n\
    \   |       ^^^^^^^^^^^ method not found in `Chars<'_>`\n\nerror[E0277]: a value\
    \ of type `Vec<&str>` cannot be built from an iterator over elements of type `char`\n\
    \    --> /tmp/tmpdecdonma.rs:18:38\n     |\n18   |     let mut c: Vec<&'static\
    \ str> = l.collect();\n     |                                      ^^^^^^^ value\
    \ of type `Vec<&str>` cannot be built from `std::iter::Iterator<Item=char>`\n\
    \     |\n     = help: the trait `FromIterator<char>` is not implemented for `Vec<&str>`\n\
    \     = help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror[E0599]: no method named `push` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmpdecdonma.rs:21:11\n   |\n21 |  \
    \       r.push(c.clone());\n   |           ^^^^ method not found in `Chars<'_>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpdecdonma.rs:23:5\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n23 |     r\n   |     ^ expected struct\
    \ `String`, found struct `Chars`\n\nerror: aborting due to 4 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut a = s.chars();\n    a.next().unwrap();\n  \
    \  a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\
    \    a.next().unwrap();\n    a.next().unwrap();\n    a.next().unwrap();\n\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpyuz6alkj.rs:14:26\n   |\n\
    14 | fn encrypt(s: String) -> String {\n   |    -------               ^^^^^^ expected\
    \ struct `String`, found `()`\n   |    |\n   |    implicitly returns `()` as its\
    \ body has no tail or `return` expression\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s + \"ewhjklnop\"\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"hiewhjklnop\"`,\n right: `\"lm\"`', /tmp/tmpe4rsxib8.rs:20:5\nnote: run with\
    \ `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_by_two(&s)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_by_two` in this scope\n  -->\
    \ /tmp/tmp7fz5zm3l.rs:15:5\n   |\n15 |     rotate_by_two(&s)\n   |     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::from(\"abcdefghijklmnopqrstuvwxyz\"\
    );\n    for i in 1..s.len() {\n        let mut j = result.len();\n        let\
    \ mut k = result.len();\n        while j > i {\n            j = k & i;\n     \
    \       k = j >> 1;\n        }\n        result[i..k] = result[i..k].rotate_left(2)\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for type `str` in the\
    \ current scope\n  --> /tmp/tmpjls8dhtn.rs:23:37\n   |\n23 |         result[i..k]\
    \ = result[i..k].rotate_left(2)\n   |                                     ^^^^^^^^^^^\
    \ method not found in `str`\n\nerror[E0277]: the size for values of type `str`\
    \ cannot be known at compilation time\n  --> /tmp/tmpjls8dhtn.rs:23:9\n   |\n\
    23 |         result[i..k] = result[i..k].rotate_left(2)\n   |         ^^^^^^^^^^^^\
    \ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: the left-hand-side of an assignment\
    \ must have a statically known size\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0277, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    for &mut c in\
    \ s.chars().cloned() {\n        let mut c = c.to_digit(26);\n        c = c.rotate_left(2);\n\
    \        c = c.rotate_left(3);\n        result.push(c);\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmp1simgaui.rs:16:29\n     |\n16   |     for &mut c in s.chars().cloned()\
    \ {\n     |                             ^^^^^^ expected reference, found `char`\n\
    \     |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmp1simgaui.rs:16:19\n\
    \   |\n16 |     for &mut c in s.chars().cloned() {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmp1simgaui.rs:16:19\n   |\n16 |     for &mut c in s.chars().cloned()\
    \ {\n   |                   ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n\
    \   |\n   = note:   expected type `char`\n           found reference `&_`\n  \
    \ = note: required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror[E0277]: the trait bound `&mut _: Clone` is not satisfied\n  --> /tmp/tmp1simgaui.rs:16:19\n\
    \   |\n16 |     for &mut c in s.chars().cloned() {\n   |                   ^^^^^^^^^^^^^^^^^^\
    \ the trait `Clone` is not implemented for `&mut _`\n   |\n   = help: the trait\
    \ `Iterator` is implemented for `Cloned<I>`\n   = note: required because of the\
    \ requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\nerror: aborting\
    \ due to 4 previous errors\n\nSome errors have detailed explanations: E0271, E0277.\n\
    For more information about an error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result: String = String::new();\n    for i\
    \ in s.chars() {\n        let index = i.to_ascii_lowercase().to_ascii_uppercase().len()\
    \ - 1;\n        result += ROTATE_ALPHABET[ROTATE_ALPHABET.len() - 1 - index] +\
    \ i.to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n\
    \    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ROTATE_ALPHABET` in this scope\n  -->\
    \ /tmp/tmpv4bh_lk9.rs:18:19\n   |\n18 |         result += ROTATE_ALPHABET[ROTATE_ALPHABET.len()\
    \ - 1 - index] + i.to_string();\n   |                   ^^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROTATE_ALPHABET` in this scope\n\
    \  --> /tmp/tmpv4bh_lk9.rs:18:35\n   |\n18 |         result += ROTATE_ALPHABET[ROTATE_ALPHABET.len()\
    \ - 1 - index] + i.to_string();\n   |                                   ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0599]: no method named `len` found for type\
    \ `char` in the current scope\n  --> /tmp/tmpv4bh_lk9.rs:17:65\n   |\n17 |   \
    \      let index = i.to_ascii_lowercase().to_ascii_uppercase().len() - 1;\n  \
    \ |                                                                 ^^^ method\
    \ not found in `char`\n\nerror: aborting due to 3 previous errors\n\nSome errors\
    \ have detailed explanations: E0425, E0599.\nFor more information about an error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| ROTATE(c)).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function, tuple struct or tuple variant `ROTATE`\
    \ in this scope\n  --> /tmp/tmpkrm5ucb4.rs:15:23\n   |\n15 |     s.chars().map(|c|\
    \ ROTATE(c)).collect()\n   |                       ^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // The first character will be the original first letter\
    \ of the alphabet \n    // rotated by two to the left so it will become 'l'. \n\
    \    let mut c = s[0];\n    let i = 1;\n    loop {\n        if c == 'a' {\n  \
    \          c = 'l';\n            i += 2;\n        }\n        if c == 'z' {\n \
    \           c = 'k';\n            i += 2;\n        }\n        if c == 'A' {\n\
    \            c = 'L';\n            i += 2;\n        }\n        if c == 'Z' {\n\
    \            c = 'K';\n            i += 2;\n        }\n        // We want to keep\
    \ rotating the letter c so that it becomes the new \n        // first letter of\
    \ the alphabet which is 'e'. \n        let x = c - 'a' + i;\n        c += x;\n\
    \        i += 2;\n        if c > 'z' {\n            c -= 26;\n        }\n    \
    \    if c < 'a' {\n            c += 26;\n        }\n        if c == s[0] {\n \
    \           break;\n        }\n    }\n    c.to_string()\n}\n\nfn main() {\n  \
    \  let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `{integer}`\n  -->\
    \ /tmp/tmpmalea0py.rs:17:17\n   |\n17 |     let mut c = s[0];\n   |          \
    \       ^^^^ `String` cannot be indexed by `{integer}`\n   |\n   = help: the trait\
    \ `Index<{integer}>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpmalea0py.rs:38:19\n\
    \   |\n38 |         let x = c - 'a' + i;\n   |                 - ^ --- char\n\
    \   |                 |\n   |                 char\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpmalea0py.rs:39:9\n\
    \   |\n39 |         c += x;\n   |         -^^^^^\n   |         |\n   |       \
    \  cannot use `+=` on type `char`\n\nerror[E0368]: binary assignment operation\
    \ `-=` cannot be applied to type `char`\n  --> /tmp/tmpmalea0py.rs:42:13\n   |\n\
    42 |             c -= 26;\n   |             -^^^^^^\n   |             |\n   |\
    \             cannot use `-=` on type `char`\n\nerror[E0368]: binary assignment\
    \ operation `+=` cannot be applied to type `char`\n  --> /tmp/tmpmalea0py.rs:45:13\n\
    \   |\n45 |             c += 26;\n   |             -^^^^^^\n   |             |\n\
    \   |             cannot use `+=` on type `char`\n\nerror[E0277]: the type `String`\
    \ cannot be indexed by `{integer}`\n  --> /tmp/tmpmalea0py.rs:47:17\n   |\n47\
    \ |         if c == s[0] {\n   |                 ^^^^ `String` cannot be indexed\
    \ by `{integer}`\n   |\n   = help: the trait `Index<{integer}>` is not implemented\
    \ for `String`\n   = help: the following other types implement trait `Index<Idx>`:\n\
    \             <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<u"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    if s.len() < 2 {\n        return s\n    }\n\n    let\
    \ mut c = 0;\n\n    let mut result = String::new();\n\n    for (i, c) in s.chars().enumerate()\
    \ {\n        let x = c + 2;\n        result.append(alphabet_rotator.chars().nth(x).unwrap());\n\
    \    }\n\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet_rotator` in this scope\n  -->\
    \ /tmp/tmpuy5lkia0.rs:25:23\n   |\n25 |         result.append(alphabet_rotator.chars().nth(x).unwrap());\n\
    \   |                       ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0369]:\
    \ cannot add `{integer}` to `char`\n  --> /tmp/tmpuy5lkia0.rs:24:19\n   |\n24\
    \ |         let x = c + 2;\n   |                 - ^ - {integer}\n   |       \
    \          |\n   |                 char\n\nerror[E0599]: no method named `append`\
    \ found for struct `String` in the current scope\n  --> /tmp/tmpuy5lkia0.rs:25:16\n\
    \   |\n25 |         result.append(alphabet_rotator.chars().nth(x).unwrap());\n\
    \   |                ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 3 previous errors\n\nSome errors have detailed explanations: E0369, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    // TODO: check input for sanity\n    let mut alphabet\
    \ = vec!['z' - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v' - 1, 'u' - 1, 't' - 1, 's'\n\
    \                         - 1, 'r' - 1, 'q' - 1, 'p' - 1, 'o' - 1, 'n' - 1, 'm'\
    \ - 1];\n    \n    for i in s.chars().enumerate() {\n        alphabet.swap(i);\n\
    \    }\n\n    let mut result = String::new();\n    let mut i = 0;\n    for c in\
    \ s.chars() {\n        result.set_char(i + alphabet.iter().filter(|&b| b == 'z').next().unwrap(),\
    \ c);\n        i += alphabet.iter().filter(|&b| b == 'z').next().unwrap() as usize;\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpl982cci9.rs:16:33\n\
    \   |\n16 |     let mut alphabet = vec!['z' - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v'\
    \ - 1, 'u' - 1, 't' - 1, 's'\n   |                             --- ^ - {integer}\n\
    \   |                             |\n   |                             char\n\n\
    error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpl982cci9.rs:16:42\n\
    \   |\n16 |     let mut alphabet = vec!['z' - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v'\
    \ - 1, 'u' - 1, 't' - 1, 's'\n   |                                      --- ^\
    \ - {integer}\n   |                                      |\n   |             \
    \                         char\n\nerror[E0369]: cannot subtract `{integer}` from\
    \ `char`\n  --> /tmp/tmpl982cci9.rs:16:51\n   |\n16 |     let mut alphabet = vec!['z'\
    \ - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v' - 1, 'u' - 1, 't' - 1, 's'\n   |       \
    \                                        --- ^ - {integer}\n   |             \
    \                                  |\n   |                                   \
    \            char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n \
    \ --> /tmp/tmpl982cci9.rs:16:60\n   |\n16 |     let mut alphabet = vec!['z' -\
    \ 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v' - 1, 'u' - 1, 't' - 1, 's'\n   |         \
    \                                               --- ^ - {integer}\n   |      \
    \                                                  |\n   |                   \
    \                                     char\n\nerror[E0369]: cannot subtract `{integer}`\
    \ from `char`\n  --> /tmp/tmpl982cci9.rs:16:69\n   |\n16 |     let mut alphabet\
    \ = vec!['z' - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v' - 1, 'u' - 1, 't' - 1, 's'\n\
    \   |                                                                 --- ^ -\
    \ {integer}\n   |                                                            \
    \     |\n   |                                                                \
    \ char\n\nerror[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpl982cci9.rs:16:78\n\
    \   |\n16 |     let mut alphabet = vec!['z' - 1, 'y' - 1, 'x' - 1, 'w' - 1, 'v'\
    \ - 1, 'u' - 1, 't' - 1, 's'\n   |   "
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let alphabet = &mut alphabets[2];\n    let mut s =\
    \ s;\n    loop {\n        match s.chars().next() {\n            Some(c) => {\n\
    \                let i = alphabet.index(c);\n                alphabet[i] = alphabet[alphabet.len()\
    \ - 1 - i];\n                alphabet[alphabet.len() - 1 - i] = c;\n         \
    \       s = String::from(&alphabet);\n            }\n            None => break,\n\
    \        }\n    }\n    s\n}\n\nfn main() {\n    let candidate = encrypt;\n   \
    \ assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabets` in this scope\n  --> /tmp/tmpict_ufx2.rs:15:25\n\
    \   |\n15 |     let alphabet = &mut alphabets[2];\n   |                      \
    \   ^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let alphabet = [\n        String::from(\"abcd\"),\n\
    \        String::from(\"bcde\"),\n        String::from(\"cdef\"),\n        String::from(\"\
    defg\"),\n        String::from(\"efgh\"),\n        String::from(\"fghi\"),\n \
    \       String::from(\"ghij\"),\n        String::from(\"hijk\"),\n        String::from(\"\
    ijkl\"),\n        String::from(\"jklm\"),\n        String::from(\"kilm\"),\n \
    \       String::from(\"lmno\"),\n        String::from(\"mnop\"),\n        String::from(\"\
    nopq\"),\n        String::from(\"opqr\"),\n        String::from(\"qrst\"),\n \
    \       String::from(\"rstu\"),\n        String::from(\"tuv\"),\n        String::from(\"\
    vwx\"),\n        String::from(\"wxy\"),\n        String::from(\"yz\"),\n     \
    \   String::from(\"z\"),\n    ];\n\n    let mut chars = s.chars();\n    let mut\
    \ encrypted: Vec<String> = vec![];\n    while chars.next() != Some(&String::from(\"\
    \\0\")) {\n        let mut new_char = chars.next().unwrap();\n        let mut\
    \ position = alphabet.iter().position(|&b| b.chars().any(|c| c.chars().any(|d|\
    \ d == new_char)));\n        encrypted.push(alphabet[position.unwrap() as usize].to_string());\n\
    \        new_char = new_char.chars().next().unwrap();\n        position = alphabet.iter().position(|&b|\
    \ b.chars().any(|c| c.chars().any(|d| d == new_char)));\n        encrypted.push(alphabet[position.unwrap()\
    \ as usize].to_string());\n    }\n    String::from(encrypted.join(\"\"))\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpwvexol57.rs:42:32\n   |\n\
    42 |     while chars.next() != Some(&String::from(\"\\0\")) {\n   |          \
    \                      ^^^^^^^^^^^^^^^^^^^ expected `char`, found `&String`\n\n\
    error[E0599]: no method named `chars` found for type `char` in the current scope\n\
    \  --> /tmp/tmpwvexol57.rs:44:78\n   |\n44 |         let mut position = alphabet.iter().position(|&b|\
    \ b.chars().any(|c| c.chars().any(|d| d == new_char)));\n   |                \
    \                                                              ^^^^^ method not\
    \ found in `char`\n\nerror[E0599]: no method named `chars` found for type `char`\
    \ in the current scope\n  --> /tmp/tmpwvexol57.rs:46:29\n   |\n46 |         new_char\
    \ = new_char.chars().next().unwrap();\n   |                             ^^^^^\
    \ method not found in `char`\n\nerror[E0599]: no method named `chars` found for\
    \ type `char` in the current scope\n  --> /tmp/tmpwvexol57.rs:47:70\n   |\n47\
    \ |         position = alphabet.iter().position(|&b| b.chars().any(|c| c.chars().any(|d|\
    \ d == new_char)));\n   |                                                    \
    \                  ^^^^^ method not found in `char`\n\nerror: aborting due to\
    \ 4 previous errors\n\nSome errors have detailed explanations: E0308, E0599.\n\
    For more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    \n    // Step\
    \ 1: Build an alphabet with each letter shifted by 2\n    let mut alphabet = String::new();\n\
    \    let mut nums = String::from(\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"\
    );\n    \n    // Add letters in the alphabet\n    let mut shift = 0;\n    for\
    \ c in s.chars() {\n        alphabet.push(*nums[c as u8] + shift);\n        shift\
    \ += 2;\n    }\n    \n    // Step 2: Rotate the alphabet to match the rotation\
    \ of the given string\n    alphabet = alphabet.chars()\n        .map(|c| alphabet[alphabet.find(c).unwrap()\
    \ + 1] as char).collect::<String>();\n    \n    // Step 3: Encrypt the string\
    \ with the rotated alphabet\n    for c in s.chars() {\n        result += alphabet[alphabet.find(c).unwrap()\
    \ + 1] as char;\n    }\n    \n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the type `String` cannot be indexed by `u8`\n  --> /tmp/tmpoogv11mp.rs:24:24\n\
    \   |\n24 |         alphabet.push(*nums[c as u8] + shift);\n   |             \
    \           ^^^^^^^^^^^^^ `String` cannot be indexed by `u8`\n   |\n   = help:\
    \ the trait `Index<u8>` is not implemented for `String`\n   = help: the following\
    \ other types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `usize`\n\
    \  --> /tmp/tmpoogv11mp.rs:30:18\n   |\n30 |         .map(|c| alphabet[alphabet.find(c).unwrap()\
    \ + 1] as char).collect::<String>();\n   |                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n   = help: the following other types implement\
    \ trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n    \
    \         <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpoogv11mp.rs:34:19\n\
    \   |\n34 |         result += alphabet[alphabet.find(c).unwrap() + 1] as char;\n\
    \   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected\
    \ `&str`, found `char`\n\nerror[E0277]: the type `String` cannot be indexed by\
    \ `usize`\n  --> /tmp/tmpoogv11mp.rs:34:19\n   |\n34 |         result += alphabet[alphabet.find(c).unwrap()\
    \ + 1] as char;\n   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ `String` cannot be indexed by `usize`\n   |\n   = help: the trait `Index<usize>`\
    \ is not implemented for `String`\n "
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt0(s)\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt0` in this scope\n  --> /tmp/tmpc7lpl2v7.rs:15:5\n\
    \   |\n15 |     encrypt0(s)\n   |     ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_str(s, alphabet::encrypt::<String>())\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `alphabet`\n\
    \  --> /tmp/tmpja_8e02y.rs:15:19\n   |\n15 |     rotate_str(s, alphabet::encrypt::<String>())\n\
    \   |                   ^^^^^^^^ use of undeclared crate or module `alphabet`\n\
    \nerror[E0425]: cannot find function `rotate_str` in this scope\n  --> /tmp/tmpja_8e02y.rs:15:5\n\
    \   |\n15 |     rotate_str(s, alphabet::encrypt::<String>())\n   |     ^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nSome\
    \ errors have detailed explanations: E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet_index = AlphabetIndex::new();\n  \
    \  let mut chars = s.chars();\n    alphabet_index.update_data(&chars);\n    alphabet_index.update_alphabet(&alphabet.chars());\n\
    \    let mut alphabet = Alphabet::new();\n    alphabet.update_data(&alphabet_index.alphabet);\n\
    \    alphabet.update_alphabet(&alphabet_index.alphabet);\n    let mut alphabet_indices\
    \ = AlphabetIndices::new();\n    alphabet_indices.update_data(&alphabet);\n  \
    \  alphabet_indices.update_alphabet(&alphabet.chars());\n    let mut alphabet_indices_array\
    \ = AlphabetIndicesArray::new();\n    alphabet_indices_array.update_data(&alphabet_indices);\n\
    \    alphabet_indices_array.update_alphabet(&alphabet.chars());\n    \n    let\
    \ mut result = String::new();\n    loop {\n        let mut current = String::new();\n\
    \        for (i, c) in chars.enumerate() {\n            if alphabet_indices.lookup(alphabet.lookup(c))\
    \ > 0 {\n                let mut new = alphabet.lookup(c);\n                new.swap(0,\
    \ alphabet_indices.lookup(alphabet.lookup(c)));\n                current.push(new);\n\
    \            } else {\n                current.push(c);\n            }\n     \
    \   }\n        if current.is_empty() {\n            break;\n        }\n      \
    \  result.push(current);\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `AlphabetIndex`\n\
    \  --> /tmp/tmpru5f5lkk.rs:15:30\n   |\n15 |     let mut alphabet_index = AlphabetIndex::new();\n\
    \   |                              ^^^^^^^^^^^^^ use of undeclared type `AlphabetIndex`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpru5f5lkk.rs:19:24\n\
    \   |\n19 |     let mut alphabet = Alphabet::new();\n   |                    \
    \    ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `AlphabetIndices`\n  --> /tmp/tmpru5f5lkk.rs:22:32\n\
    \   |\n22 |     let mut alphabet_indices = AlphabetIndices::new();\n   |     \
    \                           ^^^^^^^^^^^^^^^ use of undeclared type `AlphabetIndices`\n\
    \nerror[E0433]: failed to resolve: use of undeclared type `AlphabetIndicesArray`\n\
    \  --> /tmp/tmpru5f5lkk.rs:25:38\n   |\n25 |     let mut alphabet_indices_array\
    \ = AlphabetIndicesArray::new();\n   |                                      ^^^^^^^^^^^^^^^^^^^^\
    \ use of undeclared type `AlphabetIndicesArray`\n\nerror[E0425]: cannot find value\
    \ `alphabet` in this scope\n  --> /tmp/tmpru5f5lkk.rs:18:37\n   |\n18 |     alphabet_index.update_alphabet(&alphabet.chars());\n\
    \   |                                     ^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpru5f5lkk.rs:44:21\n   |\n44 |  \
    \       result.push(current);\n   |                     ^^^^^^^ expected `char`,\
    \ found struct `String`\n\nerror: aborting due to 6 previous errors\n\nSome errors\
    \ have detailed explanations: E0308, E0425, E0433.\nFor more information about\
    \ an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = s.clone();\n    for c in s.chars().skip(s.len()\
    \ / 2) {\n        result.rotate_left(2).append(c);\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmp9iw3j8d9.rs:17:16\n   |\n17 |         result.rotate_left(2).append(c);\n\
    \   |                ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = Alphabet::new();\n    let mut key\
    \ = Alphabet::new();\n    alphabet.rotate_right(2);\n    key.rotate_right(2);\n\
    \    alphabet.rotate_left(3);\n    key.rotate_left(3);\n    alphabet.rotate_right(2);\n\
    \    key.rotate_right(2);\n    alphabet.rotate_left(3);\n    key.rotate_left(3);\n\
    \    alphabet.rotate_right(2);\n    key.rotate_right(2);\n    alphabet.rotate_left(3);\n\
    \    key.rotate_left(3);\n    alphabet.rotate_right(2);\n    key.rotate_right(2);\n\
    \    alphabet.rotate_left(3);\n    key.rotate_left(3);\n    alphabet.rotate_right(2);\n\
    \    key.rotate_right(2);\n    alphabet.rotate_left(3);\n    key.rotate_left(3);\n\
    \    alphabet.rotate_right(2);\n    key.rotate_right(2);\n    alphabet.rotate_left(3);\n\
    \    key.rotate_left(3);\n    let mut s = String::from(s);\n    \n    for i in\
    \ 0..s.len() {\n        if alphabet.contains(&s[i..]) {\n            s.insert(i,\
    \ alphabet[alphabet.find(&s[i..])]);\n        }\n    }\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpxi12o8kc.rs:15:24\n   |\n15 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared type `Alphabet`\n  --> /tmp/tmpxi12o8kc.rs:16:19\n\
    \   |\n16 |     let mut key = Alphabet::new();\n   |                   ^^^^^^^^\
    \ use of undeclared type `Alphabet`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut res = String::new();\n\n    s.chars().for_each(|c|\
    \ {\n        let idx = c as u32 - 1;\n        res.push_str(&alphabet[idx % alphabet.len()]);\n\
    \    });\n\n    res\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpfsfxb20f.rs:19:23\n\
    \   |\n19 |         res.push_str(&alphabet[idx % alphabet.len()]);\n   |     \
    \                  ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `alphabet` in this scope\n  --> /tmp/tmpfsfxb20f.rs:19:38\n   |\n19 |\
    \         res.push_str(&alphabet[idx % alphabet.len()]);\n   |               \
    \                       ^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut idx =\
    \ 0;\n    while idx < s.len() {\n        if idx < s.len() - 2 {\n            result.push((s[(idx\
    \ * 2)..(idx * 2 + 2)].to_ascii_lowercase()\n                         + s[(idx\
    \ * 2 + 1)..idx].to_ascii_uppercase())\n                         .chars().nth(idx\
    \ % 26).unwrap());\n        } else {\n            result.push((s[(idx * 2)..(idx\
    \ * 2 + 1)].to_ascii_lowercase()\n                         + s[(idx * 2 + 2)..(idx\
    \ * 2 + 3)].to_ascii_uppercase())\n                         .chars().nth(idx %\
    \ 26).unwrap());\n        }\n        idx += 1;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpajl_ecbe.rs:20:28\n   |\n\
    20 |                          + s[(idx * 2 + 1)..idx].to_ascii_uppercase())\n\
    \   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n\
    \   |                            |\n   |                            expected `&str`,\
    \ found struct `String`\n   |                            help: consider borrowing\
    \ here: `&s[(idx * 2 + 1)..idx].to_ascii_uppercase()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpajl_ecbe.rs:24:28\n   |\n24 |                         \
    \ + s[(idx * 2 + 2)..(idx * 2 + 3)].to_ascii_uppercase())\n   |              \
    \              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n   |    \
    \                        |\n   |                            expected `&str`, found\
    \ struct `String`\n   |                            help: consider borrowing here:\
    \ `&s[(idx * 2 + 2)..(idx * 2 + 3)].to_ascii_uppercase()`\n\nerror: aborting due\
    \ to 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 101
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    String::from(\"kj\")\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: Exception
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"kj\"`,\n right: `\"lm\"`', /tmp/tmpeuv0996i.rs:20:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = alphabet_rotated_two.clone();\n\
    \    alphabet.extend_from_slice(alphabet.as_bytes());\n    let mut ciphertext\
    \ = s.as_bytes().to_owned();\n    for i in 0..ciphertext.len() {\n        ciphertext[i]\
    \ = alphabet[alphabet[i] - 2];\n    }\n    String::from_utf8(ciphertext)\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet_rotated_two` in this scope\n\
    \  --> /tmp/tmpq3yhlk_r.rs:15:24\n   |\n15 |     let mut alphabet = alphabet_rotated_two.clone();\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0308]: mismatched types\n  --> /tmp/tmpq3yhlk_r.rs:21:5\n   |\n14 | fn\
    \ encrypt(s: String) -> String {\n   |                          ------ expected\
    \ `String` because of return type\n...\n21 |     String::from_utf8(ciphertext)\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found enum `Result`\n\
    \   |\n   = note: expected struct `String`\n                found enum `Result<String,\
    \ FromUtf8Error>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate(s, 2)\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate` in this scope\n  --> /tmp/tmpextehacu.rs:15:5\n\
    \   |\n15 |     rotate(s, 2)\n   |     ^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    s.chars().for_each(|c|\
    \ {\n        let n = c.to_ascii_lowercase().unwrap();\n        result.push((n\
    \ % 26).to_string());\n    });\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `unwrap` found for type `char` in the current\
    \ scope\n  --> /tmp/tmp5qbg3d4x.rs:17:40\n   |\n17 |         let n = c.to_ascii_lowercase().unwrap();\n\
    \   |                                        ^^^^^^ method not found in `char`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt1(s, ROTATE_ALPHABET_TWO)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt1` in this scope\n  --> /tmp/tmps518687u.rs:15:5\n\
    \   |\n15 |     encrypt1(s, ROTATE_ALPHABET_TWO)\n   |     ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find value `ROTATE_ALPHABET_TWO` in this\
    \ scope\n  --> /tmp/tmps518687u.rs:15:17\n   |\n15 |     encrypt1(s, ROTATE_ALPHABET_TWO)\n\
    \   |                 ^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet_count = s.len();\n    let mut alphabet:\
    \ Vec<char> = vec!['A'..'Z', 'a'..'z'];\n\n    let mut shift = alphabet.len();\n\
    \    let mut rotated = vec![0;alphabet_count];\n    for (index, &a) in alphabet.iter().enumerate()\
    \ {\n        // Shift down a letter\n        rotated.insert(index - shift, a);\n\
    \        // Shift down 2 letters to their new position\n        shift = (index\
    \ - shift)%alphabet_count;\n    }\n\n    String::from_utf8(s.bytes().clone())\n\
    \        .into_iter()\n        .map(|&c| rotated.iter().map(|&d| {\n         \
    \   c + d.to_ascii_lowercase()\n        }).collect::<Vec<_>>())\n        .collect::<Vec<_>>()\n\
    \        .as_owned()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpezt310k9.rs:16:40\n   |\n\
    16 |     let mut alphabet: Vec<char> = vec!['A'..'Z', 'a'..'z'];\n   |       \
    \                                 ^^^^^^^^ expected `char`, found struct `std::ops::Range`\n\
    \   |\n   = note: expected type `char`\n            found struct `std::ops::Range<char>`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpezt310k9.rs:22:39\n   |\n22 |\
    \         rotated.insert(index - shift, a);\n   |                            \
    \           ^ expected integer, found `char`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpezt310k9.rs:27:23\n   |\n27 |     String::from_utf8(s.bytes().clone())\n\
    \   |                       ^^^^^^^^^^^^^^^^^ expected struct `Vec`, found struct\
    \ `std::str::Bytes`\n   |\n   = note: expected struct `Vec<u8>`\n            \
    \  found struct `std::str::Bytes<'_>`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmpezt310k9.rs:29:15\n   |\n29 |         .map(|&c| rotated.iter().map(|&d|\
    \ {\n   |               ^--\n   |               ||\n   |               |expected\
    \ due to this\n   |               expected struct `String`, found reference\n\
    \   |               help: did you mean `c`: `&String`\n   |\n   = note: expected\
    \ struct `String`\n           found reference `&_`\n\nerror[E0689]: can't call\
    \ method `to_ascii_lowercase` on ambiguous numeric type `{integer}`\n  --> /tmp/tmpezt310k9.rs:30:19\n\
    \   |\n29 |         .map(|&c| rotated.iter().map(|&d| {\n   |                \
    \                        - you must specify a type for this binding, like `i32`\n\
    30 |             c + d.to_ascii_lowercase()\n   |                   ^^^^^^^^^^^^^^^^^^\n\
    \nerror[E0599]: no method named `as_owned` found for struct `Vec<Vec<_>>` in the\
    \ current scope\n  --> /tmp/tmpezt310k9.rs:33:10\n   |\n33 |         .as_owned()\n\
    \   |          ^^^^^^^^ method not found in `Vec<Vec<_>>`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0308, E0599,\
    \ E0689.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().enumerate().map(|(_, c)| {\n        ((c as\
    \ u32 - 2) as u8)*2 + 2\n    }).fold(0, |acc, x| acc + x)\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp73g02u7m.rs:17:13\n   |\n\
    17 |     }).fold(0, |acc, x| acc + x)\n   |             ^- help: try using a conversion\
    \ method: `.to_string()`\n   |             |\n   |             expected struct\
    \ `String`, found integer\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp73g02u7m.rs:17:31\n\
    \   |\n17 |     }).fold(0, |acc, x| acc + x)\n   |                           \
    \    ^ expected `&str`, found `u8`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_left(s, ALPHABET.len() as usize, ALPHABET.clone()[ALPHABET.len()\
    \ - 1] as usize)\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_left` in this scope\n  --> /tmp/tmps456jq5y.rs:15:5\n\
    \   |\n15 |     rotate_left(s, ALPHABET.len() as usize, ALPHABET.clone()[ALPHABET.len()\
    \ - 1] as usize)\n   |     ^^^^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::intrinsics::rotate_left;\n   |\n\
    \nerror[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmps456jq5y.rs:15:20\n\
    \   |\n15 |     rotate_left(s, ALPHABET.len() as usize, ALPHABET.clone()[ALPHABET.len()\
    \ - 1] as usize)\n   |                    ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find value `ALPHABET` in this scope\n  --> /tmp/tmps456jq5y.rs:15:45\n\
    \   |\n15 |     rotate_left(s, ALPHABET.len() as usize, ALPHABET.clone()[ALPHABET.len()\
    \ - 1] as usize)\n   |                                             ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find value `ALPHABET` in this scope\n\
    \  --> /tmp/tmps456jq5y.rs:15:62\n   |\n15 |     rotate_left(s, ALPHABET.len()\
    \ as usize, ALPHABET.clone()[ALPHABET.len() - 1] as usize)\n   |             \
    \                                                 ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    ROTATE_ALPHABET[s.len() % ROTATE_ALPHABET.len()](s)\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `ROTATE_ALPHABET` in this scope\n  -->\
    \ /tmp/tmp4awb9563.rs:15:5\n   |\n15 |     ROTATE_ALPHABET[s.len() % ROTATE_ALPHABET.len()](s)\n\
    \   |     ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ value `ROTATE_ALPHABET` in this scope\n  --> /tmp/tmp4awb9563.rs:15:31\n   |\n\
    15 |     ROTATE_ALPHABET[s.len() % ROTATE_ALPHABET.len()](s)\n   |           \
    \                    ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().filter_map(|c| c.to_ascii_lowercase().chars().take(2).collect()).collect::<String>().to_owned()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpqdmcjrz0.rs:15:53\n   |\n15 |     s.chars().filter_map(|c|\
    \ c.to_ascii_lowercase().chars().take(2).collect()).collect::<String>().to_owned()\n\
    \   |                                                     ^^^^^ method not found\
    \ in `char`\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n    let mut i = 0;\n\
    \    while i < s.len() {\n        let c = s.chars().nth(i).unwrap();\n       \
    \ let k = c - 'a' + 1;\n        let k = k * k;\n        if k < 26 {\n        \
    \    result.push((c + k + 'a').chars().nth(i).unwrap());\n        }\n        i\
    \ += 1;\n    }\n    result\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `char` from `char`\n  --> /tmp/tmpi3og7913.rs:19:19\n\
    \   |\n19 |         let k = c - 'a' + 1;\n   |                 - ^ --- char\n\
    \   |                 |\n   |                 char\n\nerror[E0369]: cannot add\
    \ `_` to `char`\n  --> /tmp/tmpi3og7913.rs:22:28\n   |\n22 |             result.push((c\
    \ + k + 'a').chars().nth(i).unwrap());\n   |                          - ^ - _\n\
    \   |                          |\n   |                          char\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    if s.len() % 2 == 1 {\n        encry(s.into_boxed_str())\n\
    \    } else {\n        encry(s)\n    }\n}\n\nfn main() {\n    let candidate =\
    \ encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"\
    ));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"ewhjklnop\"\
    ));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"kj\"));\n\
    \    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"\
    faewfawefaewg\")), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encry` in this scope\n  --> /tmp/tmph76w6kdm.rs:16:9\n\
    \   |\n16 |         encry(s.into_boxed_str())\n   |         ^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `encry` in this scope\n  -->\
    \ /tmp/tmph76w6kdm.rs:18:9\n   |\n18 |         encry(s)\n   |         ^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = String::from(\"\");\n    for x in\
    \ s.chars() {\n        let a = x % alphabet_size;\n        let b = x - a;\n  \
    \      let c = alphabet[a].to_ascii_lowercase();\n        cipher = cipher.append(c);\n\
    \        cipher = cipher.append(&alphabet[b].to_ascii_lowercase());\n    }\n \
    \   cipher\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet_size` in this scope\n  --> /tmp/tmpr6b45w8l.rs:17:21\n\
    \   |\n17 |         let a = x % alphabet_size;\n   |                     ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find value `alphabet` in this\
    \ scope\n  --> /tmp/tmpr6b45w8l.rs:19:17\n   |\n19 |         let c = alphabet[a].to_ascii_lowercase();\n\
    \   |                 ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find value `alphabet` in this scope\n  --> /tmp/tmpr6b45w8l.rs:21:33\n   |\n\
    21 |         cipher = cipher.append(&alphabet[b].to_ascii_lowercase());\n   |\
    \                                 ^^^^^^^^ not found in this scope\n\nerror[E0369]:\
    \ cannot subtract `_` from `char`\n  --> /tmp/tmpr6b45w8l.rs:18:19\n   |\n18 |\
    \         let b = x - a;\n   |                 - ^ - _\n   |                 |\n\
    \   |                 char\n\nerror[E0599]: no method named `append` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmpr6b45w8l.rs:20:25\n   |\n\
    20 |         cipher = cipher.append(c);\n   |                         ^^^^^^ method\
    \ not found in `String`\n\nerror[E0599]: no method named `append` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmpr6b45w8l.rs:21:25\n   |\n21 | \
    \        cipher = cipher.append(&alphabet[b].to_ascii_lowercase());\n   |    \
    \                     ^^^^^^ method not found in `String`\n\nerror: aborting due\
    \ to 6 previous errors\n\nSome errors have detailed explanations: E0369, E0425,\
    \ E0599.\nFor more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result = String::new();\n\n    for c in s.chars().cloned()\
    \ {\n        let new_c = c.to_ascii_uppercase();\n        result.push((new_c.len()\
    \ - 1) * (new_c.len() + 2) / 2 + new_c.chars().last());\n    }\n\n    result\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpyytbeeu9.rs:17:24\n     |\n17   |     for c in s.chars().cloned()\
    \ {\n     |                        ^^^^^^ expected reference, found `char`\n \
    \    |\n     = note: expected reference `&_`\n                     found type\
    \ `char`\nnote: required by a bound in `cloned`\n\nerror[E0271]: type mismatch\
    \ resolving `<Chars<'_> as Iterator>::Item == &_`\n  --> /tmp/tmpyytbeeu9.rs:17:14\n\
    \   |\n17 |     for c in s.chars().cloned() {\n   |              ^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found reference\n   |\n   = note:   expected type `char`\n\
    \           found reference `&_`\n   = note: required because of the requirements\
    \ on the impl of `Iterator` for `Cloned<Chars<'_>>`\n   = note: required because\
    \ of the requirements on the impl of `IntoIterator` for `Cloned<Chars<'_>>`\n\n\
    error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item == &_`\n\
    \  --> /tmp/tmpyytbeeu9.rs:17:14\n   |\n17 |     for c in s.chars().cloned() {\n\
    \   |              ^^^^^^^^^^^^^^^^^^ expected `char`, found reference\n   |\n\
    \   = note:   expected type `char`\n           found reference `&_`\n   = note:\
    \ required because of the requirements on the impl of `Iterator` for `Cloned<Chars<'_>>`\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    rotate_chars(s, 2);\n    s\n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_chars` in this scope\n  -->\
    \ /tmp/tmpst28lcun.rs:15:5\n   |\n15 |     rotate_chars(s, 2);\n   |     ^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    if s.len() < 2 {\n        String::from(\"\")\n    }\
    \ else {\n        rotate_letter(s.chars().next().unwrap(), s.len() - 2)\n    }\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_letter` in this scope\n  -->\
    \ /tmp/tmp98kslph2.rs:18:9\n   |\n18 |         rotate_letter(s.chars().next().unwrap(),\
    \ s.len() - 2)\n   |         ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = vec![b'a', b'b', b'c', b'd', b'e',\
    \ b'f', b'g', b'h', b'i', b'j', b'k', b'l', b'm', b'n', b'o', b'p', b'q', b'r',\
    \ b's', b't', b'u', b'v', b'w', b'x', b'y', b'z'];\n    for &c in s.chars() {\n\
    \        alphabet.push(b + alphabet.shift());\n    }\n    String::from_utf8(alphabet).to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `b` in this scope\n  --> /tmp/tmp0tecqnc2.rs:17:23\n\
    \   |\n17 |         alphabet.push(b + alphabet.shift());\n   |               \
    \        ^ help: a local variable with a similar name exists: `c`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp0tecqnc2.rs:16:9\n   |\n16 |     for &c in s.chars()\
    \ {\n   |         ^^    --------- this expression has type `Option<char>`\n  \
    \ |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror[E0599]: no method named\
    \ `shift` found for struct `Vec<u8>` in the current scope\n  --> /tmp/tmp0tecqnc2.rs:17:36\n\
    \   |\n17 |         alphabet.push(b + alphabet.shift());\n   |               \
    \                     ^^^^^ method not found in `Vec<u8>`\n\nerror[E0599]: `Result<String,\
    \ FromUtf8Error>` doesn't implement `std::fmt::Display`\n   --> /tmp/tmp0tecqnc2.rs:19:33\n\
    \    |\n19  |       String::from_utf8(alphabet).to_string()\n    |           \
    \                        ^^^^^^^^^ `Result<String, FromUtf8Error>` cannot be formatted\
    \ with the default formatter\n    |\n    = note: the following trait bounds were\
    \ not satisfied:\n            `Result<String, FromUtf8Error>: std::fmt::Display`\n\
    \            which is required by `Result<String, FromUtf8Error>: ToString`\n\n\
    error: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0425, E0599.\nFor more information about an error, try `rustc --explain\
    \ E0308`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet_len = s.len() - 1;\n    let mut alphabet\
    \ = [0u8; 26];\n    alphabet.copy_from_slice(&ALPHABET[alphabet_len]); // zero\
    \ the letters before rotating\n    alphabet.copy_from_slice(&ALPHABET[alphabet_len\
    \ - 2]); // double the letters before rotating\n    alphabet.swap_with_original(alphabet_len);\n\
    \    \n    let mut enc = s.clone();\n    let mut offset = 0;\n    let mut char_offset\
    \ = 0;\n    while char_offset < enc.len() {\n        let char = enc.get_character(char_offset);\n\
    \        \n        let char_offset = enc.char_indices()\n            .filter_map(|(_,\
    \ i)| i.0 as usize)\n            .next() + char_offset;\n        \n        alphabet.swap_with_original(char_offset);\n\
    \        \n        // shift the characters down in alphabet by two so that every\
    \ two letters shift down by two places in alphabet (by two multiplied by two)\n\
    \        \n        // if the current character is smaller than or equal to the\
    \ letter at position 26\n        // move it to the left\n        if alphabet.iter().position(|&_|\
    \ *_ + char as u8) == 26 {\n            alphabet.iter_mut().enumerate().for_each(|(i,\
    \ &c)| {\n                *i as usize += 2 if c as usize == alphabet_len;\n  \
    \          })\n        }\n        \n        // if the current character is greater\
    \ than the letter at position 26\n        // move it to the right\n        \n\
    \        // otherwise, just add the current character to the offset\n        else\
    \ {\n            offset += char as usize;\n        }\n    }\n    \n    enc.set_characters_at_offsets(offset,\
    \ enc.char_indices());\n    enc.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found keyword\
    \ `if`\n  --> /tmp/tmp8k9jejfs.rs:39:34\n   |\n39 |                 *i as usize\
    \ += 2 if c as usize == alphabet_len;\n   |                                  ^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror[E0425]: cannot find\
    \ value `ALPHABET` in this scope\n  --> /tmp/tmp8k9jejfs.rs:17:31\n   |\n17 |\
    \     alphabet.copy_from_slice(&ALPHABET[alphabet_len]); // zero the letters before\
    \ rotating\n   |                               ^^^^^^^^ help: a local variable\
    \ with a similar name exists: `alphabet`\n\nerror[E0425]: cannot find value `ALPHABET`\
    \ in this scope\n  --> /tmp/tmp8k9jejfs.rs:18:31\n   |\n18 |     alphabet.copy_from_slice(&ALPHABET[alphabet_len\
    \ - 2]); // double the letters before rotating\n   |                         \
    \      ^^^^^^^^ help: a local variable with a similar name exists: `alphabet`\n\
    \nerror: in expressions, `_` can only be used on the left-hand side of an assignment\n\
    \  --> /tmp/tmp8k9jejfs.rs:37:43\n   |\n37 |         if alphabet.iter().position(|&_|\
    \ *_ + char as u8) == 26 {\n   |                                           ^ `_`\
    \ not allowed here\n\nerror[E0599]: no method named `swap_with_original` found\
    \ for array `[u8; 26]` in the current scope\n  --> /tmp/tmp8k9jejfs.rs:19:14\n\
    \   |\n19 |     alphabet.swap_with_original(alphabet_len);\n   |             \
    \ ^^^^^^^^^^^^^^^^^^ help: there is an associated function with a similar name:\
    \ `swap_with_slice`\n\nerror[E0599]: no method named `get_character` found for\
    \ struct `String` in the current scope\n  --> /tmp/tmp8k9jejfs.rs:25:24\n   |\n\
    25 |         let char = enc.get_character(char_offset);\n   |                \
    \        ^^^^^^^^^^^^^ method not found in `String`\n\nerror[E0610]: `char` is\
    \ a primitive type and therefore doesn't have fields\n  --> /tmp/tmp8k9jejfs.rs:28:36\n\
    \   |\n28 |             .filter_map(|(_, i)| i.0 as usize)\n   |             \
    \                       ^\n\nerror[E0369]: cannot add `usize` to `Option<_>`\n\
    \  --> /tmp/tmp8k9jejfs.rs:29:21\n   |\n27 |           let char_offset = enc.char_indices()\n\
    \   |"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut n = s.len() as u32;\n    \n    for i in 1..n\
    \ {\n        s[i] = s[i - 1];\n        s[i - 1] = s[i + n - 1];\n        s[i +\
    \ n - 1] = s[i];\n    }\n    \n    String(s)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0423]: expected function, tuple struct or tuple variant, found struct\
    \ `String`\n   --> /tmp/tmpr_jml9x8.rs:23:5\n    |\n23  |       String(s)\n  \
    \  |       ^^^^^^^^^ help: use struct literal syntax instead: `String { vec: val\
    \ }`\n\nerror[E0277]: the type `String` cannot be indexed by `u32`\n  --> /tmp/tmpr_jml9x8.rs:18:9\n\
    \   |\n18 |         s[i] = s[i - 1];\n   |         ^^^^ `String` cannot be indexed\
    \ by `u32`\n   |\n   = help: the trait `Index<u32>` is not implemented for `String`\n\
    \   = help: the following other types implement trait `Index<Idx>`:\n        \
    \     <String as Index<RangeFrom<usize>>>\n             <String as Index<RangeFull>>\n\
    \             <String as Index<RangeInclusive<usize>>>\n             <String as\
    \ Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `u32`\n  -->\
    \ /tmp/tmpr_jml9x8.rs:18:16\n   |\n18 |         s[i] = s[i - 1];\n   |       \
    \         ^^^^^^^^ `String` cannot be indexed by `u32`\n   |\n   = help: the trait\
    \ `Index<u32>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as Index<RangeTo<usize>>>\n             <String as Index<RangeToInclusive<usize>>>\n\
    \             <String as Index<std::ops::Range<usize>>>\n             <str as\
    \ Index<I>>\n\nerror[E0277]: the type `String` cannot be indexed by `u32`\n  -->\
    \ /tmp/tmpr_jml9x8.rs:19:9\n   |\n19 |         s[i - 1] = s[i + n - 1];\n   |\
    \         ^^^^^^^^ `String` cannot be indexed by `u32`\n   |\n   = help: the trait\
    \ `Index<u32>` is not implemented for `String`\n   = help: the following other\
    \ types implement trait `Index<Idx>`:\n             <String as Index<RangeFrom<usize>>>\n\
    \             <String as Index<RangeFull>>\n             <String as Index<RangeInclusive<usize>>>\n\
    \             <String as In"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt_with_alphabet(s.chars(), ROTATE_UP)\n}\n\n\
    fn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt_with_alphabet` in this scope\n\
    \  --> /tmp/tmpb5dtq_8w.rs:15:5\n   |\n15 |     encrypt_with_alphabet(s.chars(),\
    \ ROTATE_UP)\n   |     ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `ROTATE_UP` in this scope\n  --> /tmp/tmpb5dtq_8w.rs:15:38\n\
    \   |\n15 |     encrypt_with_alphabet(s.chars(), ROTATE_UP)\n   |            \
    \                          ^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [1, 2, 3, 4, 5];\n\n    alphabet.reverse();\n\
    \n    let mut new_alphabet = [0, 1, 2, 3, 4];\n\n    for letter in alphabet {\n\
    \        new_alphabet = new_alphabet.push(letter);\n    }\n\n    let mut new_s\
    \ = String::new();\n    new_s.reserve(s.len());\n\n    for letter in s.chars()\
    \ {\n        new_s.push_str(&new_alphabet[new_alphabet.index(letter) + 2]);\n\
    \    }\n\n    new_s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `push` found for array `[{integer}; 5]` in\
    \ the current scope\n  --> /tmp/tmpr6m_2vis.rs:22:37\n   |\n22 |         new_alphabet\
    \ = new_alphabet.push(letter);\n   |                                     ^^^^\
    \ method not found in `[{integer}; 5]`\n\nerror[E0599]: no method named `index`\
    \ found for array `[{integer}; 5]` in the current scope\n  --> /tmp/tmpr6m_2vis.rs:29:51\n\
    \   |\n29 |         new_s.push_str(&new_alphabet[new_alphabet.index(letter) +\
    \ 2]);\n   |                                                   ^^^^^ method not\
    \ found in `[{integer}; 5]`\n   |\n   = help: items from traits can only be used\
    \ if the trait is in scope\nhelp: the following trait is implemented but not in\
    \ scope; perhaps add a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\n\
    error: aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut cipher = s.chars().collect::<Vec<_>>();\n \
    \   cipher.rotate_left(2);\n    cipher.push(0);\n    cipher.extend_from_slice(&[0x07,\
    \ 0x06, 0x04, 0x03, 0x02]);\n    cipher.rotate_left(8);\n    cipher.extend_from_slice(&[0x08,\
    \ 0x05, 0x01, 0x02, 0x03]);\n    cipher.rotate_left(5);\n    cipher.extend_from_slice(&[0x09,\
    \ 0x04, 0x01, 0x02, 0x03]);\n    cipher.rotate_left(7);\n    cipher.extend_from_slice(&[0x04,\
    \ 0x01, 0x02, 0x03]);\n    cipher.rotate_left(4);\n    cipher.extend_from_slice(&[0x03,\
    \ 0x02, 0x01]);\n    cipher.rotate_left(3);\n    cipher.extend_from_slice(&[0x02,\
    \ 0x01]);\n    cipher.rotate_left(2);\n    cipher.extend_from_slice(&[0x01]);\n\
    \    cipher.rotate_left(1);\n    cipher.extend_from_slice(&[]);\n    cipher.into()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpatsbe1nj.rs:17:17\n   |\n\
    17 |     cipher.push(0);\n   |                 ^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpatsbe1nj.rs:18:32\n   |\n18 |\
    \     cipher.extend_from_slice(&[0x07, 0x06, 0x04, 0x03, 0x02]);\n   |       \
    \                         ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpatsbe1nj.rs:20:32\n   |\n20 |     cipher.extend_from_slice(&[0x08,\
    \ 0x05, 0x01, 0x02, 0x03]);\n   |                                ^^^^ expected\
    \ `char`, found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpatsbe1nj.rs:22:32\n\
    \   |\n22 |     cipher.extend_from_slice(&[0x09, 0x04, 0x01, 0x02, 0x03]);\n \
    \  |                                ^^^^ expected `char`, found `u8`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpatsbe1nj.rs:24:32\n   |\n24 |     cipher.extend_from_slice(&[0x04,\
    \ 0x01, 0x02, 0x03]);\n   |                                ^^^^ expected `char`,\
    \ found `u8`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpatsbe1nj.rs:26:32\n\
    \   |\n26 |     cipher.extend_from_slice(&[0x03, 0x02, 0x01]);\n   |         \
    \                       ^^^^ expected `char`, found `u8`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmpatsbe1nj.rs:28:32\n   |\n28 |     cipher.extend_from_slice(&[0x02,\
    \ 0x01]);\n   |                                ^^^^ expected `char`, found `u8`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpatsbe1nj.rs:30:32\n   |\n30 |\
    \     cipher.extend_from_slice(&[0x01]);\n   |                               \
    \ ^^^^ expected `char`, found `u8`\n\nerror[E0277]: the trait bound `String: From<Vec<char>>`\
    \ is not satisfied\n  --> /tmp/tmpatsbe1nj.rs:33:12\n   |\n33 |     cipher.into()\n\
    \   |            ^^^^ the trait `From<Vec<char>>` is not implemented for `String`\n\
    \   |\n   = help: the following other types implement trait `From<T>`:\n     \
    \        <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \   "
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut c = s.chars();\n    c.rotate(2);\n    let mut\
    \ s = String::new();\n    for c in c {\n        let x = c as u32;\n        let\
    \ y = c as u32;\n        s.push((chr(x) + chr(y)).to_string());\n    }\n    s\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `chr` in this scope\n  --> /tmp/tmp1yob5u2k.rs:21:17\n\
    \   |\n21 |         s.push((chr(x) + chr(y)).to_string());\n   |             \
    \    ^^^ not found in this scope\n\nerror[E0425]: cannot find function `chr` in\
    \ this scope\n  --> /tmp/tmp1yob5u2k.rs:21:26\n   |\n21 |         s.push((chr(x)\
    \ + chr(y)).to_string());\n   |                          ^^^ not found in this\
    \ scope\n\nerror[E0599]: no method named `rotate` found for struct `Chars` in\
    \ the current scope\n  --> /tmp/tmp1yob5u2k.rs:16:7\n   |\n16 |     c.rotate(2);\n\
    \   |       ^^^^^^ method not found in `Chars<'_>`\n\nerror: aborting due to 3\
    \ previous errors\n\nSome errors have detailed explanations: E0425, E0599.\nFor\
    \ more information about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet_to_shift = s.chars().skip(1).take(s.size());\n\
    \    alphabet_to_shift.next().unwrap();\n    let mut alphabet = alphabet_to_shift.collect::<Vec<_>>();\n\
    \n    // Shift each character one place to the left.\n    for index in alphabet.iter_mut()\
    \ {\n        *index -= 1;\n        *index -= 1;\n    }\n\n    let mut alphabet\
    \ = alphabet.clone();\n    alphabet.extend(alphabet.iter().rev().collect::<Vec<_>>());\n\
    \n    let mut alphabet = alphabet.clone();\n\n    // Rotate each character two\
    \ places to the right.\n    for index in alphabet.iter_mut() {\n        *index\
    \ += 1;\n        *index += 1;\n    }\n\n    let mut alphabet = alphabet.clone();\n\
    \n    // Shift each character one place to the left.\n    for index in alphabet.iter_mut()\
    \ {\n        *index -= 1;\n        *index -= 1;\n    }\n\n    let mut alphabet\
    \ = alphabet.clone();\n    alphabet.extend(alphabet.iter().rev().collect::<Vec<_>>());\n\
    \n    let mut alphabet = alphabet.clone();\n\n    // Rotate each character two\
    \ places to the right.\n    for index in alphabet.iter_mut() {\n        *index\
    \ += 1;\n        *index += 1;\n    }\n\n    let mut alphabet = alphabet.clone();\n\
    \n    // Shift each character one place to the left.\n    for index in alphabet.iter_mut()\
    \ {\n        *index -= 1;\n        *index -= 1;\n    }\n\n    let mut alphabet\
    \ = alphabet.clone();\n    alphabet.extend(alphabet.iter().rev().collect::<Vec<_>>());\n\
    \n    let mut alphabet = alphabet.clone();\n\n    // Rotate each character two\
    \ places to the right.\n    for index in alphabet.iter_mut() {\n        *index\
    \ += 1;\n        *index += 1;\n    }\n\n    let mut alphabet = alphabet.clone();\n\
    \n    // Shift each character one place to the left.\n    for index in alphabet.iter_mut()\
    \ {\n        *index -= 1;\n        *index -= 1;\n    }\n\n    let mut alphabet\
    \ = alphabet.clone();\n    alphabet.extend(alphabet.iter().rev().collect::<Vec<_>>());\n\
    \n    let mut alphabet = alphabet.clone();\n\n    // Rotate each character two\
    \ places to the right.\n    for index in alphabet.iter_mut() {\n        *index\
    \ += 1;\n        *index += 1;\n    }\n\n    let mut alphabet = alphabet.clone();\n\
    \n    // Shift each character one place to the left.\n    for index in alphabet.iter_mut()\
    \ {\n        *index -= 1;\n        *index -= 1;\n    }\n\n    let mut alphabet\
    \ = alphabet.\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: unexpected token: `}`\n   --> /tmp/tmpyn4ao18w.rs:102:1\n    |\n\
    102 | }\n    | ^\n\nerror: expected `;`, found `}`\n   --> /tmp/tmpyn4ao18w.rs:101:33\n\
    \    |\n101 |     let mut alphabet = alphabet.\n    |                        \
    \         ^ help: add `;` here\n102 | }\n    | - unexpected token\n\nerror[E0599]:\
    \ no method named `size` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpyn4ao18w.rs:15:58\n   |\n15 |     let mut alphabet_to_shift = s.chars().skip(1).take(s.size());\n\
    \   |                                                          ^^^^ method not\
    \ found in `String`\n\nerror[E0368]: binary assignment operation `-=` cannot be\
    \ applied to type `char`\n  --> /tmp/tmpyn4ao18w.rs:21:9\n   |\n21 |         *index\
    \ -= 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `-=`\
    \ on type `char`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:22:9\n   |\n22 |         *index -=\
    \ 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `-=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:32:9\n   |\n32 |         *index +=\
    \ 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:33:9\n   |\n33 |         *index +=\
    \ 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `+=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:40:9\n   |\n40 |         *index -=\
    \ 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `-=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `-=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:41:9\n   |\n41 |         *index -=\
    \ 1;\n   |         ------^^^^^\n   |         |\n   |         cannot use `-=` on\
    \ type `char`\n\nerror[E0368]: binary assignment operation `+=` cannot be applied\
    \ to type `char`\n  --> /tmp/tmpyn4ao18w.rs:51:"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.chars().map(|c| rotate_key(c - 97)).collect()\n}\n\
    \nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `rotate_key` in this scope\n  --> /tmp/tmpi2b0ferx.rs:15:23\n\
    \   |\n15 |     s.chars().map(|c| rotate_key(c - 97)).collect()\n   |        \
    \               ^^^^^^^^^^ not found in this scope\n\nerror[E0369]: cannot subtract\
    \ `{integer}` from `char`\n  --> /tmp/tmpi2b0ferx.rs:15:36\n   |\n15 |     s.chars().map(|c|\
    \ rotate_key(c - 97)).collect()\n   |                                  - ^ --\
    \ {integer}\n   |                                  |\n   |                   \
    \               char\n\nerror: aborting due to 2 previous errors\n\nSome errors\
    \ have detailed explanations: E0369, E0425.\nFor more information about an error,\
    \ try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut r = s.clone();\n    for c in r.chars() {\n\
    \        let mut v = c - 0x61;\n        v = (v + v + v) * 0xA + v;\n        *c\
    \ = (v + v + v + v) * 0xA + v;\n    }\n    r\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot subtract `{integer}` from `char`\n  --> /tmp/tmpox0zjxbs.rs:17:23\n\
    \   |\n17 |         let mut v = c - 0x61;\n   |                     - ^ ---- {integer}\n\
    \   |                     |\n   |                     char\n\nerror[E0614]: type\
    \ `char` cannot be dereferenced\n  --> /tmp/tmpox0zjxbs.rs:19:9\n   |\n19 |  \
    \       *c = (v + v + v + v) * 0xA + v;\n   |         ^^\n\nerror: aborting due\
    \ to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0614.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  stdout: ''
  timestamp: 1659976150
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = s.chars().cloned().collect::<Vec<char>>();\n\
    \    alphabet.sort_by_key(|&a| a.cmp(&'z'));\n    alphabet.iter_mut().for_each(|&x|\
    \ x = x.rotate_right(2).unwrap());\n    alphabet.iter().cloned().collect::<Vec<_>>().join(\"\
    _\").into()\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0271]: type mismatch resolving `<Chars<'_> as Iterator>::Item ==\
    \ &_`\n    --> /tmp/tmpzi75v7bs.rs:15:34\n     |\n15   |     let mut alphabet\
    \ = s.chars().cloned().collect::<Vec<char>>();\n     |                       \
    \           ^^^^^^ expected reference, found `char`\n     |\n     = note: expected\
    \ reference `&_`\n                     found type `char`\nnote: required by a\
    \ bound in `cloned`\n\nerror[E0599]: the method `collect` exists for struct `Cloned<Chars<'_>>`,\
    \ but its trait bounds were not satisfied\n  --> /tmp/tmpzi75v7bs.rs:15:43\n \
    \  |\n15 |       let mut alphabet = s.chars().cloned().collect::<Vec<char>>();\n\
    \   |                                             ^^^^^^^ method cannot be called\
    \ on `Cloned<Chars<'_>>` due to unsatisfied trait bounds\n   |\n   = note: the\
    \ following trait bounds were not satisfied:\n           `<Chars<'_> as Iterator>::Item\
    \ = &_`\n           which is required by `Cloned<Chars<'_>>: Iterator`\n     \
    \      `Cloned<Chars<'_>>: Iterator`\n           which is required by `&mut Cloned<Chars<'_>>:\
    \ Iterator`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0271, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0271`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.iter().map(|c| \n        (match c {\n           \
    \ 'a' .. 'z' => ('z' - 2 * 'a'),\n            'A' .. 'Z' => ('a' - 2 * 'A'),\n\
    \            _ => c,\n        }).to_string()\n    ).collect()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0658]: exclusive range pattern syntax is experimental\n  --> /tmp/tmp_jaaj356.rs:17:13\n\
    \   |\n17 |             'a' .. 'z' => ('z' - 2 * 'a'),\n   |             ^^^^^^^^^^\n\
    \   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0658]: exclusive range pattern syntax is experimental\n\
    \  --> /tmp/tmp_jaaj356.rs:18:13\n   |\n18 |             'A' .. 'Z' => ('a' -\
    \ 2 * 'A'),\n   |             ^^^^^^^^^^\n   |\n   = note: see issue #37854 <https://github.com/rust-lang/rust/issues/37854>\
    \ for more information\n\nerror[E0599]: no method named `iter` found for struct\
    \ `String` in the current scope\n  --> /tmp/tmp_jaaj356.rs:15:7\n   |\n15 |  \
    \   s.iter().map(|c| \n   |       ^^^^ method not found in `String`\n   |\nhelp:\
    \ because of the in-memory representation of `&str`, to obtain an `Iterator` over\
    \ each of its codepoint use method `chars`\n   |\n15 |     s.chars().map(|c| \n\
    \   |       ~~~~~\n\nerror[E0277]: cannot multiply `{integer}` by `char`\n  -->\
    \ /tmp/tmp_jaaj356.rs:17:36\n   |\n17 |             'a' .. 'z' => ('z' - 2 * 'a'),\n\
    \   |                                    ^ no implementation for `{integer} *\
    \ char`\n   |\n   = help: the trait `Mul<char>` is not implemented for `{integer}`\n\
    \   = help: the following other types implement trait `Mul<Rhs>`:\n          \
    \   <&'a f32 as Mul<f32>>\n             <&'a f64 as Mul<f64>>\n             <&'a\
    \ i128 as Mul<i128>>\n             <&'a i16 as Mul<i16>>\n             <&'a i32\
    \ as Mul<i32>>\n             <&'a i64 as Mul<i64>>\n             <&'a i8 as Mul<i8>>\n\
    \             <&'a isize as Mul<isize>>\n           and 49 others\n\nerror[E0369]:\
    \ cannot subtract `_` from `char`\n  --> /tmp/tmp_jaaj356.rs:17:32\n   |\n17 |\
    \             'a' .. 'z' => ('z' - 2 * 'a'),\n   |                           \
    \ --- ^ ------- _\n   |                            |\n   |                   \
    \         char\n\nerror[E0277]: cannot multiply `{integer}` by `char`\n  --> /tmp/tmp_jaaj356.rs:18:36\n\
    \   |\n18 |             'A' .. 'Z' => ('a' - 2 * 'A'),\n   |                 \
    \                   ^ no implementation f"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet: Vec<char> = s.chars().collect();\n\
    \    alphabet.rotate(2);\n    let mut result = String::new();\n    for (i, c)\
    \ in alphabet.iter_mut().enumerate() {\n        c += c.chars().next().unwrap();\n\
    \        result.push((alphabet[i]).to_string());\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate` found for struct `Vec<char>` in\
    \ the current scope\n  --> /tmp/tmp0xn6pkmx.rs:16:14\n   |\n16 |     alphabet.rotate(2);\n\
    \   |              ^^^^^^ help: there is an associated function with a similar\
    \ name: `rotate_left`\n\nerror[E0599]: no method named `chars` found for mutable\
    \ reference `&mut char` in the current scope\n  --> /tmp/tmp0xn6pkmx.rs:19:16\n\
    \   |\n19 |         c += c.chars().next().unwrap();\n   |                ^^^^^\
    \ method not found in `&mut char`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp0xn6pkmx.rs:20:21\n\
    \   |\n20 |         result.push((alphabet[i]).to_string());\n   |            \
    \         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `char`, found struct `String`\n\n\
    error: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encryptString(&s, &ROTATE_ALPHABET)\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encryptString` in this scope\n  -->\
    \ /tmp/tmph_enxlwi.rs:15:5\n   |\n15 |     encryptString(&s, &ROTATE_ALPHABET)\n\
    \   |     ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find value\
    \ `ROTATE_ALPHABET` in this scope\n  --> /tmp/tmph_enxlwi.rs:15:24\n   |\n15 |\
    \     encryptString(&s, &ROTATE_ALPHABET)\n   |                        ^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut r = s.chars().collect::<Vec<_>>();\n    r.rotate_left(2);\n\
    \    let mut s = String::from(r);\n    s.rotate_left(1);\n    s\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0277]: the trait bound `String: From<Vec<char>>` is not satisfied\n\
    \  --> /tmp/tmpw218lf3g.rs:17:17\n   |\n17 |     let mut s = String::from(r);\n\
    \   |                 ^^^^^^^^^^^^ the trait `From<Vec<char>>` is not implemented\
    \ for `String`\n   |\n   = help: the following other types implement trait `From<T>`:\n\
    \             <String as From<&String>>\n             <String as From<&mut str>>\n\
    \             <String as From<&str>>\n             <String as From<Box<str>>>\n\
    \             <String as From<Cow<'a, str>>>\n             <String as From<char>>\n\
    \nerror[E0599]: no method named `rotate_left` found for struct `String` in the\
    \ current scope\n  --> /tmp/tmpw218lf3g.rs:18:7\n   |\n18 |     s.rotate_left(1);\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror: aborting due to\
    \ 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.iter().enumerate().map(|(i, c)| {\n        let mut\
    \ r = c.to_ascii_lowercase();\n        r += 2;\n        r.rotate_left(2);\n  \
    \      r\n    }).collect()\n}\n\nfn main() {\n    let candidate = encrypt;\n \
    \   assert_eq!(candidate(String::from(\"hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"\
    asdfghjkl\")), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"\
    gf\")), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")),\
    \ String::from(\"ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\"\
    )), String::from(\"jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"\
    hellomyfriend\")), String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `iter` found for struct `String` in the current\
    \ scope\n  --> /tmp/tmpf0uq9x2i.rs:15:7\n   |\n15 |     s.iter().enumerate().map(|(i,\
    \ c)| {\n   |       ^^^^ method not found in `String`\n   |\nhelp: because of\
    \ the in-memory representation of `&str`, to obtain an `Iterator` over each of\
    \ its codepoint use method `chars`\n   |\n15 |     s.chars().enumerate().map(|(i,\
    \ c)| {\n   |       ~~~~~\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut result: String = String::new();\n    s.chars().for_each(|c|\n\
    \        if c >= 'a' && c <= 'z' {\n            result += &'a' + c - 'a'.to_digit()\
    \ + 'a'.to_digit();\n        } else if c >= 'A' && c <= 'Z' {\n            result\
    \ += &'A' + c - 'A'.to_digit() + 'A'.to_digit();\n        } else {\n         \
    \   result += &c;\n        }\n    );\n    result\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0369]: cannot add `char` to `&char`\n  --> /tmp/tmp9e4iyyzs.rs:18:28\n\
    \   |\n18 |             result += &'a' + c - 'a'.to_digit() + 'a'.to_digit();\n\
    \   |                       ---- ^ - char\n   |                       |\n   |\
    \                       &char\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmp9e4iyyzs.rs:18:38\n    |\n18 \
    \ |             result += &'a' + c - 'a'.to_digit() + 'a'.to_digit();\n    | \
    \                                     ^^^^^^^^- supplied 0 arguments\n    |  \
    \                                    |\n    |                                \
    \      expected 1 argument\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \  --> /tmp/tmp9e4iyyzs.rs:18:55\n    |\n18  |             result += &'a' + c\
    \ - 'a'.to_digit() + 'a'.to_digit();\n    |                                  \
    \                     ^^^^^^^^- supplied 0 arguments\n    |                  \
    \                                     |\n    |                               \
    \                        expected 1 argument\n    |\nnote: associated function\
    \ defined here\n\nerror[E0369]: cannot add `char` to `&char`\n  --> /tmp/tmp9e4iyyzs.rs:20:28\n\
    \   |\n20 |             result += &'A' + c - 'A'.to_digit() + 'A'.to_digit();\n\
    \   |                       ---- ^ - char\n   |                       |\n   |\
    \                       &char\n\nerror[E0061]: this function takes 1 argument\
    \ but 0 arguments were supplied\n   --> /tmp/tmp9e4iyyzs.rs:20:38\n    |\n20 \
    \ |             result += &'A' + c - 'A'.to_digit() + 'A'.to_digit();\n    | \
    \                                     ^^^^^^^^- supplied 0 arguments\n    |  \
    \                                    |\n    |                                \
    \      expected 1 argument\n    |\nnote: associated function defined here\n\n\
    error[E0061]: this function takes 1 argument but 0 arguments were supplied\n \
    \  --> /tmp/tmp9e4iyyzs.rs:20:55\n    |\n20  |             result += &'A' + c\
    \ - 'A'.to_digit() + 'A'.to_digit();\n    |                                  \
    \                    "
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt(&s, Alphabet::rot13())\n}\n\nfn main() {\n\
    \    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")),\
    \ String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpgeyb26a2.rs:15:17\n   |\n15 |     encrypt(&s, Alphabet::rot13())\n \
    \  |                 ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror[E0061]:\
    \ this function takes 1 argument but 2 arguments were supplied\n  --> /tmp/tmpgeyb26a2.rs:15:5\n\
    \   |\n15 |     encrypt(&s, Alphabet::rot13())\n   |     ^^^^^^^ --  -----------------\
    \ supplied 2 arguments\n   |     |\n   |     expected 1 argument\n   |\nnote:\
    \ function defined here\n  --> /tmp/tmpgeyb26a2.rs:14:4\n   |\n14 | fn encrypt(s:\
    \ String) -> String {\n   |    ^^^^^^^ ---------\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0061, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0061`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [0, 9, 2, 8, 4, 7, 3, 6, 1, 5];\n\
    \    alphabet.extend(alphabet.clone());\n\n    let mut result = String::new();\n\
    \    let mut shift = 2;\n    for c in s {\n        result.push((alphabet[(alphabet.index(c)\
    \ + shift) % alphabet.length]).to_string());\n        shift *= 2;\n    }\n\n \
    \   result\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `extend` found for array `[{integer}; 10]`\
    \ in the current scope\n  --> /tmp/tmp4tg57i38.rs:16:14\n   |\n16 |     alphabet.extend(alphabet.clone());\n\
    \   |              ^^^^^^ method not found in `[{integer}; 10]`\n\nerror[E0277]:\
    \ `String` is not an iterator\n  --> /tmp/tmp4tg57i38.rs:20:14\n   |\n20 |   \
    \  for c in s {\n   |              ^ `String` is not an iterator; try calling\
    \ `.chars()` or `.bytes()`\n   |\n   = help: the trait `Iterator` is not implemented\
    \ for `String`\n   = note: required because of the requirements on the impl of\
    \ `IntoIterator` for `String`\n\nerror[E0599]: no method named `index` found for\
    \ array `[{integer}; 10]` in the current scope\n  --> /tmp/tmp4tg57i38.rs:21:41\n\
    \   |\n21 |         result.push((alphabet[(alphabet.index(c) + shift) % alphabet.length]).to_string());\n\
    \   |                                         ^^^^^ method not found in `[{integer};\
    \ 10]`\n   |\n   = help: items from traits can only be used if the trait is in\
    \ scope\nhelp: the following trait is implemented but not in scope; perhaps add\
    \ a `use` for it:\n   |\n1  | use std::ops::Index;\n   |\n\nerror[E0609]: no field\
    \ `length` on type `[{integer}; 10]`\n  --> /tmp/tmp4tg57i38.rs:21:70\n   |\n\
    21 |         result.push((alphabet[(alphabet.index(c) + shift) % alphabet.length]).to_string());\n\
    \   |                                                                      ^^^^^^\n\
    \nerror: aborting due to 4 previous errors\n\nSome errors have detailed explanations:\
    \ E0277, E0599, E0609.\nFor more information about an error, try `rustc --explain\
    \ E0277`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut s = s;\n    s.rotate_left(2);\n    s.rotate_left(3);\n\
    \    s\n}\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0599]: no method named `rotate_left` found for struct `String` in\
    \ the current scope\n  --> /tmp/tmpct3jkpsa.rs:16:7\n   |\n16 |     s.rotate_left(2);\n\
    \   |       ^^^^^^^^^^^ method not found in `String`\n\nerror[E0599]: no method\
    \ named `rotate_left` found for struct `String` in the current scope\n  --> /tmp/tmpct3jkpsa.rs:17:7\n\
    \   |\n17 |     s.rotate_left(3);\n   |       ^^^^^^^^^^^ method not found in\
    \ `String`\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut alphabet = [\n        (0x04 , 0xFC , 0xBA ,\
    \ 0xEB , 0xEF , 0x2E , 0x4A , 0x28 , 0xAA , 0x4F , 0x64 , 0x6F , 0xCB , 0xA3 ,\
    \ 0x9F ),\n        (0x00 , 0xC1 , 0x63 , 0x91 , 0xB7 , 0xD3 , 0xD2 , 0xE9 , 0x57\
    \ , 0x43 , 0x4F , 0xB6 , 0xCB , 0x52 ),\n        (0x6C , 0x82 , 0xAA , 0x70 ,\
    \ 0x61 , 0x7F , 0x3F , 0x62 , 0x73 , 0x5F , 0xC5 , 0xD1 , 0xD0 , 0x6F ),\n   \
    \     (0xFE , 0xE1 , 0xC3 , 0xBB , 0xB5 , 0x81 , 0xA1 , 0x4E , 0x5A , 0xB8 , 0x8D\
    \ , 0xAA , 0x57 , 0xC2 ),\n        (0xCE , 0xE7 , 0xA2 , 0xE0 , 0x82 , 0x6A ,\
    \ 0xF4 , 0xCE , 0xCB , 0xA9 , 0x82 , 0x6B , 0x4F , 0x94 ),\n        (0xF0 , 0xC8\
    \ , 0xAA , 0x70 , 0xA4 , 0xE2 , 0xF0 , 0xA0 , 0x4A , 0x5B , 0x68 , 0x7A , 0x53\
    \ , 0x51 ),\n        (0x93 , 0x9E , 0x8E , 0xBD , 0xB3 , 0xA9 , 0x81 , 0xCE ,\
    \ 0xF1 , 0xE3 , 0xEA , 0xA5 , 0x8F , 0x8F ),\n        (0xE1 , 0xF8 , 0xC4 , 0x9E\
    \ , 0xA5 , 0x87 , 0xE3 , 0x43 , 0x8E , 0xC3 , 0x1A , 0xCE , 0xB1 , 0xAF ),\n \
    \       (0xBD , 0xF3 , 0x62 , 0xA0 , 0xD3 , 0xAD , 0xF5 , 0x93 , 0xA3 , 0x7F ,\
    \ 0xEE , 0xAD , 0x6F , 0x9F ),\n        (0xCB , 0xA1 , 0x8D , 0x92 , 0xC2 , 0xC0\
    \ , 0x5A , 0xE0 , 0xB0 , 0xDC , 0xA8 , 0x82 , 0x92 , 0x5C ),\n        (0xD3 ,\
    \ 0xB3 , 0x9A , 0xCE , 0x87 , 0x9A , 0x1F , 0xD2 , 0x71 , 0x71 , 0xD2 , 0xA7 ,\
    \ 0xEE , 0xCE ),\n        (0xC2 , 0xF5 , 0xF3 , 0xC3 \n}\n\nfn main() {\n    let\
    \ candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error: expected one of `.`, `;`, `?`, `else`, or an operator, found `}`\n\
    \  --> /tmp/tmpq5i7d50a.rs:28:1\n   |\n28 | }\n   | ^ expected one of `.`, `;`,\
    \ `?`, `else`, or an operator\n\nerror: mismatched closing delimiter: `}`\n  -->\
    \ /tmp/tmpq5i7d50a.rs:27:9\n   |\n14 | fn encrypt(s: String) -> String {\n   |\
    \                                 - closing delimiter possibly meant for this\n\
    ...\n27 |         (0xC2 , 0xF5 , 0xF3 , 0xC3 \n   |         ^ unclosed delimiter\n\
    28 | }\n   | ^ mismatched closing delimiter\n\nerror: aborting due to 2 previous\
    \ errors\n\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    enrypt::encrypt(&s)\n}\n\nfn main() {\n    let candidate\
    \ = encrypt;\n    assert_eq!(candidate(String::from(\"hi\")), String::from(\"\
    lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\")), String::from(\"\
    ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\")), String::from(\"\
    kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"ix\"));\n\
    \    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"jeiajeaijeiak\"\
    ));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")), String::from(\"\
    lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
    )), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"));\n    assert_eq!(candidate(String::from(\"\
    a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `enrypt`\n\
    \  --> /tmp/tmpwbbbhx_7.rs:15:5\n   |\n15 |     enrypt::encrypt(&s)\n   |    \
    \ ^^^^^^ use of undeclared crate or module `enrypt`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    s.iter().map(|c|\n        (*(c as u32) + 2) % alphabet.len()\
    \ as char).collect()\n        .into_iter().collect::<String>()\n}\n\nfn main()\
    \ {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"hi\"\
    )), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find value `alphabet` in this scope\n  --> /tmp/tmpc8z12nn9.rs:16:29\n\
    \   |\n16 |         (*(c as u32) + 2) % alphabet.len() as char).collect()\n  \
    \ |                             ^^^^^^^^ not found in this scope\n\nerror[E0599]:\
    \ no method named `iter` found for struct `String` in the current scope\n  -->\
    \ /tmp/tmpc8z12nn9.rs:15:7\n   |\n15 |     s.iter().map(|c|\n   |       ^^^^ method\
    \ not found in `String`\n   |\nhelp: because of the in-memory representation of\
    \ `&str`, to obtain an `Iterator` over each of its codepoint use method `chars`\n\
    \   |\n15 |     s.chars().map(|c|\n   |       ~~~~~\n\nerror[E0614]: type `u32`\
    \ cannot be dereferenced\n  --> /tmp/tmpc8z12nn9.rs:16:10\n   |\n16 |        \
    \ (*(c as u32) + 2) % alphabet.len() as char).collect()\n   |          ^^^^^^^^^^^\n\
    \nerror: aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599, E0614.\nFor more information about an error, try `rustc --explain\
    \ E0425`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt_helper(s, alphabet_rotation(&alphabet.to_string()))\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0425]: cannot find function `encrypt_helper` in this scope\n  -->\
    \ /tmp/tmp_gt__rki.rs:15:5\n   |\n15 |     encrypt_helper(s, alphabet_rotation(&alphabet.to_string()))\n\
    \   |     ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `alphabet_rotation` in this scope\n  --> /tmp/tmp_gt__rki.rs:15:23\n\
    \   |\n15 |     encrypt_helper(s, alphabet_rotation(&alphabet.to_string()))\n\
    \   |                       ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find value `alphabet` in this scope\n  --> /tmp/tmp_gt__rki.rs:15:42\n\
    \   |\n15 |     encrypt_helper(s, alphabet_rotation(&alphabet.to_string()))\n\
    \   |                                          ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    let mut ciphertext = String::new();\n\n    let mut\
    \ alphabet = Alphabet::new();\n    alphabet.add_chars(&[\"a\", \"b\", \"c\", \"\
    d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"\
    o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"\
    z\"]);\n\n    for i in 0..s.len() {\n        let mut c = s.chars().nth(i).unwrap();\n\
    \        c = alphabet.shift_up(&c);\n        ciphertext.push(c);\n    }\n    ciphertext\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmpzufhrywc.rs:17:24\n   |\n17 |     let mut alphabet = Alphabet::new();\n\
    \   |                        ^^^^^^^^ use of undeclared type `Alphabet`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  stdout: ''
  timestamp: 1659976151
- exit_code: 1
  program: "/// Create a function encrypt that takes a string as an argument and\n\
    /// returns a string encrypted with the alphabet being rotated. \n/// The alphabet\
    \ should be rotated in a manner such that the letters \n/// shift down by two\
    \ multiplied to two places.\n/// For example:\n/// >>> encrypt(String::from(\"\
    hi\"))\n/// String::from(\"lm\")\n/// >>> encrypt(String::from(\"asdfghjkl\"))\n\
    /// String::from(\"ewhjklnop\")\n/// >>> encrypt(String::from(\"gf\"))\n/// String::from(\"\
    kj\")\n/// >>> encrypt(String::from(\"et\"))\n/// String::from(\"ix\")\nfn encrypt(s:\
    \ String) -> String {\n    encrypt1(s.chars().collect(), Alphabet::R).to_string()\n\
    }\n\nfn main() {\n    let candidate = encrypt;\n    assert_eq!(candidate(String::from(\"\
    hi\")), String::from(\"lm\"));\n    assert_eq!(candidate(String::from(\"asdfghjkl\"\
    )), String::from(\"ewhjklnop\"));\n    assert_eq!(candidate(String::from(\"gf\"\
    )), String::from(\"kj\"));\n    assert_eq!(candidate(String::from(\"et\")), String::from(\"\
    ix\"));\n    assert_eq!(candidate(String::from(\"faewfawefaewg\")), String::from(\"\
    jeiajeaijeiak\"));\n    assert_eq!(candidate(String::from(\"hellomyfriend\")),\
    \ String::from(\"lippsqcjvmirh\"));\n    assert_eq!(candidate(String::from(\"\
    dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\")), String::from(\"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\"\
    ));\n    assert_eq!(candidate(String::from(\"a\")), String::from(\"e\"));\n}\n"
  status: SyntaxError
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Alphabet`\n  -->\
    \ /tmp/tmp0shz8myv.rs:15:35\n   |\n15 |     encrypt1(s.chars().collect(), Alphabet::R).to_string()\n\
    \   |                                   ^^^^^^^^ use of undeclared type `Alphabet`\n\
    \nerror[E0425]: cannot find function `encrypt1` in this scope\n  --> /tmp/tmp0shz8myv.rs:15:5\n\
    \   |\n15 |     encrypt1(s.chars().collect(), Alphabet::R).to_string()\n   | \
    \    ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  stdout: ''
  timestamp: 1659976151
